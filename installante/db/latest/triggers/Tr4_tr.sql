--liquibase formatted sql
--changeset abrandolini:20250407_181738_Tr4_tr stripComments:false runOnChange:true

-- ============================================================
--   Database name:  TR4
--   DBMS name:      ORACLE Version for SI4
--   Created on:     02/10/2025  11.01
-- ============================================================

-- Procedure AFC_ALLEGATI_ELABORAZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table AFC_ALLEGATI_ELABORAZIONE

create or replace procedure AFC_ALLEGATI_ELABORAZIONE_PI
(new_id_elaborazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "AFC_ELABORAZIONI"
   cursor cpk1_afc_allegati_elaborazione(var_id_elaborazione number) is
      select 1
      from   AFC_ELABORAZIONI
      where  ID_ELABORAZIONE = var_id_elaborazione
       and   var_id_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "AFC_ELABORAZIONI" deve esistere quando si inserisce su "AFC_ALLEGATI_ELABORAZIONE"
         if NEW_ID_ELABORAZIONE is not null then
            open  cpk1_afc_allegati_elaborazione(NEW_ID_ELABORAZIONE);
            fetch cpk1_afc_allegati_elaborazione into dummy;
            found := cpk1_afc_allegati_elaborazione%FOUND;
            close cpk1_afc_allegati_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su AFC_ELABORAZIONI. La registrazione AFC_ALLEGATI_ELABORAZIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: AFC_ALLEGATI_ELABORAZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table AFC_ALLEGATI_ELABORAZIONE
/* End Trigger: AFC_ALLEGATI_ELABORAZIONE_TC */

-- Procedure AFC_ALLEGATI_ELABORAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table AFC_ALLEGATI_ELABORAZIONE

create or replace procedure AFC_ALLEGATI_ELABORAZIONE_PU
(old_id_allegato IN number,
 old_id_elaborazione IN number,
 new_id_allegato IN number,
 new_id_elaborazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "AFC_ELABORAZIONI"
   cursor cpk1_afc_allegati_elaborazione(var_id_elaborazione number) is
      select 1
      from   AFC_ELABORAZIONI
      where  ID_ELABORAZIONE = var_id_elaborazione
       and   var_id_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "AFC_ELABORAZIONI" deve esistere quando si modifica "AFC_ALLEGATI_ELABORAZIONE"
         if  NEW_ID_ELABORAZIONE is not null and ( seq = 0 )
         and (   (NEW_ID_ELABORAZIONE != OLD_ID_ELABORAZIONE or OLD_ID_ELABORAZIONE is null) ) then
            open  cpk1_afc_allegati_elaborazione(NEW_ID_ELABORAZIONE);
            fetch cpk1_afc_allegati_elaborazione into dummy;
            found := cpk1_afc_allegati_elaborazione%FOUND;
            close cpk1_afc_allegati_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su AFC_ELABORAZIONI. La registrazione AFC_ALLEGATI_ELABORAZIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: AFC_ALLEGATI_ELABORAZIONE_PU */
/

-- Trigger AFC_ALLEGATI_ELABORAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table AFC_ALLEGATI_ELABORAZIONE

create or replace trigger AFC_ALLEGATI_ELABORAZIONE_TIU
before INSERT
    or UPDATE
on AFC_ALLEGATI_ELABORAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         AFC_ALLEGATI_ELABORAZIONE_PU(:OLD.ID_ALLEGATO,
                                      :OLD.ID_ELABORAZIONE,
                         :NEW.ID_ALLEGATO,
                         :NEW.ID_ELABORAZIONE);
         null;
      end if;
      if INSERTING then
         AFC_ALLEGATI_ELABORAZIONE_PI(:NEW.ID_ELABORAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "AFC_ALLEGATI_ELABORAZIONE"
            cursor cpk_afc_allegati_elaborazione(var_ID_ALLEGATO number) is
               select 1
                 from   AFC_ALLEGATI_ELABORAZIONE
                where  ID_ALLEGATO = var_ID_ALLEGATO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "AFC_ALLEGATI_ELABORAZIONE"
               if :new.ID_ALLEGATO is not null then
                  open  cpk_afc_allegati_elaborazione(:new.ID_ALLEGATO);
                  fetch cpk_afc_allegati_elaborazione into dummy;
                  found := cpk_afc_allegati_elaborazione%FOUND;
                  close cpk_afc_allegati_elaborazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_ALLEGATO||
                               '" gia'' presente in AFC_ALLEGATI_ELABORAZIONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: AFC_ALLEGATI_ELABORAZIONE_TIU */
/

-- Procedure AFC_ELABORAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table AFC_ELABORAZIONI

create or replace procedure AFC_ELABORAZIONI_PU
(old_id_elaborazione IN number,
 new_id_elaborazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "AFC_ALLEGATI_ELABORAZIONE"
   cursor cfk1_afc_elaborazioni(var_id_elaborazione number) is
      select 1
      from   AFC_ALLEGATI_ELABORAZIONE
      where  ID_ELABORAZIONE = var_id_elaborazione
       and   var_id_elaborazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "AFC_LOG_ELABORAZIONI"
   cursor cfk2_afc_elaborazioni(var_id_elaborazione number) is
      select 1
      from   AFC_LOG_ELABORAZIONI
      where  ID_ELABORAZIONE = var_id_elaborazione
       and   var_id_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "AFC_ELABORAZIONI" non modificabile se esistono referenze su "AFC_ALLEGATI_ELABORAZIONE"
      if (OLD_ID_ELABORAZIONE != NEW_ID_ELABORAZIONE) then
         open  cfk1_afc_elaborazioni(OLD_ID_ELABORAZIONE);
         fetch cfk1_afc_elaborazioni into dummy;
         found := cfk1_afc_elaborazioni%FOUND;
         close cfk1_afc_elaborazioni;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su AFC_ALLEGATI_ELABORAZIONE. La registrazione di AFC_ELABORAZIONI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "AFC_ELABORAZIONI" non modificabile se esistono referenze su "AFC_LOG_ELABORAZIONI"
      if (OLD_ID_ELABORAZIONE != NEW_ID_ELABORAZIONE) then
         open  cfk2_afc_elaborazioni(OLD_ID_ELABORAZIONE);
         fetch cfk2_afc_elaborazioni into dummy;
         found := cfk2_afc_elaborazioni%FOUND;
         close cfk2_afc_elaborazioni;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su AFC_LOG_ELABORAZIONI. La registrazione di AFC_ELABORAZIONI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: AFC_ELABORAZIONI_PU */
/

-- Trigger AFC_ELABORAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table AFC_ELABORAZIONI

create or replace trigger AFC_ELABORAZIONI_TIU
before INSERT
    or UPDATE
on AFC_ELABORAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         AFC_ELABORAZIONI_PU(:OLD.ID_ELABORAZIONE,
                         :NEW.ID_ELABORAZIONE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "AFC_ELABORAZIONI"
            cursor cpk_afc_elaborazioni(var_ID_ELABORAZIONE number) is
               select 1
                 from   AFC_ELABORAZIONI
                where  ID_ELABORAZIONE = var_ID_ELABORAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "AFC_ELABORAZIONI"
               if :new.ID_ELABORAZIONE is not null then
                  open  cpk_afc_elaborazioni(:new.ID_ELABORAZIONE);
                  fetch cpk_afc_elaborazioni into dummy;
                  found := cpk_afc_elaborazioni%FOUND;
                  close cpk_afc_elaborazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_ELABORAZIONE||
                               '" gia'' presente in AFC_ELABORAZIONI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: AFC_ELABORAZIONI_TIU */
/

-- Procedure AFC_ELABORAZIONI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table AFC_ELABORAZIONI

create or replace procedure AFC_ELABORAZIONI_PD
(old_id_elaborazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "AFC_ALLEGATI_ELABORAZIONE"
   cursor cfk1_afc_elaborazioni(var_id_elaborazione number) is
      select 1
      from   AFC_ALLEGATI_ELABORAZIONE
      where  ID_ELABORAZIONE = var_id_elaborazione
       and   var_id_elaborazione is not null;

   --  Declaration of DeleteParentRestrict constraint for "AFC_LOG_ELABORAZIONI"
   cursor cfk2_afc_elaborazioni(var_id_elaborazione number) is
      select 1
      from   AFC_LOG_ELABORAZIONI
      where  ID_ELABORAZIONE = var_id_elaborazione
       and   var_id_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "AFC_ELABORAZIONI" if children still exist in "AFC_ALLEGATI_ELABORAZIONE"
      open  cfk1_afc_elaborazioni(OLD_ID_ELABORAZIONE);
      fetch cfk1_afc_elaborazioni into dummy;
      found := cfk1_afc_elaborazioni%FOUND;
      close cfk1_afc_elaborazioni;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su AFC_ALLEGATI_ELABORAZIONE. La registrazione di AFC_ELABORAZIONI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "AFC_ELABORAZIONI" if children still exist in "AFC_LOG_ELABORAZIONI"
      open  cfk2_afc_elaborazioni(OLD_ID_ELABORAZIONE);
      fetch cfk2_afc_elaborazioni into dummy;
      found := cfk2_afc_elaborazioni%FOUND;
      close cfk2_afc_elaborazioni;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su AFC_LOG_ELABORAZIONI. La registrazione di AFC_ELABORAZIONI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: AFC_ELABORAZIONI_PD */
/

-- Tigger AFC_ELABORAZIONI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table AFC_ELABORAZIONI

create or replace trigger AFC_ELABORAZIONI_TD
before DELETE
on AFC_ELABORAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: AFC_ALLEGATI_ELABORAZIONE

      -- Child Restrict Table: AFC_LOG_ELABORAZIONI

      AFC_ELABORAZIONI_PD(:OLD.ID_ELABORAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: AFC_ELABORAZIONI_TD */
/

-- Procedure AFC_LOG_ELABORAZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table AFC_LOG_ELABORAZIONI

create or replace procedure AFC_LOG_ELABORAZIONI_PI
(new_id_elaborazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "AFC_ELABORAZIONI"
   cursor cpk1_afc_log_elaborazioni(var_id_elaborazione number) is
      select 1
      from   AFC_ELABORAZIONI
      where  ID_ELABORAZIONE = var_id_elaborazione
       and   var_id_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "AFC_ELABORAZIONI" deve esistere quando si inserisce su "AFC_LOG_ELABORAZIONI"
         if NEW_ID_ELABORAZIONE is not null then
            open  cpk1_afc_log_elaborazioni(NEW_ID_ELABORAZIONE);
            fetch cpk1_afc_log_elaborazioni into dummy;
            found := cpk1_afc_log_elaborazioni%FOUND;
            close cpk1_afc_log_elaborazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su AFC_ELABORAZIONI. La registrazione AFC_LOG_ELABORAZIONI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: AFC_LOG_ELABORAZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table AFC_LOG_ELABORAZIONI
/* End Trigger: AFC_LOG_ELABORAZIONI_TC */

-- Procedure AFC_LOG_ELABORAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table AFC_LOG_ELABORAZIONI

create or replace procedure AFC_LOG_ELABORAZIONI_PU
(old_id_log IN number,
 old_id_elaborazione IN number,
 new_id_log IN number,
 new_id_elaborazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "AFC_ELABORAZIONI"
   cursor cpk1_afc_log_elaborazioni(var_id_elaborazione number) is
      select 1
      from   AFC_ELABORAZIONI
      where  ID_ELABORAZIONE = var_id_elaborazione
       and   var_id_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "AFC_ELABORAZIONI" deve esistere quando si modifica "AFC_LOG_ELABORAZIONI"
         if  NEW_ID_ELABORAZIONE is not null and ( seq = 0 )
         and (   (NEW_ID_ELABORAZIONE != OLD_ID_ELABORAZIONE or OLD_ID_ELABORAZIONE is null) ) then
            open  cpk1_afc_log_elaborazioni(NEW_ID_ELABORAZIONE);
            fetch cpk1_afc_log_elaborazioni into dummy;
            found := cpk1_afc_log_elaborazioni%FOUND;
            close cpk1_afc_log_elaborazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su AFC_ELABORAZIONI. La registrazione AFC_LOG_ELABORAZIONI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: AFC_LOG_ELABORAZIONI_PU */
/

-- Trigger AFC_LOG_ELABORAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table AFC_LOG_ELABORAZIONI

create or replace trigger AFC_LOG_ELABORAZIONI_TIU
before INSERT
    or UPDATE
on AFC_LOG_ELABORAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         AFC_LOG_ELABORAZIONI_PU(:OLD.ID_LOG,
                                 :OLD.ID_ELABORAZIONE,
                         :NEW.ID_LOG,
                         :NEW.ID_ELABORAZIONE);
         null;
      end if;
      if INSERTING then
         AFC_LOG_ELABORAZIONI_PI(:NEW.ID_ELABORAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "AFC_LOG_ELABORAZIONI"
            cursor cpk_afc_log_elaborazioni(var_ID_LOG number) is
               select 1
                 from   AFC_LOG_ELABORAZIONI
                where  ID_LOG = var_ID_LOG;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "AFC_LOG_ELABORAZIONI"
               if :new.ID_LOG is not null then
                  open  cpk_afc_log_elaborazioni(:new.ID_LOG);
                  fetch cpk_afc_log_elaborazioni into dummy;
                  found := cpk_afc_log_elaborazioni%FOUND;
                  close cpk_afc_log_elaborazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_LOG||
                               '" gia'' presente in AFC_LOG_ELABORAZIONI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: AFC_LOG_ELABORAZIONI_TIU */
/

-- Procedure AGGI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table AGGI

create or replace procedure AGGI_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_aggi(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "AGGI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_aggi(NEW_TIPO_TRIBUTO);
            fetch cpk1_aggi into dummy;
            found := cpk1_aggi%FOUND;
            close cpk1_aggi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Aggi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: AGGI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table AGGI
/* End Trigger: AGGI_TC */

-- Procedure AGGI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table AGGI

create or replace procedure AGGI_PU
(old_tipo_tributo IN varchar,
 old_sequenza IN number,
 new_tipo_tributo IN varchar,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_aggi(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "AGGI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_aggi(NEW_TIPO_TRIBUTO);
            fetch cpk1_aggi into dummy;
            found := cpk1_aggi%FOUND;
            close cpk1_aggi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Aggi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: AGGI_PU */
/

-- Trigger AGGI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table AGGI

create or replace trigger AGGI_TIU
before INSERT
    or UPDATE
on AGGI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       AGGI_NR(:new.tipo_tributo,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         AGGI_PU(:OLD.TIPO_TRIBUTO,
                 :OLD.SEQUENZA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         AGGI_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "AGGI"
            cursor cpk_aggi(var_TIPO_TRIBUTO varchar,
                            var_SEQUENZA number) is
               select 1
                 from   AGGI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "AGGI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_aggi(:new.TIPO_TRIBUTO,
                                 :new.SEQUENZA);
                  fetch cpk_aggi into dummy;
                  found := cpk_aggi%FOUND;
                  close cpk_aggi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Aggi. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: AGGI_TIU */
/

-- Procedure ALIQUOTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ALIQUOTE

create or replace procedure ALIQUOTE_PI
(new_tipo_tributo IN varchar,
 new_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ALIQUOTA"
   cursor cpk1_aliquote(var_tipo_tributo varchar,
                        var_tipo_aliquota number) is
      select 1
      from   TIPI_ALIQUOTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_ALIQUOTA" deve esistere quando si inserisce su "ALIQUOTE"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_TIPO_ALIQUOTA is not null then
            open  cpk1_aliquote(NEW_TIPO_TRIBUTO,
                                NEW_TIPO_ALIQUOTA);
            fetch cpk1_aliquote into dummy;
            found := cpk1_aliquote%FOUND;
            close cpk1_aliquote;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Aliquota. La registrazione Aliquote non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ALIQUOTE
/* End Trigger: ALIQUOTE_TC */

-- Procedure ALIQUOTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ALIQUOTE

create or replace procedure ALIQUOTE_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_tipo_aliquota IN number,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ALIQUOTA"
   cursor cpk1_aliquote(var_tipo_tributo varchar,
                        var_tipo_aliquota number) is
      select 1
      from   TIPI_ALIQUOTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Declaration of UpdateParentRestrict constraint for "ALIQUOTE_CATEGORIA"
   cursor cfk1_aliquote(var_tipo_tributo varchar,
                        var_anno number,
                        var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE_CATEGORIA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_anno is not null
       and   var_tipo_aliquota is not null;

   --  Declaration of UpdateParentRestrict constraint for "RELAZIONI_OGGETTI_CALCOLO"
   cursor cfk2_aliquote(var_tipo_tributo varchar,
                        var_anno number,
                        var_tipo_aliquota number) is
      select 1
      from   RELAZIONI_OGGETTI_CALCOLO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_anno is not null
       and   var_tipo_aliquota is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_ALIQUOTA" deve esistere quando si modifica "ALIQUOTE"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_TIPO_ALIQUOTA is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_TIPO_ALIQUOTA != OLD_TIPO_ALIQUOTA or OLD_TIPO_ALIQUOTA is null) ) then
            open  cpk1_aliquote(NEW_TIPO_TRIBUTO,
                                NEW_TIPO_ALIQUOTA);
            fetch cpk1_aliquote into dummy;
            found := cpk1_aliquote%FOUND;
            close cpk1_aliquote;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Aliquota. La registrazione Aliquote non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "ALIQUOTE" non modificabile se esistono referenze su "ALIQUOTE_CATEGORIA"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_ANNO != NEW_ANNO) or
         (OLD_TIPO_ALIQUOTA != NEW_TIPO_ALIQUOTA) then
         open  cfk1_aliquote(OLD_TIPO_TRIBUTO,
                             OLD_ANNO,
                             OLD_TIPO_ALIQUOTA);
         fetch cfk1_aliquote into dummy;
         found := cfk1_aliquote%FOUND;
         close cfk1_aliquote;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Aliquote Categoria. La registrazione di Aliquote non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ALIQUOTE" non modificabile se esistono referenze su "RELAZIONI_OGGETTI_CALCOLO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_ANNO != NEW_ANNO) or
         (OLD_TIPO_ALIQUOTA != NEW_TIPO_ALIQUOTA) then
         open  cfk2_aliquote(OLD_TIPO_TRIBUTO,
                             OLD_ANNO,
                             OLD_TIPO_ALIQUOTA);
         fetch cfk2_aliquote into dummy;
         found := cfk2_aliquote%FOUND;
         close cfk2_aliquote;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su RELAZIONI_OGGETTI_CALCOLO. La registrazione di Aliquote non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_PU */
/

-- Trigger ALIQUOTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ALIQUOTE

create or replace trigger ALIQUOTE_TIU
before INSERT
    or UPDATE
on ALIQUOTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ALIQUOTE_PU(:OLD.TIPO_TRIBUTO,
                     :OLD.ANNO,
                     :OLD.TIPO_ALIQUOTA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.TIPO_ALIQUOTA);
         null;
      end if;
      if INSERTING then
         ALIQUOTE_PI(:NEW.TIPO_TRIBUTO,
                     :NEW.TIPO_ALIQUOTA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ALIQUOTE"
            cursor cpk_aliquote(var_TIPO_TRIBUTO varchar,
                                var_ANNO number,
                                var_TIPO_ALIQUOTA number) is
               select 1
                 from   ALIQUOTE
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       TIPO_ALIQUOTA = var_TIPO_ALIQUOTA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ALIQUOTE"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.TIPO_ALIQUOTA is not null then
                  open  cpk_aliquote(:new.TIPO_TRIBUTO,
                                     :new.ANNO,
                                     :new.TIPO_ALIQUOTA);
                  fetch cpk_aliquote into dummy;
                  found := cpk_aliquote%FOUND;
                  close cpk_aliquote;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.TIPO_ALIQUOTA||
                               '" gia'' presente in Aliquote. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ALIQUOTE_TIU */
/

-- Procedure ALIQUOTE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table ALIQUOTE

create or replace procedure ALIQUOTE_PD
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ALIQUOTE_CATEGORIA"
   cursor cfk1_aliquote(var_tipo_tributo varchar,
                        var_anno number,
                        var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE_CATEGORIA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_anno is not null
       and   var_tipo_aliquota is not null;

   --  Declaration of DeleteParentRestrict constraint for "RELAZIONI_OGGETTI_CALCOLO"
   cursor cfk2_aliquote(var_tipo_tributo varchar,
                        var_anno number,
                        var_tipo_aliquota number) is
      select 1
      from   RELAZIONI_OGGETTI_CALCOLO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_anno is not null
       and   var_tipo_aliquota is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "ALIQUOTE" if children still exist in "ALIQUOTE_CATEGORIA"
      open  cfk1_aliquote(OLD_TIPO_TRIBUTO,
                          OLD_ANNO,
                          OLD_TIPO_ALIQUOTA);
      fetch cfk1_aliquote into dummy;
      found := cfk1_aliquote%FOUND;
      close cfk1_aliquote;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Aliquote Categoria. La registrazione di Aliquote non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ALIQUOTE" if children still exist in "RELAZIONI_OGGETTI_CALCOLO"
      open  cfk2_aliquote(OLD_TIPO_TRIBUTO,
                          OLD_ANNO,
                          OLD_TIPO_ALIQUOTA);
      fetch cfk2_aliquote into dummy;
      found := cfk2_aliquote%FOUND;
      close cfk2_aliquote;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su RELAZIONI_OGGETTI_CALCOLO. La registrazione di Aliquote non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_PD */
/

-- Tigger ALIQUOTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ALIQUOTE

create or replace trigger ALIQUOTE_TD
before DELETE
on ALIQUOTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ALIQUOTE_CATEGORIA

      -- Child Restrict Table: RELAZIONI_OGGETTI_CALCOLO

      ALIQUOTE_PD(:OLD.TIPO_TRIBUTO,
                  :OLD.ANNO,
                  :OLD.TIPO_ALIQUOTA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ALIQUOTE_TD */
/

-- Procedure ALIQUOTE_CATEGORIA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ALIQUOTE_CATEGORIA

create or replace procedure ALIQUOTE_CATEGORIA_PI
(new_tipo_tributo IN varchar,
 new_anno IN number,
 new_tipo_aliquota IN number,
 new_categoria_catasto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ALIQUOTE"
   cursor cpk1_aliquote_categoria(var_tipo_tributo varchar,
                                  var_anno number,
                                  var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_anno is not null
       and   var_tipo_aliquota is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE_CATASTO"
   cursor cpk2_aliquote_categoria(var_categoria_catasto varchar) is
      select 1
      from   CATEGORIE_CATASTO
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ALIQUOTE" deve esistere quando si inserisce su "ALIQUOTE_CATEGORIA"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_ANNO is not null and
            NEW_TIPO_ALIQUOTA is not null then
            open  cpk1_aliquote_categoria(NEW_TIPO_TRIBUTO,
                                          NEW_ANNO,
                                          NEW_TIPO_ALIQUOTA);
            fetch cpk1_aliquote_categoria into dummy;
            found := cpk1_aliquote_categoria%FOUND;
            close cpk1_aliquote_categoria;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Aliquote. La registrazione Aliquote Categoria non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE_CATASTO" deve esistere quando si inserisce su "ALIQUOTE_CATEGORIA"
         if NEW_CATEGORIA_CATASTO is not null then
            open  cpk2_aliquote_categoria(NEW_CATEGORIA_CATASTO);
            fetch cpk2_aliquote_categoria into dummy;
            found := cpk2_aliquote_categoria%FOUND;
            close cpk2_aliquote_categoria;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie Catasto. La registrazione Aliquote Categoria non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_CATEGORIA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ALIQUOTE_CATEGORIA
/* End Trigger: ALIQUOTE_CATEGORIA_TC */

-- Procedure ALIQUOTE_CATEGORIA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ALIQUOTE_CATEGORIA

create or replace procedure ALIQUOTE_CATEGORIA_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_tipo_aliquota IN number,
 old_categoria_catasto IN varchar,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_tipo_aliquota IN number,
 new_categoria_catasto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ALIQUOTE"
   cursor cpk1_aliquote_categoria(var_tipo_tributo varchar,
                                  var_anno number,
                                  var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_anno is not null
       and   var_tipo_aliquota is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE_CATASTO"
   cursor cpk2_aliquote_categoria(var_categoria_catasto varchar) is
      select 1
      from   CATEGORIE_CATASTO
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ALIQUOTE" deve esistere quando si modifica "ALIQUOTE_CATEGORIA"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_ANNO is not null and
             NEW_TIPO_ALIQUOTA is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_ANNO != OLD_ANNO or OLD_ANNO is null)
              or (NEW_TIPO_ALIQUOTA != OLD_TIPO_ALIQUOTA or OLD_TIPO_ALIQUOTA is null) ) then
            open  cpk1_aliquote_categoria(NEW_TIPO_TRIBUTO,
                                          NEW_ANNO,
                                          NEW_TIPO_ALIQUOTA);
            fetch cpk1_aliquote_categoria into dummy;
            found := cpk1_aliquote_categoria%FOUND;
            close cpk1_aliquote_categoria;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Aliquote. La registrazione Aliquote Categoria non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE_CATASTO" deve esistere quando si modifica "ALIQUOTE_CATEGORIA"
         if  NEW_CATEGORIA_CATASTO is not null and ( seq = 0 )
         and (   (NEW_CATEGORIA_CATASTO != OLD_CATEGORIA_CATASTO or OLD_CATEGORIA_CATASTO is null) ) then
            open  cpk2_aliquote_categoria(NEW_CATEGORIA_CATASTO);
            fetch cpk2_aliquote_categoria into dummy;
            found := cpk2_aliquote_categoria%FOUND;
            close cpk2_aliquote_categoria;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie Catasto. La registrazione Aliquote Categoria non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_CATEGORIA_PU */
/

-- Trigger ALIQUOTE_CATEGORIA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ALIQUOTE_CATEGORIA

create or replace trigger ALIQUOTE_CATEGORIA_TIU
before INSERT
    or UPDATE
on ALIQUOTE_CATEGORIA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ALIQUOTE_CATEGORIA_PU(:OLD.TIPO_TRIBUTO,
                               :OLD.ANNO,
                               :OLD.TIPO_ALIQUOTA,
                               :OLD.CATEGORIA_CATASTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.TIPO_ALIQUOTA,
                         :NEW.CATEGORIA_CATASTO);
         null;
      end if;
      if INSERTING then
         ALIQUOTE_CATEGORIA_PI(:NEW.TIPO_TRIBUTO,
                               :NEW.ANNO,
                               :NEW.TIPO_ALIQUOTA,
                               :NEW.CATEGORIA_CATASTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ALIQUOTE_CATEGORIA"
            cursor cpk_aliquote_categoria(var_TIPO_TRIBUTO varchar,
                                          var_ANNO number,
                                          var_TIPO_ALIQUOTA number,
                                          var_CATEGORIA_CATASTO varchar) is
               select 1
                 from   ALIQUOTE_CATEGORIA
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       TIPO_ALIQUOTA = var_TIPO_ALIQUOTA and
                       CATEGORIA_CATASTO = var_CATEGORIA_CATASTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ALIQUOTE_CATEGORIA"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.TIPO_ALIQUOTA is not null and
                  :new.CATEGORIA_CATASTO is not null then
                  open  cpk_aliquote_categoria(:new.TIPO_TRIBUTO,
                                               :new.ANNO,
                                               :new.TIPO_ALIQUOTA,
                                               :new.CATEGORIA_CATASTO);
                  fetch cpk_aliquote_categoria into dummy;
                  found := cpk_aliquote_categoria%FOUND;
                  close cpk_aliquote_categoria;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.TIPO_ALIQUOTA||' '||
                               :new.CATEGORIA_CATASTO||
                               '" gia'' presente in Aliquote Categoria. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ALIQUOTE_CATEGORIA_TIU */
/

-- Procedure ALIQUOTE_MOBILI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ALIQUOTE_MOBILI

create or replace procedure ALIQUOTE_MOBILI_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_aliquote_mobili(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "ALIQUOTE_MOBILI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_aliquote_mobili(NEW_TIPO_TRIBUTO);
            fetch cpk1_aliquote_mobili into dummy;
            found := cpk1_aliquote_mobili%FOUND;
            close cpk1_aliquote_mobili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione ALIQUOTE_MOBILI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_MOBILI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ALIQUOTE_MOBILI
/* End Trigger: ALIQUOTE_MOBILI_TC */

-- Procedure ALIQUOTE_MOBILI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ALIQUOTE_MOBILI

create or replace procedure ALIQUOTE_MOBILI_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_da_rendita IN number,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_da_rendita IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_aliquote_mobili(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "ALIQUOTE_MOBILI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_aliquote_mobili(NEW_TIPO_TRIBUTO);
            fetch cpk1_aliquote_mobili into dummy;
            found := cpk1_aliquote_mobili%FOUND;
            close cpk1_aliquote_mobili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione ALIQUOTE_MOBILI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_MOBILI_PU */
/

-- Trigger ALIQUOTE_MOBILI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ALIQUOTE_MOBILI

create or replace trigger ALIQUOTE_MOBILI_TIU
before INSERT
    or UPDATE
on ALIQUOTE_MOBILI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ALIQUOTE_MOBILI_PU(:OLD.TIPO_TRIBUTO,
                            :OLD.ANNO,
                            :OLD.DA_RENDITA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.DA_RENDITA);
         null;
      end if;
      if INSERTING then
         ALIQUOTE_MOBILI_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ALIQUOTE_MOBILI"
            cursor cpk_aliquote_mobili(var_TIPO_TRIBUTO varchar,
                                       var_ANNO number,
                                       var_DA_RENDITA number) is
               select 1
                 from   ALIQUOTE_MOBILI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       DA_RENDITA = var_DA_RENDITA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ALIQUOTE_MOBILI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.DA_RENDITA is not null then
                  open  cpk_aliquote_mobili(:new.TIPO_TRIBUTO,
                                            :new.ANNO,
                                            :new.DA_RENDITA);
                  fetch cpk_aliquote_mobili into dummy;
                  found := cpk_aliquote_mobili%FOUND;
                  close cpk_aliquote_mobili;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.DA_RENDITA||
                               '" gia'' presente in ALIQUOTE_MOBILI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ALIQUOTE_MOBILI_TIU */
/

-- Procedure ALIQUOTE_OGCO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ALIQUOTE_OGCO

create or replace procedure ALIQUOTE_OGCO_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_tipo_tributo IN varchar,
 new_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ALIQUOTA"
   cursor cpk1_aliquote_ogco(var_tipo_tributo varchar,
                             var_tipo_aliquota number) is
      select 1
      from   TIPI_ALIQUOTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_CONTRIBUENTE"
   cursor cpk2_aliquote_ogco(var_cod_fiscale varchar,
                             var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_ALIQUOTA" deve esistere quando si inserisce su "ALIQUOTE_OGCO"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_TIPO_ALIQUOTA is not null then
            open  cpk1_aliquote_ogco(NEW_TIPO_TRIBUTO,
                                     NEW_TIPO_ALIQUOTA);
            fetch cpk1_aliquote_ogco into dummy;
            found := cpk1_aliquote_ogco%FOUND;
            close cpk1_aliquote_ogco;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Aliquota. La registrazione Aliquote Oggetto Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si inserisce su "ALIQUOTE_OGCO"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO_PRATICA is not null then
            open  cpk2_aliquote_ogco(NEW_COD_FISCALE,
                                     NEW_OGGETTO_PRATICA);
            fetch cpk2_aliquote_ogco into dummy;
            found := cpk2_aliquote_ogco%FOUND;
            close cpk2_aliquote_ogco;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Aliquote Oggetto Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_OGCO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ALIQUOTE_OGCO
/* End Trigger: ALIQUOTE_OGCO_TC */

-- Procedure ALIQUOTE_OGCO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ALIQUOTE_OGCO

create or replace procedure ALIQUOTE_OGCO_PU
(old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number,
 old_dal IN date,
 old_tipo_tributo IN varchar,
 old_tipo_aliquota IN number,
 new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_dal IN date,
 new_tipo_tributo IN varchar,
 new_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ALIQUOTA"
   cursor cpk1_aliquote_ogco(var_tipo_tributo varchar,
                             var_tipo_aliquota number) is
      select 1
      from   TIPI_ALIQUOTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_CONTRIBUENTE"
   cursor cpk2_aliquote_ogco(var_cod_fiscale varchar,
                             var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_ALIQUOTA" deve esistere quando si modifica "ALIQUOTE_OGCO"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_TIPO_ALIQUOTA is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_TIPO_ALIQUOTA != OLD_TIPO_ALIQUOTA or OLD_TIPO_ALIQUOTA is null) ) then
            open  cpk1_aliquote_ogco(NEW_TIPO_TRIBUTO,
                                     NEW_TIPO_ALIQUOTA);
            fetch cpk1_aliquote_ogco into dummy;
            found := cpk1_aliquote_ogco%FOUND;
            close cpk1_aliquote_ogco;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Aliquota. La registrazione Aliquote Oggetto Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si modifica "ALIQUOTE_OGCO"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk2_aliquote_ogco(NEW_COD_FISCALE,
                                     NEW_OGGETTO_PRATICA);
            fetch cpk2_aliquote_ogco into dummy;
            found := cpk2_aliquote_ogco%FOUND;
            close cpk2_aliquote_ogco;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Aliquote Oggetto Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALIQUOTE_OGCO_PU */
/

-- Trigger ALIQUOTE_OGCO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ALIQUOTE_OGCO

create or replace trigger ALIQUOTE_OGCO_TIU
before INSERT
    or UPDATE
on ALIQUOTE_OGCO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      ALIQUOTE_OGCO_DI(:new.dal,:new.al);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ALIQUOTE_OGCO_PU(:OLD.COD_FISCALE,
                          :OLD.OGGETTO_PRATICA,
                          :OLD.DAL,
                          :OLD.TIPO_TRIBUTO,
                          :OLD.TIPO_ALIQUOTA,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.DAL,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_ALIQUOTA);
         null;
      end if;
      if INSERTING then
         ALIQUOTE_OGCO_PI(:NEW.COD_FISCALE,
                          :NEW.OGGETTO_PRATICA,
                          :NEW.TIPO_TRIBUTO,
                          :NEW.TIPO_ALIQUOTA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ALIQUOTE_OGCO"
            cursor cpk_aliquote_ogco(var_COD_FISCALE varchar,
                                     var_OGGETTO_PRATICA number,
                                     var_DAL date) is
               select 1
                 from   ALIQUOTE_OGCO
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA and
                       DAL = var_DAL;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ALIQUOTE_OGCO"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO_PRATICA is not null and
                  :new.DAL is not null then
                  open  cpk_aliquote_ogco(:new.COD_FISCALE,
                                          :new.OGGETTO_PRATICA,
                                          :new.DAL);
                  fetch cpk_aliquote_ogco into dummy;
                  found := cpk_aliquote_ogco%FOUND;
                  close cpk_aliquote_ogco;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO_PRATICA||' '||
                               :new.DAL||
                               '" gia'' presente in Aliquote Oggetto Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ALIQUOTE_OGCO_TIU */
/

-- Procedure ALLEGATI_TESTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ALLEGATI_TESTO

create or replace procedure ALLEGATI_TESTO_PI
(new_comunicazione_testo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "COMUNICAZIONE_TESTI"
   cursor cpk1_allegati_testo(var_comunicazione_testo number) is
      select 1
      from   COMUNICAZIONE_TESTI
      where  COMUNICAZIONE_TESTO = var_comunicazione_testo
       and   var_comunicazione_testo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "COMUNICAZIONE_TESTI" deve esistere quando si inserisce su "ALLEGATI_TESTO"
         if NEW_COMUNICAZIONE_TESTO is not null then
            open  cpk1_allegati_testo(NEW_COMUNICAZIONE_TESTO);
            fetch cpk1_allegati_testo into dummy;
            found := cpk1_allegati_testo%FOUND;
            close cpk1_allegati_testo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Comunicazione Testi. La registrazione ALLEGATI_TESTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALLEGATI_TESTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ALLEGATI_TESTO
/* End Trigger: ALLEGATI_TESTO_TC */

-- Procedure ALLEGATI_TESTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ALLEGATI_TESTO

create or replace procedure ALLEGATI_TESTO_PU
(old_comunicazione_testo IN number,
 old_sequenza IN number,
 new_comunicazione_testo IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "COMUNICAZIONE_TESTI"
   cursor cpk1_allegati_testo(var_comunicazione_testo number) is
      select 1
      from   COMUNICAZIONE_TESTI
      where  COMUNICAZIONE_TESTO = var_comunicazione_testo
       and   var_comunicazione_testo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "COMUNICAZIONE_TESTI" deve esistere quando si modifica "ALLEGATI_TESTO"
         if  NEW_COMUNICAZIONE_TESTO is not null and ( seq = 0 )
         and (   (NEW_COMUNICAZIONE_TESTO != OLD_COMUNICAZIONE_TESTO or OLD_COMUNICAZIONE_TESTO is null) ) then
            open  cpk1_allegati_testo(NEW_COMUNICAZIONE_TESTO);
            fetch cpk1_allegati_testo into dummy;
            found := cpk1_allegati_testo%FOUND;
            close cpk1_allegati_testo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Comunicazione Testi. La registrazione ALLEGATI_TESTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALLEGATI_TESTO_PU */
/

-- Trigger ALLEGATI_TESTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ALLEGATI_TESTO

create or replace trigger ALLEGATI_TESTO_TIU
before INSERT
    or UPDATE
on ALLEGATI_TESTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.comunicazione_testo is null then
       ALLEGATI_TESTO_NR (:new.comunicazione_testo,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ALLEGATI_TESTO_PU(:OLD.COMUNICAZIONE_TESTO,
                           :OLD.SEQUENZA,
                         :NEW.COMUNICAZIONE_TESTO,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         ALLEGATI_TESTO_PI(:NEW.COMUNICAZIONE_TESTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ALLEGATI_TESTO"
            cursor cpk_allegati_testo(var_COMUNICAZIONE_TESTO number,
                                      var_SEQUENZA number) is
               select 1
                 from   ALLEGATI_TESTO
                where  COMUNICAZIONE_TESTO = var_COMUNICAZIONE_TESTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ALLEGATI_TESTO"
               if :new.COMUNICAZIONE_TESTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_allegati_testo(:new.COMUNICAZIONE_TESTO,
                                           :new.SEQUENZA);
                  fetch cpk_allegati_testo into dummy;
                  found := cpk_allegati_testo%FOUND;
                  close cpk_allegati_testo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COMUNICAZIONE_TESTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in ALLEGATI_TESTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ALLEGATI_TESTO_TIU */
/

-- Procedure ALLINEAMENTO_DELEGHE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ALLINEAMENTO_DELEGHE

create or replace procedure ALLINEAMENTO_DELEGHE_PI
(new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_allineamento_deleghe(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_allineamento_deleghe(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "ALLINEAMENTO_DELEGHE"
         if NEW_COD_FISCALE is not null then
            open  cpk1_allineamento_deleghe(NEW_COD_FISCALE);
            fetch cpk1_allineamento_deleghe into dummy;
            found := cpk1_allineamento_deleghe%FOUND;
            close cpk1_allineamento_deleghe;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Allineamento Deleghe non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "ALLINEAMENTO_DELEGHE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_allineamento_deleghe(NEW_TIPO_TRIBUTO);
            fetch cpk2_allineamento_deleghe into dummy;
            found := cpk2_allineamento_deleghe%FOUND;
            close cpk2_allineamento_deleghe;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Allineamento Deleghe non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALLINEAMENTO_DELEGHE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ALLINEAMENTO_DELEGHE
/* End Trigger: ALLINEAMENTO_DELEGHE_TC */

-- Procedure ALLINEAMENTO_DELEGHE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ALLINEAMENTO_DELEGHE

create or replace procedure ALLINEAMENTO_DELEGHE_PU
(old_cod_fiscale IN varchar,
 old_tipo_tributo IN varchar,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_allineamento_deleghe(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_allineamento_deleghe(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "ALLINEAMENTO_DELEGHE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_allineamento_deleghe(NEW_COD_FISCALE);
            fetch cpk1_allineamento_deleghe into dummy;
            found := cpk1_allineamento_deleghe%FOUND;
            close cpk1_allineamento_deleghe;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Allineamento Deleghe non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "ALLINEAMENTO_DELEGHE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_allineamento_deleghe(NEW_TIPO_TRIBUTO);
            fetch cpk2_allineamento_deleghe into dummy;
            found := cpk2_allineamento_deleghe%FOUND;
            close cpk2_allineamento_deleghe;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Allineamento Deleghe non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ALLINEAMENTO_DELEGHE_PU */
/

-- Trigger ALLINEAMENTO_DELEGHE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ALLINEAMENTO_DELEGHE

create or replace trigger ALLINEAMENTO_DELEGHE_TIU
before INSERT
    or UPDATE
on ALLINEAMENTO_DELEGHE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ALLINEAMENTO_DELEGHE_PU(:OLD.COD_FISCALE,
                                 :OLD.TIPO_TRIBUTO,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         ALLINEAMENTO_DELEGHE_PI(:NEW.COD_FISCALE,
                                 :NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ALLINEAMENTO_DELEGHE"
            cursor cpk_allineamento_deleghe(var_COD_FISCALE varchar,
                                            var_TIPO_TRIBUTO varchar) is
               select 1
                 from   ALLINEAMENTO_DELEGHE
                where  COD_FISCALE = var_COD_FISCALE and
                       TIPO_TRIBUTO = var_TIPO_TRIBUTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ALLINEAMENTO_DELEGHE"
               if :new.COD_FISCALE is not null and
                  :new.TIPO_TRIBUTO is not null then
                  open  cpk_allineamento_deleghe(:new.COD_FISCALE,
                                                 :new.TIPO_TRIBUTO);
                  fetch cpk_allineamento_deleghe into dummy;
                  found := cpk_allineamento_deleghe%FOUND;
                  close cpk_allineamento_deleghe;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.TIPO_TRIBUTO||
                               '" gia'' presente in Allineamento Deleghe. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ALLINEAMENTO_DELEGHE_TIU */
/

-- Procedure ANCI_ANA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANCI_ANA

create or replace procedure ANCI_ANA_PI
(new_progr_record IN number,
 new_anno_fiscale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ANCI_VER"
   cursor cpk1_anci_ana(var_progr_record number,
                        var_anno_fiscale number) is
      select 1
      from   ANCI_VER
      where  PROGR_RECORD = var_progr_record
       and   ANNO_FISCALE = var_anno_fiscale
       and   var_progr_record is not null
       and   var_anno_fiscale is not null;

   --  Dichiarazione di InsertTooManyChildren per la tabella padre "ANCI_VER"
   cursor cmc1_anci_ana(var_progr_record number,
                        var_anno_fiscale number) is
      select count(1)
      from   ANCI_ANA
      where  PROGR_RECORD = var_progr_record
       and   ANNO_FISCALE = var_anno_fiscale
       and   var_progr_record is not null
       and   var_anno_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ANCI_VER" deve esistere quando si inserisce su "ANCI_ANA"
         if NEW_PROGR_RECORD is not null and
            NEW_ANNO_FISCALE is not null then
            open  cpk1_anci_ana(NEW_PROGR_RECORD,
                                NEW_ANNO_FISCALE);
            fetch cpk1_anci_ana into dummy;
            found := cpk1_anci_ana%FOUND;
            close cpk1_anci_ana;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Anci Ver. La registrazione Anci Ana non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  La cardinality di "ANCI_VER" in "ANCI_ANA" non deve eccedere 1
         if NEW_PROGR_RECORD is not null and
            NEW_ANNO_FISCALE is not null then
            open  cmc1_anci_ana(NEW_PROGR_RECORD,
                                NEW_ANNO_FISCALE);
            fetch cmc1_anci_ana into cardinality;
            close cmc1_anci_ana;
            if cardinality >= 1 then
               errno  := -20008;
               errmsg := 'Il numero di Anci Ana assegnato a Anci Ver non e'' ammesso. La registrazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Statement di Insert MultiRow
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_ANA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANCI_ANA
/* End Trigger: ANCI_ANA_TC */

-- Procedure ANCI_ANA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANCI_ANA

create or replace procedure ANCI_ANA_PU
(old_progr_record IN number,
 old_anno_fiscale IN number,
 new_progr_record IN number,
 new_anno_fiscale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ANCI_VER"
   cursor cpk1_anci_ana(var_progr_record number,
                        var_anno_fiscale number) is
      select 1
      from   ANCI_VER
      where  PROGR_RECORD = var_progr_record
       and   ANNO_FISCALE = var_anno_fiscale
       and   var_progr_record is not null
       and   var_anno_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ANCI_VER" deve esistere quando si modifica "ANCI_ANA"
         if  NEW_PROGR_RECORD is not null and
             NEW_ANNO_FISCALE is not null and ( seq = 0 )
         and (   (NEW_PROGR_RECORD != OLD_PROGR_RECORD or OLD_PROGR_RECORD is null)
              or (NEW_ANNO_FISCALE != OLD_ANNO_FISCALE or OLD_ANNO_FISCALE is null) ) then
            open  cpk1_anci_ana(NEW_PROGR_RECORD,
                                NEW_ANNO_FISCALE);
            fetch cpk1_anci_ana into dummy;
            found := cpk1_anci_ana%FOUND;
            close cpk1_anci_ana;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Anci Ver. La registrazione Anci Ana non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_ANA_PU */
/

-- Trigger ANCI_ANA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANCI_ANA

create or replace trigger ANCI_ANA_TIU
before INSERT
    or UPDATE
on ANCI_ANA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANCI_ANA_PU(:OLD.PROGR_RECORD,
                     :OLD.ANNO_FISCALE,
                         :NEW.PROGR_RECORD,
                         :NEW.ANNO_FISCALE);
         null;
      end if;
      if INSERTING then
         ANCI_ANA_PI(:NEW.PROGR_RECORD,
                     :NEW.ANNO_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANCI_ANA"
            cursor cpk_anci_ana(var_PROGR_RECORD number,
                                var_ANNO_FISCALE number) is
               select 1
                 from   ANCI_ANA
                where  PROGR_RECORD = var_PROGR_RECORD and
                       ANNO_FISCALE = var_ANNO_FISCALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANCI_ANA"
               if :new.PROGR_RECORD is not null and
                  :new.ANNO_FISCALE is not null then
                  open  cpk_anci_ana(:new.PROGR_RECORD,
                                     :new.ANNO_FISCALE);
                  fetch cpk_anci_ana into dummy;
                  found := cpk_anci_ana%FOUND;
                  close cpk_anci_ana;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PROGR_RECORD||' '||
                               :new.ANNO_FISCALE||
                               '" gia'' presente in Anci Ana. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANCI_ANA_TIU */
/

-- Procedure ANCI_SOC_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANCI_SOC

create or replace procedure ANCI_SOC_PI
(new_progr_record IN number,
 new_anno_fiscale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ANCI_VER"
   cursor cpk1_anci_soc(var_progr_record number,
                        var_anno_fiscale number) is
      select 1
      from   ANCI_VER
      where  PROGR_RECORD = var_progr_record
       and   ANNO_FISCALE = var_anno_fiscale
       and   var_progr_record is not null
       and   var_anno_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ANCI_VER" deve esistere quando si inserisce su "ANCI_SOC"
         if NEW_PROGR_RECORD is not null and
            NEW_ANNO_FISCALE is not null then
            open  cpk1_anci_soc(NEW_PROGR_RECORD,
                                NEW_ANNO_FISCALE);
            fetch cpk1_anci_soc into dummy;
            found := cpk1_anci_soc%FOUND;
            close cpk1_anci_soc;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Anci Ver. La registrazione Anci Soc non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_SOC_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANCI_SOC
/* End Trigger: ANCI_SOC_TC */

-- Procedure ANCI_SOC_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANCI_SOC

create or replace procedure ANCI_SOC_PU
(old_progr_record IN number,
 old_anno_fiscale IN number,
 new_progr_record IN number,
 new_anno_fiscale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ANCI_VER"
   cursor cpk1_anci_soc(var_progr_record number,
                        var_anno_fiscale number) is
      select 1
      from   ANCI_VER
      where  PROGR_RECORD = var_progr_record
       and   ANNO_FISCALE = var_anno_fiscale
       and   var_progr_record is not null
       and   var_anno_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ANCI_VER" deve esistere quando si modifica "ANCI_SOC"
         if  NEW_PROGR_RECORD is not null and
             NEW_ANNO_FISCALE is not null and ( seq = 0 )
         and (   (NEW_PROGR_RECORD != OLD_PROGR_RECORD or OLD_PROGR_RECORD is null)
              or (NEW_ANNO_FISCALE != OLD_ANNO_FISCALE or OLD_ANNO_FISCALE is null) ) then
            open  cpk1_anci_soc(NEW_PROGR_RECORD,
                                NEW_ANNO_FISCALE);
            fetch cpk1_anci_soc into dummy;
            found := cpk1_anci_soc%FOUND;
            close cpk1_anci_soc;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Anci Ver. La registrazione Anci Soc non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_SOC_PU */
/

-- Trigger ANCI_SOC_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANCI_SOC

create or replace trigger ANCI_SOC_TIU
before INSERT
    or UPDATE
on ANCI_SOC
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANCI_SOC_PU(:OLD.PROGR_RECORD,
                     :OLD.ANNO_FISCALE,
                         :NEW.PROGR_RECORD,
                         :NEW.ANNO_FISCALE);
         null;
      end if;
      if INSERTING then
         ANCI_SOC_PI(:NEW.PROGR_RECORD,
                     :NEW.ANNO_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANCI_SOC"
            cursor cpk_anci_soc(var_PROGR_RECORD number,
                                var_ANNO_FISCALE number) is
               select 1
                 from   ANCI_SOC
                where  PROGR_RECORD = var_PROGR_RECORD and
                       ANNO_FISCALE = var_ANNO_FISCALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANCI_SOC"
               if :new.PROGR_RECORD is not null and
                  :new.ANNO_FISCALE is not null then
                  open  cpk_anci_soc(:new.PROGR_RECORD,
                                     :new.ANNO_FISCALE);
                  fetch cpk_anci_soc into dummy;
                  found := cpk_anci_soc%FOUND;
                  close cpk_anci_soc;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PROGR_RECORD||' '||
                               :new.ANNO_FISCALE||
                               '" gia'' presente in Anci Soc. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANCI_SOC_TIU */
/

-- Procedure ANCI_VAR_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANCI_VAR

create or replace procedure ANCI_VAR_PI
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_VAR_PI */
/

-- Procedure ANCI_VAR_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANCI_VAR

create or replace procedure ANCI_VAR_PU
(old_progressivo IN number,
 new_progressivo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_VAR_PU */
/

-- Trigger ANCI_VAR_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANCI_VAR

create or replace trigger ANCI_VAR_TIU
before INSERT
    or UPDATE
on ANCI_VAR
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.progressivo is null then
	ANCI_VAR_NR(:new.progressivo);
   end if;

   begin  -- Check REFERENTIAL Integrity at Level 0
      if UPDATING then
         ANCI_VAR_PU(:OLD.PROGRESSIVO,
                         :NEW.PROGRESSIVO);
         null;
      end if;
	if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANCI_VAR"
            cursor cpk_anci_var(var_PROGRESSIVO number) is
               select 1
                 from   ANCI_VAR
                where  PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANCI_VAR"
               if :new.PROGRESSIVO is not null then
                  open  cpk_anci_var(:new.PROGRESSIVO);
                  fetch cpk_anci_var into dummy;
                  found := cpk_anci_var%FOUND;
                  close cpk_anci_var;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PROGRESSIVO||
                               '" gia'' presente in Anci Var. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANCI_VAR_TIU */
/

-- Procedure ANCI_VER_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANCI_VER

create or replace procedure ANCI_VER_PI
(new_tipo_anomalia IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ANOMALIA"
   cursor cpk1_anci_ver(var_tipo_anomalia number) is
      select 1
      from   TIPI_ANOMALIA
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_ANOMALIA" deve esistere quando si inserisce su "ANCI_VER"
         if NEW_TIPO_ANOMALIA is not null then
            open  cpk1_anci_ver(NEW_TIPO_ANOMALIA);
            fetch cpk1_anci_ver into dummy;
            found := cpk1_anci_ver%FOUND;
            close cpk1_anci_ver;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Anomalia. La registrazione Anci Ver non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_VER_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANCI_VER
/* End Trigger: ANCI_VER_TC */

-- Procedure ANCI_VER_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANCI_VER

create or replace procedure ANCI_VER_PU
(old_progr_record IN number,
 old_anno_fiscale IN number,
 old_tipo_anomalia IN number,
 new_progr_record IN number,
 new_anno_fiscale IN number,
 new_tipo_anomalia IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ANOMALIA"
   cursor cpk1_anci_ver(var_tipo_anomalia number) is
      select 1
      from   TIPI_ANOMALIA
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_ANOMALIA" deve esistere quando si modifica "ANCI_VER"
         if  NEW_TIPO_ANOMALIA is not null and ( seq = 0 )
         and (   (NEW_TIPO_ANOMALIA != OLD_TIPO_ANOMALIA or OLD_TIPO_ANOMALIA is null) ) then
            open  cpk1_anci_ver(NEW_TIPO_ANOMALIA);
            fetch cpk1_anci_ver into dummy;
            found := cpk1_anci_ver%FOUND;
            close cpk1_anci_ver;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Anomalia. La registrazione Anci Ver non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_VER_PU */
/

-- Trigger ANCI_VER_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANCI_VER

create or replace trigger ANCI_VER_TIU
before INSERT
    or UPDATE
on ANCI_VER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANCI_VER_PU(:OLD.PROGR_RECORD,
                     :OLD.ANNO_FISCALE,
                     :OLD.TIPO_ANOMALIA,
                         :NEW.PROGR_RECORD,
                         :NEW.ANNO_FISCALE,
                         :NEW.TIPO_ANOMALIA);
         null;
      end if;
      if INSERTING then
         ANCI_VER_PI(:NEW.TIPO_ANOMALIA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANCI_VER"
            cursor cpk_anci_ver(var_PROGR_RECORD number,
                                var_ANNO_FISCALE number) is
               select 1
                 from   ANCI_VER
                where  PROGR_RECORD = var_PROGR_RECORD and
                       ANNO_FISCALE = var_ANNO_FISCALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANCI_VER"
               if :new.PROGR_RECORD is not null and
                  :new.ANNO_FISCALE is not null then
                  open  cpk_anci_ver(:new.PROGR_RECORD,
                                     :new.ANNO_FISCALE);
                  fetch cpk_anci_ver into dummy;
                  found := cpk_anci_ver%FOUND;
                  close cpk_anci_ver;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PROGR_RECORD||' '||
                               :new.ANNO_FISCALE||
                               '" gia'' presente in Anci Ver. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "ANCI_VER" for all children in "ANCI_ANA"
         if (:OLD.PROGR_RECORD != :NEW.PROGR_RECORD) or
            (:OLD.ANNO_FISCALE != :NEW.ANNO_FISCALE) then
            update ANCI_ANA
             set   PROGR_RECORD = :NEW.PROGR_RECORD,
                   ANNO_FISCALE = :NEW.ANNO_FISCALE
            where  PROGR_RECORD = :OLD.PROGR_RECORD
             and   ANNO_FISCALE = :OLD.ANNO_FISCALE;
         end if;

         --  Modify parent code of "ANCI_VER" for all children in "ANCI_SOC"
         if (:OLD.PROGR_RECORD != :NEW.PROGR_RECORD) or
            (:OLD.ANNO_FISCALE != :NEW.ANNO_FISCALE) then
            update ANCI_SOC
             set   PROGR_RECORD = :NEW.PROGR_RECORD,
                   ANNO_FISCALE = :NEW.ANNO_FISCALE
            where  PROGR_RECORD = :OLD.PROGR_RECORD
             and   ANNO_FISCALE = :OLD.ANNO_FISCALE;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANCI_VER_TIU */
/

-- Procedure ANCI_VER_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table ANCI_VER

create or replace procedure ANCI_VER_PD
(old_progr_record IN number,
 old_anno_fiscale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANCI_VER_PD */
/

-- Tigger ANCI_VER_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ANCI_VER

create or replace trigger ANCI_VER_TD
before DELETE
on ANCI_VER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      ANCI_VER_PD(:OLD.PROGR_RECORD,
                  :OLD.ANNO_FISCALE);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "ANCI_ANA"
      delete ANCI_ANA
      where  PROGR_RECORD = :OLD.PROGR_RECORD
       and   ANNO_FISCALE = :OLD.ANNO_FISCALE;

      --  Delete all children in "ANCI_SOC"
      delete ANCI_SOC
      where  PROGR_RECORD = :OLD.PROGR_RECORD
       and   ANNO_FISCALE = :OLD.ANNO_FISCALE;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANCI_VER_TD */
/

-- Procedure ANOMALIE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANOMALIE

create or replace procedure ANOMALIE_PI
(new_id_anomalia_parametro IN number,
 new_id_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ANOMALIE_PARAMETRI"
   cursor cpk1_anomalie(var_id_anomalia_parametro number) is
      select 1
      from   ANOMALIE_PARAMETRI
      where  ID_ANOMALIA_PARAMETRO = var_id_anomalia_parametro
       and   var_id_anomalia_parametro is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk2_anomalie(var_id_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_id_oggetto
       and   var_id_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ANOMALIE_PARAMETRI" deve esistere quando si inserisce su "ANOMALIE"
         if NEW_ID_ANOMALIA_PARAMETRO is not null then
            open  cpk1_anomalie(NEW_ID_ANOMALIA_PARAMETRO);
            fetch cpk1_anomalie into dummy;
            found := cpk1_anomalie%FOUND;
            close cpk1_anomalie;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su ANOMALIE_PARAMETRI. La registrazione ANOMALIE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "ANOMALIE"
         if NEW_ID_OGGETTO is not null then
            open  cpk2_anomalie(NEW_ID_OGGETTO);
            fetch cpk2_anomalie into dummy;
            found := cpk2_anomalie%FOUND;
            close cpk2_anomalie;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione ANOMALIE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANOMALIE
/* End Trigger: ANOMALIE_TC */

-- Procedure ANOMALIE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANOMALIE

create or replace procedure ANOMALIE_PU
(old_id_anomalia IN number,
 old_id_anomalia_parametro IN number,
 old_id_oggetto IN number,
 new_id_anomalia IN number,
 new_id_anomalia_parametro IN number,
 new_id_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ANOMALIE_PARAMETRI"
   cursor cpk1_anomalie(var_id_anomalia_parametro number) is
      select 1
      from   ANOMALIE_PARAMETRI
      where  ID_ANOMALIA_PARAMETRO = var_id_anomalia_parametro
       and   var_id_anomalia_parametro is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk2_anomalie(var_id_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_id_oggetto
       and   var_id_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE_PRATICHE"
   cursor cfk1_anomalie(var_id_anomalia number) is
      select 1
      from   ANOMALIE_PRATICHE
      where  ID_ANOMALIA = var_id_anomalia
       and   var_id_anomalia is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ANOMALIE_PARAMETRI" deve esistere quando si modifica "ANOMALIE"
         if  NEW_ID_ANOMALIA_PARAMETRO is not null and ( seq = 0 )
         and (   (NEW_ID_ANOMALIA_PARAMETRO != OLD_ID_ANOMALIA_PARAMETRO or OLD_ID_ANOMALIA_PARAMETRO is null) ) then
            open  cpk1_anomalie(NEW_ID_ANOMALIA_PARAMETRO);
            fetch cpk1_anomalie into dummy;
            found := cpk1_anomalie%FOUND;
            close cpk1_anomalie;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su ANOMALIE_PARAMETRI. La registrazione ANOMALIE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "ANOMALIE"
         if  NEW_ID_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_ID_OGGETTO != OLD_ID_OGGETTO or OLD_ID_OGGETTO is null) ) then
            open  cpk2_anomalie(NEW_ID_OGGETTO);
            fetch cpk2_anomalie into dummy;
            found := cpk2_anomalie%FOUND;
            close cpk2_anomalie;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione ANOMALIE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "ANOMALIE" non modificabile se esistono referenze su "ANOMALIE_PRATICHE"
      if (OLD_ID_ANOMALIA != NEW_ID_ANOMALIA) then
         open  cfk1_anomalie(OLD_ID_ANOMALIA);
         fetch cfk1_anomalie into dummy;
         found := cfk1_anomalie%FOUND;
         close cfk1_anomalie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Anomalie_Pratiche. La registrazione di ANOMALIE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_PU */
/

-- Trigger ANOMALIE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANOMALIE

create or replace trigger ANOMALIE_TIU
before INSERT
    or UPDATE
on ANOMALIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id_anomalia is null then
      ANOMALIE_NR(:new.id_anomalia);
      :new.data_creazione := sysdate;
    end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANOMALIE_PU(:OLD.ID_ANOMALIA,
                     :OLD.ID_ANOMALIA_PARAMETRO,
                     :OLD.ID_OGGETTO,
                         :NEW.ID_ANOMALIA,
                         :NEW.ID_ANOMALIA_PARAMETRO,
                         :NEW.ID_OGGETTO);
         null;
      end if;
      if INSERTING then
         ANOMALIE_PI(:NEW.ID_ANOMALIA_PARAMETRO,
                     :NEW.ID_OGGETTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANOMALIE"
            cursor cpk_anomalie(var_ID_ANOMALIA number) is
               select 1
                 from   ANOMALIE
                where  ID_ANOMALIA = var_ID_ANOMALIA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANOMALIE"
               if :new.ID_ANOMALIA is not null then
                  open  cpk_anomalie(:new.ID_ANOMALIA);
                  fetch cpk_anomalie into dummy;
                  found := cpk_anomalie%FOUND;
                  close cpk_anomalie;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_ANOMALIA||
                               '" gia'' presente in ANOMALIE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_TIU */
/

-- Procedure ANOMALIE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table ANOMALIE

create or replace procedure ANOMALIE_PD
(old_id_anomalia IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_PD */
/

-- Tigger ANOMALIE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ANOMALIE

create or replace trigger ANOMALIE_TD
before DELETE
on ANOMALIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      ANOMALIE_PD(:OLD.ID_ANOMALIA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "ANOMALIE_PRATICHE"
      delete ANOMALIE_PRATICHE
      where  ID_ANOMALIA = :OLD.ID_ANOMALIA;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_TD */
/

-- Procedure ANOMALIE_ANNO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANOMALIE_ANNO

create or replace procedure ANOMALIE_ANNO_PI
(new_tipo_anomalia IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ANOMALIA"
   cursor cpk1_anomalie_anno(var_tipo_anomalia number) is
      select 1
      from   TIPI_ANOMALIA
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_ANOMALIA" deve esistere quando si inserisce su "ANOMALIE_ANNO"
         if NEW_TIPO_ANOMALIA is not null then
            open  cpk1_anomalie_anno(NEW_TIPO_ANOMALIA);
            fetch cpk1_anomalie_anno into dummy;
            found := cpk1_anomalie_anno%FOUND;
            close cpk1_anomalie_anno;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Anomalia. La registrazione Anomalie_anno non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_ANNO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANOMALIE_ANNO
/* End Trigger: ANOMALIE_ANNO_TC */

-- Procedure ANOMALIE_ANNO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANOMALIE_ANNO

create or replace procedure ANOMALIE_ANNO_PU
(old_tipo_anomalia IN number,
 old_anno IN number,
 new_tipo_anomalia IN number,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ANOMALIA"
   cursor cpk1_anomalie_anno(var_tipo_anomalia number) is
      select 1
      from   TIPI_ANOMALIA
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_ANOMALIA" deve esistere quando si modifica "ANOMALIE_ANNO"
         if  NEW_TIPO_ANOMALIA is not null and ( seq = 0 )
         and (   (NEW_TIPO_ANOMALIA != OLD_TIPO_ANOMALIA or OLD_TIPO_ANOMALIA is null) ) then
            open  cpk1_anomalie_anno(NEW_TIPO_ANOMALIA);
            fetch cpk1_anomalie_anno into dummy;
            found := cpk1_anomalie_anno%FOUND;
            close cpk1_anomalie_anno;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Anomalia. La registrazione Anomalie_anno non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_ANNO_PU */
/

-- Trigger ANOMALIE_ANNO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANOMALIE_ANNO

create or replace trigger ANOMALIE_ANNO_TIU
before INSERT
    or UPDATE
on ANOMALIE_ANNO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANOMALIE_ANNO_PU(:OLD.TIPO_ANOMALIA,
                          :OLD.ANNO,
                         :NEW.TIPO_ANOMALIA,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         ANOMALIE_ANNO_PI(:NEW.TIPO_ANOMALIA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANOMALIE_ANNO"
            cursor cpk_anomalie_anno(var_TIPO_ANOMALIA number,
                                     var_ANNO number) is
               select 1
                 from   ANOMALIE_ANNO
                where  TIPO_ANOMALIA = var_TIPO_ANOMALIA and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANOMALIE_ANNO"
               if :new.TIPO_ANOMALIA is not null and
                  :new.ANNO is not null then
                  open  cpk_anomalie_anno(:new.TIPO_ANOMALIA,
                                          :new.ANNO);
                  fetch cpk_anomalie_anno into dummy;
                  found := cpk_anomalie_anno%FOUND;
                  close cpk_anomalie_anno;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_ANOMALIA||' '||
                               :new.ANNO||
                               '" gia'' presente in Anomalie_anno. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_ANNO_TIU */
/

-- Procedure ANOMALIE_CARICAMENTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANOMALIE_CARICAMENTO

create or replace procedure ANOMALIE_CARICAMENTO_PI
(new_documento_id IN number,
 new_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk1_anomalie_caricamento(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk2_anomalie_caricamento(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "ANOMALIE_CARICAMENTO"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk1_anomalie_caricamento(NEW_DOCUMENTO_ID);
            fetch cpk1_anomalie_caricamento into dummy;
            found := cpk1_anomalie_caricamento%FOUND;
            close cpk1_anomalie_caricamento;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione ANOMALIE_CARICAMENTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "ANOMALIE_CARICAMENTO"
         if NEW_OGGETTO is not null then
            open  cpk2_anomalie_caricamento(NEW_OGGETTO);
            fetch cpk2_anomalie_caricamento into dummy;
            found := cpk2_anomalie_caricamento%FOUND;
            close cpk2_anomalie_caricamento;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione ANOMALIE_CARICAMENTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_CARICAMENTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANOMALIE_CARICAMENTO
/* End Trigger: ANOMALIE_CARICAMENTO_TC */

-- Procedure ANOMALIE_CARICAMENTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANOMALIE_CARICAMENTO

create or replace procedure ANOMALIE_CARICAMENTO_PU
(old_documento_id IN number,
 old_sequenza IN number,
 old_oggetto IN number,
 new_documento_id IN number,
 new_sequenza IN number,
 new_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk1_anomalie_caricamento(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk2_anomalie_caricamento(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "ANOMALIE_CARICAMENTO"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk1_anomalie_caricamento(NEW_DOCUMENTO_ID);
            fetch cpk1_anomalie_caricamento into dummy;
            found := cpk1_anomalie_caricamento%FOUND;
            close cpk1_anomalie_caricamento;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione ANOMALIE_CARICAMENTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "ANOMALIE_CARICAMENTO"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk2_anomalie_caricamento(NEW_OGGETTO);
            fetch cpk2_anomalie_caricamento into dummy;
            found := cpk2_anomalie_caricamento%FOUND;
            close cpk2_anomalie_caricamento;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione ANOMALIE_CARICAMENTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_CARICAMENTO_PU */
/

-- Trigger ANOMALIE_CARICAMENTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANOMALIE_CARICAMENTO

create or replace trigger ANOMALIE_CARICAMENTO_TIU
before INSERT
    or UPDATE
on ANOMALIE_CARICAMENTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
     ANOMALIE_CARICAMENTO_NR(:new.documento_id, :new.sequenza);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANOMALIE_CARICAMENTO_PU(:OLD.DOCUMENTO_ID,
                                 :OLD.SEQUENZA,
                                 :OLD.OGGETTO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.SEQUENZA,
                         :NEW.OGGETTO);
         null;
      end if;
      if INSERTING then
         ANOMALIE_CARICAMENTO_PI(:NEW.DOCUMENTO_ID,
                                 :NEW.OGGETTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANOMALIE_CARICAMENTO"
            cursor cpk_anomalie_caricamento(var_DOCUMENTO_ID number,
                                            var_SEQUENZA number) is
               select 1
                 from   ANOMALIE_CARICAMENTO
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANOMALIE_CARICAMENTO"
               if :new.DOCUMENTO_ID is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_anomalie_caricamento(:new.DOCUMENTO_ID,
                                                 :new.SEQUENZA);
                  fetch cpk_anomalie_caricamento into dummy;
                  found := cpk_anomalie_caricamento%FOUND;
                  close cpk_anomalie_caricamento;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in ANOMALIE_CARICAMENTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_CARICAMENTO_TIU */
/

-- Procedure ANOMALIE_CONTITOLARI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANOMALIE_CONTITOLARI

create or replace procedure ANOMALIE_CONTITOLARI_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_anomalie_contitolari(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "ANOMALIE_CONTITOLARI"
         if NEW_PRATICA is not null then
            open  cpk1_anomalie_contitolari(NEW_PRATICA);
            fetch cpk1_anomalie_contitolari into dummy;
            found := cpk1_anomalie_contitolari%FOUND;
            close cpk1_anomalie_contitolari;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Anomalie Contitolari non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_CONTITOLARI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANOMALIE_CONTITOLARI
/* End Trigger: ANOMALIE_CONTITOLARI_TC */

-- Procedure ANOMALIE_CONTITOLARI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANOMALIE_CONTITOLARI

create or replace procedure ANOMALIE_CONTITOLARI_PU
(old_progressivo IN number,
 old_pratica IN number,
 new_progressivo IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_anomalie_contitolari(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "ANOMALIE_CONTITOLARI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_anomalie_contitolari(NEW_PRATICA);
            fetch cpk1_anomalie_contitolari into dummy;
            found := cpk1_anomalie_contitolari%FOUND;
            close cpk1_anomalie_contitolari;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Anomalie Contitolari non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_CONTITOLARI_PU */
/

-- Trigger ANOMALIE_CONTITOLARI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANOMALIE_CONTITOLARI

create or replace trigger ANOMALIE_CONTITOLARI_TIU
before INSERT
    or UPDATE
on ANOMALIE_CONTITOLARI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE

   if INSERTING and :new.progressivo is null then
	ANOMALIE_CONTITOLARI_NR(:new.progressivo);
   end if;

   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANOMALIE_CONTITOLARI_PU(:OLD.PROGRESSIVO,
                                 :OLD.PRATICA,
                         :NEW.PROGRESSIVO,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         ANOMALIE_CONTITOLARI_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANOMALIE_CONTITOLARI"
            cursor cpk_anomalie_contitolari(var_PROGRESSIVO number) is
               select 1
                 from   ANOMALIE_CONTITOLARI
                where  PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANOMALIE_CONTITOLARI"
               if :new.PROGRESSIVO is not null then
                  open  cpk_anomalie_contitolari(:new.PROGRESSIVO);
                  fetch cpk_anomalie_contitolari into dummy;
                  found := cpk_anomalie_contitolari%FOUND;
                  close cpk_anomalie_contitolari;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PROGRESSIVO||
                               '" gia'' presente in Anomalie Contitolari. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_CONTITOLARI_TIU */
/

-- Procedure ANOMALIE_ICI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANOMALIE_ICI

create or replace procedure ANOMALIE_ICI_PI
(new_tipo_anomalia IN number,
 new_cod_fiscale IN varchar,
 new_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ANOMALIA"
   cursor cpk1_anomalie_ici(var_tipo_anomalia number) is
      select 1
      from   TIPI_ANOMALIA
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk2_anomalie_ici(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk3_anomalie_ici(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_ANOMALIA" deve esistere quando si inserisce su "ANOMALIE_ICI"
         if NEW_TIPO_ANOMALIA is not null then
            open  cpk1_anomalie_ici(NEW_TIPO_ANOMALIA);
            fetch cpk1_anomalie_ici into dummy;
            found := cpk1_anomalie_ici%FOUND;
            close cpk1_anomalie_ici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Anomalia. La registrazione Anomalie ICI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "ANOMALIE_ICI"
         if NEW_OGGETTO is not null then
            open  cpk2_anomalie_ici(NEW_OGGETTO);
            fetch cpk2_anomalie_ici into dummy;
            found := cpk2_anomalie_ici%FOUND;
            close cpk2_anomalie_ici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Anomalie ICI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "ANOMALIE_ICI"
         if NEW_COD_FISCALE is not null then
            open  cpk3_anomalie_ici(NEW_COD_FISCALE);
            fetch cpk3_anomalie_ici into dummy;
            found := cpk3_anomalie_ici%FOUND;
            close cpk3_anomalie_ici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Anomalie ICI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_ICI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANOMALIE_ICI
/* End Trigger: ANOMALIE_ICI_TC */

-- Procedure ANOMALIE_ICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANOMALIE_ICI

create or replace procedure ANOMALIE_ICI_PU
(old_anomalia IN number,
 old_tipo_anomalia IN number,
 old_cod_fiscale IN varchar,
 old_oggetto IN number,
 new_anomalia IN number,
 new_tipo_anomalia IN number,
 new_cod_fiscale IN varchar,
 new_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ANOMALIA"
   cursor cpk1_anomalie_ici(var_tipo_anomalia number) is
      select 1
      from   TIPI_ANOMALIA
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk2_anomalie_ici(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk3_anomalie_ici(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_ANOMALIA" deve esistere quando si modifica "ANOMALIE_ICI"
         if  NEW_TIPO_ANOMALIA is not null and ( seq = 0 )
         and (   (NEW_TIPO_ANOMALIA != OLD_TIPO_ANOMALIA or OLD_TIPO_ANOMALIA is null) ) then
            open  cpk1_anomalie_ici(NEW_TIPO_ANOMALIA);
            fetch cpk1_anomalie_ici into dummy;
            found := cpk1_anomalie_ici%FOUND;
            close cpk1_anomalie_ici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Anomalia. La registrazione Anomalie ICI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "ANOMALIE_ICI"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk2_anomalie_ici(NEW_OGGETTO);
            fetch cpk2_anomalie_ici into dummy;
            found := cpk2_anomalie_ici%FOUND;
            close cpk2_anomalie_ici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Anomalie ICI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "ANOMALIE_ICI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk3_anomalie_ici(NEW_COD_FISCALE);
            fetch cpk3_anomalie_ici into dummy;
            found := cpk3_anomalie_ici%FOUND;
            close cpk3_anomalie_ici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Anomalie ICI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_ICI_PU */
/

-- Trigger ANOMALIE_ICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANOMALIE_ICI

create or replace trigger ANOMALIE_ICI_TIU
before INSERT
    or UPDATE
on ANOMALIE_ICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      ANOMALIE_ICI_DI(:new.cod_fiscale,:new.oggetto);
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.anomalia is null then
      ANOMALIE_ICI_NR(:new.anomalia);
    end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANOMALIE_ICI_PU(:OLD.ANOMALIA,
                         :OLD.TIPO_ANOMALIA,
                         :OLD.COD_FISCALE,
                         :OLD.OGGETTO,
                         :NEW.ANOMALIA,
                         :NEW.TIPO_ANOMALIA,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO);
         null;
      end if;
      if INSERTING then
         ANOMALIE_ICI_PI(:NEW.TIPO_ANOMALIA,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANOMALIE_ICI"
            cursor cpk_anomalie_ici(var_ANOMALIA number) is
               select 1
                 from   ANOMALIE_ICI
                where  ANOMALIA = var_ANOMALIA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANOMALIE_ICI"
               if :new.ANOMALIA is not null then
                  open  cpk_anomalie_ici(:new.ANOMALIA);
                  fetch cpk_anomalie_ici into dummy;
                  found := cpk_anomalie_ici%FOUND;
                  close cpk_anomalie_ici;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANOMALIA||
                               '" gia'' presente in Anomalie ICI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_ICI_TIU */
/

-- Procedure ANOMALIE_PARAMETRI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANOMALIE_PARAMETRI

create or replace procedure ANOMALIE_PARAMETRI_PI
(new_id_tipo_anomalia IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ANOMALIA"
   cursor cpk1_anomalie_parametri(var_id_tipo_anomalia number) is
      select 1
      from   TIPI_ANOMALIA
      where  TIPO_ANOMALIA = var_id_tipo_anomalia
       and   var_id_tipo_anomalia is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_anomalie_parametri(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_ANOMALIA" deve esistere quando si inserisce su "ANOMALIE_PARAMETRI"
         if NEW_ID_TIPO_ANOMALIA is not null then
            open  cpk1_anomalie_parametri(NEW_ID_TIPO_ANOMALIA);
            fetch cpk1_anomalie_parametri into dummy;
            found := cpk1_anomalie_parametri%FOUND;
            close cpk1_anomalie_parametri;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Anomalia. La registrazione ANOMALIE_PARAMETRI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "ANOMALIE_PARAMETRI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_anomalie_parametri(NEW_TIPO_TRIBUTO);
            fetch cpk2_anomalie_parametri into dummy;
            found := cpk2_anomalie_parametri%FOUND;
            close cpk2_anomalie_parametri;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione ANOMALIE_PARAMETRI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_PARAMETRI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANOMALIE_PARAMETRI
/* End Trigger: ANOMALIE_PARAMETRI_TC */

-- Procedure ANOMALIE_PARAMETRI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANOMALIE_PARAMETRI

create or replace procedure ANOMALIE_PARAMETRI_PU
(old_id_anomalia_parametro IN number,
 old_id_tipo_anomalia IN number,
 old_tipo_tributo IN varchar,
 new_id_anomalia_parametro IN number,
 new_id_tipo_anomalia IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ANOMALIA"
   cursor cpk1_anomalie_parametri(var_id_tipo_anomalia number) is
      select 1
      from   TIPI_ANOMALIA
      where  TIPO_ANOMALIA = var_id_tipo_anomalia
       and   var_id_tipo_anomalia is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_anomalie_parametri(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE"
   cursor cfk1_anomalie_parametri(var_id_anomalia_parametro number) is
      select 1
      from   ANOMALIE
      where  ID_ANOMALIA_PARAMETRO = var_id_anomalia_parametro
       and   var_id_anomalia_parametro is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_ANOMALIA" deve esistere quando si modifica "ANOMALIE_PARAMETRI"
         if  NEW_ID_TIPO_ANOMALIA is not null and ( seq = 0 )
         and (   (NEW_ID_TIPO_ANOMALIA != OLD_ID_TIPO_ANOMALIA or OLD_ID_TIPO_ANOMALIA is null) ) then
            open  cpk1_anomalie_parametri(NEW_ID_TIPO_ANOMALIA);
            fetch cpk1_anomalie_parametri into dummy;
            found := cpk1_anomalie_parametri%FOUND;
            close cpk1_anomalie_parametri;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Anomalia. La registrazione ANOMALIE_PARAMETRI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "ANOMALIE_PARAMETRI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_anomalie_parametri(NEW_TIPO_TRIBUTO);
            fetch cpk2_anomalie_parametri into dummy;
            found := cpk2_anomalie_parametri%FOUND;
            close cpk2_anomalie_parametri;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione ANOMALIE_PARAMETRI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "TIPI_ANOMALIA" non modificabile sul figlio: "ANOMALIE_PARAMETRI"
      if (OLD_ID_TIPO_ANOMALIA != NEW_ID_TIPO_ANOMALIA) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Tipi Anomalia non e'' modificabile su ANOMALIE_PARAMETRI.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ANOMALIE_PARAMETRI" non modificabile se esistono referenze su "ANOMALIE"
      if (OLD_ID_ANOMALIA_PARAMETRO != NEW_ID_ANOMALIA_PARAMETRO) then
         open  cfk1_anomalie_parametri(OLD_ID_ANOMALIA_PARAMETRO);
         fetch cfk1_anomalie_parametri into dummy;
         found := cfk1_anomalie_parametri%FOUND;
         close cfk1_anomalie_parametri;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ANOMALIE. La registrazione di ANOMALIE_PARAMETRI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_PARAMETRI_PU */
/

-- Trigger ANOMALIE_PARAMETRI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANOMALIE_PARAMETRI

create or replace trigger ANOMALIE_PARAMETRI_TIU
before INSERT
    or UPDATE
on ANOMALIE_PARAMETRI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id_anomalia_parametro is null then
      ANOMALIE_PARAMETRI_NR(:new.id_anomalia_parametro);
      :new.data_creazione := sysdate;
    end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANOMALIE_PARAMETRI_PU(:OLD.ID_ANOMALIA_PARAMETRO,
                               :OLD.ID_TIPO_ANOMALIA,
                               :OLD.TIPO_TRIBUTO,
                         :NEW.ID_ANOMALIA_PARAMETRO,
                         :NEW.ID_TIPO_ANOMALIA,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         ANOMALIE_PARAMETRI_PI(:NEW.ID_TIPO_ANOMALIA,
                               :NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANOMALIE_PARAMETRI"
            cursor cpk_anomalie_parametri(var_ID_ANOMALIA_PARAMETRO number) is
               select 1
                 from   ANOMALIE_PARAMETRI
                where  ID_ANOMALIA_PARAMETRO = var_ID_ANOMALIA_PARAMETRO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANOMALIE_PARAMETRI"
               if :new.ID_ANOMALIA_PARAMETRO is not null then
                  open  cpk_anomalie_parametri(:new.ID_ANOMALIA_PARAMETRO);
                  fetch cpk_anomalie_parametri into dummy;
                  found := cpk_anomalie_parametri%FOUND;
                  close cpk_anomalie_parametri;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_ANOMALIA_PARAMETRO||
                               '" gia'' presente in ANOMALIE_PARAMETRI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_PARAMETRI_TIU */
/

-- Procedure ANOMALIE_PARAMETRI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table ANOMALIE_PARAMETRI

create or replace procedure ANOMALIE_PARAMETRI_PD
(old_id_anomalia_parametro IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ANOMALIE"
   cursor cfk1_anomalie_parametri(var_id_anomalia_parametro number) is
      select 1
      from   ANOMALIE
      where  ID_ANOMALIA_PARAMETRO = var_id_anomalia_parametro
       and   var_id_anomalia_parametro is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "ANOMALIE_PARAMETRI" if children still exist in "ANOMALIE"
      open  cfk1_anomalie_parametri(OLD_ID_ANOMALIA_PARAMETRO);
      fetch cfk1_anomalie_parametri into dummy;
      found := cfk1_anomalie_parametri%FOUND;
      close cfk1_anomalie_parametri;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ANOMALIE. La registrazione di ANOMALIE_PARAMETRI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_PARAMETRI_PD */
/

-- Tigger ANOMALIE_PARAMETRI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ANOMALIE_PARAMETRI

create or replace trigger ANOMALIE_PARAMETRI_TD
before DELETE
on ANOMALIE_PARAMETRI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ANOMALIE

      ANOMALIE_PARAMETRI_PD(:OLD.ID_ANOMALIA_PARAMETRO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_PARAMETRI_TD */
/

-- Procedure ANOMALIE_PRATICHE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ANOMALIE_PRATICHE

create or replace procedure ANOMALIE_PRATICHE_PI
(new_id_anomalia IN number,
 new_oggetto_pratica IN number,
 new_cod_fiscale IN varchar,
 new_anomalia_pratica_rif IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_CONTRIBUENTE"
   cursor cpk1_anomalie_pratiche(var_cod_fiscale varchar,
                                 var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ANOMALIE"
   cursor cpk2_anomalie_pratiche(var_id_anomalia number) is
      select 1
      from   ANOMALIE
      where  ID_ANOMALIA = var_id_anomalia
       and   var_id_anomalia is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ANOMALIE_PRATICHE"
   cursor cpk3_anomalie_pratiche(var_anomalia_pratica_rif number) is
      select 1
      from   ANOMALIE_PRATICHE
      where  ID_ANOMALIA_PRATICA = var_anomalia_pratica_rif
       and   var_anomalia_pratica_rif is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si inserisce su "ANOMALIE_PRATICHE"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO_PRATICA is not null then
            open  cpk1_anomalie_pratiche(NEW_COD_FISCALE,
                                         NEW_OGGETTO_PRATICA);
            fetch cpk1_anomalie_pratiche into dummy;
            found := cpk1_anomalie_pratiche%FOUND;
            close cpk1_anomalie_pratiche;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Anomalie_Pratiche non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ANOMALIE" deve esistere quando si inserisce su "ANOMALIE_PRATICHE"
         if NEW_ID_ANOMALIA is not null then
            open  cpk2_anomalie_pratiche(NEW_ID_ANOMALIA);
            fetch cpk2_anomalie_pratiche into dummy;
            found := cpk2_anomalie_pratiche%FOUND;
            close cpk2_anomalie_pratiche;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su ANOMALIE. La registrazione Anomalie_Pratiche non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ANOMALIE_PRATICHE" deve esistere quando si inserisce su "ANOMALIE_PRATICHE"
         if NEW_ANOMALIA_PRATICA_RIF is not null then
            open  cpk3_anomalie_pratiche(NEW_ANOMALIA_PRATICA_RIF);
            fetch cpk3_anomalie_pratiche into dummy;
            found := cpk3_anomalie_pratiche%FOUND;
            close cpk3_anomalie_pratiche;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Anomalie_Pratiche. La registrazione Anomalie_Pratiche non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_PRATICHE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ANOMALIE_PRATICHE

create or replace trigger ANOMALIE_PRATICHE_TB
before INSERT
    or UPDATE
    or DELETE
on ANOMALIE_PRATICHE
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: ANOMALIE_PRATICHE_TB */
/

create or replace trigger ANOMALIE_PRATICHE_TC
after INSERT
   or UPDATE
   or DELETE
on ANOMALIE_PRATICHE
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: ANOMALIE_PRATICHE_TC */
/

-- Procedure ANOMALIE_PRATICHE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ANOMALIE_PRATICHE

create or replace procedure ANOMALIE_PRATICHE_PU
(old_id_anomalia_pratica IN number,
 old_id_anomalia IN number,
 old_oggetto_pratica IN number,
 old_cod_fiscale IN varchar,
 old_anomalia_pratica_rif IN number,
 new_id_anomalia_pratica IN number,
 new_id_anomalia IN number,
 new_oggetto_pratica IN number,
 new_cod_fiscale IN varchar,
 new_anomalia_pratica_rif IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_CONTRIBUENTE"
   cursor cpk1_anomalie_pratiche(var_cod_fiscale varchar,
                                 var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ANOMALIE"
   cursor cpk2_anomalie_pratiche(var_id_anomalia number) is
      select 1
      from   ANOMALIE
      where  ID_ANOMALIA = var_id_anomalia
       and   var_id_anomalia is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ANOMALIE_PRATICHE"
   cursor cpk3_anomalie_pratiche(var_anomalia_pratica_rif number) is
      select 1
      from   ANOMALIE_PRATICHE
      where  ID_ANOMALIA_PRATICA = var_anomalia_pratica_rif
       and   var_anomalia_pratica_rif is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si modifica "ANOMALIE_PRATICHE"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_anomalie_pratiche(NEW_COD_FISCALE,
                                         NEW_OGGETTO_PRATICA);
            fetch cpk1_anomalie_pratiche into dummy;
            found := cpk1_anomalie_pratiche%FOUND;
            close cpk1_anomalie_pratiche;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Anomalie_Pratiche non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ANOMALIE" deve esistere quando si modifica "ANOMALIE_PRATICHE"
         if  NEW_ID_ANOMALIA is not null and ( seq = 0 )
         and (   (NEW_ID_ANOMALIA != OLD_ID_ANOMALIA or OLD_ID_ANOMALIA is null) ) then
            open  cpk2_anomalie_pratiche(NEW_ID_ANOMALIA);
            fetch cpk2_anomalie_pratiche into dummy;
            found := cpk2_anomalie_pratiche%FOUND;
            close cpk2_anomalie_pratiche;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su ANOMALIE. La registrazione Anomalie_Pratiche non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ANOMALIE_PRATICHE" deve esistere quando si modifica "ANOMALIE_PRATICHE"
         if  NEW_ANOMALIA_PRATICA_RIF is not null and ( seq = 0 )
         and (   (NEW_ANOMALIA_PRATICA_RIF != OLD_ANOMALIA_PRATICA_RIF or OLD_ANOMALIA_PRATICA_RIF is null) ) then
            open  cpk3_anomalie_pratiche(NEW_ANOMALIA_PRATICA_RIF);
            fetch cpk3_anomalie_pratiche into dummy;
            found := cpk3_anomalie_pratiche%FOUND;
            close cpk3_anomalie_pratiche;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Anomalie_Pratiche. La registrazione Anomalie_Pratiche non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ANOMALIE_PRATICHE_PU */
/

-- Trigger ANOMALIE_PRATICHE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ANOMALIE_PRATICHE

create or replace trigger ANOMALIE_PRATICHE_TIU
before INSERT
    or UPDATE
on ANOMALIE_PRATICHE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id_anomalia is null then
      ANOMALIE_PRATICHE_NR(:new.id_anomalia_pratica);
      :new.data_reg := sysdate;
    end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ANOMALIE_PRATICHE_PU(:OLD.ID_ANOMALIA_PRATICA,
                              :OLD.ID_ANOMALIA,
                              :OLD.OGGETTO_PRATICA,
                              :OLD.COD_FISCALE,
                              :OLD.ANOMALIA_PRATICA_RIF,
                         :NEW.ID_ANOMALIA_PRATICA,
                         :NEW.ID_ANOMALIA,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.COD_FISCALE,
                         :NEW.ANOMALIA_PRATICA_RIF);
         null;
      end if;
      if INSERTING then
         ANOMALIE_PRATICHE_PI(:NEW.ID_ANOMALIA,
                              :NEW.OGGETTO_PRATICA,
                              :NEW.COD_FISCALE,
                              :NEW.ANOMALIA_PRATICA_RIF);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ANOMALIE_PRATICHE"
            cursor cpk_anomalie_pratiche(var_ID_ANOMALIA_PRATICA number) is
               select 1
                 from   ANOMALIE_PRATICHE
                where  ID_ANOMALIA_PRATICA = var_ID_ANOMALIA_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ANOMALIE_PRATICHE"
               if :new.ID_ANOMALIA_PRATICA is not null then
                  open  cpk_anomalie_pratiche(:new.ID_ANOMALIA_PRATICA);
                  fetch cpk_anomalie_pratiche into dummy;
                  found := cpk_anomalie_pratiche%FOUND;
                  close cpk_anomalie_pratiche;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_ANOMALIA_PRATICA||
                               '" gia'' presente in Anomalie_Pratiche. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_PRATICHE_TIU */
/

-- Tigger ANOMALIE_PRATICHE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ANOMALIE_PRATICHE

create or replace trigger ANOMALIE_PRATICHE_TD
before DELETE
on ANOMALIE_PRATICHE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      ANOMALIE_PRATICHE_PD(:OLD.ID_ANOMALIA_PRATICA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
            DECLARE a_istruzione  varchar2(2000);
                    a_messaggio   varchar2(2000);
            BEGIN
	     BEGIN
               a_messaggio := 'Esistono riferimenti su Anomalie Pratiche. La registrazione di Anomalie Pratiche non e'' eliminabile.';
               a_istruzione := 'select 0 from Anomalie_pratiche where anomalia_pratica_rif = '
                               ||:old.id_anomalia_pratica;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
             EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
             END;
 	    END;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ANOMALIE_PRATICHE_TD */
/

-- Procedure ARCHIVIO_VIE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ARCHIVIO_VIE

create or replace procedure ARCHIVIO_VIE_PU
(old_cod_via IN number,
 new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "CIVICI_EDIFICIO"
   cursor cfk1_archivio_vie(var_cod_via number) is
      select 1
      from   CIVICI_EDIFICIO
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of UpdateParentRestrict constraint for "CIVICI_OGGETTO"
   cursor cfk2_archivio_vie(var_cod_via number) is
      select 1
      from   CIVICI_OGGETTO
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI"
   cursor cfk3_archivio_vie(var_cod_via number) is
      select 1
      from   OGGETTI
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of UpdateParentRestrict constraint for "DENOMINAZIONI_VIA"
   cursor cfk4_archivio_vie(var_cod_via number) is
      select 1
      from   DENOMINAZIONI_VIA
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of UpdateParentRestrict constraint for "SOGGETTI"
   cursor cfk5_archivio_vie(var_cod_via number) is
      select 1
      from   SOGGETTI
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_CIVICI_OGGETTO"
   cursor cfk6_archivio_vie(var_cod_via number) is
      select 1
      from   STO_CIVICI_OGGETTO
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_OGGETTI"
   cursor cfk7_archivio_vie(var_cod_via number) is
      select 1
      from   STO_OGGETTI
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of UpdateParentRestrict constraint for "ARCHIVIO_VIE_ZONA"
   cursor cfk8_archivio_vie(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE_ZONA
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "ARCHIVIO_VIE" non modificabile se esistono referenze su "CIVICI_EDIFICIO"
      if (OLD_COD_VIA != NEW_COD_VIA) then
         open  cfk1_archivio_vie(OLD_COD_VIA);
         fetch cfk1_archivio_vie into dummy;
         found := cfk1_archivio_vie%FOUND;
         close cfk1_archivio_vie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Civici Edificio. La registrazione di Archivio Vie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ARCHIVIO_VIE" non modificabile se esistono referenze su "CIVICI_OGGETTO"
      if (OLD_COD_VIA != NEW_COD_VIA) then
         open  cfk2_archivio_vie(OLD_COD_VIA);
         fetch cfk2_archivio_vie into dummy;
         found := cfk2_archivio_vie%FOUND;
         close cfk2_archivio_vie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Civici Oggetto. La registrazione di Archivio Vie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ARCHIVIO_VIE" non modificabile se esistono referenze su "OGGETTI"
      if (OLD_COD_VIA != NEW_COD_VIA) then
         open  cfk3_archivio_vie(OLD_COD_VIA);
         fetch cfk3_archivio_vie into dummy;
         found := cfk3_archivio_vie%FOUND;
         close cfk3_archivio_vie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Archivio Vie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ARCHIVIO_VIE" non modificabile se esistono referenze su "DENOMINAZIONI_VIA"
      if (OLD_COD_VIA != NEW_COD_VIA) then
         open  cfk4_archivio_vie(OLD_COD_VIA);
         fetch cfk4_archivio_vie into dummy;
         found := cfk4_archivio_vie%FOUND;
         close cfk4_archivio_vie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Denominazioni Via. La registrazione di Archivio Vie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ARCHIVIO_VIE" non modificabile se esistono referenze su "SOGGETTI"
      if (OLD_COD_VIA != NEW_COD_VIA) then
         open  cfk5_archivio_vie(OLD_COD_VIA);
         fetch cfk5_archivio_vie into dummy;
         found := cfk5_archivio_vie%FOUND;
         close cfk5_archivio_vie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Soggetti. La registrazione di Archivio Vie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ARCHIVIO_VIE" non modificabile se esistono referenze su "STO_CIVICI_OGGETTO"
      if (OLD_COD_VIA != NEW_COD_VIA) then
         open  cfk6_archivio_vie(OLD_COD_VIA);
         fetch cfk6_archivio_vie into dummy;
         found := cfk6_archivio_vie%FOUND;
         close cfk6_archivio_vie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_CIVICI_OGGETTO. La registrazione di Archivio Vie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ARCHIVIO_VIE" non modificabile se esistono referenze su "STO_OGGETTI"
      if (OLD_COD_VIA != NEW_COD_VIA) then
         open  cfk7_archivio_vie(OLD_COD_VIA);
         fetch cfk7_archivio_vie into dummy;
         found := cfk7_archivio_vie%FOUND;
         close cfk7_archivio_vie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_OGGETTI. La registrazione di Archivio Vie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "ARCHIVIO_VIE" non modificabile se esistono referenze su "ARCHIVIO_VIE_ZONA"
      if (OLD_COD_VIA != NEW_COD_VIA) then
         open  cfk8_archivio_vie(OLD_COD_VIA);
         fetch cfk8_archivio_vie into dummy;
         found := cfk8_archivio_vie%FOUND;
         close cfk8_archivio_vie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ARCHIVIO_VIE_ZONA. La registrazione di Archivio Vie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ARCHIVIO_VIE_PU */
/

-- Trigger ARCHIVIO_VIE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ARCHIVIO_VIE

create or replace trigger ARCHIVIO_VIE_TIU
before INSERT
    or UPDATE
on ARCHIVIO_VIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.cod_via is null then
      ARCHIVIO_VIE_NR(:new.cod_via);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ARCHIVIO_VIE_PU(:OLD.COD_VIA,
                         :NEW.COD_VIA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ARCHIVIO_VIE"
            cursor cpk_archivio_vie(var_COD_VIA number) is
               select 1
                 from   ARCHIVIO_VIE
                where  COD_VIA = var_COD_VIA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ARCHIVIO_VIE"
               if :new.COD_VIA is not null then
                  open  cpk_archivio_vie(:new.COD_VIA);
                  fetch cpk_archivio_vie into dummy;
                  found := cpk_archivio_vie%FOUND;
                  close cpk_archivio_vie;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_VIA||
                               '" gia'' presente in Archivio Vie. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            ARCHIVIO_VIE_FI (:old.cod_via,:new.cod_via,:new.denom_uff,:new.denom_ord);
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ARCHIVIO_VIE_TIU */
/

-- Procedure ARCHIVIO_VIE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table ARCHIVIO_VIE

create or replace procedure ARCHIVIO_VIE_PD
(old_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CIVICI_EDIFICIO"
   cursor cfk1_archivio_vie(var_cod_via number) is
      select 1
      from   CIVICI_EDIFICIO
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of DeleteParentRestrict constraint for "CIVICI_OGGETTO"
   cursor cfk2_archivio_vie(var_cod_via number) is
      select 1
      from   CIVICI_OGGETTO
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI"
   cursor cfk3_archivio_vie(var_cod_via number) is
      select 1
      from   OGGETTI
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of DeleteParentRestrict constraint for "SOGGETTI"
   cursor cfk4_archivio_vie(var_cod_via number) is
      select 1
      from   SOGGETTI
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of DeleteParentRestrict constraint for "STO_CIVICI_OGGETTO"
   cursor cfk5_archivio_vie(var_cod_via number) is
      select 1
      from   STO_CIVICI_OGGETTO
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of DeleteParentRestrict constraint for "STO_OGGETTI"
   cursor cfk6_archivio_vie(var_cod_via number) is
      select 1
      from   STO_OGGETTI
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of DeleteParentRestrict constraint for "ARCHIVIO_VIE_ZONA"
   cursor cfk7_archivio_vie(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE_ZONA
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "ARCHIVIO_VIE" if children still exist in "CIVICI_EDIFICIO"
      open  cfk1_archivio_vie(OLD_COD_VIA);
      fetch cfk1_archivio_vie into dummy;
      found := cfk1_archivio_vie%FOUND;
      close cfk1_archivio_vie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Civici Edificio. La registrazione di Archivio Vie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ARCHIVIO_VIE" if children still exist in "CIVICI_OGGETTO"
      open  cfk2_archivio_vie(OLD_COD_VIA);
      fetch cfk2_archivio_vie into dummy;
      found := cfk2_archivio_vie%FOUND;
      close cfk2_archivio_vie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Civici Oggetto. La registrazione di Archivio Vie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ARCHIVIO_VIE" if children still exist in "OGGETTI"
      open  cfk3_archivio_vie(OLD_COD_VIA);
      fetch cfk3_archivio_vie into dummy;
      found := cfk3_archivio_vie%FOUND;
      close cfk3_archivio_vie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Archivio Vie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ARCHIVIO_VIE" if children still exist in "SOGGETTI"
      open  cfk4_archivio_vie(OLD_COD_VIA);
      fetch cfk4_archivio_vie into dummy;
      found := cfk4_archivio_vie%FOUND;
      close cfk4_archivio_vie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Soggetti. La registrazione di Archivio Vie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ARCHIVIO_VIE" if children still exist in "STO_CIVICI_OGGETTO"
      open  cfk5_archivio_vie(OLD_COD_VIA);
      fetch cfk5_archivio_vie into dummy;
      found := cfk5_archivio_vie%FOUND;
      close cfk5_archivio_vie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su STO_CIVICI_OGGETTO. La registrazione di Archivio Vie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ARCHIVIO_VIE" if children still exist in "STO_OGGETTI"
      open  cfk6_archivio_vie(OLD_COD_VIA);
      fetch cfk6_archivio_vie into dummy;
      found := cfk6_archivio_vie%FOUND;
      close cfk6_archivio_vie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su STO_OGGETTI. La registrazione di Archivio Vie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ARCHIVIO_VIE" if children still exist in "ARCHIVIO_VIE_ZONA"
      open  cfk7_archivio_vie(OLD_COD_VIA);
      fetch cfk7_archivio_vie into dummy;
      found := cfk7_archivio_vie%FOUND;
      close cfk7_archivio_vie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ARCHIVIO_VIE_ZONA. La registrazione di Archivio Vie non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ARCHIVIO_VIE_PD */
/

-- Tigger ARCHIVIO_VIE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ARCHIVIO_VIE

create or replace trigger ARCHIVIO_VIE_TD
before DELETE
on ARCHIVIO_VIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CIVICI_EDIFICIO

      -- Child Restrict Table: CIVICI_OGGETTO

      -- Child Restrict Table: OGGETTI

      -- Child Restrict Table: SOGGETTI

      -- Child Restrict Table: STO_CIVICI_OGGETTO

      -- Child Restrict Table: STO_OGGETTI

      -- Child Restrict Table: ARCHIVIO_VIE_ZONA

      ARCHIVIO_VIE_PD(:OLD.COD_VIA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "DENOMINAZIONI_VIA"
      delete DENOMINAZIONI_VIA
      where  COD_VIA = :OLD.COD_VIA;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ARCHIVIO_VIE_TD */
/

-- Procedure ARCHIVIO_VIE_ZONA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ARCHIVIO_VIE_ZONA

create or replace procedure ARCHIVIO_VIE_ZONA_PI
(new_cod_via IN number,
 new_cod_zona IN number,
 new_sequenza_zona IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE"
   cursor cpk1_archivio_vie_zona(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE_ZONE"
   cursor cpk2_archivio_vie_zona(var_cod_zona number,
                                 var_sequenza_zona number) is
      select 1
      from   ARCHIVIO_VIE_ZONE
      where  COD_ZONA = var_cod_zona
       and   SEQUENZA = var_sequenza_zona
       and   var_cod_zona is not null
       and   var_sequenza_zona is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si inserisce su "ARCHIVIO_VIE_ZONA"
         if NEW_COD_VIA is not null then
            open  cpk1_archivio_vie_zona(NEW_COD_VIA);
            fetch cpk1_archivio_vie_zona into dummy;
            found := cpk1_archivio_vie_zona%FOUND;
            close cpk1_archivio_vie_zona;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione ARCHIVIO_VIE_ZONA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE_ZONE" deve esistere quando si inserisce su "ARCHIVIO_VIE_ZONA"
         if NEW_COD_ZONA is not null and
            NEW_SEQUENZA_ZONA is not null then
            open  cpk2_archivio_vie_zona(NEW_COD_ZONA,
                                         NEW_SEQUENZA_ZONA);
            fetch cpk2_archivio_vie_zona into dummy;
            found := cpk2_archivio_vie_zona%FOUND;
            close cpk2_archivio_vie_zona;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su ARCHIVIO_VIE_ZONE. La registrazione ARCHIVIO_VIE_ZONA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ARCHIVIO_VIE_ZONA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ARCHIVIO_VIE_ZONA
/* End Trigger: ARCHIVIO_VIE_ZONA_TC */

-- Procedure ARCHIVIO_VIE_ZONA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ARCHIVIO_VIE_ZONA

create or replace procedure ARCHIVIO_VIE_ZONA_PU
(old_cod_via IN number,
 old_sequenza IN number,
 old_cod_zona IN number,
 old_sequenza_zona IN number,
 new_cod_via IN number,
 new_sequenza IN number,
 new_cod_zona IN number,
 new_sequenza_zona IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE"
   cursor cpk1_archivio_vie_zona(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE_ZONE"
   cursor cpk2_archivio_vie_zona(var_cod_zona number,
                                 var_sequenza_zona number) is
      select 1
      from   ARCHIVIO_VIE_ZONE
      where  COD_ZONA = var_cod_zona
       and   SEQUENZA = var_sequenza_zona
       and   var_cod_zona is not null
       and   var_sequenza_zona is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si modifica "ARCHIVIO_VIE_ZONA"
         if  NEW_COD_VIA is not null and ( seq = 0 )
         and (   (NEW_COD_VIA != OLD_COD_VIA or OLD_COD_VIA is null) ) then
            open  cpk1_archivio_vie_zona(NEW_COD_VIA);
            fetch cpk1_archivio_vie_zona into dummy;
            found := cpk1_archivio_vie_zona%FOUND;
            close cpk1_archivio_vie_zona;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione ARCHIVIO_VIE_ZONA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE_ZONE" deve esistere quando si modifica "ARCHIVIO_VIE_ZONA"
         if  NEW_COD_ZONA is not null and
             NEW_SEQUENZA_ZONA is not null and ( seq = 0 )
         and (   (NEW_COD_ZONA != OLD_COD_ZONA or OLD_COD_ZONA is null)
              or (NEW_SEQUENZA_ZONA != OLD_SEQUENZA_ZONA or OLD_SEQUENZA_ZONA is null) ) then
            open  cpk2_archivio_vie_zona(NEW_COD_ZONA,
                                         NEW_SEQUENZA_ZONA);
            fetch cpk2_archivio_vie_zona into dummy;
            found := cpk2_archivio_vie_zona%FOUND;
            close cpk2_archivio_vie_zona;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su ARCHIVIO_VIE_ZONE. La registrazione ARCHIVIO_VIE_ZONA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ARCHIVIO_VIE_ZONA_PU */
/

-- Trigger ARCHIVIO_VIE_ZONA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ARCHIVIO_VIE_ZONA

create or replace trigger ARCHIVIO_VIE_ZONA_TIU
before INSERT
    or UPDATE
on ARCHIVIO_VIE_ZONA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
          ARCHIVIO_VIE_ZONA_NR(:new.cod_via,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ARCHIVIO_VIE_ZONA_PU(:OLD.COD_VIA,
                              :OLD.SEQUENZA,
                              :OLD.COD_ZONA,
                              :OLD.SEQUENZA_ZONA,
                         :NEW.COD_VIA,
                         :NEW.SEQUENZA,
                         :NEW.COD_ZONA,
                         :NEW.SEQUENZA_ZONA);
         null;
      end if;
      if INSERTING then
         ARCHIVIO_VIE_ZONA_PI(:NEW.COD_VIA,
                              :NEW.COD_ZONA,
                              :NEW.SEQUENZA_ZONA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ARCHIVIO_VIE_ZONA"
            cursor cpk_archivio_vie_zona(var_COD_VIA number,
                                         var_SEQUENZA number) is
               select 1
                 from   ARCHIVIO_VIE_ZONA
                where  COD_VIA = var_COD_VIA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ARCHIVIO_VIE_ZONA"
               if :new.COD_VIA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_archivio_vie_zona(:new.COD_VIA,
                                              :new.SEQUENZA);
                  fetch cpk_archivio_vie_zona into dummy;
                  found := cpk_archivio_vie_zona%FOUND;
                  close cpk_archivio_vie_zona;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_VIA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in ARCHIVIO_VIE_ZONA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ARCHIVIO_VIE_ZONA_TIU */
/

-- Procedure ARCHIVIO_VIE_ZONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ARCHIVIO_VIE_ZONE

create or replace procedure ARCHIVIO_VIE_ZONE_PU
(old_cod_zona IN number,
 old_sequenza IN number,
 new_cod_zona IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "ARCHIVIO_VIE_ZONA"
   cursor cfk1_archivio_vie_zone(var_cod_zona number,
                                 var_sequenza number) is
      select 1
      from   ARCHIVIO_VIE_ZONA
      where  COD_ZONA = var_cod_zona
       and   SEQUENZA_ZONA = var_sequenza
       and   var_cod_zona is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "ARCHIVIO_VIE_ZONE" non modificabile se esistono referenze su "ARCHIVIO_VIE_ZONA"
      if (OLD_COD_ZONA != NEW_COD_ZONA) or
         (OLD_SEQUENZA != NEW_SEQUENZA) then
         open  cfk1_archivio_vie_zone(OLD_COD_ZONA,
                                      OLD_SEQUENZA);
         fetch cfk1_archivio_vie_zone into dummy;
         found := cfk1_archivio_vie_zone%FOUND;
         close cfk1_archivio_vie_zone;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ARCHIVIO_VIE_ZONA. La registrazione di ARCHIVIO_VIE_ZONE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ARCHIVIO_VIE_ZONE_PU */
/

-- Trigger ARCHIVIO_VIE_ZONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ARCHIVIO_VIE_ZONE

create or replace trigger ARCHIVIO_VIE_ZONE_TIU
before INSERT
    or UPDATE
on ARCHIVIO_VIE_ZONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
          ARCHIVIO_VIE_ZONE_NR(:new.cod_zona,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ARCHIVIO_VIE_ZONE_PU(:OLD.COD_ZONA,
                              :OLD.SEQUENZA,
                         :NEW.COD_ZONA,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ARCHIVIO_VIE_ZONE"
            cursor cpk_archivio_vie_zone(var_COD_ZONA number,
                                         var_SEQUENZA number) is
               select 1
                 from   ARCHIVIO_VIE_ZONE
                where  COD_ZONA = var_COD_ZONA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ARCHIVIO_VIE_ZONE"
               if :new.COD_ZONA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_archivio_vie_zone(:new.COD_ZONA,
                                              :new.SEQUENZA);
                  fetch cpk_archivio_vie_zone into dummy;
                  found := cpk_archivio_vie_zone%FOUND;
                  close cpk_archivio_vie_zone;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_ZONA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in ARCHIVIO_VIE_ZONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ARCHIVIO_VIE_ZONE_TIU */
/

-- Procedure ARCHIVIO_VIE_ZONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table ARCHIVIO_VIE_ZONE

create or replace procedure ARCHIVIO_VIE_ZONE_PD
(old_cod_zona IN number,
 old_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ARCHIVIO_VIE_ZONA"
   cursor cfk1_archivio_vie_zone(var_cod_zona number,
                                 var_sequenza number) is
      select 1
      from   ARCHIVIO_VIE_ZONA
      where  COD_ZONA = var_cod_zona
       and   SEQUENZA_ZONA = var_sequenza
       and   var_cod_zona is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "ARCHIVIO_VIE_ZONE" if children still exist in "ARCHIVIO_VIE_ZONA"
      open  cfk1_archivio_vie_zone(OLD_COD_ZONA,
                                   OLD_SEQUENZA);
      fetch cfk1_archivio_vie_zone into dummy;
      found := cfk1_archivio_vie_zone%FOUND;
      close cfk1_archivio_vie_zone;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ARCHIVIO_VIE_ZONA. La registrazione di ARCHIVIO_VIE_ZONE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ARCHIVIO_VIE_ZONE_PD */
/

-- Tigger ARCHIVIO_VIE_ZONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ARCHIVIO_VIE_ZONE

create or replace trigger ARCHIVIO_VIE_ZONE_TD
before DELETE
on ARCHIVIO_VIE_ZONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ARCHIVIO_VIE_ZONA

      ARCHIVIO_VIE_ZONE_PD(:OLD.COD_ZONA,
                           :OLD.SEQUENZA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ARCHIVIO_VIE_ZONE_TD */
/

-- Procedure ARROTONDAMENTI_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ARROTONDAMENTI_TRIBUTO

create or replace procedure ARROTONDAMENTI_TRIBUTO_PI
(new_tributo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_TRIBUTO"
   cursor cpk1_arrotondamenti_tributo(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si inserisce su "ARROTONDAMENTI_TRIBUTO"
         if NEW_TRIBUTO is not null then
            open  cpk1_arrotondamenti_tributo(NEW_TRIBUTO);
            fetch cpk1_arrotondamenti_tributo into dummy;
            found := cpk1_arrotondamenti_tributo%FOUND;
            close cpk1_arrotondamenti_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione ARROTONDAMENTI_TRIBUTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ARROTONDAMENTI_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ARROTONDAMENTI_TRIBUTO
/* End Trigger: ARROTONDAMENTI_TRIBUTO_TC */

-- Procedure ARROTONDAMENTI_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ARROTONDAMENTI_TRIBUTO

create or replace procedure ARROTONDAMENTI_TRIBUTO_PU
(old_tributo IN number,
 old_sequenza IN number,
 new_tributo IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_TRIBUTO"
   cursor cpk1_arrotondamenti_tributo(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si modifica "ARROTONDAMENTI_TRIBUTO"
         if  NEW_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null) ) then
            open  cpk1_arrotondamenti_tributo(NEW_TRIBUTO);
            fetch cpk1_arrotondamenti_tributo into dummy;
            found := cpk1_arrotondamenti_tributo%FOUND;
            close cpk1_arrotondamenti_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione ARROTONDAMENTI_TRIBUTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ARROTONDAMENTI_TRIBUTO_PU */
/

-- Trigger ARROTONDAMENTI_CODICE_TRIB_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ARROTONDAMENTI_TRIBUTO

create or replace trigger ARROTONDAMENTI_CODICE_TRIB_TIU
before INSERT
    or UPDATE
on ARROTONDAMENTI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
          ARROTONDAMENTI_TRIBUTO_NR(:new.tributo,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ARROTONDAMENTI_TRIBUTO_PU(:OLD.TRIBUTO,
                                   :OLD.SEQUENZA,
                         :NEW.TRIBUTO,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         ARROTONDAMENTI_TRIBUTO_PI(:NEW.TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ARROTONDAMENTI_TRIBUTO"
            cursor cpk_arrotondamenti_tributo(var_TRIBUTO number,
                                              var_SEQUENZA number) is
               select 1
                 from   ARROTONDAMENTI_TRIBUTO
                where  TRIBUTO = var_TRIBUTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ARROTONDAMENTI_TRIBUTO"
               if :new.TRIBUTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_arrotondamenti_tributo(:new.TRIBUTO,
                                                   :new.SEQUENZA);
                  fetch cpk_arrotondamenti_tributo into dummy;
                  found := cpk_arrotondamenti_tributo%FOUND;
                  close cpk_arrotondamenti_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TRIBUTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in ARROTONDAMENTI_TRIBUTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ARROTONDAMENTI_CODICE_TRIB_TIU */
/

-- Procedure ATTIVITA_ELABORAZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ATTIVITA_ELABORAZIONE

create or replace procedure ATTIVITA_ELABORAZIONE_PI
(new_elaborazione_id IN number,
 new_tipo_attivita IN number,
 new_stato_attivita IN number,
 new_tipo_spedizione IN varchar,
 new_modello IN number,
 new_tipo_tributo IN varchar,
 new_tipo_comunicazione IN varchar,
 new_sequenza_comunicazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ELABORAZIONI_MASSIVE"
   cursor cpk1_attivita_elaborazione(var_elaborazione_id number) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "STATI_ATTIVITA"
   cursor cpk2_attivita_elaborazione(var_stato_attivita number) is
      select 1
      from   STATI_ATTIVITA
      where  STATO_ATTIVITA = var_stato_attivita
       and   var_stato_attivita is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_SPEDIZIONE"
   cursor cpk3_attivita_elaborazione(var_tipo_spedizione varchar) is
      select 1
      from   TIPI_SPEDIZIONE
      where  TIPO_SPEDIZIONE = var_tipo_spedizione
       and   var_tipo_spedizione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ATTIVITA"
   cursor cpk4_attivita_elaborazione(var_tipo_attivita number) is
      select 1
      from   TIPI_ATTIVITA
      where  TIPO_ATTIVITA = var_tipo_attivita
       and   var_tipo_attivita is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MODELLI"
   cursor cpk5_attivita_elaborazione(var_modello number) is
      select 1
      from   MODELLI
      where  MODELLO = var_modello
       and   var_modello is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DETTAGLI_COMUNICAZIONE"
   cursor cpk6_attivita_elaborazione(var_tipo_tributo varchar,
                                     var_tipo_comunicazione varchar,
                                     var_sequenza_comunicazione number) is
      select 1
      from   DETTAGLI_COMUNICAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   SEQUENZA = var_sequenza_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null
       and   var_sequenza_comunicazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ELABORAZIONI_MASSIVE" deve esistere quando si inserisce su "ATTIVITA_ELABORAZIONE"
         if NEW_ELABORAZIONE_ID is not null then
            open  cpk1_attivita_elaborazione(NEW_ELABORAZIONE_ID);
            fetch cpk1_attivita_elaborazione into dummy;
            found := cpk1_attivita_elaborazione%FOUND;
            close cpk1_attivita_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Elaborazioni Massive. La registrazione Attivita Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "STATI_ATTIVITA" deve esistere quando si inserisce su "ATTIVITA_ELABORAZIONE"
         if NEW_STATO_ATTIVITA is not null then
            open  cpk2_attivita_elaborazione(NEW_STATO_ATTIVITA);
            fetch cpk2_attivita_elaborazione into dummy;
            found := cpk2_attivita_elaborazione%FOUND;
            close cpk2_attivita_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Stati Attivita. La registrazione Attivita Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_SPEDIZIONE" deve esistere quando si inserisce su "ATTIVITA_ELABORAZIONE"
         if NEW_TIPO_SPEDIZIONE is not null then
            open  cpk3_attivita_elaborazione(NEW_TIPO_SPEDIZIONE);
            fetch cpk3_attivita_elaborazione into dummy;
            found := cpk3_attivita_elaborazione%FOUND;
            close cpk3_attivita_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Spedizione. La registrazione Attivita Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTIVITA" deve esistere quando si inserisce su "ATTIVITA_ELABORAZIONE"
         if NEW_TIPO_ATTIVITA is not null then
            open  cpk4_attivita_elaborazione(NEW_TIPO_ATTIVITA);
            fetch cpk4_attivita_elaborazione into dummy;
            found := cpk4_attivita_elaborazione%FOUND;
            close cpk4_attivita_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Attivita. La registrazione Attivita Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MODELLI" deve esistere quando si inserisce su "ATTIVITA_ELABORAZIONE"
         if NEW_MODELLO is not null then
            open  cpk5_attivita_elaborazione(NEW_MODELLO);
            fetch cpk5_attivita_elaborazione into dummy;
            found := cpk5_attivita_elaborazione%FOUND;
            close cpk5_attivita_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Modelli. La registrazione Attivita Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DETTAGLI_COMUNICAZIONE" deve esistere quando si inserisce su "ATTIVITA_ELABORAZIONE"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_TIPO_COMUNICAZIONE is not null and
            NEW_SEQUENZA_COMUNICAZIONE is not null then
            open  cpk6_attivita_elaborazione(NEW_TIPO_TRIBUTO,
                                             NEW_TIPO_COMUNICAZIONE,
                                             NEW_SEQUENZA_COMUNICAZIONE);
            fetch cpk6_attivita_elaborazione into dummy;
            found := cpk6_attivita_elaborazione%FOUND;
            close cpk6_attivita_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DETTAGLI COMUNICAZIONE. La registrazione Attivita Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ATTIVITA_ELABORAZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ATTIVITA_ELABORAZIONE
/* End Trigger: ATTIVITA_ELABORAZIONE_TC */

-- Procedure ATTIVITA_ELABORAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ATTIVITA_ELABORAZIONE

create or replace procedure ATTIVITA_ELABORAZIONE_PU
(old_attivita_id IN number,
 old_elaborazione_id IN number,
 old_tipo_attivita IN number,
 old_stato_attivita IN number,
 old_tipo_spedizione IN varchar,
 old_modello IN number,
 old_tipo_tributo IN varchar,
 old_tipo_comunicazione IN varchar,
 old_sequenza_comunicazione IN number,
 new_attivita_id IN number,
 new_elaborazione_id IN number,
 new_tipo_attivita IN number,
 new_stato_attivita IN number,
 new_tipo_spedizione IN varchar,
 new_modello IN number,
 new_tipo_tributo IN varchar,
 new_tipo_comunicazione IN varchar,
 new_sequenza_comunicazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ELABORAZIONI_MASSIVE"
   cursor cpk1_attivita_elaborazione(var_elaborazione_id number) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "STATI_ATTIVITA"
   cursor cpk2_attivita_elaborazione(var_stato_attivita number) is
      select 1
      from   STATI_ATTIVITA
      where  STATO_ATTIVITA = var_stato_attivita
       and   var_stato_attivita is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_SPEDIZIONE"
   cursor cpk3_attivita_elaborazione(var_tipo_spedizione varchar) is
      select 1
      from   TIPI_SPEDIZIONE
      where  TIPO_SPEDIZIONE = var_tipo_spedizione
       and   var_tipo_spedizione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ATTIVITA"
   cursor cpk4_attivita_elaborazione(var_tipo_attivita number) is
      select 1
      from   TIPI_ATTIVITA
      where  TIPO_ATTIVITA = var_tipo_attivita
       and   var_tipo_attivita is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MODELLI"
   cursor cpk5_attivita_elaborazione(var_modello number) is
      select 1
      from   MODELLI
      where  MODELLO = var_modello
       and   var_modello is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DETTAGLI_COMUNICAZIONE"
   cursor cpk6_attivita_elaborazione(var_tipo_tributo varchar,
                                     var_tipo_comunicazione varchar,
                                     var_sequenza_comunicazione number) is
      select 1
      from   DETTAGLI_COMUNICAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   SEQUENZA = var_sequenza_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null
       and   var_sequenza_comunicazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_INTERROGAZIONI"
   cursor cfk1_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   SAM_INTERROGAZIONI
      where  ATTIVITA_ID = var_attivita_id
       and   var_attivita_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ELABORAZIONI_MASSIVE" deve esistere quando si modifica "ATTIVITA_ELABORAZIONE"
         if  NEW_ELABORAZIONE_ID is not null and ( seq = 0 )
         and (   (NEW_ELABORAZIONE_ID != OLD_ELABORAZIONE_ID or OLD_ELABORAZIONE_ID is null) ) then
            open  cpk1_attivita_elaborazione(NEW_ELABORAZIONE_ID);
            fetch cpk1_attivita_elaborazione into dummy;
            found := cpk1_attivita_elaborazione%FOUND;
            close cpk1_attivita_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Elaborazioni Massive. La registrazione Attivita Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "STATI_ATTIVITA" deve esistere quando si modifica "ATTIVITA_ELABORAZIONE"
         if  NEW_STATO_ATTIVITA is not null and ( seq = 0 )
         and (   (NEW_STATO_ATTIVITA != OLD_STATO_ATTIVITA or OLD_STATO_ATTIVITA is null) ) then
            open  cpk2_attivita_elaborazione(NEW_STATO_ATTIVITA);
            fetch cpk2_attivita_elaborazione into dummy;
            found := cpk2_attivita_elaborazione%FOUND;
            close cpk2_attivita_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Stati Attivita. La registrazione Attivita Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_SPEDIZIONE" deve esistere quando si modifica "ATTIVITA_ELABORAZIONE"
         if  NEW_TIPO_SPEDIZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_SPEDIZIONE != OLD_TIPO_SPEDIZIONE or OLD_TIPO_SPEDIZIONE is null) ) then
            open  cpk3_attivita_elaborazione(NEW_TIPO_SPEDIZIONE);
            fetch cpk3_attivita_elaborazione into dummy;
            found := cpk3_attivita_elaborazione%FOUND;
            close cpk3_attivita_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Spedizione. La registrazione Attivita Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTIVITA" deve esistere quando si modifica "ATTIVITA_ELABORAZIONE"
         if  NEW_TIPO_ATTIVITA is not null and ( seq = 0 )
         and (   (NEW_TIPO_ATTIVITA != OLD_TIPO_ATTIVITA or OLD_TIPO_ATTIVITA is null) ) then
            open  cpk4_attivita_elaborazione(NEW_TIPO_ATTIVITA);
            fetch cpk4_attivita_elaborazione into dummy;
            found := cpk4_attivita_elaborazione%FOUND;
            close cpk4_attivita_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Attivita. La registrazione Attivita Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MODELLI" deve esistere quando si modifica "ATTIVITA_ELABORAZIONE"
         if  NEW_MODELLO is not null and ( seq = 0 )
         and (   (NEW_MODELLO != OLD_MODELLO or OLD_MODELLO is null) ) then
            open  cpk5_attivita_elaborazione(NEW_MODELLO);
            fetch cpk5_attivita_elaborazione into dummy;
            found := cpk5_attivita_elaborazione%FOUND;
            close cpk5_attivita_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Modelli. La registrazione Attivita Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DETTAGLI_COMUNICAZIONE" deve esistere quando si modifica "ATTIVITA_ELABORAZIONE"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_TIPO_COMUNICAZIONE is not null and
             NEW_SEQUENZA_COMUNICAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_TIPO_COMUNICAZIONE != OLD_TIPO_COMUNICAZIONE or OLD_TIPO_COMUNICAZIONE is null)
              or (NEW_SEQUENZA_COMUNICAZIONE != OLD_SEQUENZA_COMUNICAZIONE or OLD_SEQUENZA_COMUNICAZIONE is null) ) then
            open  cpk6_attivita_elaborazione(NEW_TIPO_TRIBUTO,
                                             NEW_TIPO_COMUNICAZIONE,
                                             NEW_SEQUENZA_COMUNICAZIONE);
            fetch cpk6_attivita_elaborazione into dummy;
            found := cpk6_attivita_elaborazione%FOUND;
            close cpk6_attivita_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DETTAGLI COMUNICAZIONE. La registrazione Attivita Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "ATTIVITA_ELABORAZIONE" non modificabile se esistono referenze su "SAM_INTERROGAZIONI"
      if (OLD_ATTIVITA_ID != NEW_ATTIVITA_ID) then
         open  cfk1_attivita_elaborazione(OLD_ATTIVITA_ID);
         fetch cfk1_attivita_elaborazione into dummy;
         found := cfk1_attivita_elaborazione%FOUND;
         close cfk1_attivita_elaborazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_INTERROGAZIONI. La registrazione di Attivita Elaborazione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ATTIVITA_ELABORAZIONE_PU */
/

-- Trigger ATTIVITA_ELABORAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ATTIVITA_ELABORAZIONE

create or replace trigger ATTIVITA_ELABORAZIONE_TIU
before INSERT
    or UPDATE
on ATTIVITA_ELABORAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ATTIVITA_ELABORAZIONE_PU(:OLD.ATTIVITA_ID,
                                  :OLD.ELABORAZIONE_ID,
                                  :OLD.TIPO_ATTIVITA,
                                  :OLD.STATO_ATTIVITA,
                                  :OLD.TIPO_SPEDIZIONE,
                                  :OLD.MODELLO,
                                  :OLD.TIPO_TRIBUTO,
                                  :OLD.TIPO_COMUNICAZIONE,
                                  :OLD.SEQUENZA_COMUNICAZIONE,
                         :NEW.ATTIVITA_ID,
                         :NEW.ELABORAZIONE_ID,
                         :NEW.TIPO_ATTIVITA,
                         :NEW.STATO_ATTIVITA,
                         :NEW.TIPO_SPEDIZIONE,
                         :NEW.MODELLO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_COMUNICAZIONE,
                         :NEW.SEQUENZA_COMUNICAZIONE);
         null;
      end if;
      if INSERTING then
         ATTIVITA_ELABORAZIONE_PI(:NEW.ELABORAZIONE_ID,
                                  :NEW.TIPO_ATTIVITA,
                                  :NEW.STATO_ATTIVITA,
                                  :NEW.TIPO_SPEDIZIONE,
                                  :NEW.MODELLO,
                                  :NEW.TIPO_TRIBUTO,
                                  :NEW.TIPO_COMUNICAZIONE,
                                  :NEW.SEQUENZA_COMUNICAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ATTIVITA_ELABORAZIONE"
            cursor cpk_attivita_elaborazione(var_ATTIVITA_ID number) is
               select 1
                 from   ATTIVITA_ELABORAZIONE
                where  ATTIVITA_ID = var_ATTIVITA_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ATTIVITA_ELABORAZIONE"
               if :new.ATTIVITA_ID is not null then
                  open  cpk_attivita_elaborazione(:new.ATTIVITA_ID);
                  fetch cpk_attivita_elaborazione into dummy;
                  found := cpk_attivita_elaborazione%FOUND;
                  close cpk_attivita_elaborazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ATTIVITA_ID||
                               '" gia'' presente in Attivita Elaborazione. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "ATTIVITA_ELABORAZIONE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ATTIVITA_ID != :NEW.ATTIVITA_ID) then
            update DETTAGLI_ELABORAZIONE
             set   STAMPA_ID = :NEW.ATTIVITA_ID
            where  STAMPA_ID = :OLD.ATTIVITA_ID;
         end if;

         --  Modify parent code of "ATTIVITA_ELABORAZIONE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ATTIVITA_ID != :NEW.ATTIVITA_ID) then
            update DETTAGLI_ELABORAZIONE
             set   DOCUMENTALE_ID = :NEW.ATTIVITA_ID
            where  DOCUMENTALE_ID = :OLD.ATTIVITA_ID;
         end if;

         --  Modify parent code of "ATTIVITA_ELABORAZIONE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ATTIVITA_ID != :NEW.ATTIVITA_ID) then
            update DETTAGLI_ELABORAZIONE
             set   TIPOGRAFIA_ID = :NEW.ATTIVITA_ID
            where  TIPOGRAFIA_ID = :OLD.ATTIVITA_ID;
         end if;

         --  Modify parent code of "ATTIVITA_ELABORAZIONE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ATTIVITA_ID != :NEW.ATTIVITA_ID) then
            update DETTAGLI_ELABORAZIONE
             set   AVVISO_AGID_ID = :NEW.ATTIVITA_ID
            where  AVVISO_AGID_ID = :OLD.ATTIVITA_ID;
         end if;

         --  Modify parent code of "ATTIVITA_ELABORAZIONE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ATTIVITA_ID != :NEW.ATTIVITA_ID) then
            update DETTAGLI_ELABORAZIONE
             set   APPIO_ID = :NEW.ATTIVITA_ID
            where  APPIO_ID = :OLD.ATTIVITA_ID;
         end if;

         --  Modify parent code of "ATTIVITA_ELABORAZIONE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ATTIVITA_ID != :NEW.ATTIVITA_ID) then
            update DETTAGLI_ELABORAZIONE
             set   ANAGR_ID = :NEW.ATTIVITA_ID
            where  ANAGR_ID = :OLD.ATTIVITA_ID;
         end if;

         --  Modify parent code of "ATTIVITA_ELABORAZIONE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ATTIVITA_ID != :NEW.ATTIVITA_ID) then
            update DETTAGLI_ELABORAZIONE
             set   CONTROLLO_AT_ID = :NEW.ATTIVITA_ID
            where  CONTROLLO_AT_ID = :OLD.ATTIVITA_ID;
         end if;

         --  Modify parent code of "ATTIVITA_ELABORAZIONE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ATTIVITA_ID != :NEW.ATTIVITA_ID) then
            update DETTAGLI_ELABORAZIONE
             set   ALLINEAMENTO_AT_ID = :NEW.ATTIVITA_ID
            where  ALLINEAMENTO_AT_ID = :OLD.ATTIVITA_ID;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ATTIVITA_ELABORAZIONE_TIU */
/

-- Procedure ATTIVITA_ELABORAZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table ATTIVITA_ELABORAZIONE

create or replace procedure ATTIVITA_ELABORAZIONE_PD
(old_attivita_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk1_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  STAMPA_ID = var_attivita_id
       and   var_attivita_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk2_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  DOCUMENTALE_ID = var_attivita_id
       and   var_attivita_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk3_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  TIPOGRAFIA_ID = var_attivita_id
       and   var_attivita_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk4_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  AVVISO_AGID_ID = var_attivita_id
       and   var_attivita_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk5_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  APPIO_ID = var_attivita_id
       and   var_attivita_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk6_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  ANAGR_ID = var_attivita_id
       and   var_attivita_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk7_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  CONTROLLO_AT_ID = var_attivita_id
       and   var_attivita_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk8_attivita_elaborazione(var_attivita_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  ALLINEAMENTO_AT_ID = var_attivita_id
       and   var_attivita_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "ATTIVITA_ELABORAZIONE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk1_attivita_elaborazione(OLD_ATTIVITA_ID);
      fetch cfk1_attivita_elaborazione into dummy;
      found := cfk1_attivita_elaborazione%FOUND;
      close cfk1_attivita_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Attivita Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ATTIVITA_ELABORAZIONE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk2_attivita_elaborazione(OLD_ATTIVITA_ID);
      fetch cfk2_attivita_elaborazione into dummy;
      found := cfk2_attivita_elaborazione%FOUND;
      close cfk2_attivita_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Attivita Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ATTIVITA_ELABORAZIONE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk3_attivita_elaborazione(OLD_ATTIVITA_ID);
      fetch cfk3_attivita_elaborazione into dummy;
      found := cfk3_attivita_elaborazione%FOUND;
      close cfk3_attivita_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Attivita Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ATTIVITA_ELABORAZIONE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk4_attivita_elaborazione(OLD_ATTIVITA_ID);
      fetch cfk4_attivita_elaborazione into dummy;
      found := cfk4_attivita_elaborazione%FOUND;
      close cfk4_attivita_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Attivita Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ATTIVITA_ELABORAZIONE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk5_attivita_elaborazione(OLD_ATTIVITA_ID);
      fetch cfk5_attivita_elaborazione into dummy;
      found := cfk5_attivita_elaborazione%FOUND;
      close cfk5_attivita_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Attivita Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ATTIVITA_ELABORAZIONE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk6_attivita_elaborazione(OLD_ATTIVITA_ID);
      fetch cfk6_attivita_elaborazione into dummy;
      found := cfk6_attivita_elaborazione%FOUND;
      close cfk6_attivita_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Attivita Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ATTIVITA_ELABORAZIONE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk7_attivita_elaborazione(OLD_ATTIVITA_ID);
      fetch cfk7_attivita_elaborazione into dummy;
      found := cfk7_attivita_elaborazione%FOUND;
      close cfk7_attivita_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Attivita Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ATTIVITA_ELABORAZIONE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk8_attivita_elaborazione(OLD_ATTIVITA_ID);
      fetch cfk8_attivita_elaborazione into dummy;
      found := cfk8_attivita_elaborazione%FOUND;
      close cfk8_attivita_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Attivita Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ATTIVITA_ELABORAZIONE_PD */
/

-- Tigger ATTIVITA_ELABORAZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ATTIVITA_ELABORAZIONE

create or replace trigger ATTIVITA_ELABORAZIONE_TD
before DELETE
on ATTIVITA_ELABORAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      ATTIVITA_ELABORAZIONE_PD(:OLD.ATTIVITA_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "SAM_INTERROGAZIONI"
      delete SAM_INTERROGAZIONI
      where  ATTIVITA_ID = :OLD.ATTIVITA_ID;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ATTIVITA_ELABORAZIONE_TD */
/

-- Procedure ATTRIBUTI_OGCO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ATTRIBUTI_OGCO

create or replace procedure ATTRIBUTI_OGCO_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_documento_id IN number,
 new_cod_diritto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_CONTRIBUENTE"
   cursor cpk1_attributi_ogco(var_cod_fiscale varchar,
                              var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_DIRITTO"
   cursor cpk2_attributi_ogco(var_cod_diritto varchar) is
      select 1
      from   CODICI_DIRITTO
      where  COD_DIRITTO = var_cod_diritto
       and   var_cod_diritto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk3_attributi_ogco(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si inserisce su "ATTRIBUTI_OGCO"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO_PRATICA is not null then
            open  cpk1_attributi_ogco(NEW_COD_FISCALE,
                                      NEW_OGGETTO_PRATICA);
            fetch cpk1_attributi_ogco into dummy;
            found := cpk1_attributi_ogco%FOUND;
            close cpk1_attributi_ogco;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Attributi OGCO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_DIRITTO" deve esistere quando si inserisce su "ATTRIBUTI_OGCO"
         if NEW_COD_DIRITTO is not null then
            open  cpk2_attributi_ogco(NEW_COD_DIRITTO);
            fetch cpk2_attributi_ogco into dummy;
            found := cpk2_attributi_ogco%FOUND;
            close cpk2_attributi_ogco;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici Diritto. La registrazione Attributi OGCO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "ATTRIBUTI_OGCO"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk3_attributi_ogco(NEW_DOCUMENTO_ID);
            fetch cpk3_attributi_ogco into dummy;
            found := cpk3_attributi_ogco%FOUND;
            close cpk3_attributi_ogco;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione Attributi OGCO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ATTRIBUTI_OGCO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ATTRIBUTI_OGCO
/* End Trigger: ATTRIBUTI_OGCO_TC */

-- Procedure ATTRIBUTI_OGCO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ATTRIBUTI_OGCO

create or replace procedure ATTRIBUTI_OGCO_PU
(old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number,
 old_documento_id IN number,
 old_cod_diritto IN varchar,
 new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_documento_id IN number,
 new_cod_diritto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_CONTRIBUENTE"
   cursor cpk1_attributi_ogco(var_cod_fiscale varchar,
                              var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_DIRITTO"
   cursor cpk2_attributi_ogco(var_cod_diritto varchar) is
      select 1
      from   CODICI_DIRITTO
      where  COD_DIRITTO = var_cod_diritto
       and   var_cod_diritto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk3_attributi_ogco(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si modifica "ATTRIBUTI_OGCO"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_attributi_ogco(NEW_COD_FISCALE,
                                      NEW_OGGETTO_PRATICA);
            fetch cpk1_attributi_ogco into dummy;
            found := cpk1_attributi_ogco%FOUND;
            close cpk1_attributi_ogco;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Attributi OGCO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_DIRITTO" deve esistere quando si modifica "ATTRIBUTI_OGCO"
         if  NEW_COD_DIRITTO is not null and ( seq = 0 )
         and (   (NEW_COD_DIRITTO != OLD_COD_DIRITTO or OLD_COD_DIRITTO is null) ) then
            open  cpk2_attributi_ogco(NEW_COD_DIRITTO);
            fetch cpk2_attributi_ogco into dummy;
            found := cpk2_attributi_ogco%FOUND;
            close cpk2_attributi_ogco;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici Diritto. La registrazione Attributi OGCO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "ATTRIBUTI_OGCO"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk3_attributi_ogco(NEW_DOCUMENTO_ID);
            fetch cpk3_attributi_ogco into dummy;
            found := cpk3_attributi_ogco%FOUND;
            close cpk3_attributi_ogco;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione Attributi OGCO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ATTRIBUTI_OGCO_PU */
/

-- Trigger ATTRIBUTI_OGCO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ATTRIBUTI_OGCO

create or replace trigger ATTRIBUTI_OGCO_TIU
before INSERT
    or UPDATE
on ATTRIBUTI_OGCO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ATTRIBUTI_OGCO_PU(:OLD.COD_FISCALE,
                           :OLD.OGGETTO_PRATICA,
                           :OLD.DOCUMENTO_ID,
                           :OLD.COD_DIRITTO,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.DOCUMENTO_ID,
                         :NEW.COD_DIRITTO);
         null;
      end if;
      if INSERTING then
         ATTRIBUTI_OGCO_PI(:NEW.COD_FISCALE,
                           :NEW.OGGETTO_PRATICA,
                           :NEW.DOCUMENTO_ID,
                           :NEW.COD_DIRITTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ATTRIBUTI_OGCO"
            cursor cpk_attributi_ogco(var_COD_FISCALE varchar,
                                      var_OGGETTO_PRATICA number) is
               select 1
                 from   ATTRIBUTI_OGCO
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ATTRIBUTI_OGCO"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO_PRATICA is not null then
                  open  cpk_attributi_ogco(:new.COD_FISCALE,
                                           :new.OGGETTO_PRATICA);
                  fetch cpk_attributi_ogco into dummy;
                  found := cpk_attributi_ogco%FOUND;
                  close cpk_attributi_ogco;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO_PRATICA||
                               '" gia'' presente in Attributi OGCO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ATTRIBUTI_OGCO_TIU */
/

-- Procedure BONUS_SOCIALI_CONTRIBUENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table BONUS_SOCIALI_CONTRIBUENTE

create or replace procedure BONUS_SOCIALI_CONTRIBUENTE_PI
(new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_bonus_sociali_contribuent(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk2_bonus_sociali_contribuent(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "BONUS_SOCIALI_CONTRIBUENTE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_bonus_sociali_contribuent(NEW_TIPO_TRIBUTO);
            fetch cpk1_bonus_sociali_contribuent into dummy;
            found := cpk1_bonus_sociali_contribuent%FOUND;
            close cpk1_bonus_sociali_contribuent;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione BONUS_SOCIALI_CONTRIBUENTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "BONUS_SOCIALI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null then
            open  cpk2_bonus_sociali_contribuent(NEW_COD_FISCALE);
            fetch cpk2_bonus_sociali_contribuent into dummy;
            found := cpk2_bonus_sociali_contribuent%FOUND;
            close cpk2_bonus_sociali_contribuent;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione BONUS_SOCIALI_CONTRIBUENTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: BONUS_SOCIALI_CONTRIBUENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table BONUS_SOCIALI_CONTRIBUENTE
/* End Trigger: BONUS_SOCIALI_CONTRIBUENTE_TC */

-- Procedure BONUS_SOCIALI_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table BONUS_SOCIALI_CONTRIBUENTE

create or replace procedure BONUS_SOCIALI_CONTRIBUENTE_PU
(old_bonus_sociale_contribuente IN number,
 old_cod_fiscale IN varchar,
 old_tipo_tributo IN varchar,
 new_bonus_sociale_contribuente IN number,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_bonus_sociali_contribuent(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk2_bonus_sociali_contribuent(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "BONUS_SOCIALI_CONTRIBUENTE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_bonus_sociali_contribuent(NEW_TIPO_TRIBUTO);
            fetch cpk1_bonus_sociali_contribuent into dummy;
            found := cpk1_bonus_sociali_contribuent%FOUND;
            close cpk1_bonus_sociali_contribuent;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione BONUS_SOCIALI_CONTRIBUENTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "BONUS_SOCIALI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk2_bonus_sociali_contribuent(NEW_COD_FISCALE);
            fetch cpk2_bonus_sociali_contribuent into dummy;
            found := cpk2_bonus_sociali_contribuent%FOUND;
            close cpk2_bonus_sociali_contribuent;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione BONUS_SOCIALI_CONTRIBUENTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: BONUS_SOCIALI_CONTRIBUENTE_PU */
/

-- Trigger BONUS_SOCIALI_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table BONUS_SOCIALI_CONTRIBUENTE

create or replace trigger BONUS_SOCIALI_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on BONUS_SOCIALI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         BONUS_SOCIALI_CONTRIBUENTE_PU(:OLD.BONUS_SOCIALE_CONTRIBUENTE,
                                       :OLD.COD_FISCALE,
                                       :OLD.TIPO_TRIBUTO,
                         :NEW.BONUS_SOCIALE_CONTRIBUENTE,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         BONUS_SOCIALI_CONTRIBUENTE_PI(:NEW.COD_FISCALE,
                                       :NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "BONUS_SOCIALI_CONTRIBUENTE"
            cursor cpk_bonus_sociali_contribuent(var_BONUS_SOCIALE_CONTRIBUENTE number) is
               select 1
                 from   BONUS_SOCIALI_CONTRIBUENTE
                where  BONUS_SOCIALE_CONTRIBUENTE = var_BONUS_SOCIALE_CONTRIBUENTE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "BONUS_SOCIALI_CONTRIBUENTE"
               if :new.BONUS_SOCIALE_CONTRIBUENTE is not null then
                  open  cpk_bonus_sociali_contribuent(:new.BONUS_SOCIALE_CONTRIBUENTE);
                  fetch cpk_bonus_sociali_contribuent into dummy;
                  found := cpk_bonus_sociali_contribuent%FOUND;
                  close cpk_bonus_sociali_contribuent;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.BONUS_SOCIALE_CONTRIBUENTE||
                               '" gia'' presente in BONUS_SOCIALI_CONTRIBUENTE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: BONUS_SOCIALI_CONTRIBUENTE_TIU */
/

-- Procedure CARICHI_TARSU_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CARICHI_TARSU

create or replace procedure CARICHI_TARSU_PU
(old_anno IN number,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CARICHI_TARSU_PU */
/

-- Trigger CARICHI_TARSU_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CARICHI_TARSU

create or replace trigger CARICHI_TARSU_TIU
before INSERT
    or UPDATE
on CARICHI_TARSU
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CARICHI_TARSU_PU(:OLD.ANNO,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CARICHI_TARSU"
            cursor cpk_carichi_tarsu(var_ANNO number) is
               select 1
                 from   CARICHI_TARSU
                where  ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CARICHI_TARSU"
               if :new.ANNO is not null then
                  open  cpk_carichi_tarsu(:new.ANNO);
                  fetch cpk_carichi_tarsu into dummy;
                  found := cpk_carichi_tarsu%FOUND;
                  close cpk_carichi_tarsu;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANNO||
                               '" gia'' presente in Carichi TARSU. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CARICHI_TARSU_TIU */
/

-- Procedure CATEGORIE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CATEGORIE

create or replace procedure CATEGORIE_PI
(new_tributo IN number,
 new_categoria_rif IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_TRIBUTO"
   cursor cpk1_categorie(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE"
   cursor cpk2_categorie(var_tributo number,
                         var_categoria_rif number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria_rif
       and   var_tributo is not null
       and   var_categoria_rif is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si inserisce su "CATEGORIE"
         if NEW_TRIBUTO is not null then
            open  cpk1_categorie(NEW_TRIBUTO);
            fetch cpk1_categorie into dummy;
            found := cpk1_categorie%FOUND;
            close cpk1_categorie;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Categorie non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE" deve esistere quando si inserisce su "CATEGORIE"
         if NEW_TRIBUTO is not null and
            NEW_CATEGORIA_RIF is not null then
            open  cpk2_categorie(NEW_TRIBUTO,
                                 NEW_CATEGORIA_RIF);
            fetch cpk2_categorie into dummy;
            found := cpk2_categorie%FOUND;
            close cpk2_categorie;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Categorie non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CATEGORIE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CATEGORIE

create or replace trigger CATEGORIE_TB
before INSERT
    or UPDATE
    or DELETE
on CATEGORIE
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: CATEGORIE_TB */
/

create or replace trigger CATEGORIE_TC
after INSERT
   or UPDATE
   or DELETE
on CATEGORIE
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: CATEGORIE_TC */
/

-- Procedure CATEGORIE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CATEGORIE

create or replace procedure CATEGORIE_PU
(old_tributo IN number,
 old_categoria IN number,
 old_categoria_rif IN number,
 new_tributo IN number,
 new_categoria IN number,
 new_categoria_rif IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_TRIBUTO"
   cursor cpk1_categorie(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE"
   cursor cpk2_categorie(var_tributo number,
                         var_categoria_rif number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria_rif
       and   var_tributo is not null
       and   var_categoria_rif is not null;

   --  Declaration of UpdateParentRestrict constraint for "TARIFFE_NON_DOMESTICHE"
   cursor cfk1_categorie(var_tributo number,
                         var_categoria number) is
      select 1
      from   TARIFFE_NON_DOMESTICHE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;

   --  Declaration of UpdateParentRestrict constraint for "TARIFFE_CONVERSIONE"
   cursor cfk2_categorie(var_tributo number,
                         var_categoria number) is
      select 1
      from   TARIFFE_CONVERSIONE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si modifica "CATEGORIE"
         if  NEW_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null) ) then
            open  cpk1_categorie(NEW_TRIBUTO);
            fetch cpk1_categorie into dummy;
            found := cpk1_categorie%FOUND;
            close cpk1_categorie;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Categorie non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE" deve esistere quando si modifica "CATEGORIE"
         if  NEW_TRIBUTO is not null and
             NEW_CATEGORIA_RIF is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null)
              or (NEW_CATEGORIA_RIF != OLD_CATEGORIA_RIF or OLD_CATEGORIA_RIF is null) ) then
            open  cpk2_categorie(NEW_TRIBUTO,
                                 NEW_CATEGORIA_RIF);
            fetch cpk2_categorie into dummy;
            found := cpk2_categorie%FOUND;
            close cpk2_categorie;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Categorie non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "CATEGORIE" non modificabile se esistono referenze su "TARIFFE_NON_DOMESTICHE"
      if (OLD_TRIBUTO != NEW_TRIBUTO) or
         (OLD_CATEGORIA != NEW_CATEGORIA) then
         open  cfk1_categorie(OLD_TRIBUTO,
                              OLD_CATEGORIA);
         fetch cfk1_categorie into dummy;
         found := cfk1_categorie%FOUND;
         close cfk1_categorie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Tariffe non Domestiche. La registrazione di Categorie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "CATEGORIE" non modificabile se esistono referenze su "TARIFFE_CONVERSIONE"
      if (OLD_TRIBUTO != NEW_TRIBUTO) or
         (OLD_CATEGORIA != NEW_CATEGORIA) then
         open  cfk2_categorie(OLD_TRIBUTO,
                              OLD_CATEGORIA);
         fetch cfk2_categorie into dummy;
         found := cfk2_categorie%FOUND;
         close cfk2_categorie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su TARIFFE_CONVERSIONE. La registrazione di Categorie non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CATEGORIE_PU */
/

-- Trigger CATEGORIE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CATEGORIE

create or replace trigger CATEGORIE_TIU
before INSERT
    or UPDATE
on CATEGORIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.id_categoria := lpad(:new.TRIBUTO, 4, '0') || lpad(:new.CATEGORIA, 4, '0');
   end;

   begin  -- Check REFERENTIAL Integrity at Level 0
      if UPDATING then
         CATEGORIE_PU(:OLD.TRIBUTO,
                      :OLD.CATEGORIA,
                      :OLD.CATEGORIA_RIF,
                         :NEW.TRIBUTO,
                         :NEW.CATEGORIA,
                         :NEW.CATEGORIA_RIF);
         null;
      end if;
	if INSERTING then
         CATEGORIE_PI(:NEW.TRIBUTO,
                      :NEW.CATEGORIA_RIF);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CATEGORIE"
            cursor cpk_categorie(var_TRIBUTO number,
                                 var_CATEGORIA number) is
               select 1
                 from   CATEGORIE
                where  TRIBUTO = var_TRIBUTO and
                       CATEGORIA = var_CATEGORIA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CATEGORIE"
               if :new.TRIBUTO is not null and
                  :new.CATEGORIA is not null then
                  open  cpk_categorie(:new.TRIBUTO,
                                      :new.CATEGORIA);
                  fetch cpk_categorie into dummy;
                  found := cpk_categorie%FOUND;
                  close cpk_categorie;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TRIBUTO||' '||
                               :new.CATEGORIA||
                               '" gia'' presente in Categorie. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "CATEGORIE" for all children in "TARIFFE"
         if (:OLD.TRIBUTO != :NEW.TRIBUTO) or
            (:OLD.CATEGORIA != :NEW.CATEGORIA) then
            update TARIFFE
             set   TRIBUTO = :NEW.TRIBUTO,
                   CATEGORIA = :NEW.CATEGORIA
            where  TRIBUTO = :OLD.TRIBUTO
             and   CATEGORIA = :OLD.CATEGORIA;
         end if;

         --  Modify parent code of "CATEGORIE" for all children in "COEFFICIENTI_NON_DOMESTICI"
         if (:OLD.TRIBUTO != :NEW.TRIBUTO) or
            (:OLD.CATEGORIA != :NEW.CATEGORIA) then
            update COEFFICIENTI_NON_DOMESTICI
             set   TRIBUTO = :NEW.TRIBUTO,
                   CATEGORIA = :NEW.CATEGORIA
            where  TRIBUTO = :OLD.TRIBUTO
             and   CATEGORIA = :OLD.CATEGORIA;
         end if;

         --  Modify parent code of "CATEGORIE" for all children in "RUOLI_ECCEDENZE"
         if (:OLD.TRIBUTO != :NEW.TRIBUTO) or
            (:OLD.CATEGORIA != :NEW.CATEGORIA) then
            update RUOLI_ECCEDENZE
             set   TRIBUTO = :NEW.TRIBUTO,
                   CATEGORIA = :NEW.CATEGORIA
            where  TRIBUTO = :OLD.TRIBUTO
             and   CATEGORIA = :OLD.CATEGORIA;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin -- Set PostEvent Check REFERENTIAL Integrity at Level 0
      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
      IF IntegrityPackage.GetNestLevel = 0 THEN
         --
         -- Integrità Referenziale di Esistenza FK
         --
         IF INSERTING THEN
            --
            -- Integrità Referenziale di Esistenza su insert FK
            --
            IF :new.categoria_rif is NOT null THEN
               a_istruzione := 'select 1 from categorie where categoria = '
                               || :new.categoria_rif;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;
         ELSIF UPDATING THEN
            IF nvl(:new.categoria_rif,-1) != nvl(:old.categoria_rif ,-1) THEN
               --
               -- Integrità Referenziale di Esistenza su update FK
               --
               IF :new.categoria_rif is NOT null THEN
                  a_istruzione := 'select 1 from categorie where categoria = '
                                  ||:new.categoria_rif;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;
         END IF;
      END IF;
      IF UPDATING THEN
         IF :new.categoria != :old.categoria THEN
            --
            -- Integrità Referenziale su update PK
            --

            /* Caso di RESTRICT UPDATE */

               a_istruzione := 'select 0 from categorie where categoria_rif = '
                               ||:old.categoria ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

            /* Caso di CASCADE UPDATE

               a_istruzione := 'update categorie set categorie_rif ='
                               ||:new.categoria ||' where categoria_rif = '
                               ||:old.categoria;
               a_messaggio := '';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            */

         END IF;
      END IF;

      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CATEGORIE_TIU */
/

-- Procedure CATEGORIE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CATEGORIE

create or replace procedure CATEGORIE_PD
(old_tributo IN number,
 old_categoria IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "TARIFFE"
   cursor cfk1_categorie(var_tributo number,
                         var_categoria number) is
      select 1
      from   TARIFFE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;

   --  Declaration of DeleteParentRestrict constraint for "COEFFICIENTI_NON_DOMESTICI"
   cursor cfk2_categorie(var_tributo number,
                         var_categoria number) is
      select 1
      from   COEFFICIENTI_NON_DOMESTICI
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;

   --  Declaration of DeleteParentRestrict constraint for "TARIFFE_NON_DOMESTICHE"
   cursor cfk3_categorie(var_tributo number,
                         var_categoria number) is
      select 1
      from   TARIFFE_NON_DOMESTICHE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;

   --  Declaration of DeleteParentRestrict constraint for "TARIFFE_CONVERSIONE"
   cursor cfk4_categorie(var_tributo number,
                         var_categoria number) is
      select 1
      from   TARIFFE_CONVERSIONE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_ECCEDENZE"
   cursor cfk5_categorie(var_tributo number,
                         var_categoria number) is
      select 1
      from   RUOLI_ECCEDENZE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CATEGORIE" if children still exist in "TARIFFE"
      open  cfk1_categorie(OLD_TRIBUTO,
                           OLD_CATEGORIA);
      fetch cfk1_categorie into dummy;
      found := cfk1_categorie%FOUND;
      close cfk1_categorie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Tariffe. La registrazione di Categorie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CATEGORIE" if children still exist in "COEFFICIENTI_NON_DOMESTICI"
      open  cfk2_categorie(OLD_TRIBUTO,
                           OLD_CATEGORIA);
      fetch cfk2_categorie into dummy;
      found := cfk2_categorie%FOUND;
      close cfk2_categorie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Coefficienti Non Domestici. La registrazione di Categorie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CATEGORIE" if children still exist in "TARIFFE_NON_DOMESTICHE"
      open  cfk3_categorie(OLD_TRIBUTO,
                           OLD_CATEGORIA);
      fetch cfk3_categorie into dummy;
      found := cfk3_categorie%FOUND;
      close cfk3_categorie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Tariffe non Domestiche. La registrazione di Categorie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CATEGORIE" if children still exist in "TARIFFE_CONVERSIONE"
      open  cfk4_categorie(OLD_TRIBUTO,
                           OLD_CATEGORIA);
      fetch cfk4_categorie into dummy;
      found := cfk4_categorie%FOUND;
      close cfk4_categorie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su TARIFFE_CONVERSIONE. La registrazione di Categorie non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CATEGORIE" if children still exist in "RUOLI_ECCEDENZE"
      open  cfk5_categorie(OLD_TRIBUTO,
                           OLD_CATEGORIA);
      fetch cfk5_categorie into dummy;
      found := cfk5_categorie%FOUND;
      close cfk5_categorie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Eccedenze. La registrazione di Categorie non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CATEGORIE_PD */
/

-- Tigger CATEGORIE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CATEGORIE

create or replace trigger CATEGORIE_TD
before DELETE
on CATEGORIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: TARIFFE

      -- Child Restrict Table: COEFFICIENTI_NON_DOMESTICI

      -- Child Restrict Table: TARIFFE_NON_DOMESTICHE

      -- Child Restrict Table: TARIFFE_CONVERSIONE

      -- Child Restrict Table: RUOLI_ECCEDENZE

      CATEGORIE_PD(:OLD.TRIBUTO,
                   :OLD.CATEGORIA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
            DECLARE a_istruzione  varchar2(2000);
                    a_messaggio   varchar2(2000);
            BEGIN
               a_messaggio := 'Esistono riferimenti su Categorie. La registrazione di Categorie non e'' eliminabile.';
               a_istruzione := 'select 0 from categorie where categoria_rif = '
                               ||:old.categoria;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
            END;
   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CATEGORIE_TD */
/

-- Procedure CATEGORIE_CATASTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CATEGORIE_CATASTO

create or replace procedure CATEGORIE_CATASTO_PU
(old_categoria_catasto IN varchar,
 new_categoria_catasto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_categorie_catasto(var_categoria_catasto varchar) is
      select 1
      from   OGGETTI_PRATICA
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Declaration of UpdateParentRestrict constraint for "MOLTIPLICATORI"
   cursor cfk2_categorie_catasto(var_categoria_catasto varchar) is
      select 1
      from   MOLTIPLICATORI
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI"
   cursor cfk3_categorie_catasto(var_categoria_catasto varchar) is
      select 1
      from   OGGETTI
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Declaration of UpdateParentRestrict constraint for "ALIQUOTE_CATEGORIA"
   cursor cfk4_categorie_catasto(var_categoria_catasto varchar) is
      select 1
      from   ALIQUOTE_CATEGORIA
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "CATEGORIE_CATASTO" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_CATEGORIA_CATASTO != NEW_CATEGORIA_CATASTO) then
         open  cfk1_categorie_catasto(OLD_CATEGORIA_CATASTO);
         fetch cfk1_categorie_catasto into dummy;
         found := cfk1_categorie_catasto%FOUND;
         close cfk1_categorie_catasto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Categorie Catasto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "CATEGORIE_CATASTO" non modificabile se esistono referenze su "MOLTIPLICATORI"
      if (OLD_CATEGORIA_CATASTO != NEW_CATEGORIA_CATASTO) then
         open  cfk2_categorie_catasto(OLD_CATEGORIA_CATASTO);
         fetch cfk2_categorie_catasto into dummy;
         found := cfk2_categorie_catasto%FOUND;
         close cfk2_categorie_catasto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Moltiplicatori. La registrazione di Categorie Catasto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "CATEGORIE_CATASTO" non modificabile se esistono referenze su "OGGETTI"
      if (OLD_CATEGORIA_CATASTO != NEW_CATEGORIA_CATASTO) then
         open  cfk3_categorie_catasto(OLD_CATEGORIA_CATASTO);
         fetch cfk3_categorie_catasto into dummy;
         found := cfk3_categorie_catasto%FOUND;
         close cfk3_categorie_catasto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Categorie Catasto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "CATEGORIE_CATASTO" non modificabile se esistono referenze su "ALIQUOTE_CATEGORIA"
      if (OLD_CATEGORIA_CATASTO != NEW_CATEGORIA_CATASTO) then
         open  cfk4_categorie_catasto(OLD_CATEGORIA_CATASTO);
         fetch cfk4_categorie_catasto into dummy;
         found := cfk4_categorie_catasto%FOUND;
         close cfk4_categorie_catasto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Aliquote Categoria. La registrazione di Categorie Catasto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CATEGORIE_CATASTO_PU */
/

-- Trigger CATEGORIE_CATASTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CATEGORIE_CATASTO

create or replace trigger CATEGORIE_CATASTO_TIU
before INSERT
    or UPDATE
on CATEGORIE_CATASTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CATEGORIE_CATASTO_PU(:OLD.CATEGORIA_CATASTO,
                         :NEW.CATEGORIA_CATASTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CATEGORIE_CATASTO"
            cursor cpk_categorie_catasto(var_CATEGORIA_CATASTO varchar) is
               select 1
                 from   CATEGORIE_CATASTO
                where  CATEGORIA_CATASTO = var_CATEGORIA_CATASTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CATEGORIE_CATASTO"
               if :new.CATEGORIA_CATASTO is not null then
                  open  cpk_categorie_catasto(:new.CATEGORIA_CATASTO);
                  fetch cpk_categorie_catasto into dummy;
                  found := cpk_categorie_catasto%FOUND;
                  close cpk_categorie_catasto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.CATEGORIA_CATASTO||
                               '" gia'' presente in Categorie Catasto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CATEGORIE_CATASTO_TIU */
/

-- Procedure CATEGORIE_CATASTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CATEGORIE_CATASTO

create or replace procedure CATEGORIE_CATASTO_PD
(old_categoria_catasto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_categorie_catasto(var_categoria_catasto varchar) is
      select 1
      from   OGGETTI_PRATICA
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Declaration of DeleteParentRestrict constraint for "MOLTIPLICATORI"
   cursor cfk2_categorie_catasto(var_categoria_catasto varchar) is
      select 1
      from   MOLTIPLICATORI
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI"
   cursor cfk3_categorie_catasto(var_categoria_catasto varchar) is
      select 1
      from   OGGETTI
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Declaration of DeleteParentRestrict constraint for "ALIQUOTE_CATEGORIA"
   cursor cfk4_categorie_catasto(var_categoria_catasto varchar) is
      select 1
      from   ALIQUOTE_CATEGORIA
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CATEGORIE_CATASTO" if children still exist in "OGGETTI_PRATICA"
      open  cfk1_categorie_catasto(OLD_CATEGORIA_CATASTO);
      fetch cfk1_categorie_catasto into dummy;
      found := cfk1_categorie_catasto%FOUND;
      close cfk1_categorie_catasto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Categorie Catasto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CATEGORIE_CATASTO" if children still exist in "MOLTIPLICATORI"
      open  cfk2_categorie_catasto(OLD_CATEGORIA_CATASTO);
      fetch cfk2_categorie_catasto into dummy;
      found := cfk2_categorie_catasto%FOUND;
      close cfk2_categorie_catasto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Moltiplicatori. La registrazione di Categorie Catasto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CATEGORIE_CATASTO" if children still exist in "OGGETTI"
      open  cfk3_categorie_catasto(OLD_CATEGORIA_CATASTO);
      fetch cfk3_categorie_catasto into dummy;
      found := cfk3_categorie_catasto%FOUND;
      close cfk3_categorie_catasto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Categorie Catasto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CATEGORIE_CATASTO" if children still exist in "ALIQUOTE_CATEGORIA"
      open  cfk4_categorie_catasto(OLD_CATEGORIA_CATASTO);
      fetch cfk4_categorie_catasto into dummy;
      found := cfk4_categorie_catasto%FOUND;
      close cfk4_categorie_catasto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Aliquote Categoria. La registrazione di Categorie Catasto non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CATEGORIE_CATASTO_PD */
/

-- Tigger CATEGORIE_CATASTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CATEGORIE_CATASTO

create or replace trigger CATEGORIE_CATASTO_TD
before DELETE
on CATEGORIE_CATASTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI_PRATICA

      -- Child Restrict Table: MOLTIPLICATORI

      -- Child Restrict Table: OGGETTI

      -- Child Restrict Table: ALIQUOTE_CATEGORIA

      CATEGORIE_CATASTO_PD(:OLD.CATEGORIA_CATASTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CATEGORIE_CATASTO_TD */
/

-- Procedure CATEGORIE_CER_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CATEGORIE_CER

create or replace procedure CATEGORIE_CER_PI
(new_classe_cer IN varchar,
 new_sottoclasse_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOTTOCLASSI_CER"
   cursor cpk1_categorie_cer(var_classe_cer varchar,
                             var_sottoclasse_cer varchar) is
      select 1
      from   SOTTOCLASSI_CER
      where  CLASSE_CER = var_classe_cer
       and   SOTTOCLASSE_CER = var_sottoclasse_cer
       and   var_classe_cer is not null
       and   var_sottoclasse_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SOTTOCLASSI_CER" deve esistere quando si inserisce su "CATEGORIE_CER"
         if NEW_CLASSE_CER is not null and
            NEW_SOTTOCLASSE_CER is not null then
            open  cpk1_categorie_cer(NEW_CLASSE_CER,
                                     NEW_SOTTOCLASSE_CER);
            fetch cpk1_categorie_cer into dummy;
            found := cpk1_categorie_cer%FOUND;
            close cpk1_categorie_cer;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Sottoclassi CER. La registrazione Categorie CER non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CATEGORIE_CER_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CATEGORIE_CER
/* End Trigger: CATEGORIE_CER_TC */

-- Procedure CATEGORIE_CER_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CATEGORIE_CER

create or replace procedure CATEGORIE_CER_PU
(old_codice_cer IN varchar,
 old_classe_cer IN varchar,
 old_sottoclasse_cer IN varchar,
 new_codice_cer IN varchar,
 new_classe_cer IN varchar,
 new_sottoclasse_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOTTOCLASSI_CER"
   cursor cpk1_categorie_cer(var_classe_cer varchar,
                             var_sottoclasse_cer varchar) is
      select 1
      from   SOTTOCLASSI_CER
      where  CLASSE_CER = var_classe_cer
       and   SOTTOCLASSE_CER = var_sottoclasse_cer
       and   var_classe_cer is not null
       and   var_sottoclasse_cer is not null;

   --  Declaration of UpdateParentRestrict constraint for "RIDUZIONI_CER"
   cursor cfk1_categorie_cer(var_codice_cer varchar) is
      select 1
      from   RIDUZIONI_CER
      where  CODICE_CER = var_codice_cer
       and   var_codice_cer is not null;

   --  Declaration of UpdateParentRestrict constraint for "CONFERIMENTI_CER"
   cursor cfk2_categorie_cer(var_codice_cer varchar) is
      select 1
      from   CONFERIMENTI_CER
      where  CODICE_CER = var_codice_cer
       and   var_codice_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SOTTOCLASSI_CER" deve esistere quando si modifica "CATEGORIE_CER"
         if  NEW_CLASSE_CER is not null and
             NEW_SOTTOCLASSE_CER is not null and ( seq = 0 )
         and (   (NEW_CLASSE_CER != OLD_CLASSE_CER or OLD_CLASSE_CER is null)
              or (NEW_SOTTOCLASSE_CER != OLD_SOTTOCLASSE_CER or OLD_SOTTOCLASSE_CER is null) ) then
            open  cpk1_categorie_cer(NEW_CLASSE_CER,
                                     NEW_SOTTOCLASSE_CER);
            fetch cpk1_categorie_cer into dummy;
            found := cpk1_categorie_cer%FOUND;
            close cpk1_categorie_cer;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Sottoclassi CER. La registrazione Categorie CER non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "CATEGORIE_CER" non modificabile se esistono referenze su "RIDUZIONI_CER"
      if (OLD_CODICE_CER != NEW_CODICE_CER) then
         open  cfk1_categorie_cer(OLD_CODICE_CER);
         fetch cfk1_categorie_cer into dummy;
         found := cfk1_categorie_cer%FOUND;
         close cfk1_categorie_cer;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Riduzioni CER. La registrazione di Categorie CER non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "CATEGORIE_CER" non modificabile se esistono referenze su "CONFERIMENTI_CER"
      if (OLD_CODICE_CER != NEW_CODICE_CER) then
         open  cfk2_categorie_cer(OLD_CODICE_CER);
         fetch cfk2_categorie_cer into dummy;
         found := cfk2_categorie_cer%FOUND;
         close cfk2_categorie_cer;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Conferimenti CER. La registrazione di Categorie CER non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CATEGORIE_CER_PU */
/

-- Trigger CATEGORIE_CER_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CATEGORIE_CER

create or replace trigger CATEGORIE_CER_TIU
before INSERT
    or UPDATE
on CATEGORIE_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      IF :new.codice_cer is null then
         :new.codice_cer := lpad(:new.classe_cer,2,'0')||lpad(:new.sottoclasse_cer,2,'0')||lpad(:new.categoria_cer,2,'0');
         :new.s_codice_cer := lpad(:new.classe_cer,2,'0')||' '||lpad(:new.sottoclasse_cer,2,'0')||' '||lpad(:new.categoria_cer,2,'0');
      END IF;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CATEGORIE_CER_PU(:OLD.CODICE_CER,
                          :OLD.CLASSE_CER,
                          :OLD.SOTTOCLASSE_CER,
                         :NEW.CODICE_CER,
                         :NEW.CLASSE_CER,
                         :NEW.SOTTOCLASSE_CER);
         null;
      end if;
      if INSERTING then
         CATEGORIE_CER_PI(:NEW.CLASSE_CER,
                          :NEW.SOTTOCLASSE_CER);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CATEGORIE_CER"
            cursor cpk_categorie_cer(var_CODICE_CER varchar) is
               select 1
                 from   CATEGORIE_CER
                where  CODICE_CER = var_CODICE_CER;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CATEGORIE_CER"
               if :new.CODICE_CER is not null then
                  open  cpk_categorie_cer(:new.CODICE_CER);
                  fetch cpk_categorie_cer into dummy;
                  found := cpk_categorie_cer%FOUND;
                  close cpk_categorie_cer;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.CODICE_CER||
                               '" gia'' presente in Categorie CER. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CATEGORIE_CER_TIU */
/

-- Procedure CATEGORIE_CER_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CATEGORIE_CER

create or replace procedure CATEGORIE_CER_PD
(old_codice_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "RIDUZIONI_CER"
   cursor cfk1_categorie_cer(var_codice_cer varchar) is
      select 1
      from   RIDUZIONI_CER
      where  CODICE_CER = var_codice_cer
       and   var_codice_cer is not null;

   --  Declaration of DeleteParentRestrict constraint for "CONFERIMENTI_CER"
   cursor cfk2_categorie_cer(var_codice_cer varchar) is
      select 1
      from   CONFERIMENTI_CER
      where  CODICE_CER = var_codice_cer
       and   var_codice_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CATEGORIE_CER" if children still exist in "RIDUZIONI_CER"
      open  cfk1_categorie_cer(OLD_CODICE_CER);
      fetch cfk1_categorie_cer into dummy;
      found := cfk1_categorie_cer%FOUND;
      close cfk1_categorie_cer;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Riduzioni CER. La registrazione di Categorie CER non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CATEGORIE_CER" if children still exist in "CONFERIMENTI_CER"
      open  cfk2_categorie_cer(OLD_CODICE_CER);
      fetch cfk2_categorie_cer into dummy;
      found := cfk2_categorie_cer%FOUND;
      close cfk2_categorie_cer;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Conferimenti CER. La registrazione di Categorie CER non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CATEGORIE_CER_PD */
/

-- Tigger CATEGORIE_CER_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CATEGORIE_CER

create or replace trigger CATEGORIE_CER_TD
before DELETE
on CATEGORIE_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: RIDUZIONI_CER

      -- Child Restrict Table: CONFERIMENTI_CER

      CATEGORIE_CER_PD(:OLD.CODICE_CER);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CATEGORIE_CER_TD */
/

-- Procedure CAUSALI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CAUSALI

create or replace procedure CAUSALI_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_causali(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "CAUSALI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_causali(NEW_TIPO_TRIBUTO);
            fetch cpk1_causali into dummy;
            found := cpk1_causali%FOUND;
            close cpk1_causali;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Causali non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CAUSALI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CAUSALI
/* End Trigger: CAUSALI_TC */

-- Procedure CAUSALI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CAUSALI

create or replace procedure CAUSALI_PU
(old_tipo_tributo IN varchar,
 old_causale IN varchar,
 new_tipo_tributo IN varchar,
 new_causale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_causali(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "CAUSALI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_causali(NEW_TIPO_TRIBUTO);
            fetch cpk1_causali into dummy;
            found := cpk1_causali%FOUND;
            close cpk1_causali;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Causali non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CAUSALI_PU */
/

-- Trigger CAUSALI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CAUSALI

create or replace trigger CAUSALI_TIU
before INSERT
    or UPDATE
on CAUSALI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CAUSALI_PU(:OLD.TIPO_TRIBUTO,
                    :OLD.CAUSALE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.CAUSALE);
         null;
      end if;
      if INSERTING then
         CAUSALI_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CAUSALI"
            cursor cpk_causali(var_TIPO_TRIBUTO varchar,
                               var_CAUSALE varchar) is
               select 1
                 from   CAUSALI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       CAUSALE = var_CAUSALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CAUSALI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.CAUSALE is not null then
                  open  cpk_causali(:new.TIPO_TRIBUTO,
                                    :new.CAUSALE);
                  fetch cpk_causali into dummy;
                  found := cpk_causali%FOUND;
                  close cpk_causali;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.CAUSALE||
                               '" gia'' presente in Causali. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CAUSALI_TIU */
/

-- Trigger CC_FABBRICATI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CC_FABBRICATI

create or replace trigger CC_FABBRICATI_TIU
before INSERT
    or UPDATE
on CC_FABBRICATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.zona_ric 		:= nvl(rtrim(ltrim(ltrim(:new.zona,'0'))),'0');
      :new.categoria_ric	:= nvl(rtrim(ltrim(ltrim(:new.categoria,'0'))),'0');
      :new.partita_ric		:= nvl(:new.partita,'0');
   end;
/*
   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CC_FABBRICATI"
               select 1
                 from   CC_FABBRICATI
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CC_FABBRICATI"
                  fetch cpk_cc_fabbricati into dummy;
                  found := cpk_cc_fabbricati%FOUND;
                  close cpk_cc_fabbricati;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               '" gia'' presente in CC_FABBRICATI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;
*/
   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CC_FABBRICATI_TIU */
/

-- Trigger CC_IDENTIFICATIVI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CC_IDENTIFICATIVI

create or replace trigger CC_IDENTIFICATIVI_TIU
before INSERT
    or UPDATE
on CC_IDENTIFICATIVI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.sezione_ric 		:= rtrim(ltrim(ltrim(:new.sezione,'0')));
      :new.foglio_ric		:= substr(rtrim(ltrim(ltrim(:new.foglio,'0'))),1,5);
      :new.numero_ric		:= substr(rtrim(ltrim(ltrim(:new.numero,'0'))),1,5);
      :new.subalterno_ric	:= rtrim(ltrim(ltrim(:new.subalterno,'0')));

      :new.estremi_catasto 	:= lpad(nvl(:new.sezione_ric,' '),3,' ')||
       				   substr(lpad(nvl(:new.foglio_ric,' '),5,' '),1,5)||
       				   substr(lpad(nvl(:new.numero_ric,' '),5,' '),1,5)||
       				   lpad(nvl(:new.subalterno_ric,' '),4,' ')||
       				   '   ';
      :new.sezione_ric      	:= nvl(:new.sezione_ric,'0');
      :new.foglio_ric        	:= nvl(:new.foglio_ric,'0');
      :new.numero_ric       	:= nvl(:new.numero_ric,'0');
      :new.subalterno_ric     	:= nvl(:new.subalterno_ric,'0');

   end;
/*
   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CC_IDENTIFICATIVI"
               select 1
                 from   CC_IDENTIFICATIVI
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CC_IDENTIFICATIVI"
                  fetch cpk_cc_identificativi into dummy;
                  found := cpk_cc_identificativi%FOUND;
                  close cpk_cc_identificativi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               '" gia'' presente in CC_IDENTIFICATIVI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;
*/
   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CC_IDENTIFICATIVI_TIU */
/

-- Trigger CC_PARTICELLE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CC_PARTICELLE

create or replace trigger CC_PARTICELLE_TIU
before INSERT
    or UPDATE
on CC_PARTICELLE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.foglio_ric		:= substr(rtrim(ltrim(ltrim(:new.foglio,'0'))),1,5);
      :new.numero_ric		:= substr(rtrim(ltrim(ltrim(:new.numero,'0'))),1,5);
      :new.subalterno_ric	:= substr(rtrim(ltrim(ltrim(:new.subalterno,'0'))),1,4);

      :new.estremi_catasto  := '   '||
              substr(lpad(nvl(:new.foglio_ric,' '),5,' '),1,5)||
              substr(lpad(nvl(:new.numero_ric,' '),5,' '),1,5)||
              lpad(nvl(:new.subalterno_ric,' '),4,' ')||
              '   ';

      :new.sezione_ric        	:= '0';
      :new.foglio_ric        	:= nvl(:new.foglio_ric,'0');
      :new.numero_ric       	:= nvl(:new.numero_ric,'0');
      :new.subalterno_ric     	:= nvl(:new.subalterno_ric,'0');
   end;
/*
   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CC_PARTICELLE"
               select 1
                 from   CC_PARTICELLE
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CC_PARTICELLE"
                  fetch cpk_cc_particelle into dummy;
                  found := cpk_cc_particelle%FOUND;
                  close cpk_cc_particelle;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               '" gia'' presente in CC_PARTICELLE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;
*/
   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CC_PARTICELLE_TIU */
/

-- Trigger CC_SOGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CC_SOGGETTI

create or replace trigger CC_SOGGETTI_TIU
before INSERT
    or UPDATE
on CC_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.id_soggetto_ric	:= nvl(:new.id_soggetto,:new.id_soggetto_2);
      if :new.cognome is null and :new.nome is null then
         :new.cognome_nome_ric	:= rtrim(ltrim(:new.denominazione));
      else
         :new.cognome_nome_ric	:= rtrim(ltrim(:new.cognome))||'/'||rtrim(ltrim(:new.nome));
      end if;
      :new.cod_fiscale_ric	:= nvl(:new.codice_fiscale,lpad(to_char(:new.codice_fiscale_2),11,'0'));
   end;
/*
   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CC_SOGGETTI"
               select 1
                 from   CC_SOGGETTI
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CC_SOGGETTI"
                  fetch cpk_cc_soggetti into dummy;
                  found := cpk_cc_soggetti%FOUND;
                  close cpk_cc_soggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               '" gia'' presente in CC_SOGGETTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;
*/
   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CC_SOGGETTI_TIU */
/

-- Procedure CIVICI_EDIFICIO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CIVICI_EDIFICIO

create or replace procedure CIVICI_EDIFICIO_PI
(new_edificio IN number,
 new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "EDIFICI"
   cursor cpk1_civici_edificio(var_edificio number) is
      select 1
      from   EDIFICI
      where  EDIFICIO = var_edificio
       and   var_edificio is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE"
   cursor cpk2_civici_edificio(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "EDIFICI" deve esistere quando si inserisce su "CIVICI_EDIFICIO"
         if NEW_EDIFICIO is not null then
            open  cpk1_civici_edificio(NEW_EDIFICIO);
            fetch cpk1_civici_edificio into dummy;
            found := cpk1_civici_edificio%FOUND;
            close cpk1_civici_edificio;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Edifici. La registrazione Civici Edificio non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si inserisce su "CIVICI_EDIFICIO"
         if NEW_COD_VIA is not null then
            open  cpk2_civici_edificio(NEW_COD_VIA);
            fetch cpk2_civici_edificio into dummy;
            found := cpk2_civici_edificio%FOUND;
            close cpk2_civici_edificio;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Civici Edificio non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CIVICI_EDIFICIO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CIVICI_EDIFICIO
/* End Trigger: CIVICI_EDIFICIO_TC */

-- Procedure CIVICI_EDIFICIO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CIVICI_EDIFICIO

create or replace procedure CIVICI_EDIFICIO_PU
(old_edificio IN number,
 old_sequenza IN number,
 old_cod_via IN number,
 new_edificio IN number,
 new_sequenza IN number,
 new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "EDIFICI"
   cursor cpk1_civici_edificio(var_edificio number) is
      select 1
      from   EDIFICI
      where  EDIFICIO = var_edificio
       and   var_edificio is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE"
   cursor cpk2_civici_edificio(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "EDIFICI" deve esistere quando si modifica "CIVICI_EDIFICIO"
         if  NEW_EDIFICIO is not null and ( seq = 0 )
         and (   (NEW_EDIFICIO != OLD_EDIFICIO or OLD_EDIFICIO is null) ) then
            open  cpk1_civici_edificio(NEW_EDIFICIO);
            fetch cpk1_civici_edificio into dummy;
            found := cpk1_civici_edificio%FOUND;
            close cpk1_civici_edificio;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Edifici. La registrazione Civici Edificio non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si modifica "CIVICI_EDIFICIO"
         if  NEW_COD_VIA is not null and ( seq = 0 )
         and (   (NEW_COD_VIA != OLD_COD_VIA or OLD_COD_VIA is null) ) then
            open  cpk2_civici_edificio(NEW_COD_VIA);
            fetch cpk2_civici_edificio into dummy;
            found := cpk2_civici_edificio%FOUND;
            close cpk2_civici_edificio;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Civici Edificio non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CIVICI_EDIFICIO_PU */
/

-- Trigger CIVICI_EDIFICIO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CIVICI_EDIFICIO

create or replace trigger CIVICI_EDIFICIO_TIU
before INSERT
    or UPDATE
on CIVICI_EDIFICIO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       CIVICI_EDIFICIO_NR (:new.edificio,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CIVICI_EDIFICIO_PU(:OLD.EDIFICIO,
                            :OLD.SEQUENZA,
                            :OLD.COD_VIA,
                         :NEW.EDIFICIO,
                         :NEW.SEQUENZA,
                         :NEW.COD_VIA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            CIVICI_EDIFICIO_PI(:NEW.EDIFICIO,
                               :NEW.COD_VIA);
            declare  --  Check UNIQUE PK Integrity per la tabella "CIVICI_EDIFICIO"
            cursor cpk_civici_edificio(var_EDIFICIO number,
                                       var_SEQUENZA number) is
               select 1
                 from   CIVICI_EDIFICIO
                where  EDIFICIO = var_EDIFICIO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CIVICI_EDIFICIO"
               if :new.EDIFICIO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_civici_edificio(:new.EDIFICIO,
                                            :new.SEQUENZA);
                  fetch cpk_civici_edificio into dummy;
                  found := cpk_civici_edificio%FOUND;
                  close cpk_civici_edificio;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.EDIFICIO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Civici Edificio. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CIVICI_EDIFICIO_TIU */
/

-- Procedure CIVICI_OGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CIVICI_OGGETTO

create or replace procedure CIVICI_OGGETTO_PI
(new_oggetto IN number,
 new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk1_civici_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE"
   cursor cpk2_civici_oggetto(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "CIVICI_OGGETTO"
         if NEW_OGGETTO is not null then
            open  cpk1_civici_oggetto(NEW_OGGETTO);
            fetch cpk1_civici_oggetto into dummy;
            found := cpk1_civici_oggetto%FOUND;
            close cpk1_civici_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Civici Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si inserisce su "CIVICI_OGGETTO"
         if NEW_COD_VIA is not null then
            open  cpk2_civici_oggetto(NEW_COD_VIA);
            fetch cpk2_civici_oggetto into dummy;
            found := cpk2_civici_oggetto%FOUND;
            close cpk2_civici_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Civici Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CIVICI_OGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CIVICI_OGGETTO
/* End Trigger: CIVICI_OGGETTO_TC */

-- Procedure CIVICI_OGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CIVICI_OGGETTO

create or replace procedure CIVICI_OGGETTO_PU
(old_oggetto IN number,
 old_sequenza IN number,
 old_cod_via IN number,
 new_oggetto IN number,
 new_sequenza IN number,
 new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk1_civici_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE"
   cursor cpk2_civici_oggetto(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "CIVICI_OGGETTO"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk1_civici_oggetto(NEW_OGGETTO);
            fetch cpk1_civici_oggetto into dummy;
            found := cpk1_civici_oggetto%FOUND;
            close cpk1_civici_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Civici Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si modifica "CIVICI_OGGETTO"
         if  NEW_COD_VIA is not null and ( seq = 0 )
         and (   (NEW_COD_VIA != OLD_COD_VIA or OLD_COD_VIA is null) ) then
            open  cpk2_civici_oggetto(NEW_COD_VIA);
            fetch cpk2_civici_oggetto into dummy;
            found := cpk2_civici_oggetto%FOUND;
            close cpk2_civici_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Civici Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CIVICI_OGGETTO_PU */
/

-- Trigger CIVICI_OGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CIVICI_OGGETTO

create or replace trigger CIVICI_OGGETTO_TIU
before INSERT
    or UPDATE
on CIVICI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       CIVICI_OGGETTO_NR (:new.oggetto,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CIVICI_OGGETTO_PU(:OLD.OGGETTO,
                           :OLD.SEQUENZA,
                           :OLD.COD_VIA,
                         :NEW.OGGETTO,
                         :NEW.SEQUENZA,
                         :NEW.COD_VIA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            CIVICI_OGGETTO_PI(:NEW.OGGETTO,
                              :NEW.COD_VIA);
            declare  --  Check UNIQUE PK Integrity per la tabella "CIVICI_OGGETTO"
            cursor cpk_civici_oggetto(var_OGGETTO number,
                                      var_SEQUENZA number) is
               select 1
                 from   CIVICI_OGGETTO
                where  OGGETTO = var_OGGETTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CIVICI_OGGETTO"
               if :new.OGGETTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_civici_oggetto(:new.OGGETTO,
                                           :new.SEQUENZA);
                  fetch cpk_civici_oggetto into dummy;
                  found := cpk_civici_oggetto%FOUND;
                  close cpk_civici_oggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Civici Oggetto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CIVICI_OGGETTO_TIU */
/

-- Procedure CIVICI_OGGETTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CIVICI_OGGETTO

create or replace procedure CIVICI_OGGETTO_PD
(old_oggetto IN number,
 old_sequenza IN number,
 old_indirizzo_localita IN varchar2,
 old_cod_via IN number,
 old_num_civ IN number,
 old_suffisso IN varchar2)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin
      CIVICI_OGGETTO_FI(old_oggetto,old_indirizzo_localita,old_cod_via,old_num_civ,
                        old_suffisso);
   end;
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CIVICI_OGGETTO_PD */
/

-- Tigger CIVICI_OGGETTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CIVICI_OGGETTO

create or replace trigger CIVICI_OGGETTO_TD
before DELETE
on CIVICI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      */  null;
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
      CIVICI_OGGETTO_PD(:OLD.OGGETTO,
                        :OLD.SEQUENZA,
                         :old.indirizzo_localita,:old.cod_via,:old.num_civ,
                         :old.suffisso);
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CIVICI_OGGETTO_TD */
/

-- Procedure CLASSI_CER_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CLASSI_CER

create or replace procedure CLASSI_CER_PU
(old_classe_cer IN varchar,
 new_classe_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SOTTOCLASSI_CER"
   cursor cfk1_classi_cer(var_classe_cer varchar) is
      select 1
      from   SOTTOCLASSI_CER
      where  CLASSE_CER = var_classe_cer
       and   var_classe_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "CLASSI_CER" non modificabile se esistono referenze su "SOTTOCLASSI_CER"
      if (OLD_CLASSE_CER != NEW_CLASSE_CER) then
         open  cfk1_classi_cer(OLD_CLASSE_CER);
         fetch cfk1_classi_cer into dummy;
         found := cfk1_classi_cer%FOUND;
         close cfk1_classi_cer;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sottoclassi CER. La registrazione di Classi CER non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CLASSI_CER_PU */
/

-- Trigger CLASSI_CER_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CLASSI_CER

create or replace trigger CLASSI_CER_TIU
before INSERT
    or UPDATE
on CLASSI_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CLASSI_CER_PU(:OLD.CLASSE_CER,
                         :NEW.CLASSE_CER);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CLASSI_CER"
            cursor cpk_classi_cer(var_CLASSE_CER varchar) is
               select 1
                 from   CLASSI_CER
                where  CLASSE_CER = var_CLASSE_CER;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CLASSI_CER"
               if :new.CLASSE_CER is not null then
                  open  cpk_classi_cer(:new.CLASSE_CER);
                  fetch cpk_classi_cer into dummy;
                  found := cpk_classi_cer%FOUND;
                  close cpk_classi_cer;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.CLASSE_CER||
                               '" gia'' presente in Classi CER. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CLASSI_CER_TIU */
/

-- Procedure CLASSI_CER_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CLASSI_CER

create or replace procedure CLASSI_CER_PD
(old_classe_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SOTTOCLASSI_CER"
   cursor cfk1_classi_cer(var_classe_cer varchar) is
      select 1
      from   SOTTOCLASSI_CER
      where  CLASSE_CER = var_classe_cer
       and   var_classe_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CLASSI_CER" if children still exist in "SOTTOCLASSI_CER"
      open  cfk1_classi_cer(OLD_CLASSE_CER);
      fetch cfk1_classi_cer into dummy;
      found := cfk1_classi_cer%FOUND;
      close cfk1_classi_cer;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sottoclassi CER. La registrazione di Classi CER non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CLASSI_CER_PD */
/

-- Tigger CLASSI_CER_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CLASSI_CER

create or replace trigger CLASSI_CER_TD
before DELETE
on CLASSI_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SOTTOCLASSI_CER

      CLASSI_CER_PD(:OLD.CLASSE_CER);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CLASSI_CER_TD */
/

-- Procedure CLASSI_SUPERFICIE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CLASSI_SUPERFICIE

create or replace procedure CLASSI_SUPERFICIE_PI
(new_anno IN number,
 new_settore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SETTORI_ATTIVITA"
   cursor cpk1_classi_superficie(var_settore number) is
      select 1
      from   SETTORI_ATTIVITA
      where  SETTORE = var_settore
       and   var_settore is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SCAGLIONI_REDDITO"
   cursor cpk2_classi_superficie(var_anno number) is
      select 1
      from   SCAGLIONI_REDDITO
      where  ANNO = var_anno
       and   var_anno is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SETTORI_ATTIVITA" deve esistere quando si inserisce su "CLASSI_SUPERFICIE"
         if NEW_SETTORE is not null then
            open  cpk1_classi_superficie(NEW_SETTORE);
            fetch cpk1_classi_superficie into dummy;
            found := cpk1_classi_superficie%FOUND;
            close cpk1_classi_superficie;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SETTORI_ATTIVITA. La registrazione CLASSI_SUPERFICIE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SCAGLIONI_REDDITO" deve esistere quando si inserisce su "CLASSI_SUPERFICIE"
         if NEW_ANNO is not null then
            open  cpk2_classi_superficie(NEW_ANNO);
            fetch cpk2_classi_superficie into dummy;
            found := cpk2_classi_superficie%FOUND;
            close cpk2_classi_superficie;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SCAGLIONI_REDDITO. La registrazione CLASSI_SUPERFICIE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CLASSI_SUPERFICIE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CLASSI_SUPERFICIE
/* End Trigger: CLASSI_SUPERFICIE_TC */

-- Procedure CLASSI_SUPERFICIE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CLASSI_SUPERFICIE

create or replace procedure CLASSI_SUPERFICIE_PU
(old_anno IN number,
 old_settore IN number,
 old_classe IN number,
 new_anno IN number,
 new_settore IN number,
 new_classe IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SETTORI_ATTIVITA"
   cursor cpk1_classi_superficie(var_settore number) is
      select 1
      from   SETTORI_ATTIVITA
      where  SETTORE = var_settore
       and   var_settore is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SCAGLIONI_REDDITO"
   cursor cpk2_classi_superficie(var_anno number) is
      select 1
      from   SCAGLIONI_REDDITO
      where  ANNO = var_anno
       and   var_anno is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_classi_superficie(var_anno number,
                                 var_settore number,
                                 var_classe number) is
      select 1
      from   OGGETTI_PRATICA
      where  ANNO = var_anno
       and   SETTORE = var_settore
       and   CLASSE_SUP = var_classe
       and   var_anno is not null
       and   var_settore is not null
       and   var_classe is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SETTORI_ATTIVITA" deve esistere quando si modifica "CLASSI_SUPERFICIE"
         if  NEW_SETTORE is not null and ( seq = 0 )
         and (   (NEW_SETTORE != OLD_SETTORE or OLD_SETTORE is null) ) then
            open  cpk1_classi_superficie(NEW_SETTORE);
            fetch cpk1_classi_superficie into dummy;
            found := cpk1_classi_superficie%FOUND;
            close cpk1_classi_superficie;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SETTORI_ATTIVITA. La registrazione CLASSI_SUPERFICIE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SCAGLIONI_REDDITO" deve esistere quando si modifica "CLASSI_SUPERFICIE"
         if  NEW_ANNO is not null and ( seq = 0 )
         and (   (NEW_ANNO != OLD_ANNO or OLD_ANNO is null) ) then
            open  cpk2_classi_superficie(NEW_ANNO);
            fetch cpk2_classi_superficie into dummy;
            found := cpk2_classi_superficie%FOUND;
            close cpk2_classi_superficie;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SCAGLIONI_REDDITO. La registrazione CLASSI_SUPERFICIE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "CLASSI_SUPERFICIE" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_ANNO != NEW_ANNO) or
         (OLD_SETTORE != NEW_SETTORE) or
         (OLD_CLASSE != NEW_CLASSE) then
         open  cfk1_classi_superficie(OLD_ANNO,
                                      OLD_SETTORE,
                                      OLD_CLASSE);
         fetch cfk1_classi_superficie into dummy;
         found := cfk1_classi_superficie%FOUND;
         close cfk1_classi_superficie;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di CLASSI_SUPERFICIE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CLASSI_SUPERFICIE_PU */
/

-- Trigger CLASSI_SUPERFICIE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CLASSI_SUPERFICIE

create or replace trigger CLASSI_SUPERFICIE_TIU
before INSERT
    or UPDATE
on CLASSI_SUPERFICIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CLASSI_SUPERFICIE_PU(:OLD.ANNO,
                              :OLD.SETTORE,
                              :OLD.CLASSE,
                         :NEW.ANNO,
                         :NEW.SETTORE,
                         :NEW.CLASSE);
         null;
      end if;
      if INSERTING then
         CLASSI_SUPERFICIE_PI(:NEW.ANNO,
                              :NEW.SETTORE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CLASSI_SUPERFICIE"
            cursor cpk_classi_superficie(var_ANNO number,
                                         var_SETTORE number,
                                         var_CLASSE number) is
               select 1
                 from   CLASSI_SUPERFICIE
                where  ANNO = var_ANNO and
                       SETTORE = var_SETTORE and
                       CLASSE = var_CLASSE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CLASSI_SUPERFICIE"
               if :new.ANNO is not null and
                  :new.SETTORE is not null and
                  :new.CLASSE is not null then
                  open  cpk_classi_superficie(:new.ANNO,
                                              :new.SETTORE,
                                              :new.CLASSE);
                  fetch cpk_classi_superficie into dummy;
                  found := cpk_classi_superficie%FOUND;
                  close cpk_classi_superficie;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANNO||' '||
                               :new.SETTORE||' '||
                               :new.CLASSE||
                               '" gia'' presente in CLASSI_SUPERFICIE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CLASSI_SUPERFICIE_TIU */
/

-- Procedure CLASSI_SUPERFICIE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CLASSI_SUPERFICIE

create or replace procedure CLASSI_SUPERFICIE_PD
(old_anno IN number,
 old_settore IN number,
 old_classe IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_classi_superficie(var_anno number,
                                 var_settore number,
                                 var_classe number) is
      select 1
      from   OGGETTI_PRATICA
      where  ANNO = var_anno
       and   SETTORE = var_settore
       and   CLASSE_SUP = var_classe
       and   var_anno is not null
       and   var_settore is not null
       and   var_classe is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CLASSI_SUPERFICIE" if children still exist in "OGGETTI_PRATICA"
      open  cfk1_classi_superficie(OLD_ANNO,
                                   OLD_SETTORE,
                                   OLD_CLASSE);
      fetch cfk1_classi_superficie into dummy;
      found := cfk1_classi_superficie%FOUND;
      close cfk1_classi_superficie;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di CLASSI_SUPERFICIE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CLASSI_SUPERFICIE_PD */
/

-- Tigger CLASSI_SUPERFICIE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CLASSI_SUPERFICIE

create or replace trigger CLASSI_SUPERFICIE_TD
before DELETE
on CLASSI_SUPERFICIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI_PRATICA

      CLASSI_SUPERFICIE_PD(:OLD.ANNO,
                           :OLD.SETTORE,
                           :OLD.CLASSE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CLASSI_SUPERFICIE_TD */
/

-- Procedure CODICI_DIRITTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CODICI_DIRITTO

create or replace procedure CODICI_DIRITTO_PU
(old_cod_diritto IN varchar,
 new_cod_diritto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "ATTRIBUTI_OGCO"
   cursor cfk1_codici_diritto(var_cod_diritto varchar) is
      select 1
      from   ATTRIBUTI_OGCO
      where  COD_DIRITTO = var_cod_diritto
       and   var_cod_diritto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "CODICI_DIRITTO" non modificabile se esistono referenze su "ATTRIBUTI_OGCO"
      if (OLD_COD_DIRITTO != NEW_COD_DIRITTO) then
         open  cfk1_codici_diritto(OLD_COD_DIRITTO);
         fetch cfk1_codici_diritto into dummy;
         found := cfk1_codici_diritto%FOUND;
         close cfk1_codici_diritto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Attributi OGCO. La registrazione di Codici Diritto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_DIRITTO_PU */
/

-- Trigger CODICI_DIRITTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CODICI_DIRITTO

create or replace trigger CODICI_DIRITTO_TIU
before INSERT
    or UPDATE
on CODICI_DIRITTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CODICI_DIRITTO_PU(:OLD.COD_DIRITTO,
                         :NEW.COD_DIRITTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CODICI_DIRITTO"
            cursor cpk_codici_diritto(var_COD_DIRITTO varchar) is
               select 1
                 from   CODICI_DIRITTO
                where  COD_DIRITTO = var_COD_DIRITTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CODICI_DIRITTO"
               if :new.COD_DIRITTO is not null then
                  open  cpk_codici_diritto(:new.COD_DIRITTO);
                  fetch cpk_codici_diritto into dummy;
                  found := cpk_codici_diritto%FOUND;
                  close cpk_codici_diritto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_DIRITTO||
                               '" gia'' presente in Codici Diritto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CODICI_DIRITTO_TIU */
/

-- Procedure CODICI_DIRITTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CODICI_DIRITTO

create or replace procedure CODICI_DIRITTO_PD
(old_cod_diritto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ATTRIBUTI_OGCO"
   cursor cfk1_codici_diritto(var_cod_diritto varchar) is
      select 1
      from   ATTRIBUTI_OGCO
      where  COD_DIRITTO = var_cod_diritto
       and   var_cod_diritto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CODICI_DIRITTO" if children still exist in "ATTRIBUTI_OGCO"
      open  cfk1_codici_diritto(OLD_COD_DIRITTO);
      fetch cfk1_codici_diritto into dummy;
      found := cfk1_codici_diritto%FOUND;
      close cfk1_codici_diritto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Attributi OGCO. La registrazione di Codici Diritto non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_DIRITTO_PD */
/

-- Tigger CODICI_DIRITTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CODICI_DIRITTO

create or replace trigger CODICI_DIRITTO_TD
before DELETE
on CODICI_DIRITTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ATTRIBUTI_OGCO

      CODICI_DIRITTO_PD(:OLD.COD_DIRITTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CODICI_DIRITTO_TD */
/

-- Procedure CODICI_F24_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CODICI_F24

create or replace procedure CODICI_F24_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_codici_f24(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "CODICI_F24"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_codici_f24(NEW_TIPO_TRIBUTO);
            fetch cpk1_codici_f24 into dummy;
            found := cpk1_codici_f24%FOUND;
            close cpk1_codici_f24;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione CODICI_F24 non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_F24_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CODICI_F24
/* End Trigger: CODICI_F24_TC */

-- Procedure CODICI_F24_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CODICI_F24

create or replace procedure CODICI_F24_PU
(old_tributo_f24 IN varchar,
 old_tipo_tributo IN varchar,
 old_descrizione_titr IN varchar,
 new_tributo_f24 IN varchar,
 new_tipo_tributo IN varchar,
 new_descrizione_titr IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_codici_f24(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_CONTABILI"
   cursor cfk1_codici_f24(var_tributo_f24 varchar,
                          var_tipo_tributo varchar,
                          var_descrizione_titr varchar) is
      select 1
      from   DATI_CONTABILI
      where  COD_TRIBUTO_F24 = var_tributo_f24
       and   TIPO_TRIBUTO = var_tipo_tributo
       and   DESCRIZIONE_TITR = var_descrizione_titr
       and   var_tributo_f24 is not null
       and   var_tipo_tributo is not null
       and   var_descrizione_titr is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "CODICI_F24"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_codici_f24(NEW_TIPO_TRIBUTO);
            fetch cpk1_codici_f24 into dummy;
            found := cpk1_codici_f24%FOUND;
            close cpk1_codici_f24;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione CODICI_F24 non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "CODICI_F24" non modificabile se esistono referenze su "DATI_CONTABILI"
      if (OLD_TRIBUTO_F24 != NEW_TRIBUTO_F24) or
         (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_DESCRIZIONE_TITR != NEW_DESCRIZIONE_TITR) then
         open  cfk1_codici_f24(OLD_TRIBUTO_F24,
                               OLD_TIPO_TRIBUTO,
                               OLD_DESCRIZIONE_TITR);
         fetch cfk1_codici_f24 into dummy;
         found := cfk1_codici_f24%FOUND;
         close cfk1_codici_f24;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Dati Contabili. La registrazione di CODICI_F24 non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_F24_PU */
/

-- Trigger CODICI_F24_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CODICI_F24

create or replace trigger CODICI_F24_TIU
before INSERT
    or UPDATE
on CODICI_F24
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CODICI_F24_PU(:OLD.TRIBUTO_F24,
                       :OLD.TIPO_TRIBUTO,
                       :OLD.DESCRIZIONE_TITR,
                         :NEW.TRIBUTO_F24,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.DESCRIZIONE_TITR);
         null;
      end if;
      if INSERTING then
         CODICI_F24_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CODICI_F24"
            cursor cpk_codici_f24(var_TRIBUTO_F24 varchar,
                                  var_TIPO_TRIBUTO varchar,
                                  var_DESCRIZIONE_TITR varchar) is
               select 1
                 from   CODICI_F24
                where  TRIBUTO_F24 = var_TRIBUTO_F24 and
                       TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       DESCRIZIONE_TITR = var_DESCRIZIONE_TITR;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CODICI_F24"
               if :new.TRIBUTO_F24 is not null and
                  :new.TIPO_TRIBUTO is not null and
                  :new.DESCRIZIONE_TITR is not null then
                  open  cpk_codici_f24(:new.TRIBUTO_F24,
                                       :new.TIPO_TRIBUTO,
                                       :new.DESCRIZIONE_TITR);
                  fetch cpk_codici_f24 into dummy;
                  found := cpk_codici_f24%FOUND;
                  close cpk_codici_f24;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TRIBUTO_F24||' '||
                               :new.TIPO_TRIBUTO||' '||
                               :new.DESCRIZIONE_TITR||
                               '" gia'' presente in CODICI_F24. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CODICI_F24_TIU */
/

-- Procedure CODICI_F24_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CODICI_F24

create or replace procedure CODICI_F24_PD
(old_tributo_f24 IN varchar,
 old_tipo_tributo IN varchar,
 old_descrizione_titr IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DATI_CONTABILI"
   cursor cfk1_codici_f24(var_tributo_f24 varchar,
                          var_tipo_tributo varchar,
                          var_descrizione_titr varchar) is
      select 1
      from   DATI_CONTABILI
      where  COD_TRIBUTO_F24 = var_tributo_f24
       and   TIPO_TRIBUTO = var_tipo_tributo
       and   DESCRIZIONE_TITR = var_descrizione_titr
       and   var_tributo_f24 is not null
       and   var_tipo_tributo is not null
       and   var_descrizione_titr is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CODICI_F24" if children still exist in "DATI_CONTABILI"
      open  cfk1_codici_f24(OLD_TRIBUTO_F24,
                            OLD_TIPO_TRIBUTO,
                            OLD_DESCRIZIONE_TITR);
      fetch cfk1_codici_f24 into dummy;
      found := cfk1_codici_f24%FOUND;
      close cfk1_codici_f24;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dati Contabili. La registrazione di CODICI_F24 non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_F24_PD */
/

-- Tigger CODICI_F24_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CODICI_F24

create or replace trigger CODICI_F24_TD
before DELETE
on CODICI_F24
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DATI_CONTABILI

      CODICI_F24_PD(:OLD.TRIBUTO_F24,
                    :OLD.TIPO_TRIBUTO,
                    :OLD.DESCRIZIONE_TITR);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CODICI_F24_TD */
/

-- Procedure CODICI_RFID_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CODICI_RFID

create or replace procedure CODICI_RFID_PI
(new_cod_fiscale IN varchar,
 new_oggetto IN number,
 new_cod_contenitore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_codici_rfid(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk2_codici_rfid(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTENITORI"
   cursor cpk3_codici_rfid(var_cod_contenitore number) is
      select 1
      from   CONTENITORI
      where  COD_CONTENITORE = var_cod_contenitore
       and   var_cod_contenitore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "CODICI_RFID"
         if NEW_COD_FISCALE is not null then
            open  cpk1_codici_rfid(NEW_COD_FISCALE);
            fetch cpk1_codici_rfid into dummy;
            found := cpk1_codici_rfid%FOUND;
            close cpk1_codici_rfid;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Codici RFID non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "CODICI_RFID"
         if NEW_OGGETTO is not null then
            open  cpk2_codici_rfid(NEW_OGGETTO);
            fetch cpk2_codici_rfid into dummy;
            found := cpk2_codici_rfid%FOUND;
            close cpk2_codici_rfid;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Codici RFID non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTENITORI" deve esistere quando si inserisce su "CODICI_RFID"
         if NEW_COD_CONTENITORE is not null then
            open  cpk3_codici_rfid(NEW_COD_CONTENITORE);
            fetch cpk3_codici_rfid into dummy;
            found := cpk3_codici_rfid%FOUND;
            close cpk3_codici_rfid;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contenitori. La registrazione Codici RFID non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_RFID_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CODICI_RFID
/* End Trigger: CODICI_RFID_TC */

-- Procedure CODICI_RFID_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CODICI_RFID

create or replace procedure CODICI_RFID_PU
(old_cod_fiscale IN varchar,
 old_oggetto IN number,
 old_cod_rfid IN varchar,
 old_cod_contenitore IN number,
 new_cod_fiscale IN varchar,
 new_oggetto IN number,
 new_cod_rfid IN varchar,
 new_cod_contenitore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_codici_rfid(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk2_codici_rfid(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTENITORI"
   cursor cpk3_codici_rfid(var_cod_contenitore number) is
      select 1
      from   CONTENITORI
      where  COD_CONTENITORE = var_cod_contenitore
       and   var_cod_contenitore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "CODICI_RFID"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_codici_rfid(NEW_COD_FISCALE);
            fetch cpk1_codici_rfid into dummy;
            found := cpk1_codici_rfid%FOUND;
            close cpk1_codici_rfid;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Codici RFID non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "CODICI_RFID"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk2_codici_rfid(NEW_OGGETTO);
            fetch cpk2_codici_rfid into dummy;
            found := cpk2_codici_rfid%FOUND;
            close cpk2_codici_rfid;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Codici RFID non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTENITORI" deve esistere quando si modifica "CODICI_RFID"
         if  NEW_COD_CONTENITORE is not null and ( seq = 0 )
         and (   (NEW_COD_CONTENITORE != OLD_COD_CONTENITORE or OLD_COD_CONTENITORE is null) ) then
            open  cpk3_codici_rfid(NEW_COD_CONTENITORE);
            fetch cpk3_codici_rfid into dummy;
            found := cpk3_codici_rfid%FOUND;
            close cpk3_codici_rfid;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contenitori. La registrazione Codici RFID non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_RFID_PU */
/

-- Trigger CODICI_RFID_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CODICI_RFID

create or replace trigger CODICI_RFID_TIU
before INSERT
    or UPDATE
on CODICI_RFID
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CODICI_RFID_PU(:OLD.COD_FISCALE,
                        :OLD.OGGETTO,
                        :OLD.COD_RFID,
                        :OLD.COD_CONTENITORE,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO,
                         :NEW.COD_RFID,
                         :NEW.COD_CONTENITORE);
         null;
      end if;
      if INSERTING then
         CODICI_RFID_PI(:NEW.COD_FISCALE,
                        :NEW.OGGETTO,
                        :NEW.COD_CONTENITORE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CODICI_RFID"
            cursor cpk_codici_rfid(var_COD_FISCALE varchar,
                                   var_OGGETTO number,
                                   var_COD_RFID varchar) is
               select 1
                 from   CODICI_RFID
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO = var_OGGETTO and
                       COD_RFID = var_COD_RFID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CODICI_RFID"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO is not null and
                  :new.COD_RFID is not null then
                  open  cpk_codici_rfid(:new.COD_FISCALE,
                                        :new.OGGETTO,
                                        :new.COD_RFID);
                  fetch cpk_codici_rfid into dummy;
                  found := cpk_codici_rfid%FOUND;
                  close cpk_codici_rfid;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO||' '||
                               :new.COD_RFID||
                               '" gia'' presente in Codici RFID. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "CODICI_RFID" for all children in "SVUOTAMENTI"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO != :NEW.OGGETTO) or
            (:OLD.COD_RFID != :NEW.COD_RFID) then
            update SVUOTAMENTI
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO = :NEW.OGGETTO,
                   COD_RFID = :NEW.COD_RFID
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO = :OLD.OGGETTO
             and   COD_RFID = :OLD.COD_RFID;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CODICI_RFID_TIU */
/

-- Procedure CODICI_RFID_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CODICI_RFID

create or replace procedure CODICI_RFID_PD
(old_cod_fiscale IN varchar,
 old_oggetto IN number,
 old_cod_rfid IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SVUOTAMENTI"
   cursor cfk1_codici_rfid(var_cod_fiscale varchar,
                           var_oggetto number,
                           var_cod_rfid varchar) is
      select 1
      from   SVUOTAMENTI
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO = var_oggetto
       and   COD_RFID = var_cod_rfid
       and   var_cod_fiscale is not null
       and   var_oggetto is not null
       and   var_cod_rfid is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CODICI_RFID" if children still exist in "SVUOTAMENTI"
      open  cfk1_codici_rfid(OLD_COD_FISCALE,
                             OLD_OGGETTO,
                             OLD_COD_RFID);
      fetch cfk1_codici_rfid into dummy;
      found := cfk1_codici_rfid%FOUND;
      close cfk1_codici_rfid;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Svuotamenti. La registrazione di Codici RFID non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_RFID_PD */
/

-- Tigger CODICI_RFID_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CODICI_RFID

create or replace trigger CODICI_RFID_TD
before DELETE
on CODICI_RFID
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SVUOTAMENTI

      CODICI_RFID_PD(:OLD.COD_FISCALE,
                     :OLD.OGGETTO,
                     :OLD.COD_RFID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CODICI_RFID_TD */
/

-- Procedure CODICI_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CODICI_TRIBUTO

create or replace procedure CODICI_TRIBUTO_PI
(new_tipo_tributo IN varchar,
 new_gruppo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_codici_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "GRUPPI_TRIBUTO"
   cursor cpk2_codici_tributo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "CODICI_TRIBUTO"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_codici_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk1_codici_tributo into dummy;
            found := cpk1_codici_tributo%FOUND;
            close cpk1_codici_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Codici Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_TRIBUTO" deve esistere quando si inserisce su "CODICI_TRIBUTO"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_GRUPPO_TRIBUTO is not null then
            open  cpk2_codici_tributo(NEW_TIPO_TRIBUTO,
                                      NEW_GRUPPO_TRIBUTO);
            fetch cpk2_codici_tributo into dummy;
            found := cpk2_codici_tributo%FOUND;
            close cpk2_codici_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Gruppi_tributo. La registrazione Codici Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CODICI_TRIBUTO
/* End Trigger: CODICI_TRIBUTO_TC */

-- Procedure CODICI_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CODICI_TRIBUTO

create or replace procedure CODICI_TRIBUTO_PU
(old_tributo IN number,
 old_tipo_tributo IN varchar,
 old_gruppo_tributo IN varchar,
 new_tributo IN number,
 new_tipo_tributo IN varchar,
 new_gruppo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_codici_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "GRUPPI_TRIBUTO"
   cursor cpk2_codici_tributo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_CONTABILI"
   cursor cfk1_codici_tributo(var_tributo number) is
      select 1
      from   DATI_CONTABILI
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "TARIFFE_CONVERSIONE"
   cursor cfk2_codici_tributo(var_tributo number) is
      select 1
      from   TARIFFE_CONVERSIONE
      where  CONVERTI_TRIBUTO = var_tributo
       and   var_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "CODICI_TRIBUTO"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_codici_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk1_codici_tributo into dummy;
            found := cpk1_codici_tributo%FOUND;
            close cpk1_codici_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Codici Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_TRIBUTO" deve esistere quando si modifica "CODICI_TRIBUTO"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_GRUPPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_GRUPPO_TRIBUTO != OLD_GRUPPO_TRIBUTO or OLD_GRUPPO_TRIBUTO is null) ) then
            open  cpk2_codici_tributo(NEW_TIPO_TRIBUTO,
                                      NEW_GRUPPO_TRIBUTO);
            fetch cpk2_codici_tributo into dummy;
            found := cpk2_codici_tributo%FOUND;
            close cpk2_codici_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Gruppi_tributo. La registrazione Codici Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "CODICI_TRIBUTO" non modificabile se esistono referenze su "DATI_CONTABILI"
      if (OLD_TRIBUTO != NEW_TRIBUTO) then
         open  cfk1_codici_tributo(OLD_TRIBUTO);
         fetch cfk1_codici_tributo into dummy;
         found := cfk1_codici_tributo%FOUND;
         close cfk1_codici_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Dati Contabili. La registrazione di Codici Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "CODICI_TRIBUTO" non modificabile se esistono referenze su "TARIFFE_CONVERSIONE"
      if (OLD_TRIBUTO != NEW_TRIBUTO) then
         open  cfk2_codici_tributo(OLD_TRIBUTO);
         fetch cfk2_codici_tributo into dummy;
         found := cfk2_codici_tributo%FOUND;
         close cfk2_codici_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su TARIFFE_CONVERSIONE. La registrazione di Codici Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_TRIBUTO_PU */
/

-- Trigger CODICI_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CODICI_TRIBUTO

create or replace trigger CODICI_TRIBUTO_TIU
before INSERT
    or UPDATE
on CODICI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CODICI_TRIBUTO_PU(:OLD.TRIBUTO,
                           :OLD.TIPO_TRIBUTO,
                           :OLD.GRUPPO_TRIBUTO,
                         :NEW.TRIBUTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.GRUPPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         CODICI_TRIBUTO_PI(:NEW.TIPO_TRIBUTO,
                           :NEW.GRUPPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CODICI_TRIBUTO"
            cursor cpk_codici_tributo(var_TRIBUTO number) is
               select 1
                 from   CODICI_TRIBUTO
                where  TRIBUTO = var_TRIBUTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CODICI_TRIBUTO"
               if :new.TRIBUTO is not null then
                  open  cpk_codici_tributo(:new.TRIBUTO);
                  fetch cpk_codici_tributo into dummy;
                  found := cpk_codici_tributo%FOUND;
                  close cpk_codici_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TRIBUTO||
                               '" gia'' presente in Codici Tributo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "CODICI_TRIBUTO" for all children in "OGGETTI_PRATICA"
         if (:OLD.TRIBUTO != :NEW.TRIBUTO) then
            update OGGETTI_PRATICA
             set   TRIBUTO = :NEW.TRIBUTO
            where  TRIBUTO = :OLD.TRIBUTO;
         end if;

         --  Modify parent code of "CODICI_TRIBUTO" for all children in "RUOLI_CONTRIBUENTE"
         if (:OLD.TRIBUTO != :NEW.TRIBUTO) then
            update RUOLI_CONTRIBUENTE
             set   TRIBUTO = :NEW.TRIBUTO
            where  TRIBUTO = :OLD.TRIBUTO;
         end if;

         --  Modify parent code of "CODICI_TRIBUTO" for all children in "SANZIONI"
         if (:OLD.TRIBUTO != :NEW.TRIBUTO) then
            update SANZIONI
             set   TRIBUTO = :NEW.TRIBUTO
            where  TRIBUTO = :OLD.TRIBUTO;
         end if;

         --  Modify parent code of "CODICI_TRIBUTO" for all children in "CATEGORIE"
         if (:OLD.TRIBUTO != :NEW.TRIBUTO) then
            update CATEGORIE
             set   TRIBUTO = :NEW.TRIBUTO
            where  TRIBUTO = :OLD.TRIBUTO;
         end if;

         --  Modify parent code of "CODICI_TRIBUTO" for all children in "ARROTONDAMENTI_TRIBUTO"
         if (:OLD.TRIBUTO != :NEW.TRIBUTO) then
            update ARROTONDAMENTI_TRIBUTO
             set   TRIBUTO = :NEW.TRIBUTO
            where  TRIBUTO = :OLD.TRIBUTO;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CODICI_TRIBUTO_TIU */
/

-- Procedure CODICI_TRIBUTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CODICI_TRIBUTO

create or replace procedure CODICI_TRIBUTO_PD
(old_tributo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_codici_tributo(var_tributo number) is
      select 1
      from   OGGETTI_PRATICA
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_CONTRIBUENTE"
   cursor cfk2_codici_tributo(var_tributo number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SANZIONI"
   cursor cfk3_codici_tributo(var_tributo number) is
      select 1
      from   SANZIONI
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "CATEGORIE"
   cursor cfk4_codici_tributo(var_tributo number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_CONTABILI"
   cursor cfk5_codici_tributo(var_tributo number) is
      select 1
      from   DATI_CONTABILI
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "ARROTONDAMENTI_TRIBUTO"
   cursor cfk6_codici_tributo(var_tributo number) is
      select 1
      from   ARROTONDAMENTI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "TARIFFE_CONVERSIONE"
   cursor cfk7_codici_tributo(var_tributo number) is
      select 1
      from   TARIFFE_CONVERSIONE
      where  CONVERTI_TRIBUTO = var_tributo
       and   var_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CODICI_TRIBUTO" if children still exist in "OGGETTI_PRATICA"
      open  cfk1_codici_tributo(OLD_TRIBUTO);
      fetch cfk1_codici_tributo into dummy;
      found := cfk1_codici_tributo%FOUND;
      close cfk1_codici_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Codici Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CODICI_TRIBUTO" if children still exist in "RUOLI_CONTRIBUENTE"
      open  cfk2_codici_tributo(OLD_TRIBUTO);
      fetch cfk2_codici_tributo into dummy;
      found := cfk2_codici_tributo%FOUND;
      close cfk2_codici_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Contribuente. La registrazione di Codici Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CODICI_TRIBUTO" if children still exist in "SANZIONI"
      open  cfk3_codici_tributo(OLD_TRIBUTO);
      fetch cfk3_codici_tributo into dummy;
      found := cfk3_codici_tributo%FOUND;
      close cfk3_codici_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sanzioni. La registrazione di Codici Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CODICI_TRIBUTO" if children still exist in "CATEGORIE"
      open  cfk4_codici_tributo(OLD_TRIBUTO);
      fetch cfk4_codici_tributo into dummy;
      found := cfk4_codici_tributo%FOUND;
      close cfk4_codici_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Categorie. La registrazione di Codici Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CODICI_TRIBUTO" if children still exist in "DATI_CONTABILI"
      open  cfk5_codici_tributo(OLD_TRIBUTO);
      fetch cfk5_codici_tributo into dummy;
      found := cfk5_codici_tributo%FOUND;
      close cfk5_codici_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dati Contabili. La registrazione di Codici Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CODICI_TRIBUTO" if children still exist in "ARROTONDAMENTI_TRIBUTO"
      open  cfk6_codici_tributo(OLD_TRIBUTO);
      fetch cfk6_codici_tributo into dummy;
      found := cfk6_codici_tributo%FOUND;
      close cfk6_codici_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ARROTONDAMENTI_TRIBUTO. La registrazione di Codici Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CODICI_TRIBUTO" if children still exist in "TARIFFE_CONVERSIONE"
      open  cfk7_codici_tributo(OLD_TRIBUTO);
      fetch cfk7_codici_tributo into dummy;
      found := cfk7_codici_tributo%FOUND;
      close cfk7_codici_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su TARIFFE_CONVERSIONE. La registrazione di Codici Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CODICI_TRIBUTO_PD */
/

-- Tigger CODICI_TRIBUTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CODICI_TRIBUTO

create or replace trigger CODICI_TRIBUTO_TD
before DELETE
on CODICI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI_PRATICA

      -- Child Restrict Table: RUOLI_CONTRIBUENTE

      -- Child Restrict Table: SANZIONI

      -- Child Restrict Table: CATEGORIE

      -- Child Restrict Table: DATI_CONTABILI

      -- Child Restrict Table: ARROTONDAMENTI_TRIBUTO

      -- Child Restrict Table: TARIFFE_CONVERSIONE

      CODICI_TRIBUTO_PD(:OLD.TRIBUTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CODICI_TRIBUTO_TD */
/

-- Procedure COEFFICIENTI_DOMESTICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table COEFFICIENTI_DOMESTICI

create or replace procedure COEFFICIENTI_DOMESTICI_PU
(old_anno IN number,
 old_numero_familiari IN number,
 new_anno IN number,
 new_numero_familiari IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COEFFICIENTI_DOMESTICI_PU */
/

-- Trigger COEFFICIENTI_DOMESTICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table COEFFICIENTI_DOMESTICI

create or replace trigger COEFFICIENTI_DOMESTICI_TIU
before INSERT
    or UPDATE
on COEFFICIENTI_DOMESTICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         COEFFICIENTI_DOMESTICI_PU(:OLD.ANNO,
                                   :OLD.NUMERO_FAMILIARI,
                         :NEW.ANNO,
                         :NEW.NUMERO_FAMILIARI);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "COEFFICIENTI_DOMESTICI"
            cursor cpk_coefficienti_domestici(var_ANNO number,
                                              var_NUMERO_FAMILIARI number) is
               select 1
                 from   COEFFICIENTI_DOMESTICI
                where  ANNO = var_ANNO and
                       NUMERO_FAMILIARI = var_NUMERO_FAMILIARI;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "COEFFICIENTI_DOMESTICI"
               if :new.ANNO is not null and
                  :new.NUMERO_FAMILIARI is not null then
                  open  cpk_coefficienti_domestici(:new.ANNO,
                                                   :new.NUMERO_FAMILIARI);
                  fetch cpk_coefficienti_domestici into dummy;
                  found := cpk_coefficienti_domestici%FOUND;
                  close cpk_coefficienti_domestici;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANNO||' '||
                               :new.NUMERO_FAMILIARI||
                               '" gia'' presente in Coefficienti Domestici. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COEFFICIENTI_DOMESTICI_TIU */
/

-- Procedure COEFFICIENTI_NON_DOMESTICI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table COEFFICIENTI_NON_DOMESTICI

create or replace procedure COEFFICIENTI_NON_DOMESTICI_PI
(new_tributo IN number,
 new_categoria IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE"
   cursor cpk1_coefficienti_non_domestic(var_tributo number,
                                         var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CATEGORIE" deve esistere quando si inserisce su "COEFFICIENTI_NON_DOMESTICI"
         if NEW_TRIBUTO is not null and
            NEW_CATEGORIA is not null then
            open  cpk1_coefficienti_non_domestic(NEW_TRIBUTO,
                                                 NEW_CATEGORIA);
            fetch cpk1_coefficienti_non_domestic into dummy;
            found := cpk1_coefficienti_non_domestic%FOUND;
            close cpk1_coefficienti_non_domestic;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Coefficienti Non Domestici non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COEFFICIENTI_NON_DOMESTICI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table COEFFICIENTI_NON_DOMESTICI
/* End Trigger: COEFFICIENTI_NON_DOMESTICI_TC */

-- Procedure COEFFICIENTI_NON_DOMESTICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table COEFFICIENTI_NON_DOMESTICI

create or replace procedure COEFFICIENTI_NON_DOMESTICI_PU
(old_tributo IN number,
 old_categoria IN number,
 old_anno IN number,
 new_tributo IN number,
 new_categoria IN number,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE"
   cursor cpk1_coefficienti_non_domestic(var_tributo number,
                                         var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CATEGORIE" deve esistere quando si modifica "COEFFICIENTI_NON_DOMESTICI"
         if  NEW_TRIBUTO is not null and
             NEW_CATEGORIA is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null)
              or (NEW_CATEGORIA != OLD_CATEGORIA or OLD_CATEGORIA is null) ) then
            open  cpk1_coefficienti_non_domestic(NEW_TRIBUTO,
                                                 NEW_CATEGORIA);
            fetch cpk1_coefficienti_non_domestic into dummy;
            found := cpk1_coefficienti_non_domestic%FOUND;
            close cpk1_coefficienti_non_domestic;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Coefficienti Non Domestici non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COEFFICIENTI_NON_DOMESTICI_PU */
/

-- Trigger COEFFICIENTI_NON_DOMESTICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table COEFFICIENTI_NON_DOMESTICI

create or replace trigger COEFFICIENTI_NON_DOMESTICI_TIU
before INSERT
    or UPDATE
on COEFFICIENTI_NON_DOMESTICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         COEFFICIENTI_NON_DOMESTICI_PU(:OLD.TRIBUTO,
                                       :OLD.CATEGORIA,
                                       :OLD.ANNO,
                         :NEW.TRIBUTO,
                         :NEW.CATEGORIA,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         COEFFICIENTI_NON_DOMESTICI_PI(:NEW.TRIBUTO,
                                       :NEW.CATEGORIA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "COEFFICIENTI_NON_DOMESTICI"
            cursor cpk_coefficienti_non_domestic(var_TRIBUTO number,
                                                 var_CATEGORIA number,
                                                 var_ANNO number) is
               select 1
                 from   COEFFICIENTI_NON_DOMESTICI
                where  TRIBUTO = var_TRIBUTO and
                       CATEGORIA = var_CATEGORIA and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "COEFFICIENTI_NON_DOMESTICI"
               if :new.TRIBUTO is not null and
                  :new.CATEGORIA is not null and
                  :new.ANNO is not null then
                  open  cpk_coefficienti_non_domestic(:new.TRIBUTO,
                                                      :new.CATEGORIA,
                                                      :new.ANNO);
                  fetch cpk_coefficienti_non_domestic into dummy;
                  found := cpk_coefficienti_non_domestic%FOUND;
                  close cpk_coefficienti_non_domestic;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TRIBUTO||' '||
                               :new.CATEGORIA||' '||
                               :new.ANNO||
                               '" gia'' presente in Coefficienti Non Domestici. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COEFFICIENTI_NON_DOMESTICI_TIU */
/

-- Procedure COMPENSAZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table COMPENSAZIONI

create or replace procedure COMPENSAZIONI_PI
(new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_motivo_compensazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_compensazioni(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MOTIVI_COMPENSAZIONE"
   cursor cpk2_compensazioni(var_motivo_compensazione number) is
      select 1
      from   MOTIVI_COMPENSAZIONE
      where  MOTIVO_COMPENSAZIONE = var_motivo_compensazione
       and   var_motivo_compensazione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk3_compensazioni(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "COMPENSAZIONI"
         if NEW_COD_FISCALE is not null then
            open  cpk1_compensazioni(NEW_COD_FISCALE);
            fetch cpk1_compensazioni into dummy;
            found := cpk1_compensazioni%FOUND;
            close cpk1_compensazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Compensazioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_COMPENSAZIONE" deve esistere quando si inserisce su "COMPENSAZIONI"
         if NEW_MOTIVO_COMPENSAZIONE is not null then
            open  cpk2_compensazioni(NEW_MOTIVO_COMPENSAZIONE);
            fetch cpk2_compensazioni into dummy;
            found := cpk2_compensazioni%FOUND;
            close cpk2_compensazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Motivi Compensazione. La registrazione Compensazioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "COMPENSAZIONI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk3_compensazioni(NEW_TIPO_TRIBUTO);
            fetch cpk3_compensazioni into dummy;
            found := cpk3_compensazioni%FOUND;
            close cpk3_compensazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Compensazioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMPENSAZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table COMPENSAZIONI
/* End Trigger: COMPENSAZIONI_TC */

-- Procedure COMPENSAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table COMPENSAZIONI

create or replace procedure COMPENSAZIONI_PU
(old_id_compensazione IN number,
 old_cod_fiscale IN varchar,
 old_tipo_tributo IN varchar,
 old_motivo_compensazione IN number,
 new_id_compensazione IN number,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_motivo_compensazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_compensazioni(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MOTIVI_COMPENSAZIONE"
   cursor cpk2_compensazioni(var_motivo_compensazione number) is
      select 1
      from   MOTIVI_COMPENSAZIONE
      where  MOTIVO_COMPENSAZIONE = var_motivo_compensazione
       and   var_motivo_compensazione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk3_compensazioni(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "VERSAMENTI"
   cursor cfk1_compensazioni(var_id_compensazione number) is
      select 1
      from   VERSAMENTI
      where  ID_COMPENSAZIONE = var_id_compensazione
       and   var_id_compensazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "COMPENSAZIONI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_compensazioni(NEW_COD_FISCALE);
            fetch cpk1_compensazioni into dummy;
            found := cpk1_compensazioni%FOUND;
            close cpk1_compensazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Compensazioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_COMPENSAZIONE" deve esistere quando si modifica "COMPENSAZIONI"
         if  NEW_MOTIVO_COMPENSAZIONE is not null and ( seq = 0 )
         and (   (NEW_MOTIVO_COMPENSAZIONE != OLD_MOTIVO_COMPENSAZIONE or OLD_MOTIVO_COMPENSAZIONE is null) ) then
            open  cpk2_compensazioni(NEW_MOTIVO_COMPENSAZIONE);
            fetch cpk2_compensazioni into dummy;
            found := cpk2_compensazioni%FOUND;
            close cpk2_compensazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Motivi Compensazione. La registrazione Compensazioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "COMPENSAZIONI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk3_compensazioni(NEW_TIPO_TRIBUTO);
            fetch cpk3_compensazioni into dummy;
            found := cpk3_compensazioni%FOUND;
            close cpk3_compensazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Compensazioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "COMPENSAZIONI" non modificabile se esistono referenze su "VERSAMENTI"
      if (OLD_ID_COMPENSAZIONE != NEW_ID_COMPENSAZIONE) then
         open  cfk1_compensazioni(OLD_ID_COMPENSAZIONE);
         fetch cfk1_compensazioni into dummy;
         found := cfk1_compensazioni%FOUND;
         close cfk1_compensazioni;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Compensazioni non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMPENSAZIONI_PU */
/

-- Trigger COMPENSAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table COMPENSAZIONI

create or replace trigger COMPENSAZIONI_TIU
before INSERT
    or UPDATE
on COMPENSAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id_compensazione is null then
       COMPENSAZIONI_NR(:new.id_compensazione);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         COMPENSAZIONI_PU(:OLD.ID_COMPENSAZIONE,
                          :OLD.COD_FISCALE,
                          :OLD.TIPO_TRIBUTO,
                          :OLD.MOTIVO_COMPENSAZIONE,
                         :NEW.ID_COMPENSAZIONE,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.MOTIVO_COMPENSAZIONE);
         null;
      end if;
      if INSERTING then
         COMPENSAZIONI_PI(:NEW.COD_FISCALE,
                          :NEW.TIPO_TRIBUTO,
                          :NEW.MOTIVO_COMPENSAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "COMPENSAZIONI"
            cursor cpk_compensazioni(var_ID_COMPENSAZIONE number) is
               select 1
                 from   COMPENSAZIONI
                where  ID_COMPENSAZIONE = var_ID_COMPENSAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "COMPENSAZIONI"
               if :new.ID_COMPENSAZIONE is not null then
                  open  cpk_compensazioni(:new.ID_COMPENSAZIONE);
                  fetch cpk_compensazioni into dummy;
                  found := cpk_compensazioni%FOUND;
                  close cpk_compensazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_COMPENSAZIONE||
                               '" gia'' presente in Compensazioni. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COMPENSAZIONI_TIU */
/

-- Procedure COMPENSAZIONI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table COMPENSAZIONI

create or replace procedure COMPENSAZIONI_PD
(old_id_compensazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk1_compensazioni(var_id_compensazione number) is
      select 1
      from   VERSAMENTI
      where  ID_COMPENSAZIONE = var_id_compensazione
       and   var_id_compensazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "COMPENSAZIONI" if children still exist in "VERSAMENTI"
      open  cfk1_compensazioni(OLD_ID_COMPENSAZIONE);
      fetch cfk1_compensazioni into dummy;
      found := cfk1_compensazioni%FOUND;
      close cfk1_compensazioni;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Compensazioni non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMPENSAZIONI_PD */
/

-- Tigger COMPENSAZIONI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table COMPENSAZIONI

create or replace trigger COMPENSAZIONI_TD
before DELETE
on COMPENSAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: VERSAMENTI

      COMPENSAZIONI_PD(:OLD.ID_COMPENSAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COMPENSAZIONI_TD */
/

-- Procedure COMPENSAZIONI_RUOLO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table COMPENSAZIONI_RUOLO

create or replace procedure COMPENSAZIONI_RUOLO_PI
(new_cod_fiscale IN varchar,
 new_ruolo IN number,
 new_oggetto_pratica IN number,
 new_motivo_compensazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk1_compensazioni_ruolo(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk2_compensazioni_ruolo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk3_compensazioni_ruolo(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MOTIVI_COMPENSAZIONE"
   cursor cpk4_compensazioni_ruolo(var_motivo_compensazione number) is
      select 1
      from   MOTIVI_COMPENSAZIONE
      where  MOTIVO_COMPENSAZIONE = var_motivo_compensazione
       and   var_motivo_compensazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "COMPENSAZIONI_RUOLO"
         if NEW_RUOLO is not null then
            open  cpk1_compensazioni_ruolo(NEW_RUOLO);
            fetch cpk1_compensazioni_ruolo into dummy;
            found := cpk1_compensazioni_ruolo%FOUND;
            close cpk1_compensazioni_ruolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Compensazioni Ruolo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "COMPENSAZIONI_RUOLO"
         if NEW_COD_FISCALE is not null then
            open  cpk2_compensazioni_ruolo(NEW_COD_FISCALE);
            fetch cpk2_compensazioni_ruolo into dummy;
            found := cpk2_compensazioni_ruolo%FOUND;
            close cpk2_compensazioni_ruolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Compensazioni Ruolo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "COMPENSAZIONI_RUOLO"
         if NEW_OGGETTO_PRATICA is not null then
            open  cpk3_compensazioni_ruolo(NEW_OGGETTO_PRATICA);
            fetch cpk3_compensazioni_ruolo into dummy;
            found := cpk3_compensazioni_ruolo%FOUND;
            close cpk3_compensazioni_ruolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Compensazioni Ruolo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_COMPENSAZIONE" deve esistere quando si inserisce su "COMPENSAZIONI_RUOLO"
         if NEW_MOTIVO_COMPENSAZIONE is not null then
            open  cpk4_compensazioni_ruolo(NEW_MOTIVO_COMPENSAZIONE);
            fetch cpk4_compensazioni_ruolo into dummy;
            found := cpk4_compensazioni_ruolo%FOUND;
            close cpk4_compensazioni_ruolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Motivi Compensazione. La registrazione Compensazioni Ruolo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMPENSAZIONI_RUOLO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table COMPENSAZIONI_RUOLO
/* End Trigger: COMPENSAZIONI_RUOLO_TC */

-- Procedure COMPENSAZIONI_RUOLO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table COMPENSAZIONI_RUOLO

create or replace procedure COMPENSAZIONI_RUOLO_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_ruolo IN number,
 old_oggetto_pratica IN number,
 old_motivo_compensazione IN number,
 new_cod_fiscale IN varchar,
 new_anno IN number,
 new_ruolo IN number,
 new_oggetto_pratica IN number,
 new_motivo_compensazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk1_compensazioni_ruolo(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk2_compensazioni_ruolo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk3_compensazioni_ruolo(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MOTIVI_COMPENSAZIONE"
   cursor cpk4_compensazioni_ruolo(var_motivo_compensazione number) is
      select 1
      from   MOTIVI_COMPENSAZIONE
      where  MOTIVO_COMPENSAZIONE = var_motivo_compensazione
       and   var_motivo_compensazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "COMPENSAZIONI_RUOLO"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk1_compensazioni_ruolo(NEW_RUOLO);
            fetch cpk1_compensazioni_ruolo into dummy;
            found := cpk1_compensazioni_ruolo%FOUND;
            close cpk1_compensazioni_ruolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Compensazioni Ruolo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "COMPENSAZIONI_RUOLO"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk2_compensazioni_ruolo(NEW_COD_FISCALE);
            fetch cpk2_compensazioni_ruolo into dummy;
            found := cpk2_compensazioni_ruolo%FOUND;
            close cpk2_compensazioni_ruolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Compensazioni Ruolo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "COMPENSAZIONI_RUOLO"
         if  NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk3_compensazioni_ruolo(NEW_OGGETTO_PRATICA);
            fetch cpk3_compensazioni_ruolo into dummy;
            found := cpk3_compensazioni_ruolo%FOUND;
            close cpk3_compensazioni_ruolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Compensazioni Ruolo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_COMPENSAZIONE" deve esistere quando si modifica "COMPENSAZIONI_RUOLO"
         if  NEW_MOTIVO_COMPENSAZIONE is not null and ( seq = 0 )
         and (   (NEW_MOTIVO_COMPENSAZIONE != OLD_MOTIVO_COMPENSAZIONE or OLD_MOTIVO_COMPENSAZIONE is null) ) then
            open  cpk4_compensazioni_ruolo(NEW_MOTIVO_COMPENSAZIONE);
            fetch cpk4_compensazioni_ruolo into dummy;
            found := cpk4_compensazioni_ruolo%FOUND;
            close cpk4_compensazioni_ruolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Motivi Compensazione. La registrazione Compensazioni Ruolo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMPENSAZIONI_RUOLO_PU */
/

-- Trigger COMPENSAZIONI_RUOLO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table COMPENSAZIONI_RUOLO

create or replace trigger COMPENSAZIONI_RUOLO_TIU
before INSERT
    or UPDATE
on COMPENSAZIONI_RUOLO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         COMPENSAZIONI_RUOLO_PU(:OLD.COD_FISCALE,
                                :OLD.ANNO,
                                :OLD.RUOLO,
                                :OLD.OGGETTO_PRATICA,
                                :OLD.MOTIVO_COMPENSAZIONE,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO,
                         :NEW.RUOLO,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.MOTIVO_COMPENSAZIONE);
         null;
      end if;
      if INSERTING then
         COMPENSAZIONI_RUOLO_PI(:NEW.COD_FISCALE,
                                :NEW.RUOLO,
                                :NEW.OGGETTO_PRATICA,
                                :NEW.MOTIVO_COMPENSAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "COMPENSAZIONI_RUOLO"
            cursor cpk_compensazioni_ruolo(var_COD_FISCALE varchar,
                                           var_ANNO number,
                                           var_RUOLO number,
                                           var_OGGETTO_PRATICA number) is
               select 1
                 from   COMPENSAZIONI_RUOLO
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO and
                       RUOLO = var_RUOLO and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "COMPENSAZIONI_RUOLO"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null and
                  :new.RUOLO is not null and
                  :new.OGGETTO_PRATICA is not null then
                  open  cpk_compensazioni_ruolo(:new.COD_FISCALE,
                                                :new.ANNO,
                                                :new.RUOLO,
                                                :new.OGGETTO_PRATICA);
                  fetch cpk_compensazioni_ruolo into dummy;
                  found := cpk_compensazioni_ruolo%FOUND;
                  close cpk_compensazioni_ruolo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||' '||
                               :new.RUOLO||' '||
                               :new.OGGETTO_PRATICA||
                               '" gia'' presente in Compensazioni Ruolo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COMPENSAZIONI_RUOLO_TIU */
/

-- Procedure COMUNICAZIONE_PARAMETRI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table COMUNICAZIONE_PARAMETRI

create or replace procedure COMUNICAZIONE_PARAMETRI_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_comunicazione_parametri(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "COMUNICAZIONE_PARAMETRI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_comunicazione_parametri(NEW_TIPO_TRIBUTO);
            fetch cpk1_comunicazione_parametri into dummy;
            found := cpk1_comunicazione_parametri%FOUND;
            close cpk1_comunicazione_parametri;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione COMUNICAZIONE_PARAMETRI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMUNICAZIONE_PARAMETRI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table COMUNICAZIONE_PARAMETRI
/* End Trigger: COMUNICAZIONE_PARAMETRI_TC */

-- Procedure COMUNICAZIONE_PARAMETRI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table COMUNICAZIONE_PARAMETRI

create or replace procedure COMUNICAZIONE_PARAMETRI_PU
(old_tipo_tributo IN varchar,
 old_tipo_comunicazione IN varchar,
 new_tipo_tributo IN varchar,
 new_tipo_comunicazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_comunicazione_parametri(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "COMUNICAZIONE_TESTI"
   cursor cfk1_comunicazione_parametri(var_tipo_tributo varchar,
                                       var_tipo_comunicazione varchar) is
      select 1
      from   COMUNICAZIONE_TESTI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "DETTAGLI_COMUNICAZIONE"
   cursor cfk2_comunicazione_parametri(var_tipo_tributo varchar,
                                       var_tipo_comunicazione varchar) is
      select 1
      from   DETTAGLI_COMUNICAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "COMUNICAZIONE_PARAMETRI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_comunicazione_parametri(NEW_TIPO_TRIBUTO);
            fetch cpk1_comunicazione_parametri into dummy;
            found := cpk1_comunicazione_parametri%FOUND;
            close cpk1_comunicazione_parametri;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione COMUNICAZIONE_PARAMETRI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "COMUNICAZIONE_PARAMETRI" non modificabile se esistono referenze su "COMUNICAZIONE_TESTI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_TIPO_COMUNICAZIONE != NEW_TIPO_COMUNICAZIONE) then
         open  cfk1_comunicazione_parametri(OLD_TIPO_TRIBUTO,
                                            OLD_TIPO_COMUNICAZIONE);
         fetch cfk1_comunicazione_parametri into dummy;
         found := cfk1_comunicazione_parametri%FOUND;
         close cfk1_comunicazione_parametri;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Comunicazione Testi. La registrazione di COMUNICAZIONE_PARAMETRI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "COMUNICAZIONE_PARAMETRI" non modificabile se esistono referenze su "DETTAGLI_COMUNICAZIONE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_TIPO_COMUNICAZIONE != NEW_TIPO_COMUNICAZIONE) then
         open  cfk2_comunicazione_parametri(OLD_TIPO_TRIBUTO,
                                            OLD_TIPO_COMUNICAZIONE);
         fetch cfk2_comunicazione_parametri into dummy;
         found := cfk2_comunicazione_parametri%FOUND;
         close cfk2_comunicazione_parametri;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DETTAGLI COMUNICAZIONE. La registrazione di COMUNICAZIONE_PARAMETRI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMUNICAZIONE_PARAMETRI_PU */
/

-- Trigger COMUNICAZIONE_PARAMETRI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table COMUNICAZIONE_PARAMETRI

create or replace trigger COMUNICAZIONE_PARAMETRI_TIU
before INSERT
    or UPDATE
on COMUNICAZIONE_PARAMETRI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         COMUNICAZIONE_PARAMETRI_PU(:OLD.TIPO_TRIBUTO,
                                    :OLD.TIPO_COMUNICAZIONE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_COMUNICAZIONE);
         null;
      end if;
      if INSERTING then
         COMUNICAZIONE_PARAMETRI_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "COMUNICAZIONE_PARAMETRI"
            cursor cpk_comunicazione_parametri(var_TIPO_TRIBUTO varchar,
                                               var_TIPO_COMUNICAZIONE varchar) is
               select 1
                 from   COMUNICAZIONE_PARAMETRI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       TIPO_COMUNICAZIONE = var_TIPO_COMUNICAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "COMUNICAZIONE_PARAMETRI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.TIPO_COMUNICAZIONE is not null then
                  open  cpk_comunicazione_parametri(:new.TIPO_TRIBUTO,
                                                    :new.TIPO_COMUNICAZIONE);
                  fetch cpk_comunicazione_parametri into dummy;
                  found := cpk_comunicazione_parametri%FOUND;
                  close cpk_comunicazione_parametri;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.TIPO_COMUNICAZIONE||
                               '" gia'' presente in COMUNICAZIONE_PARAMETRI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COMUNICAZIONE_PARAMETRI_TIU */
/

-- Procedure COMUNICAZIONE_PARAMETRI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table COMUNICAZIONE_PARAMETRI

create or replace procedure COMUNICAZIONE_PARAMETRI_PD
(old_tipo_tributo IN varchar,
 old_tipo_comunicazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "COMUNICAZIONE_TESTI"
   cursor cfk1_comunicazione_parametri(var_tipo_tributo varchar,
                                       var_tipo_comunicazione varchar) is
      select 1
      from   COMUNICAZIONE_TESTI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_COMUNICAZIONE"
   cursor cfk2_comunicazione_parametri(var_tipo_tributo varchar,
                                       var_tipo_comunicazione varchar) is
      select 1
      from   DETTAGLI_COMUNICAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "COMUNICAZIONE_PARAMETRI" if children still exist in "COMUNICAZIONE_TESTI"
      open  cfk1_comunicazione_parametri(OLD_TIPO_TRIBUTO,
                                         OLD_TIPO_COMUNICAZIONE);
      fetch cfk1_comunicazione_parametri into dummy;
      found := cfk1_comunicazione_parametri%FOUND;
      close cfk1_comunicazione_parametri;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Comunicazione Testi. La registrazione di COMUNICAZIONE_PARAMETRI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "COMUNICAZIONE_PARAMETRI" if children still exist in "DETTAGLI_COMUNICAZIONE"
      open  cfk2_comunicazione_parametri(OLD_TIPO_TRIBUTO,
                                         OLD_TIPO_COMUNICAZIONE);
      fetch cfk2_comunicazione_parametri into dummy;
      found := cfk2_comunicazione_parametri%FOUND;
      close cfk2_comunicazione_parametri;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DETTAGLI COMUNICAZIONE. La registrazione di COMUNICAZIONE_PARAMETRI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMUNICAZIONE_PARAMETRI_PD */
/

-- Tigger COMUNICAZIONE_PARAMETRI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table COMUNICAZIONE_PARAMETRI

create or replace trigger COMUNICAZIONE_PARAMETRI_TD
before DELETE
on COMUNICAZIONE_PARAMETRI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: COMUNICAZIONE_TESTI

      -- Child Restrict Table: DETTAGLI_COMUNICAZIONE

      COMUNICAZIONE_PARAMETRI_PD(:OLD.TIPO_TRIBUTO,
                                 :OLD.TIPO_COMUNICAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COMUNICAZIONE_PARAMETRI_TD */
/

-- Procedure COMUNICAZIONE_TESTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table COMUNICAZIONE_TESTI

create or replace procedure COMUNICAZIONE_TESTI_PI
(new_tipo_tributo IN varchar,
 new_tipo_comunicazione IN varchar,
 new_tipo_canale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "COMUNICAZIONE_PARAMETRI"
   cursor cpk1_comunicazione_testi(var_tipo_tributo varchar,
                                   var_tipo_comunicazione varchar) is
      select 1
      from   COMUNICAZIONE_PARAMETRI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_CANALE"
   cursor cpk2_comunicazione_testi(var_tipo_canale number) is
      select 1
      from   TIPI_CANALE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "COMUNICAZIONE_PARAMETRI" deve esistere quando si inserisce su "COMUNICAZIONE_TESTI"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_TIPO_COMUNICAZIONE is not null then
            open  cpk1_comunicazione_testi(NEW_TIPO_TRIBUTO,
                                           NEW_TIPO_COMUNICAZIONE);
            fetch cpk1_comunicazione_testi into dummy;
            found := cpk1_comunicazione_testi%FOUND;
            close cpk1_comunicazione_testi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su COMUNICAZIONE_PARAMETRI. La registrazione Comunicazione Testi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CANALE" deve esistere quando si inserisce su "COMUNICAZIONE_TESTI"
         if NEW_TIPO_CANALE is not null then
            open  cpk2_comunicazione_testi(NEW_TIPO_CANALE);
            fetch cpk2_comunicazione_testi into dummy;
            found := cpk2_comunicazione_testi%FOUND;
            close cpk2_comunicazione_testi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Canale. La registrazione Comunicazione Testi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMUNICAZIONE_TESTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table COMUNICAZIONE_TESTI
/* End Trigger: COMUNICAZIONE_TESTI_TC */

-- Procedure COMUNICAZIONE_TESTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table COMUNICAZIONE_TESTI

create or replace procedure COMUNICAZIONE_TESTI_PU
(old_comunicazione_testo IN number,
 old_tipo_tributo IN varchar,
 old_tipo_comunicazione IN varchar,
 old_tipo_canale IN number,
 new_comunicazione_testo IN number,
 new_tipo_tributo IN varchar,
 new_tipo_comunicazione IN varchar,
 new_tipo_canale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "COMUNICAZIONE_PARAMETRI"
   cursor cpk1_comunicazione_testi(var_tipo_tributo varchar,
                                   var_tipo_comunicazione varchar) is
      select 1
      from   COMUNICAZIONE_PARAMETRI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_CANALE"
   cursor cpk2_comunicazione_testi(var_tipo_canale number) is
      select 1
      from   TIPI_CANALE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;

   --  Declaration of UpdateParentRestrict constraint for "ALLEGATI_TESTO"
   cursor cfk1_comunicazione_testi(var_comunicazione_testo number) is
      select 1
      from   ALLEGATI_TESTO
      where  COMUNICAZIONE_TESTO = var_comunicazione_testo
       and   var_comunicazione_testo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "COMUNICAZIONE_PARAMETRI" deve esistere quando si modifica "COMUNICAZIONE_TESTI"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_TIPO_COMUNICAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_TIPO_COMUNICAZIONE != OLD_TIPO_COMUNICAZIONE or OLD_TIPO_COMUNICAZIONE is null) ) then
            open  cpk1_comunicazione_testi(NEW_TIPO_TRIBUTO,
                                           NEW_TIPO_COMUNICAZIONE);
            fetch cpk1_comunicazione_testi into dummy;
            found := cpk1_comunicazione_testi%FOUND;
            close cpk1_comunicazione_testi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su COMUNICAZIONE_PARAMETRI. La registrazione Comunicazione Testi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CANALE" deve esistere quando si modifica "COMUNICAZIONE_TESTI"
         if  NEW_TIPO_CANALE is not null and ( seq = 0 )
         and (   (NEW_TIPO_CANALE != OLD_TIPO_CANALE or OLD_TIPO_CANALE is null) ) then
            open  cpk2_comunicazione_testi(NEW_TIPO_CANALE);
            fetch cpk2_comunicazione_testi into dummy;
            found := cpk2_comunicazione_testi%FOUND;
            close cpk2_comunicazione_testi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Canale. La registrazione Comunicazione Testi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "COMUNICAZIONE_TESTI" non modificabile se esistono referenze su "ALLEGATI_TESTO"
      if (OLD_COMUNICAZIONE_TESTO != NEW_COMUNICAZIONE_TESTO) then
         open  cfk1_comunicazione_testi(OLD_COMUNICAZIONE_TESTO);
         fetch cfk1_comunicazione_testi into dummy;
         found := cfk1_comunicazione_testi%FOUND;
         close cfk1_comunicazione_testi;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ALLEGATI_TESTO. La registrazione di Comunicazione Testi non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMUNICAZIONE_TESTI_PU */
/

-- Trigger COMUNICAZIONE_TESTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table COMUNICAZIONE_TESTI

create or replace trigger COMUNICAZIONE_TESTI_TIU
before INSERT
    or UPDATE
on COMUNICAZIONE_TESTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.comunicazione_testo is null then
       COMUNICAZIONE_TESTI_NR (:new.comunicazione_testo);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         COMUNICAZIONE_TESTI_PU(:OLD.COMUNICAZIONE_TESTO,
                                :OLD.TIPO_TRIBUTO,
                                :OLD.TIPO_COMUNICAZIONE,
                                :OLD.TIPO_CANALE,
                         :NEW.COMUNICAZIONE_TESTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_COMUNICAZIONE,
                         :NEW.TIPO_CANALE);
         null;
      end if;
      if INSERTING then
         COMUNICAZIONE_TESTI_PI(:NEW.TIPO_TRIBUTO,
                                :NEW.TIPO_COMUNICAZIONE,
                                :NEW.TIPO_CANALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "COMUNICAZIONE_TESTI"
            cursor cpk_comunicazione_testi(var_COMUNICAZIONE_TESTO number) is
               select 1
                 from   COMUNICAZIONE_TESTI
                where  COMUNICAZIONE_TESTO = var_COMUNICAZIONE_TESTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "COMUNICAZIONE_TESTI"
               if :new.COMUNICAZIONE_TESTO is not null then
                  open  cpk_comunicazione_testi(:new.COMUNICAZIONE_TESTO);
                  fetch cpk_comunicazione_testi into dummy;
                  found := cpk_comunicazione_testi%FOUND;
                  close cpk_comunicazione_testi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COMUNICAZIONE_TESTO||
                               '" gia'' presente in Comunicazione Testi. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COMUNICAZIONE_TESTI_TIU */
/

-- Procedure COMUNICAZIONE_TESTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table COMUNICAZIONE_TESTI

create or replace procedure COMUNICAZIONE_TESTI_PD
(old_comunicazione_testo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ALLEGATI_TESTO"
   cursor cfk1_comunicazione_testi(var_comunicazione_testo number) is
      select 1
      from   ALLEGATI_TESTO
      where  COMUNICAZIONE_TESTO = var_comunicazione_testo
       and   var_comunicazione_testo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "COMUNICAZIONE_TESTI" if children still exist in "ALLEGATI_TESTO"
      open  cfk1_comunicazione_testi(OLD_COMUNICAZIONE_TESTO);
      fetch cfk1_comunicazione_testi into dummy;
      found := cfk1_comunicazione_testi%FOUND;
      close cfk1_comunicazione_testi;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ALLEGATI_TESTO. La registrazione di Comunicazione Testi non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COMUNICAZIONE_TESTI_PD */
/

-- Tigger COMUNICAZIONE_TESTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table COMUNICAZIONE_TESTI

create or replace trigger COMUNICAZIONE_TESTI_TD
before DELETE
on COMUNICAZIONE_TESTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ALLEGATI_TESTO

      COMUNICAZIONE_TESTI_PD(:OLD.COMUNICAZIONE_TESTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COMUNICAZIONE_TESTI_TD */
/

-- Procedure CONFERIMENTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CONFERIMENTI

create or replace procedure CONFERIMENTI_PI
(new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_conferimenti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "CONFERIMENTI"
         if NEW_COD_FISCALE is not null then
            open  cpk1_conferimenti(NEW_COD_FISCALE);
            fetch cpk1_conferimenti into dummy;
            found := cpk1_conferimenti%FOUND;
            close cpk1_conferimenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Conferimenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CONFERIMENTI
/* End Trigger: CONFERIMENTI_TC */

-- Procedure CONFERIMENTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CONFERIMENTI

create or replace procedure CONFERIMENTI_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 new_cod_fiscale IN varchar,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_conferimenti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "CONFERIMENTI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_conferimenti(NEW_COD_FISCALE);
            fetch cpk1_conferimenti into dummy;
            found := cpk1_conferimenti%FOUND;
            close cpk1_conferimenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Conferimenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_PU */
/

-- Trigger CONFERIMENTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CONFERIMENTI

create or replace trigger CONFERIMENTI_TIU
before INSERT
    or UPDATE
on CONFERIMENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CONFERIMENTI_PU(:OLD.COD_FISCALE,
                         :OLD.ANNO,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         CONFERIMENTI_PI(:NEW.COD_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CONFERIMENTI"
            cursor cpk_conferimenti(var_COD_FISCALE varchar,
                                    var_ANNO number) is
               select 1
                 from   CONFERIMENTI
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CONFERIMENTI"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null then
                  open  cpk_conferimenti(:new.COD_FISCALE,
                                         :new.ANNO);
                  fetch cpk_conferimenti into dummy;
                  found := cpk_conferimenti%FOUND;
                  close cpk_conferimenti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||
                               '" gia'' presente in Conferimenti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            CONFERIMENTI_FI(:new.ruolo, :new.importo_scalato);
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONFERIMENTI_TIU */
/

-- Procedure CONFERIMENTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CONFERIMENTI

create or replace procedure CONFERIMENTI_PD
(old_cod_fiscale IN varchar,
 old_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_PD */
/

-- Tigger CONFERIMENTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CONFERIMENTI

create or replace trigger CONFERIMENTI_TD
before DELETE
on CONFERIMENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            CONFERIMENTI_FI(:old.ruolo, :old.importo_scalato);
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      CONFERIMENTI_PD(:OLD.COD_FISCALE,
                      :OLD.ANNO);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONFERIMENTI_TD */
/

-- Procedure CONFERIMENTI_CER_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CONFERIMENTI_CER

create or replace procedure CONFERIMENTI_CER_PI
(new_cod_fiscale IN varchar,
 new_codice_cer IN varchar,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE_CER"
   cursor cpk1_conferimenti_cer(var_codice_cer varchar) is
      select 1
      from   CATEGORIE_CER
      where  CODICE_CER = var_codice_cer
       and   var_codice_cer is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk2_conferimenti_cer(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk3_conferimenti_cer(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CATEGORIE_CER" deve esistere quando si inserisce su "CONFERIMENTI_CER"
         if NEW_CODICE_CER is not null then
            open  cpk1_conferimenti_cer(NEW_CODICE_CER);
            fetch cpk1_conferimenti_cer into dummy;
            found := cpk1_conferimenti_cer%FOUND;
            close cpk1_conferimenti_cer;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie CER. La registrazione Conferimenti CER non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "CONFERIMENTI_CER"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk2_conferimenti_cer(NEW_DOCUMENTO_ID);
            fetch cpk2_conferimenti_cer into dummy;
            found := cpk2_conferimenti_cer%FOUND;
            close cpk2_conferimenti_cer;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione Conferimenti CER non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "CONFERIMENTI_CER"
         if NEW_COD_FISCALE is not null then
            open  cpk3_conferimenti_cer(NEW_COD_FISCALE);
            fetch cpk3_conferimenti_cer into dummy;
            found := cpk3_conferimenti_cer%FOUND;
            close cpk3_conferimenti_cer;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Conferimenti CER non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_CER_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CONFERIMENTI_CER
/* End Trigger: CONFERIMENTI_CER_TC */

-- Procedure CONFERIMENTI_CER_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CONFERIMENTI_CER

create or replace procedure CONFERIMENTI_CER_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_tipo_utenza IN varchar,
 old_data_conferimento IN date,
 old_codice_cer IN varchar,
 old_documento_id IN number,
 new_cod_fiscale IN varchar,
 new_anno IN number,
 new_tipo_utenza IN varchar,
 new_data_conferimento IN date,
 new_codice_cer IN varchar,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE_CER"
   cursor cpk1_conferimenti_cer(var_codice_cer varchar) is
      select 1
      from   CATEGORIE_CER
      where  CODICE_CER = var_codice_cer
       and   var_codice_cer is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk2_conferimenti_cer(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk3_conferimenti_cer(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CATEGORIE_CER" deve esistere quando si modifica "CONFERIMENTI_CER"
         if  NEW_CODICE_CER is not null and ( seq = 0 )
         and (   (NEW_CODICE_CER != OLD_CODICE_CER or OLD_CODICE_CER is null) ) then
            open  cpk1_conferimenti_cer(NEW_CODICE_CER);
            fetch cpk1_conferimenti_cer into dummy;
            found := cpk1_conferimenti_cer%FOUND;
            close cpk1_conferimenti_cer;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie CER. La registrazione Conferimenti CER non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "CONFERIMENTI_CER"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk2_conferimenti_cer(NEW_DOCUMENTO_ID);
            fetch cpk2_conferimenti_cer into dummy;
            found := cpk2_conferimenti_cer%FOUND;
            close cpk2_conferimenti_cer;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione Conferimenti CER non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "CONFERIMENTI_CER"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk3_conferimenti_cer(NEW_COD_FISCALE);
            fetch cpk3_conferimenti_cer into dummy;
            found := cpk3_conferimenti_cer%FOUND;
            close cpk3_conferimenti_cer;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Conferimenti CER non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_CER_PU */
/

-- Trigger CONFERIMENTI_CER_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CONFERIMENTI_CER

create or replace trigger CONFERIMENTI_CER_TIU
before INSERT
    or UPDATE
on CONFERIMENTI_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CONFERIMENTI_CER_PU(:OLD.COD_FISCALE,
                             :OLD.ANNO,
                             :OLD.TIPO_UTENZA,
                             :OLD.DATA_CONFERIMENTO,
                             :OLD.CODICE_CER,
                             :OLD.DOCUMENTO_ID,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO,
                         :NEW.TIPO_UTENZA,
                         :NEW.DATA_CONFERIMENTO,
                         :NEW.CODICE_CER,
                         :NEW.DOCUMENTO_ID);
         null;
      end if;
      if INSERTING then
         CONFERIMENTI_CER_PI(:NEW.COD_FISCALE,
                             :NEW.CODICE_CER,
                             :NEW.DOCUMENTO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CONFERIMENTI_CER"
            cursor cpk_conferimenti_cer(var_COD_FISCALE varchar,
                                        var_ANNO number,
                                        var_TIPO_UTENZA varchar,
                                        var_DATA_CONFERIMENTO date,
                                        var_CODICE_CER varchar) is
               select 1
                 from   CONFERIMENTI_CER
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO and
                       TIPO_UTENZA = var_TIPO_UTENZA and
                       DATA_CONFERIMENTO = var_DATA_CONFERIMENTO and
                       CODICE_CER = var_CODICE_CER;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CONFERIMENTI_CER"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null and
                  :new.TIPO_UTENZA is not null and
                  :new.DATA_CONFERIMENTO is not null and
                  :new.CODICE_CER is not null then
                  open  cpk_conferimenti_cer(:new.COD_FISCALE,
                                             :new.ANNO,
                                             :new.TIPO_UTENZA,
                                             :new.DATA_CONFERIMENTO,
                                             :new.CODICE_CER);
                  fetch cpk_conferimenti_cer into dummy;
                  found := cpk_conferimenti_cer%FOUND;
                  close cpk_conferimenti_cer;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||' '||
                               :new.TIPO_UTENZA||' '||
                               :new.DATA_CONFERIMENTO||' '||
                               :new.CODICE_CER||
                               '" gia'' presente in Conferimenti CER. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "CONFERIMENTI_CER" for all children in "CONFERIMENTI_CER_RUOLO"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.ANNO != :NEW.ANNO) or
            (:OLD.TIPO_UTENZA != :NEW.TIPO_UTENZA) or
            (:OLD.DATA_CONFERIMENTO != :NEW.DATA_CONFERIMENTO) or
            (:OLD.CODICE_CER != :NEW.CODICE_CER) then
            update CONFERIMENTI_CER_RUOLO
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   ANNO = :NEW.ANNO,
                   TIPO_UTENZA = :NEW.TIPO_UTENZA,
                   DATA_CONFERIMENTO = :NEW.DATA_CONFERIMENTO,
                   CODICE_CER = :NEW.CODICE_CER
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   ANNO = :OLD.ANNO
             and   TIPO_UTENZA = :OLD.TIPO_UTENZA
             and   DATA_CONFERIMENTO = :OLD.DATA_CONFERIMENTO
             and   CODICE_CER = :OLD.CODICE_CER;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONFERIMENTI_CER_TIU */
/

-- Procedure CONFERIMENTI_CER_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CONFERIMENTI_CER

create or replace procedure CONFERIMENTI_CER_PD
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_tipo_utenza IN varchar,
 old_data_conferimento IN date,
 old_codice_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CONFERIMENTI_CER_RUOLO"
   cursor cfk1_conferimenti_cer(var_cod_fiscale varchar,
                                var_anno number,
                                var_tipo_utenza varchar,
                                var_data_conferimento date,
                                var_codice_cer varchar) is
      select 1
      from   CONFERIMENTI_CER_RUOLO
      where  COD_FISCALE = var_cod_fiscale
       and   ANNO = var_anno
       and   TIPO_UTENZA = var_tipo_utenza
       and   DATA_CONFERIMENTO = var_data_conferimento
       and   CODICE_CER = var_codice_cer
       and   var_cod_fiscale is not null
       and   var_anno is not null
       and   var_tipo_utenza is not null
       and   var_data_conferimento is not null
       and   var_codice_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CONFERIMENTI_CER" if children still exist in "CONFERIMENTI_CER_RUOLO"
      open  cfk1_conferimenti_cer(OLD_COD_FISCALE,
                                  OLD_ANNO,
                                  OLD_TIPO_UTENZA,
                                  OLD_DATA_CONFERIMENTO,
                                  OLD_CODICE_CER);
      fetch cfk1_conferimenti_cer into dummy;
      found := cfk1_conferimenti_cer%FOUND;
      close cfk1_conferimenti_cer;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su CONFERIMENTI_CER_RUOLO. La registrazione di Conferimenti CER non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_CER_PD */
/

-- Tigger CONFERIMENTI_CER_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CONFERIMENTI_CER

create or replace trigger CONFERIMENTI_CER_TD
before DELETE
on CONFERIMENTI_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CONFERIMENTI_CER_RUOLO

      CONFERIMENTI_CER_PD(:OLD.COD_FISCALE,
                          :OLD.ANNO,
                          :OLD.TIPO_UTENZA,
                          :OLD.DATA_CONFERIMENTO,
                          :OLD.CODICE_CER);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONFERIMENTI_CER_TD */
/

-- Procedure CONFERIMENTI_CER_RUOLO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CONFERIMENTI_CER_RUOLO

create or replace procedure CONFERIMENTI_CER_RUOLO_PI
(new_cod_fiscale IN varchar,
 new_anno IN number,
 new_tipo_utenza IN varchar,
 new_data_conferimento IN date,
 new_codice_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONFERIMENTI_CER"
   cursor cpk1_conferimenti_cer_ruolo(var_cod_fiscale varchar,
                                      var_anno number,
                                      var_tipo_utenza varchar,
                                      var_data_conferimento date,
                                      var_codice_cer varchar) is
      select 1
      from   CONFERIMENTI_CER
      where  COD_FISCALE = var_cod_fiscale
       and   ANNO = var_anno
       and   TIPO_UTENZA = var_tipo_utenza
       and   DATA_CONFERIMENTO = var_data_conferimento
       and   CODICE_CER = var_codice_cer
       and   var_cod_fiscale is not null
       and   var_anno is not null
       and   var_tipo_utenza is not null
       and   var_data_conferimento is not null
       and   var_codice_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONFERIMENTI_CER" deve esistere quando si inserisce su "CONFERIMENTI_CER_RUOLO"
         if NEW_COD_FISCALE is not null and
            NEW_ANNO is not null and
            NEW_TIPO_UTENZA is not null and
            NEW_DATA_CONFERIMENTO is not null and
            NEW_CODICE_CER is not null then
            open  cpk1_conferimenti_cer_ruolo(NEW_COD_FISCALE,
                                              NEW_ANNO,
                                              NEW_TIPO_UTENZA,
                                              NEW_DATA_CONFERIMENTO,
                                              NEW_CODICE_CER);
            fetch cpk1_conferimenti_cer_ruolo into dummy;
            found := cpk1_conferimenti_cer_ruolo%FOUND;
            close cpk1_conferimenti_cer_ruolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Conferimenti CER. La registrazione CONFERIMENTI_CER_RUOLO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_CER_RUOLO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CONFERIMENTI_CER_RUOLO
/* End Trigger: CONFERIMENTI_CER_RUOLO_TC */

-- Procedure CONFERIMENTI_CER_RUOLO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CONFERIMENTI_CER_RUOLO

create or replace procedure CONFERIMENTI_CER_RUOLO_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_tipo_utenza IN varchar,
 old_data_conferimento IN date,
 old_codice_cer IN varchar,
 old_sequenza IN number,
 new_cod_fiscale IN varchar,
 new_anno IN number,
 new_tipo_utenza IN varchar,
 new_data_conferimento IN date,
 new_codice_cer IN varchar,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONFERIMENTI_CER"
   cursor cpk1_conferimenti_cer_ruolo(var_cod_fiscale varchar,
                                      var_anno number,
                                      var_tipo_utenza varchar,
                                      var_data_conferimento date,
                                      var_codice_cer varchar) is
      select 1
      from   CONFERIMENTI_CER
      where  COD_FISCALE = var_cod_fiscale
       and   ANNO = var_anno
       and   TIPO_UTENZA = var_tipo_utenza
       and   DATA_CONFERIMENTO = var_data_conferimento
       and   CODICE_CER = var_codice_cer
       and   var_cod_fiscale is not null
       and   var_anno is not null
       and   var_tipo_utenza is not null
       and   var_data_conferimento is not null
       and   var_codice_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONFERIMENTI_CER" deve esistere quando si modifica "CONFERIMENTI_CER_RUOLO"
         if  NEW_COD_FISCALE is not null and
             NEW_ANNO is not null and
             NEW_TIPO_UTENZA is not null and
             NEW_DATA_CONFERIMENTO is not null and
             NEW_CODICE_CER is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_ANNO != OLD_ANNO or OLD_ANNO is null)
              or (NEW_TIPO_UTENZA != OLD_TIPO_UTENZA or OLD_TIPO_UTENZA is null)
              or (NEW_DATA_CONFERIMENTO != OLD_DATA_CONFERIMENTO or OLD_DATA_CONFERIMENTO is null)
              or (NEW_CODICE_CER != OLD_CODICE_CER or OLD_CODICE_CER is null) ) then
            open  cpk1_conferimenti_cer_ruolo(NEW_COD_FISCALE,
                                              NEW_ANNO,
                                              NEW_TIPO_UTENZA,
                                              NEW_DATA_CONFERIMENTO,
                                              NEW_CODICE_CER);
            fetch cpk1_conferimenti_cer_ruolo into dummy;
            found := cpk1_conferimenti_cer_ruolo%FOUND;
            close cpk1_conferimenti_cer_ruolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Conferimenti CER. La registrazione CONFERIMENTI_CER_RUOLO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_CER_RUOLO_PU */
/

-- Trigger CONFERIMENTI_CER_RUOLO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CONFERIMENTI_CER_RUOLO

create or replace trigger CONFERIMENTI_CER_RUOLO_TIU
before INSERT
    or UPDATE
on CONFERIMENTI_CER_RUOLO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
      CONFERIMENTI_CER_RUOLO_NR(:new.cod_fiscale,:new.anno,:new.tipo_utenza,:new.data_conferimento,:new.codice_cer,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CONFERIMENTI_CER_RUOLO_PU(:OLD.COD_FISCALE,
                                   :OLD.ANNO,
                                   :OLD.TIPO_UTENZA,
                                   :OLD.DATA_CONFERIMENTO,
                                   :OLD.CODICE_CER,
                                   :OLD.SEQUENZA,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO,
                         :NEW.TIPO_UTENZA,
                         :NEW.DATA_CONFERIMENTO,
                         :NEW.CODICE_CER,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         CONFERIMENTI_CER_RUOLO_PI(:NEW.COD_FISCALE,
                                   :NEW.ANNO,
                                   :NEW.TIPO_UTENZA,
                                   :NEW.DATA_CONFERIMENTO,
                                   :NEW.CODICE_CER);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CONFERIMENTI_CER_RUOLO"
            cursor cpk_conferimenti_cer_ruolo(var_COD_FISCALE varchar,
                                              var_ANNO number,
                                              var_TIPO_UTENZA varchar,
                                              var_DATA_CONFERIMENTO date,
                                              var_CODICE_CER varchar,
                                              var_SEQUENZA number) is
               select 1
                 from   CONFERIMENTI_CER_RUOLO
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO and
                       TIPO_UTENZA = var_TIPO_UTENZA and
                       DATA_CONFERIMENTO = var_DATA_CONFERIMENTO and
                       CODICE_CER = var_CODICE_CER and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CONFERIMENTI_CER_RUOLO"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null and
                  :new.TIPO_UTENZA is not null and
                  :new.DATA_CONFERIMENTO is not null and
                  :new.CODICE_CER is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_conferimenti_cer_ruolo(:new.COD_FISCALE,
                                                   :new.ANNO,
                                                   :new.TIPO_UTENZA,
                                                   :new.DATA_CONFERIMENTO,
                                                   :new.CODICE_CER,
                                                   :new.SEQUENZA);
                  fetch cpk_conferimenti_cer_ruolo into dummy;
                  found := cpk_conferimenti_cer_ruolo%FOUND;
                  close cpk_conferimenti_cer_ruolo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||' '||
                               :new.TIPO_UTENZA||' '||
                               :new.DATA_CONFERIMENTO||' '||
                               :new.CODICE_CER||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in CONFERIMENTI_CER_RUOLO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            CONFERIMENTI_CER_RUOLO_FI(:new.ruolo, :new.importo_scalato);
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONFERIMENTI_CER_RUOLO_TIU */
/

-- Procedure CONFERIMENTI_CER_RUOLO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CONFERIMENTI_CER_RUOLO

create or replace procedure CONFERIMENTI_CER_RUOLO_PD
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_tipo_utenza IN varchar,
 old_data_conferimento IN date,
 old_codice_cer IN varchar,
 old_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONFERIMENTI_CER_RUOLO_PD */
/

-- Tigger CONFERIMENTI_CER_RUOLO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CONFERIMENTI_CER_RUOLO

create or replace trigger CONFERIMENTI_CER_RUOLO_TD
before DELETE
on CONFERIMENTI_CER_RUOLO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            CONFERIMENTI_CER_RUOLO_FI(:old.ruolo, :old.importo_scalato);
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      CONFERIMENTI_CER_RUOLO_PD(:OLD.COD_FISCALE,
                                :OLD.ANNO,
                                :OLD.TIPO_UTENZA,
                                :OLD.DATA_CONFERIMENTO,
                                :OLD.CODICE_CER,
                                :OLD.SEQUENZA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONFERIMENTI_CER_RUOLO_TD */
/

-- Procedure CONSISTENZE_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CONSISTENZE_TRIBUTO

create or replace procedure CONSISTENZE_TRIBUTO_PI
(new_tipo_tributo IN varchar,
 new_oggetto IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PARTIZIONI_OGGETTO"
   cursor cpk1_consistenze_tributo(var_oggetto number,
                                   var_sequenza number) is
      select 1
      from   PARTIZIONI_OGGETTO
      where  OGGETTO = var_oggetto
       and   SEQUENZA = var_sequenza
       and   var_oggetto is not null
       and   var_sequenza is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_consistenze_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PARTIZIONI_OGGETTO" deve esistere quando si inserisce su "CONSISTENZE_TRIBUTO"
         if NEW_OGGETTO is not null and
            NEW_SEQUENZA is not null then
            open  cpk1_consistenze_tributo(NEW_OGGETTO,
                                           NEW_SEQUENZA);
            fetch cpk1_consistenze_tributo into dummy;
            found := cpk1_consistenze_tributo%FOUND;
            close cpk1_consistenze_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Partizioni Oggetto. La registrazione Consistenze Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "CONSISTENZE_TRIBUTO"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_consistenze_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk2_consistenze_tributo into dummy;
            found := cpk2_consistenze_tributo%FOUND;
            close cpk2_consistenze_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Consistenze Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONSISTENZE_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CONSISTENZE_TRIBUTO
/* End Trigger: CONSISTENZE_TRIBUTO_TC */

-- Procedure CONSISTENZE_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CONSISTENZE_TRIBUTO

create or replace procedure CONSISTENZE_TRIBUTO_PU
(old_tipo_tributo IN varchar,
 old_oggetto IN number,
 old_sequenza IN number,
 new_tipo_tributo IN varchar,
 new_oggetto IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PARTIZIONI_OGGETTO"
   cursor cpk1_consistenze_tributo(var_oggetto number,
                                   var_sequenza number) is
      select 1
      from   PARTIZIONI_OGGETTO
      where  OGGETTO = var_oggetto
       and   SEQUENZA = var_sequenza
       and   var_oggetto is not null
       and   var_sequenza is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_consistenze_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PARTIZIONI_OGGETTO" deve esistere quando si modifica "CONSISTENZE_TRIBUTO"
         if  NEW_OGGETTO is not null and
             NEW_SEQUENZA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null)
              or (NEW_SEQUENZA != OLD_SEQUENZA or OLD_SEQUENZA is null) ) then
            open  cpk1_consistenze_tributo(NEW_OGGETTO,
                                           NEW_SEQUENZA);
            fetch cpk1_consistenze_tributo into dummy;
            found := cpk1_consistenze_tributo%FOUND;
            close cpk1_consistenze_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Partizioni Oggetto. La registrazione Consistenze Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "CONSISTENZE_TRIBUTO"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_consistenze_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk2_consistenze_tributo into dummy;
            found := cpk2_consistenze_tributo%FOUND;
            close cpk2_consistenze_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Consistenze Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONSISTENZE_TRIBUTO_PU */
/

-- Trigger CONSISTENZE_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CONSISTENZE_TRIBUTO

create or replace trigger CONSISTENZE_TRIBUTO_TIU
before INSERT
    or UPDATE
on CONSISTENZE_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CONSISTENZE_TRIBUTO_PU(:OLD.TIPO_TRIBUTO,
                                :OLD.OGGETTO,
                                :OLD.SEQUENZA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.OGGETTO,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         CONSISTENZE_TRIBUTO_PI(:NEW.TIPO_TRIBUTO,
                                :NEW.OGGETTO,
                                :NEW.SEQUENZA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CONSISTENZE_TRIBUTO"
            cursor cpk_consistenze_tributo(var_TIPO_TRIBUTO varchar,
                                           var_OGGETTO number,
                                           var_SEQUENZA number) is
               select 1
                 from   CONSISTENZE_TRIBUTO
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       OGGETTO = var_OGGETTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CONSISTENZE_TRIBUTO"
               if :new.TIPO_TRIBUTO is not null and
                  :new.OGGETTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_consistenze_tributo(:new.TIPO_TRIBUTO,
                                                :new.OGGETTO,
                                                :new.SEQUENZA);
                  fetch cpk_consistenze_tributo into dummy;
                  found := cpk_consistenze_tributo%FOUND;
                  close cpk_consistenze_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.OGGETTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Consistenze Tributo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONSISTENZE_TRIBUTO_TIU */
/

-- Procedure CONTATTI_CONTRIBUENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CONTATTI_CONTRIBUENTE

create or replace procedure CONTATTI_CONTRIBUENTE_PI
(new_cod_fiscale IN varchar,
 new_tipo_contatto IN number,
 new_tipo_richiedente IN number,
 new_tipo_tributo IN varchar,
 new_pratica_k IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_contatti_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_CONTATTO"
   cursor cpk2_contatti_contribuente(var_tipo_contatto number) is
      select 1
      from   TIPI_CONTATTO
      where  TIPO_CONTATTO = var_tipo_contatto
       and   var_tipo_contatto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_RICHIEDENTE"
   cursor cpk3_contatti_contribuente(var_tipo_richiedente number) is
      select 1
      from   TIPI_RICHIEDENTE
      where  TIPO_RICHIEDENTE = var_tipo_richiedente
       and   var_tipo_richiedente is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk4_contatti_contribuente(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk5_contatti_contribuente(var_pratica_k number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica_k
       and   var_pratica_k is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "CONTATTI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null then
            open  cpk1_contatti_contribuente(NEW_COD_FISCALE);
            fetch cpk1_contatti_contribuente into dummy;
            found := cpk1_contatti_contribuente%FOUND;
            close cpk1_contatti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Contatti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CONTATTO" deve esistere quando si inserisce su "CONTATTI_CONTRIBUENTE"
         if NEW_TIPO_CONTATTO is not null then
            open  cpk2_contatti_contribuente(NEW_TIPO_CONTATTO);
            fetch cpk2_contatti_contribuente into dummy;
            found := cpk2_contatti_contribuente%FOUND;
            close cpk2_contatti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Contatto. La registrazione Contatti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_RICHIEDENTE" deve esistere quando si inserisce su "CONTATTI_CONTRIBUENTE"
         if NEW_TIPO_RICHIEDENTE is not null then
            open  cpk3_contatti_contribuente(NEW_TIPO_RICHIEDENTE);
            fetch cpk3_contatti_contribuente into dummy;
            found := cpk3_contatti_contribuente%FOUND;
            close cpk3_contatti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Richiedente. La registrazione Contatti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "CONTATTI_CONTRIBUENTE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk4_contatti_contribuente(NEW_TIPO_TRIBUTO);
            fetch cpk4_contatti_contribuente into dummy;
            found := cpk4_contatti_contribuente%FOUND;
            close cpk4_contatti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Contatti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "CONTATTI_CONTRIBUENTE"
         if NEW_PRATICA_K is not null then
            open  cpk5_contatti_contribuente(NEW_PRATICA_K);
            fetch cpk5_contatti_contribuente into dummy;
            found := cpk5_contatti_contribuente%FOUND;
            close cpk5_contatti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Contatti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTATTI_CONTRIBUENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CONTATTI_CONTRIBUENTE

create or replace trigger CONTATTI_CONTRIBUENTE_tb
before INSERT
    or UPDATE
    or DELETE
on CONTATTI_CONTRIBUENTE
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: CONTATTI_CONTRIBUENTE_TB */
/

create or replace trigger CONTATTI_CONTRIBUENTE_tc
after INSERT
   or UPDATE
   or DELETE
on CONTATTI_CONTRIBUENTE
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: CONTATTI_CONTRIBUENTE_TC */
/

-- Procedure CONTATTI_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CONTATTI_CONTRIBUENTE

create or replace procedure CONTATTI_CONTRIBUENTE_PU
(old_cod_fiscale IN varchar,
 old_sequenza IN number,
 old_tipo_contatto IN number,
 old_tipo_richiedente IN number,
 old_tipo_tributo IN varchar,
 old_pratica_k IN number,
 new_cod_fiscale IN varchar,
 new_sequenza IN number,
 new_tipo_contatto IN number,
 new_tipo_richiedente IN number,
 new_tipo_tributo IN varchar,
 new_pratica_k IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_contatti_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_CONTATTO"
   cursor cpk2_contatti_contribuente(var_tipo_contatto number) is
      select 1
      from   TIPI_CONTATTO
      where  TIPO_CONTATTO = var_tipo_contatto
       and   var_tipo_contatto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_RICHIEDENTE"
   cursor cpk3_contatti_contribuente(var_tipo_richiedente number) is
      select 1
      from   TIPI_RICHIEDENTE
      where  TIPO_RICHIEDENTE = var_tipo_richiedente
       and   var_tipo_richiedente is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk4_contatti_contribuente(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk5_contatti_contribuente(var_pratica_k number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica_k
       and   var_pratica_k is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "CONTATTI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_contatti_contribuente(NEW_COD_FISCALE);
            fetch cpk1_contatti_contribuente into dummy;
            found := cpk1_contatti_contribuente%FOUND;
            close cpk1_contatti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Contatti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CONTATTO" deve esistere quando si modifica "CONTATTI_CONTRIBUENTE"
         if  NEW_TIPO_CONTATTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_CONTATTO != OLD_TIPO_CONTATTO or OLD_TIPO_CONTATTO is null) ) then
            open  cpk2_contatti_contribuente(NEW_TIPO_CONTATTO);
            fetch cpk2_contatti_contribuente into dummy;
            found := cpk2_contatti_contribuente%FOUND;
            close cpk2_contatti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Contatto. La registrazione Contatti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_RICHIEDENTE" deve esistere quando si modifica "CONTATTI_CONTRIBUENTE"
         if  NEW_TIPO_RICHIEDENTE is not null and ( seq = 0 )
         and (   (NEW_TIPO_RICHIEDENTE != OLD_TIPO_RICHIEDENTE or OLD_TIPO_RICHIEDENTE is null) ) then
            open  cpk3_contatti_contribuente(NEW_TIPO_RICHIEDENTE);
            fetch cpk3_contatti_contribuente into dummy;
            found := cpk3_contatti_contribuente%FOUND;
            close cpk3_contatti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Richiedente. La registrazione Contatti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "CONTATTI_CONTRIBUENTE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk4_contatti_contribuente(NEW_TIPO_TRIBUTO);
            fetch cpk4_contatti_contribuente into dummy;
            found := cpk4_contatti_contribuente%FOUND;
            close cpk4_contatti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Contatti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "CONTATTI_CONTRIBUENTE"
         if  NEW_PRATICA_K is not null and ( seq = 0 )
         and (   (NEW_PRATICA_K != OLD_PRATICA_K or OLD_PRATICA_K is null) ) then
            open  cpk5_contatti_contribuente(NEW_PRATICA_K);
            fetch cpk5_contatti_contribuente into dummy;
            found := cpk5_contatti_contribuente%FOUND;
            close cpk5_contatti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Contatti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTATTI_CONTRIBUENTE_PU */
/

-- Trigger CONTATTI_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CONTATTI_CONTRIBUENTE

create or replace trigger CONTATTI_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on CONTATTI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       CONTATTI_CONTRIBUENTE_NR (:new.cod_fiscale,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CONTATTI_CONTRIBUENTE_PU(:OLD.COD_FISCALE,
                                  :OLD.SEQUENZA,
                                  :OLD.TIPO_CONTATTO,
                                  :OLD.TIPO_RICHIEDENTE,
                                  :OLD.TIPO_TRIBUTO,
                                  :OLD.PRATICA_K,
                         :NEW.COD_FISCALE,
                         :NEW.SEQUENZA,
                         :NEW.TIPO_CONTATTO,
                         :NEW.TIPO_RICHIEDENTE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.PRATICA_K);
         null;
      end if;
      if INSERTING then
         CONTATTI_CONTRIBUENTE_PI(:NEW.COD_FISCALE,
                                  :NEW.TIPO_CONTATTO,
                                  :NEW.TIPO_RICHIEDENTE,
                                  :NEW.TIPO_TRIBUTO,
                                  :NEW.PRATICA_K);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CONTATTI_CONTRIBUENTE"
            cursor cpk_contatti_contribuente(var_COD_FISCALE varchar,
                                             var_SEQUENZA number) is
               select 1
                 from   CONTATTI_CONTRIBUENTE
                where  COD_FISCALE = var_COD_FISCALE and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CONTATTI_CONTRIBUENTE"
               if :new.COD_FISCALE is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_contatti_contribuente(:new.COD_FISCALE,
                                                  :new.SEQUENZA);
                  fetch cpk_contatti_contribuente into dummy;
                  found := cpk_contatti_contribuente%FOUND;
                  close cpk_contatti_contribuente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Contatti Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONTATTI_CONTRIBUENTE_TIU */
/

-- Tigger CONTATTI_CONTRIBUENTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CONTATTI_CONTRIBUENTE

create or replace trigger CONTATTI_CONTRIBUENTE_TD
before DELETE
on CONTATTI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      CONTATTI_CONTRIBUENTE_PD(:OLD.COD_FISCALE,
                               :OLD.SEQUENZA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
      DECLARE
	a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
            a_istruzione := 'BEGIN CONTRIBUENTI_CHK_DEL('''||:old.cod_fiscale||''','''''||'); end;';
            a_messaggio := '';
            IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;
   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONTATTI_CONTRIBUENTE_TD */
/

-- Procedure CONTENITORI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CONTENITORI

create or replace procedure CONTENITORI_PU
(old_cod_contenitore IN number,
 new_cod_contenitore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "CODICI_RFID"
   cursor cfk1_contenitori(var_cod_contenitore number) is
      select 1
      from   CODICI_RFID
      where  COD_CONTENITORE = var_cod_contenitore
       and   var_cod_contenitore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "CONTENITORI" non modificabile se esistono referenze su "CODICI_RFID"
      if (OLD_COD_CONTENITORE != NEW_COD_CONTENITORE) then
         open  cfk1_contenitori(OLD_COD_CONTENITORE);
         fetch cfk1_contenitori into dummy;
         found := cfk1_contenitori%FOUND;
         close cfk1_contenitori;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Codici RFID. La registrazione di Contenitori non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTENITORI_PU */
/

-- Trigger CONTENITORI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CONTENITORI

create or replace trigger CONTENITORI_TIU
before INSERT
    or UPDATE
on CONTENITORI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CONTENITORI_PU(:OLD.COD_CONTENITORE,
                         :NEW.COD_CONTENITORE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CONTENITORI"
            cursor cpk_contenitori(var_COD_CONTENITORE number) is
               select 1
                 from   CONTENITORI
                where  COD_CONTENITORE = var_COD_CONTENITORE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CONTENITORI"
               if :new.COD_CONTENITORE is not null then
                  open  cpk_contenitori(:new.COD_CONTENITORE);
                  fetch cpk_contenitori into dummy;
                  found := cpk_contenitori%FOUND;
                  close cpk_contenitori;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_CONTENITORE||
                               '" gia'' presente in Contenitori. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONTENITORI_TIU */
/

-- Procedure CONTENITORI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CONTENITORI

create or replace procedure CONTENITORI_PD
(old_cod_contenitore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CODICI_RFID"
   cursor cfk1_contenitori(var_cod_contenitore number) is
      select 1
      from   CODICI_RFID
      where  COD_CONTENITORE = var_cod_contenitore
       and   var_cod_contenitore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CONTENITORI" if children still exist in "CODICI_RFID"
      open  cfk1_contenitori(OLD_COD_CONTENITORE);
      fetch cfk1_contenitori into dummy;
      found := cfk1_contenitori%FOUND;
      close cfk1_contenitori;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Codici RFID. La registrazione di Contenitori non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTENITORI_PD */
/

-- Tigger CONTENITORI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CONTENITORI

create or replace trigger CONTENITORI_TD
before DELETE
on CONTENITORI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CODICI_RFID

      CONTENITORI_PD(:OLD.COD_CONTENITORE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONTENITORI_TD */
/

-- Procedure CONTRIBUENTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CONTRIBUENTI

create or replace procedure CONTRIBUENTI_PI
(new_ni IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk1_contribuenti(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "CONTRIBUENTI"
         if NEW_NI is not null then
            open  cpk1_contribuenti(NEW_NI);
            fetch cpk1_contribuenti into dummy;
            found := cpk1_contribuenti%FOUND;
            close cpk1_contribuenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Contribuenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTRIBUENTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CONTRIBUENTI
/* End Trigger: CONTRIBUENTI_TC */

-- Procedure CONTRIBUENTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CONTRIBUENTI

create or replace procedure CONTRIBUENTI_PU
(old_cod_fiscale IN varchar,
 old_ni IN number,
 new_cod_fiscale IN varchar,
 new_ni IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk1_contribuenti(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "CONTRIBUENTI"
         if  NEW_NI is not null and ( seq = 0 )
         and (   (NEW_NI != OLD_NI or OLD_NI is null) ) then
            open  cpk1_contribuenti(NEW_NI);
            fetch cpk1_contribuenti into dummy;
            found := cpk1_contribuenti%FOUND;
            close cpk1_contribuenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Contribuenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTRIBUENTI_PU */
/

-- Trigger CONTRIBUENTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CONTRIBUENTI

create or replace trigger CONTRIBUENTI_TIU
before INSERT
    or UPDATE
on CONTRIBUENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* CONTRIBUENTI_DI(:new.cod_fiscale,:new.ni); */ null;
   end;

   begin  -- Check REFERENTIAL Integrity at Level 0
      if UPDATING then
         CONTRIBUENTI_PU(:OLD.COD_FISCALE,
                         :OLD.NI,
                         :NEW.COD_FISCALE,
                         :NEW.NI);
         null;
      end if;
	if INSERTING then
         CONTRIBUENTI_PI(:NEW.NI);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CONTRIBUENTI"
            cursor cpk_contribuenti(var_COD_FISCALE varchar) is
               select 1
                 from   CONTRIBUENTI
                where  COD_FISCALE = var_COD_FISCALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CONTRIBUENTI"
               if :new.COD_FISCALE is not null then
                  open  cpk_contribuenti(:new.COD_FISCALE);
                  fetch cpk_contribuenti into dummy;
                  found := cpk_contribuenti%FOUND;
                  close cpk_contribuenti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||
                               '" gia'' presente in Contribuenti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         /* Attivazione Procedure di Cascade Update (.UpdateParentCascade) */
         CONTRIBUENTI_CU(:OLD.COD_FISCALE,
                         :NEW.COD_FISCALE,
                         :OLD.NI,
                         :NEW.NI);
--         CONTRIBUENTI_CU(:OLD.COD_FISCALE,
--                         :NEW.COD_FISCALE);
--         .UpdateParentCascade
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONTRIBUENTI_TIU */
/

-- Procedure CONTRIBUENTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table CONTRIBUENTI

create or replace procedure CONTRIBUENTI_PD
(old_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_CONTRIBUENTE"
   cursor cfk1_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "MAGGIORI_DETRAZIONI"
   cursor cfk2_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   MAGGIORI_DETRAZIONI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "RAPPORTI_TRIBUTO"
   cursor cfk3_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   RAPPORTI_TRIBUTO
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk4_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   PRATICHE_TRIBUTO
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_CONTRIBUENTE"
   cursor cfk5_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk6_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   VERSAMENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "CONTATTI_CONTRIBUENTE"
   cursor cfk7_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   CONTATTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "TERRENI_RIDOTTI"
   cursor cfk8_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   TERRENI_RIDOTTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "DELEGHE_BANCARIE"
   cursor cfk9_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   DELEGHE_BANCARIE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "NOTIFICHE_OGGETTO"
   cursor cfk10_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   NOTIFICHE_OGGETTO
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "FATTURE"
   cursor cfk11_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   FATTURE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "COMPENSAZIONI_RUOLO"
   cursor cfk12_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   COMPENSAZIONI_RUOLO
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "ALLINEAMENTO_DELEGHE"
   cursor cfk13_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   ALLINEAMENTO_DELEGHE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "DOCUMENTI_CONTRIBUENTE"
   cursor cfk14_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETRAZIONI_FIGLI"
   cursor cfk15_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   DETRAZIONI_FIGLI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "EVENTI_CONTRIBUENTE"
   cursor cfk16_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   EVENTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "COMPENSAZIONI"
   cursor cfk17_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   COMPENSAZIONI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "CONFERIMENTI"
   cursor cfk18_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   CONFERIMENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "CONFERIMENTI_CER"
   cursor cfk19_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   CONFERIMENTI_CER
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "RATE_IMPOSTA"
   cursor cfk20_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   RATE_IMPOSTA
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "STO_RAPPORTI_TRIBUTO"
   cursor cfk21_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   STO_RAPPORTI_TRIBUTO
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "STO_PRATICHE_TRIBUTO"
   cursor cfk22_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "STO_OGGETTI_CONTRIBUENTE"
   cursor cfk23_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   STO_OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk24_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "CONTRIBUENTI_CC_SOGGETTI"
   cursor cfk25_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI_CC_SOGGETTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_INTERROGAZIONI"
   cursor cfk26_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   SAM_INTERROGAZIONI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "STATI_CONTRIBUENTE"
   cursor cfk27_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   STATI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "CODICI_RFID"
   cursor cfk28_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   CODICI_RFID
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_ECCEDENZE"
   cursor cfk29_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   RUOLI_ECCEDENZE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of DeleteParentRestrict constraint for "BONUS_SOCIALI_CONTRIBUENTE"
   cursor cfk30_contribuenti(var_cod_fiscale varchar) is
      select 1
      from   BONUS_SOCIALI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "OGGETTI_CONTRIBUENTE"
      open  cfk1_contribuenti(OLD_COD_FISCALE);
      fetch cfk1_contribuenti into dummy;
      found := cfk1_contribuenti%FOUND;
      close cfk1_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Contribuente. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "MAGGIORI_DETRAZIONI"
      open  cfk2_contribuenti(OLD_COD_FISCALE);
      fetch cfk2_contribuenti into dummy;
      found := cfk2_contribuenti%FOUND;
      close cfk2_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Maggiori Detrazioni. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "RAPPORTI_TRIBUTO"
      open  cfk3_contribuenti(OLD_COD_FISCALE);
      fetch cfk3_contribuenti into dummy;
      found := cfk3_contribuenti%FOUND;
      close cfk3_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Rapporti Tributo. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "PRATICHE_TRIBUTO"
      open  cfk4_contribuenti(OLD_COD_FISCALE);
      fetch cfk4_contribuenti into dummy;
      found := cfk4_contribuenti%FOUND;
      close cfk4_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "RUOLI_CONTRIBUENTE"
      open  cfk5_contribuenti(OLD_COD_FISCALE);
      fetch cfk5_contribuenti into dummy;
      found := cfk5_contribuenti%FOUND;
      close cfk5_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Contribuente. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "VERSAMENTI"
      open  cfk6_contribuenti(OLD_COD_FISCALE);
      fetch cfk6_contribuenti into dummy;
      found := cfk6_contribuenti%FOUND;
      close cfk6_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "CONTATTI_CONTRIBUENTE"
      open  cfk7_contribuenti(OLD_COD_FISCALE);
      fetch cfk7_contribuenti into dummy;
      found := cfk7_contribuenti%FOUND;
      close cfk7_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Contatti Contribuente. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "TERRENI_RIDOTTI"
      open  cfk8_contribuenti(OLD_COD_FISCALE);
      fetch cfk8_contribuenti into dummy;
      found := cfk8_contribuenti%FOUND;
      close cfk8_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Terreni Ridotti. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "DELEGHE_BANCARIE"
      open  cfk9_contribuenti(OLD_COD_FISCALE);
      fetch cfk9_contribuenti into dummy;
      found := cfk9_contribuenti%FOUND;
      close cfk9_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Deleghe Bancarie. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "NOTIFICHE_OGGETTO"
      open  cfk10_contribuenti(OLD_COD_FISCALE);
      fetch cfk10_contribuenti into dummy;
      found := cfk10_contribuenti%FOUND;
      close cfk10_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Notifiche_oggetto. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "FATTURE"
      open  cfk11_contribuenti(OLD_COD_FISCALE);
      fetch cfk11_contribuenti into dummy;
      found := cfk11_contribuenti%FOUND;
      close cfk11_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Fatture. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "COMPENSAZIONI_RUOLO"
      open  cfk12_contribuenti(OLD_COD_FISCALE);
      fetch cfk12_contribuenti into dummy;
      found := cfk12_contribuenti%FOUND;
      close cfk12_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Compensazioni Ruolo. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "ALLINEAMENTO_DELEGHE"
      open  cfk13_contribuenti(OLD_COD_FISCALE);
      fetch cfk13_contribuenti into dummy;
      found := cfk13_contribuenti%FOUND;
      close cfk13_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Allineamento Deleghe. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "DOCUMENTI_CONTRIBUENTE"
      open  cfk14_contribuenti(OLD_COD_FISCALE);
      fetch cfk14_contribuenti into dummy;
      found := cfk14_contribuenti%FOUND;
      close cfk14_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Documenti Contribuente. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "DETRAZIONI_FIGLI"
      open  cfk15_contribuenti(OLD_COD_FISCALE);
      fetch cfk15_contribuenti into dummy;
      found := cfk15_contribuenti%FOUND;
      close cfk15_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Detrazioni_figli. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "EVENTI_CONTRIBUENTE"
      open  cfk16_contribuenti(OLD_COD_FISCALE);
      fetch cfk16_contribuenti into dummy;
      found := cfk16_contribuenti%FOUND;
      close cfk16_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Eventi Contribuente. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "COMPENSAZIONI"
      open  cfk17_contribuenti(OLD_COD_FISCALE);
      fetch cfk17_contribuenti into dummy;
      found := cfk17_contribuenti%FOUND;
      close cfk17_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Compensazioni. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "CONFERIMENTI"
      open  cfk18_contribuenti(OLD_COD_FISCALE);
      fetch cfk18_contribuenti into dummy;
      found := cfk18_contribuenti%FOUND;
      close cfk18_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Conferimenti. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "CONFERIMENTI_CER"
      open  cfk19_contribuenti(OLD_COD_FISCALE);
      fetch cfk19_contribuenti into dummy;
      found := cfk19_contribuenti%FOUND;
      close cfk19_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Conferimenti CER. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "RATE_IMPOSTA"
      open  cfk20_contribuenti(OLD_COD_FISCALE);
      fetch cfk20_contribuenti into dummy;
      found := cfk20_contribuenti%FOUND;
      close cfk20_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Rate Imposta. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "STO_RAPPORTI_TRIBUTO"
      open  cfk21_contribuenti(OLD_COD_FISCALE);
      fetch cfk21_contribuenti into dummy;
      found := cfk21_contribuenti%FOUND;
      close cfk21_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su STO_RAPPORTI_TRIBUTO. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "STO_PRATICHE_TRIBUTO"
      open  cfk22_contribuenti(OLD_COD_FISCALE);
      fetch cfk22_contribuenti into dummy;
      found := cfk22_contribuenti%FOUND;
      close cfk22_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su STO_PRATICHE_TRIBUTO. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "STO_OGGETTI_CONTRIBUENTE"
      open  cfk23_contribuenti(OLD_COD_FISCALE);
      fetch cfk23_contribuenti into dummy;
      found := cfk23_contribuenti%FOUND;
      close cfk23_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su STO_OGGETTI_CONTRIBUENTE. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk24_contribuenti(OLD_COD_FISCALE);
      fetch cfk24_contribuenti into dummy;
      found := cfk24_contribuenti%FOUND;
      close cfk24_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "CONTRIBUENTI_CC_SOGGETTI"
      open  cfk25_contribuenti(OLD_COD_FISCALE);
      fetch cfk25_contribuenti into dummy;
      found := cfk25_contribuenti%FOUND;
      close cfk25_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Contribuenti_cc_soggetti. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "SAM_INTERROGAZIONI"
      open  cfk26_contribuenti(OLD_COD_FISCALE);
      fetch cfk26_contribuenti into dummy;
      found := cfk26_contribuenti%FOUND;
      close cfk26_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_INTERROGAZIONI. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "STATI_CONTRIBUENTE"
      open  cfk27_contribuenti(OLD_COD_FISCALE);
      fetch cfk27_contribuenti into dummy;
      found := cfk27_contribuenti%FOUND;
      close cfk27_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Stati Contribuente. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "CODICI_RFID"
      open  cfk28_contribuenti(OLD_COD_FISCALE);
      fetch cfk28_contribuenti into dummy;
      found := cfk28_contribuenti%FOUND;
      close cfk28_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Codici RFID. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "RUOLI_ECCEDENZE"
      open  cfk29_contribuenti(OLD_COD_FISCALE);
      fetch cfk29_contribuenti into dummy;
      found := cfk29_contribuenti%FOUND;
      close cfk29_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Eccedenze. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "CONTRIBUENTI" if children still exist in "BONUS_SOCIALI_CONTRIBUENTE"
      open  cfk30_contribuenti(OLD_COD_FISCALE);
      fetch cfk30_contribuenti into dummy;
      found := cfk30_contribuenti%FOUND;
      close cfk30_contribuenti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su BONUS_SOCIALI_CONTRIBUENTE. La registrazione di Contribuenti non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTRIBUENTI_PD */
/

-- Tigger CONTRIBUENTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table CONTRIBUENTI

create or replace trigger CONTRIBUENTI_TD
before DELETE
on CONTRIBUENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI_CONTRIBUENTE

      -- Child Restrict Table: MAGGIORI_DETRAZIONI

      -- Child Restrict Table: RAPPORTI_TRIBUTO

      -- Child Restrict Table: PRATICHE_TRIBUTO

      -- Child Restrict Table: RUOLI_CONTRIBUENTE

      -- Child Restrict Table: VERSAMENTI

      -- Child Restrict Table: CONTATTI_CONTRIBUENTE

      -- Child Restrict Table: TERRENI_RIDOTTI

      -- Child Restrict Table: DELEGHE_BANCARIE

      -- Child Restrict Table: NOTIFICHE_OGGETTO

      -- Child Restrict Table: FATTURE

      -- Child Restrict Table: COMPENSAZIONI_RUOLO

      -- Child Restrict Table: ALLINEAMENTO_DELEGHE

      -- Child Restrict Table: DOCUMENTI_CONTRIBUENTE

      -- Child Restrict Table: DETRAZIONI_FIGLI

      -- Child Restrict Table: EVENTI_CONTRIBUENTE

      -- Child Restrict Table: COMPENSAZIONI

      -- Child Restrict Table: CONFERIMENTI

      -- Child Restrict Table: CONFERIMENTI_CER

      -- Child Restrict Table: RATE_IMPOSTA

      -- Child Restrict Table: STO_RAPPORTI_TRIBUTO

      -- Child Restrict Table: STO_PRATICHE_TRIBUTO

      -- Child Restrict Table: STO_OGGETTI_CONTRIBUENTE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      -- Child Restrict Table: CONTRIBUENTI_CC_SOGGETTI

      -- Child Restrict Table: SAM_INTERROGAZIONI

      -- Child Restrict Table: STATI_CONTRIBUENTE

      -- Child Restrict Table: CODICI_RFID

      -- Child Restrict Table: RUOLI_ECCEDENZE

      -- Child Restrict Table: BONUS_SOCIALI_CONTRIBUENTE

      CONTRIBUENTI_PD(:OLD.COD_FISCALE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "ANOMALIE_ICI"
      delete ANOMALIE_ICI
      where  COD_FISCALE = :OLD.COD_FISCALE;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONTRIBUENTI_TD */
/

-- Procedure CONTRIBUENTI_CC_SOGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CONTRIBUENTI_CC_SOGGETTI

create or replace procedure CONTRIBUENTI_CC_SOGGETTI_PI
(new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_contribuenti_cc_soggetti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "CONTRIBUENTI_CC_SOGGETTI"
         if NEW_COD_FISCALE is not null then
            open  cpk1_contribuenti_cc_soggetti(NEW_COD_FISCALE);
            fetch cpk1_contribuenti_cc_soggetti into dummy;
            found := cpk1_contribuenti_cc_soggetti%FOUND;
            close cpk1_contribuenti_cc_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Contribuenti_cc_soggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTRIBUENTI_CC_SOGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CONTRIBUENTI_CC_SOGGETTI
/* End Trigger: CONTRIBUENTI_CC_SOGGETTI_TC */

-- Procedure CONTRIBUENTI_CC_SOGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CONTRIBUENTI_CC_SOGGETTI

create or replace procedure CONTRIBUENTI_CC_SOGGETTI_PU
(old_id IN number,
 old_cod_fiscale IN varchar,
 new_id IN number,
 new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_contribuenti_cc_soggetti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "CONTRIBUENTI_CC_SOGGETTI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_contribuenti_cc_soggetti(NEW_COD_FISCALE);
            fetch cpk1_contribuenti_cc_soggetti into dummy;
            found := cpk1_contribuenti_cc_soggetti%FOUND;
            close cpk1_contribuenti_cc_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Contribuenti_cc_soggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CONTRIBUENTI_CC_SOGGETTI_PU */
/

-- Trigger CONTRIBUENTI_CC_SOGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CONTRIBUENTI_CC_SOGGETTI

create or replace trigger CONTRIBUENTI_CC_SOGGETTI_TIU
before INSERT
    or UPDATE
on CONTRIBUENTI_CC_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id is null then
      CONTRIBUENTI_CC_SOGGETTI_NR(:new.id);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CONTRIBUENTI_CC_SOGGETTI_PU(:OLD.ID,
                                     :OLD.COD_FISCALE,
                         :NEW.ID,
                         :NEW.COD_FISCALE);
         null;
      end if;
      if INSERTING then
         CONTRIBUENTI_CC_SOGGETTI_PI(:NEW.COD_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CONTRIBUENTI_CC_SOGGETTI"
            cursor cpk_contribuenti_cc_soggetti(var_ID number) is
               select 1
                 from   CONTRIBUENTI_CC_SOGGETTI
                where  ID = var_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CONTRIBUENTI_CC_SOGGETTI"
               if :new.ID is not null then
                  open  cpk_contribuenti_cc_soggetti(:new.ID);
                  fetch cpk_contribuenti_cc_soggetti into dummy;
                  found := cpk_contribuenti_cc_soggetti%FOUND;
                  close cpk_contribuenti_cc_soggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID||
                               '" gia'' presente in Contribuenti_cc_soggetti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CONTRIBUENTI_CC_SOGGETTI_TIU */
/

-- Procedure COSTI_STORICI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table COSTI_STORICI

create or replace procedure COSTI_STORICI_PI
(new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk1_costi_storici(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "COSTI_STORICI"
         if NEW_OGGETTO_PRATICA is not null then
            open  cpk1_costi_storici(NEW_OGGETTO_PRATICA);
            fetch cpk1_costi_storici into dummy;
            found := cpk1_costi_storici%FOUND;
            close cpk1_costi_storici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Costi Storici non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COSTI_STORICI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table COSTI_STORICI
/* End Trigger: COSTI_STORICI_TC */

-- Procedure COSTI_STORICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table COSTI_STORICI

create or replace procedure COSTI_STORICI_PU
(old_oggetto_pratica IN number,
 old_anno IN number,
 new_oggetto_pratica IN number,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk1_costi_storici(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "COSTI_STORICI"
         if  NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_costi_storici(NEW_OGGETTO_PRATICA);
            fetch cpk1_costi_storici into dummy;
            found := cpk1_costi_storici%FOUND;
            close cpk1_costi_storici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Costi Storici non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "OGGETTI_PRATICA" non modificabile sul figlio: "COSTI_STORICI"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Oggetti Pratica non e'' modificabile su Costi Storici.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COSTI_STORICI_PU */
/

-- Trigger COSTI_STORICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table COSTI_STORICI

create or replace trigger COSTI_STORICI_TIU
before INSERT
    or UPDATE
on COSTI_STORICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         COSTI_STORICI_PU(:OLD.OGGETTO_PRATICA,
                          :OLD.ANNO,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         COSTI_STORICI_PI(:NEW.OGGETTO_PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "COSTI_STORICI"
            cursor cpk_costi_storici(var_OGGETTO_PRATICA number,
                                     var_ANNO number) is
               select 1
                 from   COSTI_STORICI
                where  OGGETTO_PRATICA = var_OGGETTO_PRATICA and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "COSTI_STORICI"
               if :new.OGGETTO_PRATICA is not null and
                  :new.ANNO is not null then
                  open  cpk_costi_storici(:new.OGGETTO_PRATICA,
                                          :new.ANNO);
                  fetch cpk_costi_storici into dummy;
                  found := cpk_costi_storici%FOUND;
                  close cpk_costi_storici;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO_PRATICA||' '||
                               :new.ANNO||
                               '" gia'' presente in Costi Storici. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COSTI_STORICI_TIU */
/

-- Procedure COSTI_TARSU_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table COSTI_TARSU

create or replace procedure COSTI_TARSU_PI
(new_tipo_costo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_COSTO"
   cursor cpk1_costi_tarsu(var_tipo_costo varchar) is
      select 1
      from   TIPI_COSTO
      where  TIPO_COSTO = var_tipo_costo
       and   var_tipo_costo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_COSTO" deve esistere quando si inserisce su "COSTI_TARSU"
         if NEW_TIPO_COSTO is not null then
            open  cpk1_costi_tarsu(NEW_TIPO_COSTO);
            fetch cpk1_costi_tarsu into dummy;
            found := cpk1_costi_tarsu%FOUND;
            close cpk1_costi_tarsu;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Costo. La registrazione Costi TARSU non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COSTI_TARSU_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table COSTI_TARSU
/* End Trigger: COSTI_TARSU_TC */

-- Procedure COSTI_TARSU_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table COSTI_TARSU

create or replace procedure COSTI_TARSU_PU
(old_anno IN number,
 old_sequenza IN number,
 old_tipo_costo IN varchar,
 new_anno IN number,
 new_sequenza IN number,
 new_tipo_costo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_COSTO"
   cursor cpk1_costi_tarsu(var_tipo_costo varchar) is
      select 1
      from   TIPI_COSTO
      where  TIPO_COSTO = var_tipo_costo
       and   var_tipo_costo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_COSTO" deve esistere quando si modifica "COSTI_TARSU"
         if  NEW_TIPO_COSTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_COSTO != OLD_TIPO_COSTO or OLD_TIPO_COSTO is null) ) then
            open  cpk1_costi_tarsu(NEW_TIPO_COSTO);
            fetch cpk1_costi_tarsu into dummy;
            found := cpk1_costi_tarsu%FOUND;
            close cpk1_costi_tarsu;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Costo. La registrazione Costi TARSU non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: COSTI_TARSU_PU */
/

-- Trigger COSTI_TARSU_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table COSTI_TARSU

create or replace trigger COSTI_TARSU_TIU
before INSERT
    or UPDATE
on COSTI_TARSU
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         COSTI_TARSU_PU(:OLD.ANNO,
                        :OLD.SEQUENZA,
                        :OLD.TIPO_COSTO,
                         :NEW.ANNO,
                         :NEW.SEQUENZA,
                         :NEW.TIPO_COSTO);
         null;
      end if;
      if INSERTING then
         COSTI_TARSU_PI(:NEW.TIPO_COSTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "COSTI_TARSU"
            cursor cpk_costi_tarsu(var_ANNO number,
                                   var_SEQUENZA number,
                                   var_TIPO_COSTO varchar) is
               select 1
                 from   COSTI_TARSU
                where  ANNO = var_ANNO and
                       SEQUENZA = var_SEQUENZA and
                       TIPO_COSTO = var_TIPO_COSTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "COSTI_TARSU"
               if :new.ANNO is not null and
                  :new.SEQUENZA is not null and
                  :new.TIPO_COSTO is not null then
                  open  cpk_costi_tarsu(:new.ANNO,
                                        :new.SEQUENZA,
                                        :new.TIPO_COSTO);
                  fetch cpk_costi_tarsu into dummy;
                  found := cpk_costi_tarsu%FOUND;
                  close cpk_costi_tarsu;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANNO||' '||
                               :new.SEQUENZA||' '||
                               :new.TIPO_COSTO||
                               '" gia'' presente in Costi TARSU. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: COSTI_TARSU_TIU */
/

-- Procedure CREDITI_RAVVEDIMENTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table CREDITI_RAVVEDIMENTO

create or replace procedure CREDITI_RAVVEDIMENTO_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_crediti_ravvedimento(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "CREDITI_RAVVEDIMENTO"
         if NEW_PRATICA is not null then
            open  cpk1_crediti_ravvedimento(NEW_PRATICA);
            fetch cpk1_crediti_ravvedimento into dummy;
            found := cpk1_crediti_ravvedimento%FOUND;
            close cpk1_crediti_ravvedimento;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione CREDITI_RAVVEDIMENTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CREDITI_RAVVEDIMENTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table CREDITI_RAVVEDIMENTO
/* End Trigger: CREDITI_RAVVEDIMENTO_TC */

-- Procedure CREDITI_RAVVEDIMENTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table CREDITI_RAVVEDIMENTO

create or replace procedure CREDITI_RAVVEDIMENTO_PU
(old_pratica IN number,
 old_sequenza IN number,
 new_pratica IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_crediti_ravvedimento(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "CREDITI_RAVVEDIMENTO"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_crediti_ravvedimento(NEW_PRATICA);
            fetch cpk1_crediti_ravvedimento into dummy;
            found := cpk1_crediti_ravvedimento%FOUND;
            close cpk1_crediti_ravvedimento;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione CREDITI_RAVVEDIMENTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: CREDITI_RAVVEDIMENTO_PU */
/

-- Trigger CREDITI_RAVVEDIMENTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CREDITI_RAVVEDIMENTO

create or replace trigger CREDITI_RAVVEDIMENTO_TIU
before INSERT
    or UPDATE
on CREDITI_RAVVEDIMENTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
      CREDITI_RAVVEDIMENTO_NR(:new.pratica,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         CREDITI_RAVVEDIMENTO_PU(:OLD.PRATICA,
                                 :OLD.SEQUENZA,
                         :NEW.PRATICA,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         CREDITI_RAVVEDIMENTO_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CREDITI_RAVVEDIMENTO"
            cursor cpk_crediti_ravvedimento(var_PRATICA number,
                                            var_SEQUENZA number) is
               select 1
                 from   CREDITI_RAVVEDIMENTO
                where  PRATICA = var_PRATICA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CREDITI_RAVVEDIMENTO"
               if :new.PRATICA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_crediti_ravvedimento(:new.PRATICA,
                                                 :new.SEQUENZA);
                  fetch cpk_crediti_ravvedimento into dummy;
                  found := cpk_crediti_ravvedimento%FOUND;
                  close cpk_crediti_ravvedimento;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in CREDITI_RAVVEDIMENTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CREDITI_RAVVEDIMENTO_TIU */
/

-- Trigger CUARCUIU_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CUARCUIU

create or replace trigger CUARCUIU_TIU
before INSERT
    or UPDATE
on CUARCUIU
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.categoria_ric	:= rtrim(ltrim(ltrim(:new.categoria1||
				   lpad(:new.categoria2,2,'0'),'0')));
      :new.sezione_ric 		:= rtrim(ltrim(ltrim(:new.sezione,'0')));
      :new.foglio_ric 		:= substr(rtrim(ltrim(ltrim(:new.foglio,'0'))),1,5);
      :new.numero_ric 		:= substr(rtrim(ltrim(ltrim(:new.numero,'0'))),1,5);
      :new.subalterno_ric 	:= rtrim(ltrim(ltrim(:new.subalterno,'0')));
      :new.zona_ric 		:= rtrim(ltrim(ltrim(:new.zona,'0')));
   end;
/*
   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CUARCUIU"
               select 1
                 from   CUARCUIU
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CUARCUIU"
                  fetch cpk_cuarcuiu into dummy;
                  found := cpk_cuarcuiu%FOUND;
                  close cpk_cuarcuiu;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               '" gia'' presente in CUARCUIU. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;
*/
   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CUARCUIU_TIU */
/

-- Trigger CUFISICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CUFISICA

create or replace trigger CUFISICA_TIU
before INSERT
    or UPDATE
on CUFISICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.cognome_nome_ric	:= rtrim(ltrim(:new.cognome))||'/'||rtrim(ltrim(:new.nome));
   end;
/*
   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CUFISICA"
               select 1
                 from   CUFISICA
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CUFISICA"
                  fetch cpk_cufisica into dummy;
                  found := cpk_cufisica%FOUND;
                  close cpk_cufisica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               '" gia'' presente in CUFISICA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;
*/
   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CUFISICA_TIU */
/

-- Trigger CUNONFIS_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table CUNONFIS

create or replace trigger CUNONFIS_TIU
before INSERT
    or UPDATE
on CUNONFIS
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.denominazione_ric	:= rtrim(ltrim(:new.denominazione));
   end;
/*
   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "CUNONFIS"
               select 1
                 from   CUNONFIS
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "CUNONFIS"
                  fetch cpk_cunonfis into dummy;
                  found := cpk_cunonfis%FOUND;
                  close cpk_cunonfis;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               '" gia'' presente in CUNONFIS. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;
*/
   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: CUNONFIS_TIU */
/

-- Procedure DATE_INTERESSI_VIOLAZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATE_INTERESSI_VIOLAZIONI

create or replace procedure DATE_INTERESSI_VIOLAZIONI_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_date_interessi_violazioni(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "DATE_INTERESSI_VIOLAZIONI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_date_interessi_violazioni(NEW_TIPO_TRIBUTO);
            fetch cpk1_date_interessi_violazioni into dummy;
            found := cpk1_date_interessi_violazioni%FOUND;
            close cpk1_date_interessi_violazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Date Interessi Violazioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATE_INTERESSI_VIOLAZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATE_INTERESSI_VIOLAZIONI
/* End Trigger: DATE_INTERESSI_VIOLAZIONI_TC */

-- Procedure DATE_INTERESSI_VIOLAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATE_INTERESSI_VIOLAZIONI

create or replace procedure DATE_INTERESSI_VIOLAZIONI_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_data_atto_da IN date,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_data_atto_da IN date)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_date_interessi_violazioni(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "DATE_INTERESSI_VIOLAZIONI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_date_interessi_violazioni(NEW_TIPO_TRIBUTO);
            fetch cpk1_date_interessi_violazioni into dummy;
            found := cpk1_date_interessi_violazioni%FOUND;
            close cpk1_date_interessi_violazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Date Interessi Violazioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATE_INTERESSI_VIOLAZIONI_PU */
/

-- Trigger DATE_INTERESSI_VIOLAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATE_INTERESSI_VIOLAZIONI

create or replace trigger DATE_INTERESSI_VIOLAZIONI_TIU
before INSERT
    or UPDATE
on DATE_INTERESSI_VIOLAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATE_INTERESSI_VIOLAZIONI_PU(:OLD.TIPO_TRIBUTO,
                                      :OLD.ANNO,
                                      :OLD.DATA_ATTO_DA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.DATA_ATTO_DA);
         null;
      end if;
      if INSERTING then
         DATE_INTERESSI_VIOLAZIONI_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATE_INTERESSI_VIOLAZIONI"
            cursor cpk_date_interessi_violazioni(var_TIPO_TRIBUTO varchar,
                                                 var_ANNO number,
                                                 var_DATA_ATTO_DA date) is
               select 1
                 from   DATE_INTERESSI_VIOLAZIONI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       DATA_ATTO_DA = var_DATA_ATTO_DA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATE_INTERESSI_VIOLAZIONI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.DATA_ATTO_DA is not null then
                  open  cpk_date_interessi_violazioni(:new.TIPO_TRIBUTO,
                                                      :new.ANNO,
                                                      :new.DATA_ATTO_DA);
                  fetch cpk_date_interessi_violazioni into dummy;
                  found := cpk_date_interessi_violazioni%FOUND;
                  close cpk_date_interessi_violazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.DATA_ATTO_DA||
                               '" gia'' presente in Date Interessi Violazioni. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATE_INTERESSI_VIOLAZIONI_TIU */
/

-- Procedure DATI_CONTABILI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_CONTABILI

create or replace procedure DATI_CONTABILI_PI
(new_tipo_tributo IN varchar,
 new_tributo IN number,
 new_cod_tributo_f24 IN varchar,
 new_descrizione_titr IN varchar,
 new_stato_pratica IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_dati_contabili(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_STATO"
   cursor cpk2_dati_contabili(var_stato_pratica varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_stato_pratica
       and   var_stato_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_F24"
   cursor cpk3_dati_contabili(var_cod_tributo_f24 varchar,
                              var_tipo_tributo varchar,
                              var_descrizione_titr varchar) is
      select 1
      from   CODICI_F24
      where  TRIBUTO_F24 = var_cod_tributo_f24
       and   TIPO_TRIBUTO = var_tipo_tributo
       and   DESCRIZIONE_TITR = var_descrizione_titr
       and   var_cod_tributo_f24 is not null
       and   var_tipo_tributo is not null
       and   var_descrizione_titr is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_TRIBUTO"
   cursor cpk4_dati_contabili(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "DATI_CONTABILI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_dati_contabili(NEW_TIPO_TRIBUTO);
            fetch cpk1_dati_contabili into dummy;
            found := cpk1_dati_contabili%FOUND;
            close cpk1_dati_contabili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Dati Contabili non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si inserisce su "DATI_CONTABILI"
         if NEW_STATO_PRATICA is not null then
            open  cpk2_dati_contabili(NEW_STATO_PRATICA);
            fetch cpk2_dati_contabili into dummy;
            found := cpk2_dati_contabili%FOUND;
            close cpk2_dati_contabili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione Dati Contabili non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_F24" deve esistere quando si inserisce su "DATI_CONTABILI"
         if NEW_COD_TRIBUTO_F24 is not null and
            NEW_TIPO_TRIBUTO is not null and
            NEW_DESCRIZIONE_TITR is not null then
            open  cpk3_dati_contabili(NEW_COD_TRIBUTO_F24,
                                      NEW_TIPO_TRIBUTO,
                                      NEW_DESCRIZIONE_TITR);
            fetch cpk3_dati_contabili into dummy;
            found := cpk3_dati_contabili%FOUND;
            close cpk3_dati_contabili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su CODICI_F24. La registrazione Dati Contabili non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si inserisce su "DATI_CONTABILI"
         if NEW_TRIBUTO is not null then
            open  cpk4_dati_contabili(NEW_TRIBUTO);
            fetch cpk4_dati_contabili into dummy;
            found := cpk4_dati_contabili%FOUND;
            close cpk4_dati_contabili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Dati Contabili non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_CONTABILI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_CONTABILI
/* End Trigger: DATI_CONTABILI_TC */

-- Procedure DATI_CONTABILI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_CONTABILI

create or replace procedure DATI_CONTABILI_PU
(old_id_dato_contabile IN number,
 old_tipo_tributo IN varchar,
 old_tributo IN number,
 old_cod_tributo_f24 IN varchar,
 old_descrizione_titr IN varchar,
 old_stato_pratica IN varchar,
 new_id_dato_contabile IN number,
 new_tipo_tributo IN varchar,
 new_tributo IN number,
 new_cod_tributo_f24 IN varchar,
 new_descrizione_titr IN varchar,
 new_stato_pratica IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_dati_contabili(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_STATO"
   cursor cpk2_dati_contabili(var_stato_pratica varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_stato_pratica
       and   var_stato_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_F24"
   cursor cpk3_dati_contabili(var_cod_tributo_f24 varchar,
                              var_tipo_tributo varchar,
                              var_descrizione_titr varchar) is
      select 1
      from   CODICI_F24
      where  TRIBUTO_F24 = var_cod_tributo_f24
       and   TIPO_TRIBUTO = var_tipo_tributo
       and   DESCRIZIONE_TITR = var_descrizione_titr
       and   var_cod_tributo_f24 is not null
       and   var_tipo_tributo is not null
       and   var_descrizione_titr is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_TRIBUTO"
   cursor cpk4_dati_contabili(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "DATI_CONTABILI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_dati_contabili(NEW_TIPO_TRIBUTO);
            fetch cpk1_dati_contabili into dummy;
            found := cpk1_dati_contabili%FOUND;
            close cpk1_dati_contabili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Dati Contabili non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si modifica "DATI_CONTABILI"
         if  NEW_STATO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_STATO_PRATICA != OLD_STATO_PRATICA or OLD_STATO_PRATICA is null) ) then
            open  cpk2_dati_contabili(NEW_STATO_PRATICA);
            fetch cpk2_dati_contabili into dummy;
            found := cpk2_dati_contabili%FOUND;
            close cpk2_dati_contabili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione Dati Contabili non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_F24" deve esistere quando si modifica "DATI_CONTABILI"
         if  NEW_COD_TRIBUTO_F24 is not null and
             NEW_TIPO_TRIBUTO is not null and
             NEW_DESCRIZIONE_TITR is not null and ( seq = 0 )
         and (   (NEW_COD_TRIBUTO_F24 != OLD_COD_TRIBUTO_F24 or OLD_COD_TRIBUTO_F24 is null)
              or (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_DESCRIZIONE_TITR != OLD_DESCRIZIONE_TITR or OLD_DESCRIZIONE_TITR is null) ) then
            open  cpk3_dati_contabili(NEW_COD_TRIBUTO_F24,
                                      NEW_TIPO_TRIBUTO,
                                      NEW_DESCRIZIONE_TITR);
            fetch cpk3_dati_contabili into dummy;
            found := cpk3_dati_contabili%FOUND;
            close cpk3_dati_contabili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su CODICI_F24. La registrazione Dati Contabili non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si modifica "DATI_CONTABILI"
         if  NEW_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null) ) then
            open  cpk4_dati_contabili(NEW_TRIBUTO);
            fetch cpk4_dati_contabili into dummy;
            found := cpk4_dati_contabili%FOUND;
            close cpk4_dati_contabili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Dati Contabili non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_CONTABILI_PU */
/

-- Trigger DATI_CONTABILI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_CONTABILI

create or replace trigger DATI_CONTABILI_TIU
before INSERT
    or UPDATE
on DATI_CONTABILI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      DATI_CONTABILI_DI(:new.emissione_dal,:new.emissione_al,:new.ripartizione_dal,:new.ripartizione_al);
   end;

   if INSERTING and :new.id_dato_contabile is null then
      DATI_CONTABILI_NR (:new.id_dato_contabile);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_CONTABILI_PU(:OLD.ID_DATO_CONTABILE,
                           :OLD.TIPO_TRIBUTO,
                           :OLD.TRIBUTO,
                           :OLD.COD_TRIBUTO_F24,
                           :OLD.DESCRIZIONE_TITR,
                           :OLD.STATO_PRATICA,
                         :NEW.ID_DATO_CONTABILE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TRIBUTO,
                         :NEW.COD_TRIBUTO_F24,
                         :NEW.DESCRIZIONE_TITR,
                         :NEW.STATO_PRATICA);
         null;
      end if;
      if INSERTING then
         DATI_CONTABILI_PI(:NEW.TIPO_TRIBUTO,
                           :NEW.TRIBUTO,
                           :NEW.COD_TRIBUTO_F24,
                           :NEW.DESCRIZIONE_TITR,
                           :NEW.STATO_PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_CONTABILI"
            cursor cpk_dati_contabili(var_ID_DATO_CONTABILE number) is
               select 1
                 from   DATI_CONTABILI
                where  ID_DATO_CONTABILE = var_ID_DATO_CONTABILE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_CONTABILI"
               if :new.ID_DATO_CONTABILE is not null then
                  open  cpk_dati_contabili(:new.ID_DATO_CONTABILE);
                  fetch cpk_dati_contabili into dummy;
                  found := cpk_dati_contabili%FOUND;
                  close cpk_dati_contabili;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_DATO_CONTABILE||
                               '" gia'' presente in Dati Contabili. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_CONTABILI_TIU */
/

-- Procedure DATI_METRICI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI

create or replace procedure DATI_METRICI_PI
(new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si inserisce su "DATI_METRICI"
         if NEW_UIU_ID is not null then
            open  cpk1_dati_metrici(NEW_UIU_ID);
            fetch cpk1_dati_metrici into dummy;
            found := cpk1_dati_metrici%FOUND;
            close cpk1_dati_metrici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI
/* End Trigger: DATI_METRICI_TC */

-- Procedure DATI_METRICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI

create or replace procedure DATI_METRICI_PU
(old_id IN number,
 old_uiu_id IN number,
 new_id IN number,
 new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si modifica "DATI_METRICI"
         if  NEW_UIU_ID is not null and ( seq = 0 )
         and (   (NEW_UIU_ID != OLD_UIU_ID or OLD_UIU_ID is null) ) then
            open  cpk1_dati_metrici(NEW_UIU_ID);
            fetch cpk1_dati_metrici into dummy;
            found := cpk1_dati_metrici%FOUND;
            close cpk1_dati_metrici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_PU */
/

-- Trigger DATI_METRICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI

create or replace trigger DATI_METRICI_TIU
before INSERT
    or UPDATE
on DATI_METRICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_PU(:OLD.ID,
                         :OLD.UIU_ID,
                         :NEW.ID,
                         :NEW.UIU_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_PI(:NEW.UIU_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI"
            cursor cpk_dati_metrici(var_ID number) is
               select 1
                 from   DATI_METRICI
                where  ID = var_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI"
               if :new.ID is not null then
                  open  cpk_dati_metrici(:new.ID);
                  fetch cpk_dati_metrici into dummy;
                  found := cpk_dati_metrici%FOUND;
                  close cpk_dati_metrici;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID||
                               '" gia'' presente in DATI_METRICI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_TIU */
/

-- Procedure DATI_METRICI_DATI_ATTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_DATI_ATTO

create or replace procedure DATI_METRICI_DATI_ATTO_PI
(new_soggetti_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_SOGGETTI"
   cursor cpk1_dati_metrici_dati_atto(var_soggetti_id number) is
      select 1
      from   DATI_METRICI_SOGGETTI
      where  SOGGETTI_ID = var_soggetti_id
       and   var_soggetti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_SOGGETTI" deve esistere quando si inserisce su "DATI_METRICI_DATI_ATTO"
         if NEW_SOGGETTI_ID is not null then
            open  cpk1_dati_metrici_dati_atto(NEW_SOGGETTI_ID);
            fetch cpk1_dati_metrici_dati_atto into dummy;
            found := cpk1_dati_metrici_dati_atto%FOUND;
            close cpk1_dati_metrici_dati_atto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_SOGGETTI. La registrazione DATI_METRICI_DATI_ATTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_DATI_ATTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_DATI_ATTO
/* End Trigger: DATI_METRICI_DATI_ATTO_TC */

-- Procedure DATI_METRICI_DATI_ATTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_DATI_ATTO

create or replace procedure DATI_METRICI_DATI_ATTO_PU
(old_dati_atto_id IN number,
 old_soggetti_id IN number,
 new_dati_atto_id IN number,
 new_soggetti_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_SOGGETTI"
   cursor cpk1_dati_metrici_dati_atto(var_soggetti_id number) is
      select 1
      from   DATI_METRICI_SOGGETTI
      where  SOGGETTI_ID = var_soggetti_id
       and   var_soggetti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_SOGGETTI" deve esistere quando si modifica "DATI_METRICI_DATI_ATTO"
         if  NEW_SOGGETTI_ID is not null and ( seq = 0 )
         and (   (NEW_SOGGETTI_ID != OLD_SOGGETTI_ID or OLD_SOGGETTI_ID is null) ) then
            open  cpk1_dati_metrici_dati_atto(NEW_SOGGETTI_ID);
            fetch cpk1_dati_metrici_dati_atto into dummy;
            found := cpk1_dati_metrici_dati_atto%FOUND;
            close cpk1_dati_metrici_dati_atto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_SOGGETTI. La registrazione DATI_METRICI_DATI_ATTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_DATI_ATTO_PU */
/

-- Trigger DATI_METRICI_DATI_ATTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_DATI_ATTO

create or replace trigger DATI_METRICI_DATI_ATTO_TIU
before INSERT
    or UPDATE
on DATI_METRICI_DATI_ATTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_DATI_ATTO_PU(:OLD.DATI_ATTO_ID,
                                   :OLD.SOGGETTI_ID,
                         :NEW.DATI_ATTO_ID,
                         :NEW.SOGGETTI_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_DATI_ATTO_PI(:NEW.SOGGETTI_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_DATI_ATTO"
            cursor cpk_dati_metrici_dati_atto(var_DATI_ATTO_ID number) is
               select 1
                 from   DATI_METRICI_DATI_ATTO
                where  DATI_ATTO_ID = var_DATI_ATTO_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_DATI_ATTO"
               if :new.DATI_ATTO_ID is not null then
                  open  cpk_dati_metrici_dati_atto(:new.DATI_ATTO_ID);
                  fetch cpk_dati_metrici_dati_atto into dummy;
                  found := cpk_dati_metrici_dati_atto%FOUND;
                  close cpk_dati_metrici_dati_atto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DATI_ATTO_ID||
                               '" gia'' presente in DATI_METRICI_DATI_ATTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_DATI_ATTO_TIU */
/

-- Procedure DATI_METRICI_DATI_NUOVI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_DATI_NUOVI

create or replace procedure DATI_METRICI_DATI_NUOVI_PI
(new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_dati_nuovi(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si inserisce su "DATI_METRICI_DATI_NUOVI"
         if NEW_UIU_ID is not null then
            open  cpk1_dati_metrici_dati_nuovi(NEW_UIU_ID);
            fetch cpk1_dati_metrici_dati_nuovi into dummy;
            found := cpk1_dati_metrici_dati_nuovi%FOUND;
            close cpk1_dati_metrici_dati_nuovi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_DATI_NUOVI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_DATI_NUOVI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_DATI_NUOVI
/* End Trigger: DATI_METRICI_DATI_NUOVI_TC */

-- Procedure DATI_METRICI_DATI_NUOVI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_DATI_NUOVI

create or replace procedure DATI_METRICI_DATI_NUOVI_PU
(old_dati_nuovi_id IN number,
 old_uiu_id IN number,
 new_dati_nuovi_id IN number,
 new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_dati_nuovi(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si modifica "DATI_METRICI_DATI_NUOVI"
         if  NEW_UIU_ID is not null and ( seq = 0 )
         and (   (NEW_UIU_ID != OLD_UIU_ID or OLD_UIU_ID is null) ) then
            open  cpk1_dati_metrici_dati_nuovi(NEW_UIU_ID);
            fetch cpk1_dati_metrici_dati_nuovi into dummy;
            found := cpk1_dati_metrici_dati_nuovi%FOUND;
            close cpk1_dati_metrici_dati_nuovi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_DATI_NUOVI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_DATI_NUOVI_PU */
/

-- Trigger DATI_METRICI_DATI_NUOVI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_DATI_NUOVI

create or replace trigger DATI_METRICI_DATI_NUOVI_TIU
before INSERT
    or UPDATE
on DATI_METRICI_DATI_NUOVI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_DATI_NUOVI_PU(:OLD.DATI_NUOVI_ID,
                                    :OLD.UIU_ID,
                         :NEW.DATI_NUOVI_ID,
                         :NEW.UIU_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_DATI_NUOVI_PI(:NEW.UIU_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_DATI_NUOVI"
            cursor cpk_dati_metrici_dati_nuovi(var_DATI_NUOVI_ID number) is
               select 1
                 from   DATI_METRICI_DATI_NUOVI
                where  DATI_NUOVI_ID = var_DATI_NUOVI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_DATI_NUOVI"
               if :new.DATI_NUOVI_ID is not null then
                  open  cpk_dati_metrici_dati_nuovi(:new.DATI_NUOVI_ID);
                  fetch cpk_dati_metrici_dati_nuovi into dummy;
                  found := cpk_dati_metrici_dati_nuovi%FOUND;
                  close cpk_dati_metrici_dati_nuovi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DATI_NUOVI_ID||
                               '" gia'' presente in DATI_METRICI_DATI_NUOVI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_DATI_NUOVI_TIU */
/

-- Procedure DATI_METRICI_ESITI_AGENZIA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_ESITI_AGENZIA

create or replace procedure DATI_METRICI_ESITI_AGENZIA_PI
(new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_esiti_agenzi(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si inserisce su "DATI_METRICI_ESITI_AGENZIA"
         if NEW_UIU_ID is not null then
            open  cpk1_dati_metrici_esiti_agenzi(NEW_UIU_ID);
            fetch cpk1_dati_metrici_esiti_agenzi into dummy;
            found := cpk1_dati_metrici_esiti_agenzi%FOUND;
            close cpk1_dati_metrici_esiti_agenzi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_ESITI_AGENZIA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_ESITI_AGENZIA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_ESITI_AGENZIA
/* End Trigger: DATI_METRICI_ESITI_AGENZIA_TC */

-- Procedure DATI_METRICI_ESITI_AGENZIA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_ESITI_AGENZIA

create or replace procedure DATI_METRICI_ESITI_AGENZIA_PU
(old_esiti_agenzia_id IN number,
 old_uiu_id IN number,
 new_esiti_agenzia_id IN number,
 new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_esiti_agenzi(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si modifica "DATI_METRICI_ESITI_AGENZIA"
         if  NEW_UIU_ID is not null and ( seq = 0 )
         and (   (NEW_UIU_ID != OLD_UIU_ID or OLD_UIU_ID is null) ) then
            open  cpk1_dati_metrici_esiti_agenzi(NEW_UIU_ID);
            fetch cpk1_dati_metrici_esiti_agenzi into dummy;
            found := cpk1_dati_metrici_esiti_agenzi%FOUND;
            close cpk1_dati_metrici_esiti_agenzi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_ESITI_AGENZIA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_ESITI_AGENZIA_PU */
/

-- Trigger DATI_METRICI_ESITI_AGENZIA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_ESITI_AGENZIA

create or replace trigger DATI_METRICI_ESITI_AGENZIA_TIU
before INSERT
    or UPDATE
on DATI_METRICI_ESITI_AGENZIA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_ESITI_AGENZIA_PU(:OLD.ESITI_AGENZIA_ID,
                                       :OLD.UIU_ID,
                         :NEW.ESITI_AGENZIA_ID,
                         :NEW.UIU_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_ESITI_AGENZIA_PI(:NEW.UIU_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_ESITI_AGENZIA"
            cursor cpk_dati_metrici_esiti_agenzi(var_ESITI_AGENZIA_ID number) is
               select 1
                 from   DATI_METRICI_ESITI_AGENZIA
                where  ESITI_AGENZIA_ID = var_ESITI_AGENZIA_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_ESITI_AGENZIA"
               if :new.ESITI_AGENZIA_ID is not null then
                  open  cpk_dati_metrici_esiti_agenzi(:new.ESITI_AGENZIA_ID);
                  fetch cpk_dati_metrici_esiti_agenzi into dummy;
                  found := cpk_dati_metrici_esiti_agenzi%FOUND;
                  close cpk_dati_metrici_esiti_agenzi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ESITI_AGENZIA_ID||
                               '" gia'' presente in DATI_METRICI_ESITI_AGENZIA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_ESITI_AGENZIA_TIU */
/

-- Procedure DATI_METRICI_ESITI_COMUNE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_ESITI_COMUNE

create or replace procedure DATI_METRICI_ESITI_COMUNE_PI
(new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_esiti_comune(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si inserisce su "DATI_METRICI_ESITI_COMUNE"
         if NEW_UIU_ID is not null then
            open  cpk1_dati_metrici_esiti_comune(NEW_UIU_ID);
            fetch cpk1_dati_metrici_esiti_comune into dummy;
            found := cpk1_dati_metrici_esiti_comune%FOUND;
            close cpk1_dati_metrici_esiti_comune;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_ESITI_COMUNE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_ESITI_COMUNE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_ESITI_COMUNE
/* End Trigger: DATI_METRICI_ESITI_COMUNE_TC */

-- Procedure DATI_METRICI_ESITI_COMUNE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_ESITI_COMUNE

create or replace procedure DATI_METRICI_ESITI_COMUNE_PU
(old_esiti_comune_id IN number,
 old_uiu_id IN number,
 new_esiti_comune_id IN number,
 new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_esiti_comune(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si modifica "DATI_METRICI_ESITI_COMUNE"
         if  NEW_UIU_ID is not null and ( seq = 0 )
         and (   (NEW_UIU_ID != OLD_UIU_ID or OLD_UIU_ID is null) ) then
            open  cpk1_dati_metrici_esiti_comune(NEW_UIU_ID);
            fetch cpk1_dati_metrici_esiti_comune into dummy;
            found := cpk1_dati_metrici_esiti_comune%FOUND;
            close cpk1_dati_metrici_esiti_comune;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_ESITI_COMUNE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_ESITI_COMUNE_PU */
/

-- Trigger DATI_METRICI_ESITI_COMUNE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_ESITI_COMUNE

create or replace trigger DATI_METRICI_ESITI_COMUNE_TIU
before INSERT
    or UPDATE
on DATI_METRICI_ESITI_COMUNE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_ESITI_COMUNE_PU(:OLD.ESITI_COMUNE_ID,
                                      :OLD.UIU_ID,
                         :NEW.ESITI_COMUNE_ID,
                         :NEW.UIU_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_ESITI_COMUNE_PI(:NEW.UIU_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_ESITI_COMUNE"
            cursor cpk_dati_metrici_esiti_comune(var_ESITI_COMUNE_ID number) is
               select 1
                 from   DATI_METRICI_ESITI_COMUNE
                where  ESITI_COMUNE_ID = var_ESITI_COMUNE_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_ESITI_COMUNE"
               if :new.ESITI_COMUNE_ID is not null then
                  open  cpk_dati_metrici_esiti_comune(:new.ESITI_COMUNE_ID);
                  fetch cpk_dati_metrici_esiti_comune into dummy;
                  found := cpk_dati_metrici_esiti_comune%FOUND;
                  close cpk_dati_metrici_esiti_comune;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ESITI_COMUNE_ID||
                               '" gia'' presente in DATI_METRICI_ESITI_COMUNE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_ESITI_COMUNE_TIU */
/

-- Procedure DATI_METRICI_IDENTIFICATIVI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_IDENTIFICATIVI

create or replace procedure DATI_METRICI_IDENTIFICATIVI_PI
(new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_identificati(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si inserisce su "DATI_METRICI_IDENTIFICATIVI"
         if NEW_UIU_ID is not null then
            open  cpk1_dati_metrici_identificati(NEW_UIU_ID);
            fetch cpk1_dati_metrici_identificati into dummy;
            found := cpk1_dati_metrici_identificati%FOUND;
            close cpk1_dati_metrici_identificati;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_IDENTIFICATIVI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_IDENTIFICATIVI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_IDENTIFICATIVI
/* End Trigger: DATI_METRICI_IDENTIFICATIVI_TC */

-- Procedure DATI_METRICI_IDENTIFICATIVI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_IDENTIFICATIVI

create or replace procedure DATI_METRICI_IDENTIFICATIVI_PU
(old_identificativi_id IN number,
 old_uiu_id IN number,
 new_identificativi_id IN number,
 new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_identificati(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si modifica "DATI_METRICI_IDENTIFICATIVI"
         if  NEW_UIU_ID is not null and ( seq = 0 )
         and (   (NEW_UIU_ID != OLD_UIU_ID or OLD_UIU_ID is null) ) then
            open  cpk1_dati_metrici_identificati(NEW_UIU_ID);
            fetch cpk1_dati_metrici_identificati into dummy;
            found := cpk1_dati_metrici_identificati%FOUND;
            close cpk1_dati_metrici_identificati;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_IDENTIFICATIVI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_IDENTIFICATIVI_PU */
/

-- Trigger DATI_METRICI_IDENTIFICATIV_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_IDENTIFICATIVI

create or replace trigger DATI_METRICI_IDENTIFICATIV_TIU
before INSERT
    or UPDATE
on DATI_METRICI_IDENTIFICATIVI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_IDENTIFICATIVI_PU(:OLD.IDENTIFICATIVI_ID,
                                        :OLD.UIU_ID,
                         :NEW.IDENTIFICATIVI_ID,
                         :NEW.UIU_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_IDENTIFICATIVI_PI(:NEW.UIU_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_IDENTIFICATIVI"
            cursor cpk_dati_metrici_identificati(var_IDENTIFICATIVI_ID number) is
               select 1
                 from   DATI_METRICI_IDENTIFICATIVI
                where  IDENTIFICATIVI_ID = var_IDENTIFICATIVI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_IDENTIFICATIVI"
               if :new.IDENTIFICATIVI_ID is not null then
                  open  cpk_dati_metrici_identificati(:new.IDENTIFICATIVI_ID);
                  fetch cpk_dati_metrici_identificati into dummy;
                  found := cpk_dati_metrici_identificati%FOUND;
                  close cpk_dati_metrici_identificati;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.IDENTIFICATIVI_ID||
                               '" gia'' presente in DATI_METRICI_IDENTIFICATIVI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_IDENTIFICATIV_TIU */
/

-- Procedure DATI_METRICI_INDIRIZZI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_INDIRIZZI

create or replace procedure DATI_METRICI_INDIRIZZI_PI
(new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_indirizzi(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si inserisce su "DATI_METRICI_INDIRIZZI"
         if NEW_UIU_ID is not null then
            open  cpk1_dati_metrici_indirizzi(NEW_UIU_ID);
            fetch cpk1_dati_metrici_indirizzi into dummy;
            found := cpk1_dati_metrici_indirizzi%FOUND;
            close cpk1_dati_metrici_indirizzi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_INDIRIZZI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_INDIRIZZI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_INDIRIZZI
/* End Trigger: DATI_METRICI_INDIRIZZI_TC */

-- Procedure DATI_METRICI_INDIRIZZI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_INDIRIZZI

create or replace procedure DATI_METRICI_INDIRIZZI_PU
(old_indirizzi_id IN number,
 old_uiu_id IN number,
 new_indirizzi_id IN number,
 new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_indirizzi(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si modifica "DATI_METRICI_INDIRIZZI"
         if  NEW_UIU_ID is not null and ( seq = 0 )
         and (   (NEW_UIU_ID != OLD_UIU_ID or OLD_UIU_ID is null) ) then
            open  cpk1_dati_metrici_indirizzi(NEW_UIU_ID);
            fetch cpk1_dati_metrici_indirizzi into dummy;
            found := cpk1_dati_metrici_indirizzi%FOUND;
            close cpk1_dati_metrici_indirizzi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_INDIRIZZI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_INDIRIZZI_PU */
/

-- Trigger DATI_METRICI_INDIRIZZI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_INDIRIZZI

create or replace trigger DATI_METRICI_INDIRIZZI_TIU
before INSERT
    or UPDATE
on DATI_METRICI_INDIRIZZI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_INDIRIZZI_PU(:OLD.INDIRIZZI_ID,
                                   :OLD.UIU_ID,
                         :NEW.INDIRIZZI_ID,
                         :NEW.UIU_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_INDIRIZZI_PI(:NEW.UIU_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_INDIRIZZI"
            cursor cpk_dati_metrici_indirizzi(var_INDIRIZZI_ID number) is
               select 1
                 from   DATI_METRICI_INDIRIZZI
                where  INDIRIZZI_ID = var_INDIRIZZI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_INDIRIZZI"
               if :new.INDIRIZZI_ID is not null then
                  open  cpk_dati_metrici_indirizzi(:new.INDIRIZZI_ID);
                  fetch cpk_dati_metrici_indirizzi into dummy;
                  found := cpk_dati_metrici_indirizzi%FOUND;
                  close cpk_dati_metrici_indirizzi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.INDIRIZZI_ID||
                               '" gia'' presente in DATI_METRICI_INDIRIZZI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_INDIRIZZI_TIU */
/

-- Procedure DATI_METRICI_SOGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_SOGGETTI

create or replace procedure DATI_METRICI_SOGGETTI_PI
(new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_soggetti(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si inserisce su "DATI_METRICI_SOGGETTI"
         if NEW_UIU_ID is not null then
            open  cpk1_dati_metrici_soggetti(NEW_UIU_ID);
            fetch cpk1_dati_metrici_soggetti into dummy;
            found := cpk1_dati_metrici_soggetti%FOUND;
            close cpk1_dati_metrici_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_SOGGETTI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_SOGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_SOGGETTI
/* End Trigger: DATI_METRICI_SOGGETTI_TC */

-- Procedure DATI_METRICI_SOGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_SOGGETTI

create or replace procedure DATI_METRICI_SOGGETTI_PU
(old_soggetti_id IN number,
 old_uiu_id IN number,
 new_soggetti_id IN number,
 new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_soggetti(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_DATI_ATTO"
   cursor cfk1_dati_metrici_soggetti(var_soggetti_id number) is
      select 1
      from   DATI_METRICI_DATI_ATTO
      where  SOGGETTI_ID = var_soggetti_id
       and   var_soggetti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si modifica "DATI_METRICI_SOGGETTI"
         if  NEW_UIU_ID is not null and ( seq = 0 )
         and (   (NEW_UIU_ID != OLD_UIU_ID or OLD_UIU_ID is null) ) then
            open  cpk1_dati_metrici_soggetti(NEW_UIU_ID);
            fetch cpk1_dati_metrici_soggetti into dummy;
            found := cpk1_dati_metrici_soggetti%FOUND;
            close cpk1_dati_metrici_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_SOGGETTI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DATI_METRICI_SOGGETTI" non modificabile se esistono referenze su "DATI_METRICI_DATI_ATTO"
      if (OLD_SOGGETTI_ID != NEW_SOGGETTI_ID) then
         open  cfk1_dati_metrici_soggetti(OLD_SOGGETTI_ID);
         fetch cfk1_dati_metrici_soggetti into dummy;
         found := cfk1_dati_metrici_soggetti%FOUND;
         close cfk1_dati_metrici_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_DATI_ATTO. La registrazione di DATI_METRICI_SOGGETTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_SOGGETTI_PU */
/

-- Trigger DATI_METRICI_SOGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_SOGGETTI

create or replace trigger DATI_METRICI_SOGGETTI_TIU
before INSERT
    or UPDATE
on DATI_METRICI_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_SOGGETTI_PU(:OLD.SOGGETTI_ID,
                                  :OLD.UIU_ID,
                         :NEW.SOGGETTI_ID,
                         :NEW.UIU_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_SOGGETTI_PI(:NEW.UIU_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_SOGGETTI"
            cursor cpk_dati_metrici_soggetti(var_SOGGETTI_ID number) is
               select 1
                 from   DATI_METRICI_SOGGETTI
                where  SOGGETTI_ID = var_SOGGETTI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_SOGGETTI"
               if :new.SOGGETTI_ID is not null then
                  open  cpk_dati_metrici_soggetti(:new.SOGGETTI_ID);
                  fetch cpk_dati_metrici_soggetti into dummy;
                  found := cpk_dati_metrici_soggetti%FOUND;
                  close cpk_dati_metrici_soggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.SOGGETTI_ID||
                               '" gia'' presente in DATI_METRICI_SOGGETTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_SOGGETTI_TIU */
/

-- Procedure DATI_METRICI_SOGGETTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table DATI_METRICI_SOGGETTI

create or replace procedure DATI_METRICI_SOGGETTI_PD
(old_soggetti_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_DATI_ATTO"
   cursor cfk1_dati_metrici_soggetti(var_soggetti_id number) is
      select 1
      from   DATI_METRICI_DATI_ATTO
      where  SOGGETTI_ID = var_soggetti_id
       and   var_soggetti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "DATI_METRICI_SOGGETTI" if children still exist in "DATI_METRICI_DATI_ATTO"
      open  cfk1_dati_metrici_soggetti(OLD_SOGGETTI_ID);
      fetch cfk1_dati_metrici_soggetti into dummy;
      found := cfk1_dati_metrici_soggetti%FOUND;
      close cfk1_dati_metrici_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_DATI_ATTO. La registrazione di DATI_METRICI_SOGGETTI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_SOGGETTI_PD */
/

-- Tigger DATI_METRICI_SOGGETTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DATI_METRICI_SOGGETTI

create or replace trigger DATI_METRICI_SOGGETTI_TD
before DELETE
on DATI_METRICI_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DATI_METRICI_DATI_ATTO

      DATI_METRICI_SOGGETTI_PD(:OLD.SOGGETTI_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_SOGGETTI_TD */
/

-- Procedure DATI_METRICI_TESTATE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_TESTATE

create or replace procedure DATI_METRICI_TESTATE_PI
(new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk1_dati_metrici_testate(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "DATI_METRICI_TESTATE"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk1_dati_metrici_testate(NEW_DOCUMENTO_ID);
            fetch cpk1_dati_metrici_testate into dummy;
            found := cpk1_dati_metrici_testate%FOUND;
            close cpk1_dati_metrici_testate;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione DATI_METRICI_TESTATE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_TESTATE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_TESTATE
/* End Trigger: DATI_METRICI_TESTATE_TC */

-- Procedure DATI_METRICI_TESTATE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_TESTATE

create or replace procedure DATI_METRICI_TESTATE_PU
(old_testate_id IN number,
 old_documento_id IN number,
 new_testate_id IN number,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk1_dati_metrici_testate(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_UIU"
   cursor cfk1_dati_metrici_testate(var_testate_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  TESTATE_ID = var_testate_id
       and   var_testate_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "DATI_METRICI_TESTATE"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk1_dati_metrici_testate(NEW_DOCUMENTO_ID);
            fetch cpk1_dati_metrici_testate into dummy;
            found := cpk1_dati_metrici_testate%FOUND;
            close cpk1_dati_metrici_testate;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione DATI_METRICI_TESTATE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile sul figlio: "DATI_METRICI_TESTATE"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di DOCUMENTI_CARICATI non e'' modificabile su DATI_METRICI_TESTATE.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DATI_METRICI_TESTATE" non modificabile se esistono referenze su "DATI_METRICI_UIU"
      if (OLD_TESTATE_ID != NEW_TESTATE_ID) then
         open  cfk1_dati_metrici_testate(OLD_TESTATE_ID);
         fetch cfk1_dati_metrici_testate into dummy;
         found := cfk1_dati_metrici_testate%FOUND;
         close cfk1_dati_metrici_testate;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_UIU. La registrazione di DATI_METRICI_TESTATE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_TESTATE_PU */
/

-- Trigger DATI_METRICI_TESTATE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_TESTATE

create or replace trigger DATI_METRICI_TESTATE_TIU
before INSERT
    or UPDATE
on DATI_METRICI_TESTATE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_TESTATE_PU(:OLD.TESTATE_ID,
                                 :OLD.DOCUMENTO_ID,
                         :NEW.TESTATE_ID,
                         :NEW.DOCUMENTO_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_TESTATE_PI(:NEW.DOCUMENTO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_TESTATE"
            cursor cpk_dati_metrici_testate(var_TESTATE_ID number) is
               select 1
                 from   DATI_METRICI_TESTATE
                where  TESTATE_ID = var_TESTATE_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_TESTATE"
               if :new.TESTATE_ID is not null then
                  open  cpk_dati_metrici_testate(:new.TESTATE_ID);
                  fetch cpk_dati_metrici_testate into dummy;
                  found := cpk_dati_metrici_testate%FOUND;
                  close cpk_dati_metrici_testate;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TESTATE_ID||
                               '" gia'' presente in DATI_METRICI_TESTATE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_TESTATE_TIU */
/

-- Procedure DATI_METRICI_TESTATE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table DATI_METRICI_TESTATE

create or replace procedure DATI_METRICI_TESTATE_PD
(old_testate_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_UIU"
   cursor cfk1_dati_metrici_testate(var_testate_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  TESTATE_ID = var_testate_id
       and   var_testate_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "DATI_METRICI_TESTATE" if children still exist in "DATI_METRICI_UIU"
      open  cfk1_dati_metrici_testate(OLD_TESTATE_ID);
      fetch cfk1_dati_metrici_testate into dummy;
      found := cfk1_dati_metrici_testate%FOUND;
      close cfk1_dati_metrici_testate;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_UIU. La registrazione di DATI_METRICI_TESTATE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_TESTATE_PD */
/

-- Tigger DATI_METRICI_TESTATE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DATI_METRICI_TESTATE

create or replace trigger DATI_METRICI_TESTATE_TD
before DELETE
on DATI_METRICI_TESTATE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DATI_METRICI_UIU

      DATI_METRICI_TESTATE_PD(:OLD.TESTATE_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_TESTATE_TD */
/

-- Procedure DATI_METRICI_UBICAZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_UBICAZIONI

create or replace procedure DATI_METRICI_UBICAZIONI_PI
(new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_ubicazioni(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si inserisce su "DATI_METRICI_UBICAZIONI"
         if NEW_UIU_ID is not null then
            open  cpk1_dati_metrici_ubicazioni(NEW_UIU_ID);
            fetch cpk1_dati_metrici_ubicazioni into dummy;
            found := cpk1_dati_metrici_ubicazioni%FOUND;
            close cpk1_dati_metrici_ubicazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_UBICAZIONI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_UBICAZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_UBICAZIONI
/* End Trigger: DATI_METRICI_UBICAZIONI_TC */

-- Procedure DATI_METRICI_UBICAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_UBICAZIONI

create or replace procedure DATI_METRICI_UBICAZIONI_PU
(old_ubicazioni_id IN number,
 old_uiu_id IN number,
 new_ubicazioni_id IN number,
 new_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_UIU"
   cursor cpk1_dati_metrici_ubicazioni(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UIU
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_UIU" deve esistere quando si modifica "DATI_METRICI_UBICAZIONI"
         if  NEW_UIU_ID is not null and ( seq = 0 )
         and (   (NEW_UIU_ID != OLD_UIU_ID or OLD_UIU_ID is null) ) then
            open  cpk1_dati_metrici_ubicazioni(NEW_UIU_ID);
            fetch cpk1_dati_metrici_ubicazioni into dummy;
            found := cpk1_dati_metrici_ubicazioni%FOUND;
            close cpk1_dati_metrici_ubicazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_UIU. La registrazione DATI_METRICI_UBICAZIONI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_UBICAZIONI_PU */
/

-- Trigger DATI_METRICI_UBICAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_UBICAZIONI

create or replace trigger DATI_METRICI_UBICAZIONI_TIU
before INSERT
    or UPDATE
on DATI_METRICI_UBICAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_UBICAZIONI_PU(:OLD.UBICAZIONI_ID,
                                    :OLD.UIU_ID,
                         :NEW.UBICAZIONI_ID,
                         :NEW.UIU_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_UBICAZIONI_PI(:NEW.UIU_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_UBICAZIONI"
            cursor cpk_dati_metrici_ubicazioni(var_UBICAZIONI_ID number) is
               select 1
                 from   DATI_METRICI_UBICAZIONI
                where  UBICAZIONI_ID = var_UBICAZIONI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_UBICAZIONI"
               if :new.UBICAZIONI_ID is not null then
                  open  cpk_dati_metrici_ubicazioni(:new.UBICAZIONI_ID);
                  fetch cpk_dati_metrici_ubicazioni into dummy;
                  found := cpk_dati_metrici_ubicazioni%FOUND;
                  close cpk_dati_metrici_ubicazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.UBICAZIONI_ID||
                               '" gia'' presente in DATI_METRICI_UBICAZIONI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_UBICAZIONI_TIU */
/

-- Procedure DATI_METRICI_UIU_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DATI_METRICI_UIU

create or replace procedure DATI_METRICI_UIU_PI
(new_testate_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DATI_METRICI_TESTATE"
   cursor cpk1_dati_metrici_uiu(var_testate_id number) is
      select 1
      from   DATI_METRICI_TESTATE
      where  TESTATE_ID = var_testate_id
       and   var_testate_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DATI_METRICI_TESTATE" deve esistere quando si inserisce su "DATI_METRICI_UIU"
         if NEW_TESTATE_ID is not null then
            open  cpk1_dati_metrici_uiu(NEW_TESTATE_ID);
            fetch cpk1_dati_metrici_uiu into dummy;
            found := cpk1_dati_metrici_uiu%FOUND;
            close cpk1_dati_metrici_uiu;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DATI_METRICI_TESTATE. La registrazione DATI_METRICI_UIU non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_UIU_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DATI_METRICI_UIU
/* End Trigger: DATI_METRICI_UIU_TC */

-- Procedure DATI_METRICI_UIU_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DATI_METRICI_UIU

create or replace procedure DATI_METRICI_UIU_PU
(old_uiu_id IN number,
 old_testate_id IN number,
 new_uiu_id IN number,
 new_testate_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DATI_METRICI_TESTATE"
   cursor cpk1_dati_metrici_uiu(var_testate_id number) is
      select 1
      from   DATI_METRICI_TESTATE
      where  TESTATE_ID = var_testate_id
       and   var_testate_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI"
   cursor cfk1_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_SOGGETTI"
   cursor cfk2_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_SOGGETTI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_DATI_NUOVI"
   cursor cfk3_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_DATI_NUOVI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_ESITI_AGENZIA"
   cursor cfk4_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_ESITI_AGENZIA
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_ESITI_COMUNE"
   cursor cfk5_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_ESITI_COMUNE
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_IDENTIFICATIVI"
   cursor cfk6_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_IDENTIFICATIVI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_INDIRIZZI"
   cursor cfk7_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_INDIRIZZI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_UBICAZIONI"
   cursor cfk8_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UBICAZIONI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DATI_METRICI_TESTATE" deve esistere quando si modifica "DATI_METRICI_UIU"
         if  NEW_TESTATE_ID is not null and ( seq = 0 )
         and (   (NEW_TESTATE_ID != OLD_TESTATE_ID or OLD_TESTATE_ID is null) ) then
            open  cpk1_dati_metrici_uiu(NEW_TESTATE_ID);
            fetch cpk1_dati_metrici_uiu into dummy;
            found := cpk1_dati_metrici_uiu%FOUND;
            close cpk1_dati_metrici_uiu;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DATI_METRICI_TESTATE. La registrazione DATI_METRICI_UIU non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DATI_METRICI_UIU" non modificabile se esistono referenze su "DATI_METRICI"
      if (OLD_UIU_ID != NEW_UIU_ID) then
         open  cfk1_dati_metrici_uiu(OLD_UIU_ID);
         fetch cfk1_dati_metrici_uiu into dummy;
         found := cfk1_dati_metrici_uiu%FOUND;
         close cfk1_dati_metrici_uiu;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI. La registrazione di DATI_METRICI_UIU non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DATI_METRICI_UIU" non modificabile se esistono referenze su "DATI_METRICI_SOGGETTI"
      if (OLD_UIU_ID != NEW_UIU_ID) then
         open  cfk2_dati_metrici_uiu(OLD_UIU_ID);
         fetch cfk2_dati_metrici_uiu into dummy;
         found := cfk2_dati_metrici_uiu%FOUND;
         close cfk2_dati_metrici_uiu;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_SOGGETTI. La registrazione di DATI_METRICI_UIU non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DATI_METRICI_UIU" non modificabile se esistono referenze su "DATI_METRICI_DATI_NUOVI"
      if (OLD_UIU_ID != NEW_UIU_ID) then
         open  cfk3_dati_metrici_uiu(OLD_UIU_ID);
         fetch cfk3_dati_metrici_uiu into dummy;
         found := cfk3_dati_metrici_uiu%FOUND;
         close cfk3_dati_metrici_uiu;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_DATI_NUOVI. La registrazione di DATI_METRICI_UIU non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DATI_METRICI_UIU" non modificabile se esistono referenze su "DATI_METRICI_ESITI_AGENZIA"
      if (OLD_UIU_ID != NEW_UIU_ID) then
         open  cfk4_dati_metrici_uiu(OLD_UIU_ID);
         fetch cfk4_dati_metrici_uiu into dummy;
         found := cfk4_dati_metrici_uiu%FOUND;
         close cfk4_dati_metrici_uiu;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_ESITI_AGENZIA. La registrazione di DATI_METRICI_UIU non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DATI_METRICI_UIU" non modificabile se esistono referenze su "DATI_METRICI_ESITI_COMUNE"
      if (OLD_UIU_ID != NEW_UIU_ID) then
         open  cfk5_dati_metrici_uiu(OLD_UIU_ID);
         fetch cfk5_dati_metrici_uiu into dummy;
         found := cfk5_dati_metrici_uiu%FOUND;
         close cfk5_dati_metrici_uiu;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_ESITI_COMUNE. La registrazione di DATI_METRICI_UIU non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DATI_METRICI_UIU" non modificabile se esistono referenze su "DATI_METRICI_IDENTIFICATIVI"
      if (OLD_UIU_ID != NEW_UIU_ID) then
         open  cfk6_dati_metrici_uiu(OLD_UIU_ID);
         fetch cfk6_dati_metrici_uiu into dummy;
         found := cfk6_dati_metrici_uiu%FOUND;
         close cfk6_dati_metrici_uiu;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_IDENTIFICATIVI. La registrazione di DATI_METRICI_UIU non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DATI_METRICI_UIU" non modificabile se esistono referenze su "DATI_METRICI_INDIRIZZI"
      if (OLD_UIU_ID != NEW_UIU_ID) then
         open  cfk7_dati_metrici_uiu(OLD_UIU_ID);
         fetch cfk7_dati_metrici_uiu into dummy;
         found := cfk7_dati_metrici_uiu%FOUND;
         close cfk7_dati_metrici_uiu;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_INDIRIZZI. La registrazione di DATI_METRICI_UIU non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DATI_METRICI_UIU" non modificabile se esistono referenze su "DATI_METRICI_UBICAZIONI"
      if (OLD_UIU_ID != NEW_UIU_ID) then
         open  cfk8_dati_metrici_uiu(OLD_UIU_ID);
         fetch cfk8_dati_metrici_uiu into dummy;
         found := cfk8_dati_metrici_uiu%FOUND;
         close cfk8_dati_metrici_uiu;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_UBICAZIONI. La registrazione di DATI_METRICI_UIU non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_UIU_PU */
/

-- Trigger DATI_METRICI_UIU_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DATI_METRICI_UIU

create or replace trigger DATI_METRICI_UIU_TIU
before INSERT
    or UPDATE
on DATI_METRICI_UIU
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DATI_METRICI_UIU_PU(:OLD.UIU_ID,
                             :OLD.TESTATE_ID,
                         :NEW.UIU_ID,
                         :NEW.TESTATE_ID);
         null;
      end if;
      if INSERTING then
         DATI_METRICI_UIU_PI(:NEW.TESTATE_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DATI_METRICI_UIU"
            cursor cpk_dati_metrici_uiu(var_UIU_ID number) is
               select 1
                 from   DATI_METRICI_UIU
                where  UIU_ID = var_UIU_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DATI_METRICI_UIU"
               if :new.UIU_ID is not null then
                  open  cpk_dati_metrici_uiu(:new.UIU_ID);
                  fetch cpk_dati_metrici_uiu into dummy;
                  found := cpk_dati_metrici_uiu%FOUND;
                  close cpk_dati_metrici_uiu;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.UIU_ID||
                               '" gia'' presente in DATI_METRICI_UIU. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_UIU_TIU */
/

-- Procedure DATI_METRICI_UIU_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table DATI_METRICI_UIU

create or replace procedure DATI_METRICI_UIU_PD
(old_uiu_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI"
   cursor cfk1_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_SOGGETTI"
   cursor cfk2_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_SOGGETTI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_DATI_NUOVI"
   cursor cfk3_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_DATI_NUOVI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_ESITI_AGENZIA"
   cursor cfk4_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_ESITI_AGENZIA
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_ESITI_COMUNE"
   cursor cfk5_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_ESITI_COMUNE
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_IDENTIFICATIVI"
   cursor cfk6_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_IDENTIFICATIVI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_INDIRIZZI"
   cursor cfk7_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_INDIRIZZI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_UBICAZIONI"
   cursor cfk8_dati_metrici_uiu(var_uiu_id number) is
      select 1
      from   DATI_METRICI_UBICAZIONI
      where  UIU_ID = var_uiu_id
       and   var_uiu_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "DATI_METRICI_UIU" if children still exist in "DATI_METRICI"
      open  cfk1_dati_metrici_uiu(OLD_UIU_ID);
      fetch cfk1_dati_metrici_uiu into dummy;
      found := cfk1_dati_metrici_uiu%FOUND;
      close cfk1_dati_metrici_uiu;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI. La registrazione di DATI_METRICI_UIU non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DATI_METRICI_UIU" if children still exist in "DATI_METRICI_SOGGETTI"
      open  cfk2_dati_metrici_uiu(OLD_UIU_ID);
      fetch cfk2_dati_metrici_uiu into dummy;
      found := cfk2_dati_metrici_uiu%FOUND;
      close cfk2_dati_metrici_uiu;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_SOGGETTI. La registrazione di DATI_METRICI_UIU non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DATI_METRICI_UIU" if children still exist in "DATI_METRICI_DATI_NUOVI"
      open  cfk3_dati_metrici_uiu(OLD_UIU_ID);
      fetch cfk3_dati_metrici_uiu into dummy;
      found := cfk3_dati_metrici_uiu%FOUND;
      close cfk3_dati_metrici_uiu;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_DATI_NUOVI. La registrazione di DATI_METRICI_UIU non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DATI_METRICI_UIU" if children still exist in "DATI_METRICI_ESITI_AGENZIA"
      open  cfk4_dati_metrici_uiu(OLD_UIU_ID);
      fetch cfk4_dati_metrici_uiu into dummy;
      found := cfk4_dati_metrici_uiu%FOUND;
      close cfk4_dati_metrici_uiu;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_ESITI_AGENZIA. La registrazione di DATI_METRICI_UIU non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DATI_METRICI_UIU" if children still exist in "DATI_METRICI_ESITI_COMUNE"
      open  cfk5_dati_metrici_uiu(OLD_UIU_ID);
      fetch cfk5_dati_metrici_uiu into dummy;
      found := cfk5_dati_metrici_uiu%FOUND;
      close cfk5_dati_metrici_uiu;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_ESITI_COMUNE. La registrazione di DATI_METRICI_UIU non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DATI_METRICI_UIU" if children still exist in "DATI_METRICI_IDENTIFICATIVI"
      open  cfk6_dati_metrici_uiu(OLD_UIU_ID);
      fetch cfk6_dati_metrici_uiu into dummy;
      found := cfk6_dati_metrici_uiu%FOUND;
      close cfk6_dati_metrici_uiu;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_IDENTIFICATIVI. La registrazione di DATI_METRICI_UIU non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DATI_METRICI_UIU" if children still exist in "DATI_METRICI_INDIRIZZI"
      open  cfk7_dati_metrici_uiu(OLD_UIU_ID);
      fetch cfk7_dati_metrici_uiu into dummy;
      found := cfk7_dati_metrici_uiu%FOUND;
      close cfk7_dati_metrici_uiu;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_INDIRIZZI. La registrazione di DATI_METRICI_UIU non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DATI_METRICI_UIU" if children still exist in "DATI_METRICI_UBICAZIONI"
      open  cfk8_dati_metrici_uiu(OLD_UIU_ID);
      fetch cfk8_dati_metrici_uiu into dummy;
      found := cfk8_dati_metrici_uiu%FOUND;
      close cfk8_dati_metrici_uiu;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_UBICAZIONI. La registrazione di DATI_METRICI_UIU non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DATI_METRICI_UIU_PD */
/

-- Tigger DATI_METRICI_UIU_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DATI_METRICI_UIU

create or replace trigger DATI_METRICI_UIU_TD
before DELETE
on DATI_METRICI_UIU
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DATI_METRICI

      -- Child Restrict Table: DATI_METRICI_SOGGETTI

      -- Child Restrict Table: DATI_METRICI_DATI_NUOVI

      -- Child Restrict Table: DATI_METRICI_ESITI_AGENZIA

      -- Child Restrict Table: DATI_METRICI_ESITI_COMUNE

      -- Child Restrict Table: DATI_METRICI_IDENTIFICATIVI

      -- Child Restrict Table: DATI_METRICI_INDIRIZZI

      -- Child Restrict Table: DATI_METRICI_UBICAZIONI

      DATI_METRICI_UIU_PD(:OLD.UIU_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DATI_METRICI_UIU_TD */
/

-- Procedure DEBITI_RAVVEDIMENTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DEBITI_RAVVEDIMENTO

create or replace procedure DEBITI_RAVVEDIMENTO_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_debiti_ravvedimento(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "DEBITI_RAVVEDIMENTO"
         if NEW_PRATICA is not null then
            open  cpk1_debiti_ravvedimento(NEW_PRATICA);
            fetch cpk1_debiti_ravvedimento into dummy;
            found := cpk1_debiti_ravvedimento%FOUND;
            close cpk1_debiti_ravvedimento;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione DEBITI_RAVVEDIMENTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DEBITI_RAVVEDIMENTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DEBITI_RAVVEDIMENTO
/* End Trigger: DEBITI_RAVVEDIMENTO_TC */

-- Procedure DEBITI_RAVVEDIMENTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DEBITI_RAVVEDIMENTO

create or replace procedure DEBITI_RAVVEDIMENTO_PU
(old_pratica IN number,
 old_ruolo IN number,
 new_pratica IN number,
 new_ruolo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_debiti_ravvedimento(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "DEBITI_RAVVEDIMENTO"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_debiti_ravvedimento(NEW_PRATICA);
            fetch cpk1_debiti_ravvedimento into dummy;
            found := cpk1_debiti_ravvedimento%FOUND;
            close cpk1_debiti_ravvedimento;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione DEBITI_RAVVEDIMENTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DEBITI_RAVVEDIMENTO_PU */
/

-- Trigger DEBITI_RAVVEDIMENTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DEBITI_RAVVEDIMENTO

create or replace trigger DEBITI_RAVVEDIMENTO_TIU
before INSERT
    or UPDATE
on DEBITI_RAVVEDIMENTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DEBITI_RAVVEDIMENTO_PU(:OLD.PRATICA,
                                :OLD.RUOLO,
                         :NEW.PRATICA,
                         :NEW.RUOLO);
         null;
      end if;
      if INSERTING then
         DEBITI_RAVVEDIMENTO_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DEBITI_RAVVEDIMENTO"
            cursor cpk_debiti_ravvedimento(var_PRATICA number,
                                           var_RUOLO number) is
               select 1
                 from   DEBITI_RAVVEDIMENTO
                where  PRATICA = var_PRATICA and
                       RUOLO = var_RUOLO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DEBITI_RAVVEDIMENTO"
               if :new.PRATICA is not null and
                  :new.RUOLO is not null then
                  open  cpk_debiti_ravvedimento(:new.PRATICA,
                                                :new.RUOLO);
                  fetch cpk_debiti_ravvedimento into dummy;
                  found := cpk_debiti_ravvedimento%FOUND;
                  close cpk_debiti_ravvedimento;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||' '||
                               :new.RUOLO||
                               '" gia'' presente in DEBITI_RAVVEDIMENTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DEBITI_RAVVEDIMENTO_TIU */
/

-- Procedure DELEGHE_BANCARIE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DELEGHE_BANCARIE

create or replace procedure DELEGHE_BANCARIE_PI
(new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_deleghe_bancarie(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_deleghe_bancarie(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "DELEGHE_BANCARIE"
         if NEW_COD_FISCALE is not null then
            open  cpk1_deleghe_bancarie(NEW_COD_FISCALE);
            fetch cpk1_deleghe_bancarie into dummy;
            found := cpk1_deleghe_bancarie%FOUND;
            close cpk1_deleghe_bancarie;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Deleghe Bancarie non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "DELEGHE_BANCARIE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_deleghe_bancarie(NEW_TIPO_TRIBUTO);
            fetch cpk2_deleghe_bancarie into dummy;
            found := cpk2_deleghe_bancarie%FOUND;
            close cpk2_deleghe_bancarie;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Deleghe Bancarie non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DELEGHE_BANCARIE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DELEGHE_BANCARIE
/* End Trigger: DELEGHE_BANCARIE_TC */

-- Procedure DELEGHE_BANCARIE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DELEGHE_BANCARIE

create or replace procedure DELEGHE_BANCARIE_PU
(old_cod_fiscale IN varchar,
 old_tipo_tributo IN varchar,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_deleghe_bancarie(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_deleghe_bancarie(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "DELEGHE_BANCARIE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_deleghe_bancarie(NEW_COD_FISCALE);
            fetch cpk1_deleghe_bancarie into dummy;
            found := cpk1_deleghe_bancarie%FOUND;
            close cpk1_deleghe_bancarie;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Deleghe Bancarie non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "DELEGHE_BANCARIE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_deleghe_bancarie(NEW_TIPO_TRIBUTO);
            fetch cpk2_deleghe_bancarie into dummy;
            found := cpk2_deleghe_bancarie%FOUND;
            close cpk2_deleghe_bancarie;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Deleghe Bancarie non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DELEGHE_BANCARIE_PU */
/

-- Trigger DELEGHE_BANCARIE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DELEGHE_BANCARIE

create or replace trigger DELEGHE_BANCARIE_TIU
before INSERT
    or UPDATE
on DELEGHE_BANCARIE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DELEGHE_BANCARIE_PU(:OLD.COD_FISCALE,
                             :OLD.TIPO_TRIBUTO,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         DELEGHE_BANCARIE_PI(:NEW.COD_FISCALE,
                             :NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DELEGHE_BANCARIE"
            cursor cpk_deleghe_bancarie(var_COD_FISCALE varchar,
                                        var_TIPO_TRIBUTO varchar) is
               select 1
                 from   DELEGHE_BANCARIE
                where  COD_FISCALE = var_COD_FISCALE and
                       TIPO_TRIBUTO = var_TIPO_TRIBUTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DELEGHE_BANCARIE"
               if :new.COD_FISCALE is not null and
                  :new.TIPO_TRIBUTO is not null then
                  open  cpk_deleghe_bancarie(:new.COD_FISCALE,
                                             :new.TIPO_TRIBUTO);
                  fetch cpk_deleghe_bancarie into dummy;
                  found := cpk_deleghe_bancarie%FOUND;
                  close cpk_deleghe_bancarie;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.TIPO_TRIBUTO||
                               '" gia'' presente in Deleghe Bancarie. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DELEGHE_BANCARIE_TIU */
/

-- Procedure DENOMINAZIONI_VIA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DENOMINAZIONI_VIA

create or replace procedure DENOMINAZIONI_VIA_PI
(new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE"
   cursor cpk1_denominazioni_via(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si inserisce su "DENOMINAZIONI_VIA"
         if NEW_COD_VIA is not null then
            open  cpk1_denominazioni_via(NEW_COD_VIA);
            fetch cpk1_denominazioni_via into dummy;
            found := cpk1_denominazioni_via%FOUND;
            close cpk1_denominazioni_via;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Denominazioni Via non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENOMINAZIONI_VIA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DENOMINAZIONI_VIA
/* End Trigger: DENOMINAZIONI_VIA_TC */

-- Procedure DENOMINAZIONI_VIA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DENOMINAZIONI_VIA

create or replace procedure DENOMINAZIONI_VIA_PU
(old_cod_via IN number,
 old_progr_via IN number,
 new_cod_via IN number,
 new_progr_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE"
   cursor cpk1_denominazioni_via(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si modifica "DENOMINAZIONI_VIA"
         if  NEW_COD_VIA is not null and ( seq = 0 )
         and (   (NEW_COD_VIA != OLD_COD_VIA or OLD_COD_VIA is null) ) then
            open  cpk1_denominazioni_via(NEW_COD_VIA);
            fetch cpk1_denominazioni_via into dummy;
            found := cpk1_denominazioni_via%FOUND;
            close cpk1_denominazioni_via;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Denominazioni Via non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENOMINAZIONI_VIA_PU */
/

-- Trigger DENOMINAZIONI_VIA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DENOMINAZIONI_VIA

create or replace trigger DENOMINAZIONI_VIA_TIU
before INSERT
    or UPDATE
on DENOMINAZIONI_VIA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DENOMINAZIONI_VIA_PU(:OLD.COD_VIA,
                              :OLD.PROGR_VIA,
                         :NEW.COD_VIA,
                         :NEW.PROGR_VIA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            DENOMINAZIONI_VIA_PI(:NEW.COD_VIA);
            declare  --  Check UNIQUE PK Integrity per la tabella "DENOMINAZIONI_VIA"
            cursor cpk_denominazioni_via(var_COD_VIA number,
                                         var_PROGR_VIA number) is
               select 1
                 from   DENOMINAZIONI_VIA
                where  COD_VIA = var_COD_VIA and
                       PROGR_VIA = var_PROGR_VIA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DENOMINAZIONI_VIA"
               if :new.COD_VIA is not null and
                  :new.PROGR_VIA is not null then
                  open  cpk_denominazioni_via(:new.COD_VIA,
                                              :new.PROGR_VIA);
                  fetch cpk_denominazioni_via into dummy;
                  found := cpk_denominazioni_via%FOUND;
                  close cpk_denominazioni_via;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_VIA||' '||
                               :new.PROGR_VIA||
                               '" gia'' presente in Denominazioni Via. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            DENOMINAZIONI_VIA_FI (:new.cod_via,:new.progr_via,:new.descrizione);
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DENOMINAZIONI_VIA_TIU */
/

-- Procedure DENOMINAZIONI_VIA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table DENOMINAZIONI_VIA

create or replace procedure DENOMINAZIONI_VIA_PD
(old_cod_via IN number,
 old_progr_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin
     if IntegrityPackage.GetNestLevel = 0 and
        old_progr_via in (1,99) THEN
           RAISE_APPLICATION_ERROR
             (-20999,'Eliminazione non consentita per i progressivi 1 e 99');
     END IF;
   end;
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENOMINAZIONI_VIA_PD */
/

-- Tigger DENOMINAZIONI_VIA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DENOMINAZIONI_VIA

create or replace trigger DENOMINAZIONI_VIA_TD
before DELETE
on DENOMINAZIONI_VIA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      */  null;
      DENOMINAZIONI_VIA_PD(:OLD.COD_VIA,
                           :OLD.PROGR_VIA);
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DENOMINAZIONI_VIA_TD */
/

-- Procedure DENUNCE_ICI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DENUNCE_ICI

create or replace procedure DENUNCE_ICI_PI
(new_pratica IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FONTI"
   cursor cpk1_denunce_ici(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk2_denunce_ici(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertTooManyChildren per la tabella padre "PRATICHE_TRIBUTO"
   cursor cmc1_denunce_ici(var_pratica number) is
      select count(1)
      from   DENUNCE_ICI
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "FONTI" deve esistere quando si inserisce su "DENUNCE_ICI"
         if NEW_FONTE is not null then
            open  cpk1_denunce_ici(NEW_FONTE);
            fetch cpk1_denunce_ici into dummy;
            found := cpk1_denunce_ici%FOUND;
            close cpk1_denunce_ici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Denunce ICI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "DENUNCE_ICI"
         if NEW_PRATICA is not null then
            open  cpk2_denunce_ici(NEW_PRATICA);
            fetch cpk2_denunce_ici into dummy;
            found := cpk2_denunce_ici%FOUND;
            close cpk2_denunce_ici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Denunce ICI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  La cardinality di "PRATICHE_TRIBUTO" in "DENUNCE_ICI" non deve eccedere 1
         if NEW_PRATICA is not null then
            open  cmc1_denunce_ici(NEW_PRATICA);
            fetch cmc1_denunce_ici into cardinality;
            close cmc1_denunce_ici;
            if cardinality >= 1 then
               errno  := -20008;
               errmsg := 'Il numero di Denunce ICI assegnato a Pratiche Tributo non e'' ammesso. La registrazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Statement di Insert MultiRow
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENUNCE_ICI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DENUNCE_ICI
/* End Trigger: DENUNCE_ICI_TC */

-- Procedure DENUNCE_ICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DENUNCE_ICI

create or replace procedure DENUNCE_ICI_PU
(old_pratica IN number,
 old_fonte IN number,
 new_pratica IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FONTI"
   cursor cpk1_denunce_ici(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk2_denunce_ici(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "FONTI" deve esistere quando si modifica "DENUNCE_ICI"
         if  NEW_FONTE is not null and ( seq = 0 )
         and (   (NEW_FONTE != OLD_FONTE or OLD_FONTE is null) ) then
            open  cpk1_denunce_ici(NEW_FONTE);
            fetch cpk1_denunce_ici into dummy;
            found := cpk1_denunce_ici%FOUND;
            close cpk1_denunce_ici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Denunce ICI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "DENUNCE_ICI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk2_denunce_ici(NEW_PRATICA);
            fetch cpk2_denunce_ici into dummy;
            found := cpk2_denunce_ici%FOUND;
            close cpk2_denunce_ici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Denunce ICI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENUNCE_ICI_PU */
/

-- Trigger DENUNCE_ICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DENUNCE_ICI

create or replace trigger DENUNCE_ICI_TIU
before INSERT
    or UPDATE
on DENUNCE_ICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DENUNCE_ICI_PU(:OLD.PRATICA,
                        :OLD.FONTE,
                         :NEW.PRATICA,
                         :NEW.FONTE);
         null;
      end if;
      if INSERTING then
         DENUNCE_ICI_PI(:NEW.PRATICA,
                        :NEW.FONTE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DENUNCE_ICI"
            cursor cpk_denunce_ici(var_PRATICA number) is
               select 1
                 from   DENUNCE_ICI
                where  PRATICA = var_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DENUNCE_ICI"
               if :new.PRATICA is not null then
                  open  cpk_denunce_ici(:new.PRATICA);
                  fetch cpk_denunce_ici into dummy;
                  found := cpk_denunce_ici%FOUND;
                  close cpk_denunce_ici;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||
                               '" gia'' presente in Denunce ICI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DENUNCE_ICI_TIU */
/

-- Procedure DENUNCE_ICIAP_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DENUNCE_ICIAP

create or replace procedure DENUNCE_ICIAP_PI
(new_pratica IN number,
 new_settore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_denunce_iciap(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SETTORI_ATTIVITA"
   cursor cpk2_denunce_iciap(var_settore number) is
      select 1
      from   SETTORI_ATTIVITA
      where  SETTORE = var_settore
       and   var_settore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "DENUNCE_ICIAP"
         if NEW_PRATICA is not null then
            open  cpk1_denunce_iciap(NEW_PRATICA);
            fetch cpk1_denunce_iciap into dummy;
            found := cpk1_denunce_iciap%FOUND;
            close cpk1_denunce_iciap;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Denunce ICIAP non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SETTORI_ATTIVITA" deve esistere quando si inserisce su "DENUNCE_ICIAP"
         if NEW_SETTORE is not null then
            open  cpk2_denunce_iciap(NEW_SETTORE);
            fetch cpk2_denunce_iciap into dummy;
            found := cpk2_denunce_iciap%FOUND;
            close cpk2_denunce_iciap;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SETTORI_ATTIVITA. La registrazione Denunce ICIAP non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENUNCE_ICIAP_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DENUNCE_ICIAP
/* End Trigger: DENUNCE_ICIAP_TC */

-- Procedure DENUNCE_ICIAP_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DENUNCE_ICIAP

create or replace procedure DENUNCE_ICIAP_PU
(old_pratica IN number,
 old_settore IN number,
 new_pratica IN number,
 new_settore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_denunce_iciap(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SETTORI_ATTIVITA"
   cursor cpk2_denunce_iciap(var_settore number) is
      select 1
      from   SETTORI_ATTIVITA
      where  SETTORE = var_settore
       and   var_settore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "DENUNCE_ICIAP"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_denunce_iciap(NEW_PRATICA);
            fetch cpk1_denunce_iciap into dummy;
            found := cpk1_denunce_iciap%FOUND;
            close cpk1_denunce_iciap;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Denunce ICIAP non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SETTORI_ATTIVITA" deve esistere quando si modifica "DENUNCE_ICIAP"
         if  NEW_SETTORE is not null and ( seq = 0 )
         and (   (NEW_SETTORE != OLD_SETTORE or OLD_SETTORE is null) ) then
            open  cpk2_denunce_iciap(NEW_SETTORE);
            fetch cpk2_denunce_iciap into dummy;
            found := cpk2_denunce_iciap%FOUND;
            close cpk2_denunce_iciap;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SETTORI_ATTIVITA. La registrazione Denunce ICIAP non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENUNCE_ICIAP_PU */
/

-- Trigger DENUNCE_ICIAP_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DENUNCE_ICIAP

create or replace trigger DENUNCE_ICIAP_TIU
before INSERT
    or UPDATE
on DENUNCE_ICIAP
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      DENUNCE_ICIAP_DI (:new.data_compilazione);
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DENUNCE_ICIAP_PU(:OLD.PRATICA,
                          :OLD.SETTORE,
                         :NEW.PRATICA,
                         :NEW.SETTORE);
         null;
      end if;
      if INSERTING then
         DENUNCE_ICIAP_PI(:NEW.PRATICA,
                          :NEW.SETTORE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DENUNCE_ICIAP"
            cursor cpk_denunce_iciap(var_PRATICA number) is
               select 1
                 from   DENUNCE_ICIAP
                where  PRATICA = var_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DENUNCE_ICIAP"
               if :new.PRATICA is not null then
                  open  cpk_denunce_iciap(:new.PRATICA);
                  fetch cpk_denunce_iciap into dummy;
                  found := cpk_denunce_iciap%FOUND;
                  close cpk_denunce_iciap;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||
                               '" gia'' presente in Denunce ICIAP. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DENUNCE_ICIAP_TIU */
/

-- Procedure DENUNCE_TASI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DENUNCE_TASI

create or replace procedure DENUNCE_TASI_PI
(new_pratica IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_denunce_tasi(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FONTI"
   cursor cpk2_denunce_tasi(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "DENUNCE_TASI"
         if NEW_PRATICA is not null then
            open  cpk1_denunce_tasi(NEW_PRATICA);
            fetch cpk1_denunce_tasi into dummy;
            found := cpk1_denunce_tasi%FOUND;
            close cpk1_denunce_tasi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Denunce TASI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si inserisce su "DENUNCE_TASI"
         if NEW_FONTE is not null then
            open  cpk2_denunce_tasi(NEW_FONTE);
            fetch cpk2_denunce_tasi into dummy;
            found := cpk2_denunce_tasi%FOUND;
            close cpk2_denunce_tasi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Denunce TASI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENUNCE_TASI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DENUNCE_TASI
/* End Trigger: DENUNCE_TASI_TC */

-- Procedure DENUNCE_TASI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DENUNCE_TASI

create or replace procedure DENUNCE_TASI_PU
(old_pratica IN number,
 old_fonte IN number,
 new_pratica IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_denunce_tasi(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FONTI"
   cursor cpk2_denunce_tasi(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "DENUNCE_TASI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_denunce_tasi(NEW_PRATICA);
            fetch cpk1_denunce_tasi into dummy;
            found := cpk1_denunce_tasi%FOUND;
            close cpk1_denunce_tasi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Denunce TASI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si modifica "DENUNCE_TASI"
         if  NEW_FONTE is not null and ( seq = 0 )
         and (   (NEW_FONTE != OLD_FONTE or OLD_FONTE is null) ) then
            open  cpk2_denunce_tasi(NEW_FONTE);
            fetch cpk2_denunce_tasi into dummy;
            found := cpk2_denunce_tasi%FOUND;
            close cpk2_denunce_tasi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Denunce TASI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DENUNCE_TASI_PU */
/

-- Trigger DENUNCE_TASI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DENUNCE_TASI

create or replace trigger DENUNCE_TASI_TIU
before INSERT
    or UPDATE
on DENUNCE_TASI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DENUNCE_TASI_PU(:OLD.PRATICA,
                         :OLD.FONTE,
                         :NEW.PRATICA,
                         :NEW.FONTE);
         null;
      end if;
      if INSERTING then
         DENUNCE_TASI_PI(:NEW.PRATICA,
                         :NEW.FONTE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DENUNCE_TASI"
            cursor cpk_denunce_tasi(var_PRATICA number) is
               select 1
                 from   DENUNCE_TASI
                where  PRATICA = var_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DENUNCE_TASI"
               if :new.PRATICA is not null then
                  open  cpk_denunce_tasi(:new.PRATICA);
                  fetch cpk_denunce_tasi into dummy;
                  found := cpk_denunce_tasi%FOUND;
                  close cpk_denunce_tasi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||
                               '" gia'' presente in Denunce TASI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DENUNCE_TASI_TIU */
/

-- Procedure DETRAZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DETRAZIONI

create or replace procedure DETRAZIONI_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_detrazioni(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "DETRAZIONI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_detrazioni(NEW_TIPO_TRIBUTO);
            fetch cpk1_detrazioni into dummy;
            found := cpk1_detrazioni%FOUND;
            close cpk1_detrazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Detrazioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DETRAZIONI
/* End Trigger: DETRAZIONI_TC */

-- Procedure DETRAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETRAZIONI

create or replace procedure DETRAZIONI_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 new_tipo_tributo IN varchar,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_detrazioni(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "MAGGIORI_DETRAZIONI"
   cursor cfk1_detrazioni(var_tipo_tributo varchar,
                          var_anno number) is
      select 1
      from   MAGGIORI_DETRAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   var_tipo_tributo is not null
       and   var_anno is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "DETRAZIONI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_detrazioni(NEW_TIPO_TRIBUTO);
            fetch cpk1_detrazioni into dummy;
            found := cpk1_detrazioni%FOUND;
            close cpk1_detrazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Detrazioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DETRAZIONI" non modificabile se esistono referenze su "MAGGIORI_DETRAZIONI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_ANNO != NEW_ANNO) then
         open  cfk1_detrazioni(OLD_TIPO_TRIBUTO,
                               OLD_ANNO);
         fetch cfk1_detrazioni into dummy;
         found := cfk1_detrazioni%FOUND;
         close cfk1_detrazioni;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Maggiori Detrazioni. La registrazione di Detrazioni non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_PU */
/

-- Trigger DETRAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETRAZIONI

create or replace trigger DETRAZIONI_TIU
before INSERT
    or UPDATE
on DETRAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETRAZIONI_PU(:OLD.TIPO_TRIBUTO,
                       :OLD.ANNO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         DETRAZIONI_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETRAZIONI"
            cursor cpk_detrazioni(var_TIPO_TRIBUTO varchar,
                                  var_ANNO number) is
               select 1
                 from   DETRAZIONI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETRAZIONI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null then
                  open  cpk_detrazioni(:new.TIPO_TRIBUTO,
                                       :new.ANNO);
                  fetch cpk_detrazioni into dummy;
                  found := cpk_detrazioni%FOUND;
                  close cpk_detrazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||
                               '" gia'' presente in Detrazioni. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETRAZIONI_TIU */
/

-- Procedure DETRAZIONI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table DETRAZIONI

create or replace procedure DETRAZIONI_PD
(old_tipo_tributo IN varchar,
 old_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "MAGGIORI_DETRAZIONI"
   cursor cfk1_detrazioni(var_tipo_tributo varchar,
                          var_anno number) is
      select 1
      from   MAGGIORI_DETRAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   var_tipo_tributo is not null
       and   var_anno is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "DETRAZIONI" if children still exist in "MAGGIORI_DETRAZIONI"
      open  cfk1_detrazioni(OLD_TIPO_TRIBUTO,
                            OLD_ANNO);
      fetch cfk1_detrazioni into dummy;
      found := cfk1_detrazioni%FOUND;
      close cfk1_detrazioni;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Maggiori Detrazioni. La registrazione di Detrazioni non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_PD */
/

-- Tigger DETRAZIONI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DETRAZIONI

create or replace trigger DETRAZIONI_TD
before DELETE
on DETRAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: MAGGIORI_DETRAZIONI

      DETRAZIONI_PD(:OLD.TIPO_TRIBUTO,
                    :OLD.ANNO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETRAZIONI_TD */
/

-- Procedure DETRAZIONI_FIGLI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DETRAZIONI_FIGLI

create or replace procedure DETRAZIONI_FIGLI_PI
(new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_detrazioni_figli(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "DETRAZIONI_FIGLI"
         if NEW_COD_FISCALE is not null then
            open  cpk1_detrazioni_figli(NEW_COD_FISCALE);
            fetch cpk1_detrazioni_figli into dummy;
            found := cpk1_detrazioni_figli%FOUND;
            close cpk1_detrazioni_figli;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Detrazioni_figli non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_FIGLI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DETRAZIONI_FIGLI
/* End Trigger: DETRAZIONI_FIGLI_TC */

-- Procedure DETRAZIONI_FIGLI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETRAZIONI_FIGLI

create or replace procedure DETRAZIONI_FIGLI_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_da_mese IN number,
 new_cod_fiscale IN varchar,
 new_anno IN number,
 new_da_mese IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_detrazioni_figli(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "DETRAZIONI_FIGLI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_detrazioni_figli(NEW_COD_FISCALE);
            fetch cpk1_detrazioni_figli into dummy;
            found := cpk1_detrazioni_figli%FOUND;
            close cpk1_detrazioni_figli;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Detrazioni_figli non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_FIGLI_PU */
/

-- Trigger DETRAZIONI_FIGLI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETRAZIONI_FIGLI

create or replace trigger DETRAZIONI_FIGLI_TIU
before INSERT
    or UPDATE
on DETRAZIONI_FIGLI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETRAZIONI_FIGLI_PU(:OLD.COD_FISCALE,
                             :OLD.ANNO,
                             :OLD.DA_MESE,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO,
                         :NEW.DA_MESE);
         null;
      end if;
      if INSERTING then
         DETRAZIONI_FIGLI_PI(:NEW.COD_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETRAZIONI_FIGLI"
            cursor cpk_detrazioni_figli(var_COD_FISCALE varchar,
                                        var_ANNO number,
                                        var_DA_MESE number) is
               select 1
                 from   DETRAZIONI_FIGLI
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO and
                       DA_MESE = var_DA_MESE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETRAZIONI_FIGLI"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null and
                  :new.DA_MESE is not null then
                  open  cpk_detrazioni_figli(:new.COD_FISCALE,
                                             :new.ANNO,
                                             :new.DA_MESE);
                  fetch cpk_detrazioni_figli into dummy;
                  found := cpk_detrazioni_figli%FOUND;
                  close cpk_detrazioni_figli;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||' '||
                               :new.DA_MESE||
                               '" gia'' presente in Detrazioni_figli. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETRAZIONI_FIGLI_TIU */
/

-- Procedure DETRAZIONI_FIGLI_CTR_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETRAZIONI_FIGLI_CTR

create or replace procedure DETRAZIONI_FIGLI_CTR_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_data_riferimento IN date,
 new_cod_fiscale IN varchar,
 new_anno IN number,
 new_data_riferimento IN date)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_FIGLI_CTR_PU */
/

-- Trigger DETRAZIONI_FIGLI_CTR_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETRAZIONI_FIGLI_CTR

create or replace trigger DETRAZIONI_FIGLI_CTR_TIU
before INSERT
    or UPDATE
on DETRAZIONI_FIGLI_CTR
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETRAZIONI_FIGLI_CTR_PU(:OLD.COD_FISCALE,
                                 :OLD.ANNO,
                                 :OLD.DATA_RIFERIMENTO,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO,
                         :NEW.DATA_RIFERIMENTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETRAZIONI_FIGLI_CTR"
            cursor cpk_detrazioni_figli_ctr(var_COD_FISCALE varchar,
                                            var_ANNO number,
                                            var_DATA_RIFERIMENTO date) is
               select 1
                 from   DETRAZIONI_FIGLI_CTR
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO and
                       DATA_RIFERIMENTO = var_DATA_RIFERIMENTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETRAZIONI_FIGLI_CTR"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null and
                  :new.DATA_RIFERIMENTO is not null then
                  open  cpk_detrazioni_figli_ctr(:new.COD_FISCALE,
                                                 :new.ANNO,
                                                 :new.DATA_RIFERIMENTO);
                  fetch cpk_detrazioni_figli_ctr into dummy;
                  found := cpk_detrazioni_figli_ctr%FOUND;
                  close cpk_detrazioni_figli_ctr;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||' '||
                               :new.DATA_RIFERIMENTO||
                               '" gia'' presente in Detrazioni Figli Ctr. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETRAZIONI_FIGLI_CTR_TIU */
/

-- Procedure DETRAZIONI_FIGLI_OGIM_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DETRAZIONI_FIGLI_OGIM

create or replace procedure DETRAZIONI_FIGLI_OGIM_PI
(new_oggetto_imposta IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_IMPOSTA"
   cursor cpk1_detrazioni_figli_ogim(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si inserisce su "DETRAZIONI_FIGLI_OGIM"
         if NEW_OGGETTO_IMPOSTA is not null then
            open  cpk1_detrazioni_figli_ogim(NEW_OGGETTO_IMPOSTA);
            fetch cpk1_detrazioni_figli_ogim into dummy;
            found := cpk1_detrazioni_figli_ogim%FOUND;
            close cpk1_detrazioni_figli_ogim;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Detrazioni Figli OGIM non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_FIGLI_OGIM_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DETRAZIONI_FIGLI_OGIM
/* End Trigger: DETRAZIONI_FIGLI_OGIM_TC */

-- Procedure DETRAZIONI_FIGLI_OGIM_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETRAZIONI_FIGLI_OGIM

create or replace procedure DETRAZIONI_FIGLI_OGIM_PU
(old_oggetto_imposta IN number,
 old_da_mese IN number,
 new_oggetto_imposta IN number,
 new_da_mese IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_IMPOSTA"
   cursor cpk1_detrazioni_figli_ogim(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si modifica "DETRAZIONI_FIGLI_OGIM"
         if  NEW_OGGETTO_IMPOSTA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_IMPOSTA != OLD_OGGETTO_IMPOSTA or OLD_OGGETTO_IMPOSTA is null) ) then
            open  cpk1_detrazioni_figli_ogim(NEW_OGGETTO_IMPOSTA);
            fetch cpk1_detrazioni_figli_ogim into dummy;
            found := cpk1_detrazioni_figli_ogim%FOUND;
            close cpk1_detrazioni_figli_ogim;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Detrazioni Figli OGIM non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_FIGLI_OGIM_PU */
/

-- Trigger DETRAZIONI_FIGLI_OGIM_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETRAZIONI_FIGLI_OGIM

create or replace trigger DETRAZIONI_FIGLI_OGIM_TIU
before INSERT
    or UPDATE
on DETRAZIONI_FIGLI_OGIM
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETRAZIONI_FIGLI_OGIM_PU(:OLD.OGGETTO_IMPOSTA,
                                  :OLD.DA_MESE,
                         :NEW.OGGETTO_IMPOSTA,
                         :NEW.DA_MESE);
         null;
      end if;
      if INSERTING then
         DETRAZIONI_FIGLI_OGIM_PI(:NEW.OGGETTO_IMPOSTA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETRAZIONI_FIGLI_OGIM"
            cursor cpk_detrazioni_figli_ogim(var_OGGETTO_IMPOSTA number,
                                             var_DA_MESE number) is
               select 1
                 from   DETRAZIONI_FIGLI_OGIM
                where  OGGETTO_IMPOSTA = var_OGGETTO_IMPOSTA and
                       DA_MESE = var_DA_MESE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETRAZIONI_FIGLI_OGIM"
               if :new.OGGETTO_IMPOSTA is not null and
                  :new.DA_MESE is not null then
                  open  cpk_detrazioni_figli_ogim(:new.OGGETTO_IMPOSTA,
                                                  :new.DA_MESE);
                  fetch cpk_detrazioni_figli_ogim into dummy;
                  found := cpk_detrazioni_figli_ogim%FOUND;
                  close cpk_detrazioni_figli_ogim;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO_IMPOSTA||' '||
                               :new.DA_MESE||
                               '" gia'' presente in Detrazioni Figli OGIM. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETRAZIONI_FIGLI_OGIM_TIU */
/

-- Procedure DETRAZIONI_IMPONIBILE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DETRAZIONI_IMPONIBILE

create or replace procedure DETRAZIONI_IMPONIBILE_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_CONTRIBUENTE"
   cursor cpk1_detrazioni_imponibile(var_cod_fiscale varchar,
                                     var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si inserisce su "DETRAZIONI_IMPONIBILE"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO_PRATICA is not null then
            open  cpk1_detrazioni_imponibile(NEW_COD_FISCALE,
                                             NEW_OGGETTO_PRATICA);
            fetch cpk1_detrazioni_imponibile into dummy;
            found := cpk1_detrazioni_imponibile%FOUND;
            close cpk1_detrazioni_imponibile;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione DETRAZIONI_IMPONIBILE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_IMPONIBILE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DETRAZIONI_IMPONIBILE
/* End Trigger: DETRAZIONI_IMPONIBILE_TC */

-- Procedure DETRAZIONI_IMPONIBILE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETRAZIONI_IMPONIBILE

create or replace procedure DETRAZIONI_IMPONIBILE_PU
(old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number,
 old_anno IN number,
 old_da_mese IN number,
 new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_anno IN number,
 new_da_mese IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_CONTRIBUENTE"
   cursor cpk1_detrazioni_imponibile(var_cod_fiscale varchar,
                                     var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si modifica "DETRAZIONI_IMPONIBILE"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_detrazioni_imponibile(NEW_COD_FISCALE,
                                             NEW_OGGETTO_PRATICA);
            fetch cpk1_detrazioni_imponibile into dummy;
            found := cpk1_detrazioni_imponibile%FOUND;
            close cpk1_detrazioni_imponibile;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione DETRAZIONI_IMPONIBILE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_IMPONIBILE_PU */
/

-- Trigger DETRAZIONI_IMPONIBILE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETRAZIONI_IMPONIBILE

create or replace trigger DETRAZIONI_IMPONIBILE_TIU
before INSERT
    or UPDATE
on DETRAZIONI_IMPONIBILE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETRAZIONI_IMPONIBILE_PU(:OLD.COD_FISCALE,
                                  :OLD.OGGETTO_PRATICA,
                                  :OLD.ANNO,
                                  :OLD.DA_MESE,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.ANNO,
                         :NEW.DA_MESE);
         null;
      end if;
      if INSERTING then
         DETRAZIONI_IMPONIBILE_PI(:NEW.COD_FISCALE,
                                  :NEW.OGGETTO_PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETRAZIONI_IMPONIBILE"
            cursor cpk_detrazioni_imponibile(var_COD_FISCALE varchar,
                                             var_OGGETTO_PRATICA number,
                                             var_ANNO number,
                                             var_DA_MESE number) is
               select 1
                 from   DETRAZIONI_IMPONIBILE
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA and
                       ANNO = var_ANNO and
                       DA_MESE = var_DA_MESE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETRAZIONI_IMPONIBILE"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO_PRATICA is not null and
                  :new.ANNO is not null and
                  :new.DA_MESE is not null then
                  open  cpk_detrazioni_imponibile(:new.COD_FISCALE,
                                                  :new.OGGETTO_PRATICA,
                                                  :new.ANNO,
                                                  :new.DA_MESE);
                  fetch cpk_detrazioni_imponibile into dummy;
                  found := cpk_detrazioni_imponibile%FOUND;
                  close cpk_detrazioni_imponibile;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO_PRATICA||' '||
                               :new.ANNO||' '||
                               :new.DA_MESE||
                               '" gia'' presente in DETRAZIONI_IMPONIBILE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETRAZIONI_IMPONIBILE_TIU */
/

-- Procedure DETRAZIONI_MOBILI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DETRAZIONI_MOBILI

create or replace procedure DETRAZIONI_MOBILI_PI
(new_tipo_tributo IN varchar,
 new_motivo_detrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_detrazioni_mobili(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MOTIVI_DETRAZIONE"
   cursor cpk2_detrazioni_mobili(var_tipo_tributo varchar,
                                 var_motivo_detrazione number) is
      select 1
      from   MOTIVI_DETRAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "DETRAZIONI_MOBILI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_detrazioni_mobili(NEW_TIPO_TRIBUTO);
            fetch cpk1_detrazioni_mobili into dummy;
            found := cpk1_detrazioni_mobili%FOUND;
            close cpk1_detrazioni_mobili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Detrazioni Mobili non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_DETRAZIONE" deve esistere quando si inserisce su "DETRAZIONI_MOBILI"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_MOTIVO_DETRAZIONE is not null then
            open  cpk2_detrazioni_mobili(NEW_TIPO_TRIBUTO,
                                         NEW_MOTIVO_DETRAZIONE);
            fetch cpk2_detrazioni_mobili into dummy;
            found := cpk2_detrazioni_mobili%FOUND;
            close cpk2_detrazioni_mobili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Motivi Detrazione. La registrazione Detrazioni Mobili non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_MOBILI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DETRAZIONI_MOBILI
/* End Trigger: DETRAZIONI_MOBILI_TC */

-- Procedure DETRAZIONI_MOBILI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETRAZIONI_MOBILI

create or replace procedure DETRAZIONI_MOBILI_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_motivo_detrazione IN number,
 old_da_rendita IN number,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_motivo_detrazione IN number,
 new_da_rendita IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_detrazioni_mobili(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MOTIVI_DETRAZIONE"
   cursor cpk2_detrazioni_mobili(var_tipo_tributo varchar,
                                 var_motivo_detrazione number) is
      select 1
      from   MOTIVI_DETRAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "DETRAZIONI_MOBILI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_detrazioni_mobili(NEW_TIPO_TRIBUTO);
            fetch cpk1_detrazioni_mobili into dummy;
            found := cpk1_detrazioni_mobili%FOUND;
            close cpk1_detrazioni_mobili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Detrazioni Mobili non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_DETRAZIONE" deve esistere quando si modifica "DETRAZIONI_MOBILI"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_MOTIVO_DETRAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_MOTIVO_DETRAZIONE != OLD_MOTIVO_DETRAZIONE or OLD_MOTIVO_DETRAZIONE is null) ) then
            open  cpk2_detrazioni_mobili(NEW_TIPO_TRIBUTO,
                                         NEW_MOTIVO_DETRAZIONE);
            fetch cpk2_detrazioni_mobili into dummy;
            found := cpk2_detrazioni_mobili%FOUND;
            close cpk2_detrazioni_mobili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Motivi Detrazione. La registrazione Detrazioni Mobili non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_MOBILI_PU */
/

-- Trigger DETRAZIONI_MOBILI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETRAZIONI_MOBILI

create or replace trigger DETRAZIONI_MOBILI_TIU
before INSERT
    or UPDATE
on DETRAZIONI_MOBILI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETRAZIONI_MOBILI_PU(:OLD.TIPO_TRIBUTO,
                              :OLD.ANNO,
                              :OLD.MOTIVO_DETRAZIONE,
                              :OLD.DA_RENDITA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.MOTIVO_DETRAZIONE,
                         :NEW.DA_RENDITA);
         null;
      end if;
      if INSERTING then
         DETRAZIONI_MOBILI_PI(:NEW.TIPO_TRIBUTO,
                              :NEW.MOTIVO_DETRAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETRAZIONI_MOBILI"
            cursor cpk_detrazioni_mobili(var_TIPO_TRIBUTO varchar,
                                         var_ANNO number,
                                         var_MOTIVO_DETRAZIONE number,
                                         var_DA_RENDITA number) is
               select 1
                 from   DETRAZIONI_MOBILI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       MOTIVO_DETRAZIONE = var_MOTIVO_DETRAZIONE and
                       DA_RENDITA = var_DA_RENDITA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETRAZIONI_MOBILI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.MOTIVO_DETRAZIONE is not null and
                  :new.DA_RENDITA is not null then
                  open  cpk_detrazioni_mobili(:new.TIPO_TRIBUTO,
                                              :new.ANNO,
                                              :new.MOTIVO_DETRAZIONE,
                                              :new.DA_RENDITA);
                  fetch cpk_detrazioni_mobili into dummy;
                  found := cpk_detrazioni_mobili%FOUND;
                  close cpk_detrazioni_mobili;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.MOTIVO_DETRAZIONE||' '||
                               :new.DA_RENDITA||
                               '" gia'' presente in Detrazioni Mobili. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETRAZIONI_MOBILI_TIU */
/

-- Procedure DETRAZIONI_OGCO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DETRAZIONI_OGCO

create or replace procedure DETRAZIONI_OGCO_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_tipo_tributo IN varchar,
 new_motivo_detrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MOTIVI_DETRAZIONE"
   cursor cpk1_detrazioni_ogco(var_tipo_tributo varchar,
                               var_motivo_detrazione number) is
      select 1
      from   MOTIVI_DETRAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_CONTRIBUENTE"
   cursor cpk2_detrazioni_ogco(var_cod_fiscale varchar,
                               var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "MOTIVI_DETRAZIONE" deve esistere quando si inserisce su "DETRAZIONI_OGCO"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_MOTIVO_DETRAZIONE is not null then
            open  cpk1_detrazioni_ogco(NEW_TIPO_TRIBUTO,
                                       NEW_MOTIVO_DETRAZIONE);
            fetch cpk1_detrazioni_ogco into dummy;
            found := cpk1_detrazioni_ogco%FOUND;
            close cpk1_detrazioni_ogco;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Motivi Detrazione. La registrazione Detrazioni Oggetti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si inserisce su "DETRAZIONI_OGCO"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO_PRATICA is not null then
            open  cpk2_detrazioni_ogco(NEW_COD_FISCALE,
                                       NEW_OGGETTO_PRATICA);
            fetch cpk2_detrazioni_ogco into dummy;
            found := cpk2_detrazioni_ogco%FOUND;
            close cpk2_detrazioni_ogco;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Detrazioni Oggetti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_OGCO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DETRAZIONI_OGCO
/* End Trigger: DETRAZIONI_OGCO_TC */

-- Procedure DETRAZIONI_OGCO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETRAZIONI_OGCO

create or replace procedure DETRAZIONI_OGCO_PU
(old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number,
 old_anno IN number,
 old_tipo_tributo IN varchar,
 old_motivo_detrazione IN number,
 new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_anno IN number,
 new_tipo_tributo IN varchar,
 new_motivo_detrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MOTIVI_DETRAZIONE"
   cursor cpk1_detrazioni_ogco(var_tipo_tributo varchar,
                               var_motivo_detrazione number) is
      select 1
      from   MOTIVI_DETRAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_CONTRIBUENTE"
   cursor cpk2_detrazioni_ogco(var_cod_fiscale varchar,
                               var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "MOTIVI_DETRAZIONE" deve esistere quando si modifica "DETRAZIONI_OGCO"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_MOTIVO_DETRAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_MOTIVO_DETRAZIONE != OLD_MOTIVO_DETRAZIONE or OLD_MOTIVO_DETRAZIONE is null) ) then
            open  cpk1_detrazioni_ogco(NEW_TIPO_TRIBUTO,
                                       NEW_MOTIVO_DETRAZIONE);
            fetch cpk1_detrazioni_ogco into dummy;
            found := cpk1_detrazioni_ogco%FOUND;
            close cpk1_detrazioni_ogco;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Motivi Detrazione. La registrazione Detrazioni Oggetti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si modifica "DETRAZIONI_OGCO"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk2_detrazioni_ogco(NEW_COD_FISCALE,
                                       NEW_OGGETTO_PRATICA);
            fetch cpk2_detrazioni_ogco into dummy;
            found := cpk2_detrazioni_ogco%FOUND;
            close cpk2_detrazioni_ogco;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Detrazioni Oggetti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETRAZIONI_OGCO_PU */
/

-- Trigger DETRAZIONI_OGCO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETRAZIONI_OGCO

create or replace trigger DETRAZIONI_OGCO_TIU
before INSERT
    or UPDATE
on DETRAZIONI_OGCO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETRAZIONI_OGCO_PU(:OLD.COD_FISCALE,
                            :OLD.OGGETTO_PRATICA,
                            :OLD.ANNO,
                            :OLD.TIPO_TRIBUTO,
                            :OLD.MOTIVO_DETRAZIONE,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.ANNO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.MOTIVO_DETRAZIONE);
         null;
      end if;
      if INSERTING then
         DETRAZIONI_OGCO_PI(:NEW.COD_FISCALE,
                            :NEW.OGGETTO_PRATICA,
                            :NEW.TIPO_TRIBUTO,
                            :NEW.MOTIVO_DETRAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETRAZIONI_OGCO"
            cursor cpk_detrazioni_ogco(var_COD_FISCALE varchar,
                                       var_OGGETTO_PRATICA number,
                                       var_ANNO number) is
               select 1
                 from   DETRAZIONI_OGCO
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETRAZIONI_OGCO"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO_PRATICA is not null and
                  :new.ANNO is not null then
                  open  cpk_detrazioni_ogco(:new.COD_FISCALE,
                                            :new.OGGETTO_PRATICA,
                                            :new.ANNO);
                  fetch cpk_detrazioni_ogco into dummy;
                  found := cpk_detrazioni_ogco%FOUND;
                  close cpk_detrazioni_ogco;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO_PRATICA||' '||
                               :new.ANNO||
                               '" gia'' presente in Detrazioni Oggetti Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETRAZIONI_OGCO_TIU */
/

-- Procedure DETTAGLI_COMUNICAZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DETTAGLI_COMUNICAZIONE

create or replace procedure DETTAGLI_COMUNICAZIONE_PI
(new_tipo_tributo IN varchar,
 new_tipo_comunicazione IN varchar,
 new_tipo_canale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "COMUNICAZIONE_PARAMETRI"
   cursor cpk1_dettagli_comunicazione(var_tipo_tributo varchar,
                                      var_tipo_comunicazione varchar) is
      select 1
      from   COMUNICAZIONE_PARAMETRI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_CANALE"
   cursor cpk2_dettagli_comunicazione(var_tipo_canale number) is
      select 1
      from   TIPI_CANALE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "COMUNICAZIONE_PARAMETRI" deve esistere quando si inserisce su "DETTAGLI_COMUNICAZIONE"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_TIPO_COMUNICAZIONE is not null then
            open  cpk1_dettagli_comunicazione(NEW_TIPO_TRIBUTO,
                                              NEW_TIPO_COMUNICAZIONE);
            fetch cpk1_dettagli_comunicazione into dummy;
            found := cpk1_dettagli_comunicazione%FOUND;
            close cpk1_dettagli_comunicazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su COMUNICAZIONE_PARAMETRI. La registrazione DETTAGLI COMUNICAZIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CANALE" deve esistere quando si inserisce su "DETTAGLI_COMUNICAZIONE"
         if NEW_TIPO_CANALE is not null then
            open  cpk2_dettagli_comunicazione(NEW_TIPO_CANALE);
            fetch cpk2_dettagli_comunicazione into dummy;
            found := cpk2_dettagli_comunicazione%FOUND;
            close cpk2_dettagli_comunicazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Canale. La registrazione DETTAGLI COMUNICAZIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETTAGLI_COMUNICAZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DETTAGLI_COMUNICAZIONE
/* End Trigger: DETTAGLI_COMUNICAZIONE_TC */

-- Procedure DETTAGLI_COMUNICAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETTAGLI_COMUNICAZIONE

create or replace procedure DETTAGLI_COMUNICAZIONE_PU
(old_tipo_tributo IN varchar,
 old_tipo_comunicazione IN varchar,
 old_sequenza IN number,
 old_tipo_canale IN number,
 new_tipo_tributo IN varchar,
 new_tipo_comunicazione IN varchar,
 new_sequenza IN number,
 new_tipo_canale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "COMUNICAZIONE_PARAMETRI"
   cursor cpk1_dettagli_comunicazione(var_tipo_tributo varchar,
                                      var_tipo_comunicazione varchar) is
      select 1
      from   COMUNICAZIONE_PARAMETRI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_CANALE"
   cursor cpk2_dettagli_comunicazione(var_tipo_canale number) is
      select 1
      from   TIPI_CANALE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;

   --  Declaration of UpdateParentRestrict constraint for "ATTIVITA_ELABORAZIONE"
   cursor cfk1_dettagli_comunicazione(var_tipo_tributo varchar,
                                      var_tipo_comunicazione varchar,
                                      var_sequenza number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   SEQUENZA_COMUNICAZIONE = var_sequenza
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "COMUNICAZIONE_PARAMETRI" deve esistere quando si modifica "DETTAGLI_COMUNICAZIONE"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_TIPO_COMUNICAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_TIPO_COMUNICAZIONE != OLD_TIPO_COMUNICAZIONE or OLD_TIPO_COMUNICAZIONE is null) ) then
            open  cpk1_dettagli_comunicazione(NEW_TIPO_TRIBUTO,
                                              NEW_TIPO_COMUNICAZIONE);
            fetch cpk1_dettagli_comunicazione into dummy;
            found := cpk1_dettagli_comunicazione%FOUND;
            close cpk1_dettagli_comunicazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su COMUNICAZIONE_PARAMETRI. La registrazione DETTAGLI COMUNICAZIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CANALE" deve esistere quando si modifica "DETTAGLI_COMUNICAZIONE"
         if  NEW_TIPO_CANALE is not null and ( seq = 0 )
         and (   (NEW_TIPO_CANALE != OLD_TIPO_CANALE or OLD_TIPO_CANALE is null) ) then
            open  cpk2_dettagli_comunicazione(NEW_TIPO_CANALE);
            fetch cpk2_dettagli_comunicazione into dummy;
            found := cpk2_dettagli_comunicazione%FOUND;
            close cpk2_dettagli_comunicazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Canale. La registrazione DETTAGLI COMUNICAZIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DETTAGLI_COMUNICAZIONE" non modificabile se esistono referenze su "ATTIVITA_ELABORAZIONE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_TIPO_COMUNICAZIONE != NEW_TIPO_COMUNICAZIONE) or
         (OLD_SEQUENZA != NEW_SEQUENZA) then
         open  cfk1_dettagli_comunicazione(OLD_TIPO_TRIBUTO,
                                           OLD_TIPO_COMUNICAZIONE,
                                           OLD_SEQUENZA);
         fetch cfk1_dettagli_comunicazione into dummy;
         found := cfk1_dettagli_comunicazione%FOUND;
         close cfk1_dettagli_comunicazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Attivita Elaborazione. La registrazione di DETTAGLI COMUNICAZIONE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETTAGLI_COMUNICAZIONE_PU */
/

-- Trigger DETTAGLI_COMUNICAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETTAGLI_COMUNICAZIONE

create or replace trigger DETTAGLI_COMUNICAZIONE_TIU
before INSERT
    or UPDATE
on DETTAGLI_COMUNICAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       DETTAGLI_COMUNICAZIONE_NR (:new.tipo_tributo,:new.tipo_comunicazione,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETTAGLI_COMUNICAZIONE_PU(:OLD.TIPO_TRIBUTO,
                                   :OLD.TIPO_COMUNICAZIONE,
                                   :OLD.SEQUENZA,
                                   :OLD.TIPO_CANALE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_COMUNICAZIONE,
                         :NEW.SEQUENZA,
                         :NEW.TIPO_CANALE);
         null;
      end if;
      if INSERTING then
         DETTAGLI_COMUNICAZIONE_PI(:NEW.TIPO_TRIBUTO,
                                   :NEW.TIPO_COMUNICAZIONE,
                                   :NEW.TIPO_CANALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETTAGLI_COMUNICAZIONE"
            cursor cpk_dettagli_comunicazione(var_TIPO_TRIBUTO varchar,
                                              var_TIPO_COMUNICAZIONE varchar,
                                              var_SEQUENZA number) is
               select 1
                 from   DETTAGLI_COMUNICAZIONE
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       TIPO_COMUNICAZIONE = var_TIPO_COMUNICAZIONE and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETTAGLI_COMUNICAZIONE"
               if :new.TIPO_TRIBUTO is not null and
                  :new.TIPO_COMUNICAZIONE is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_dettagli_comunicazione(:new.TIPO_TRIBUTO,
                                                   :new.TIPO_COMUNICAZIONE,
                                                   :new.SEQUENZA);
                  fetch cpk_dettagli_comunicazione into dummy;
                  found := cpk_dettagli_comunicazione%FOUND;
                  close cpk_dettagli_comunicazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.TIPO_COMUNICAZIONE||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in DETTAGLI COMUNICAZIONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETTAGLI_COMUNICAZIONE_TIU */
/

-- Procedure DETTAGLI_COMUNICAZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table DETTAGLI_COMUNICAZIONE

create or replace procedure DETTAGLI_COMUNICAZIONE_PD
(old_tipo_tributo IN varchar,
 old_tipo_comunicazione IN varchar,
 old_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ATTIVITA_ELABORAZIONE"
   cursor cfk1_dettagli_comunicazione(var_tipo_tributo varchar,
                                      var_tipo_comunicazione varchar,
                                      var_sequenza number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_COMUNICAZIONE = var_tipo_comunicazione
       and   SEQUENZA_COMUNICAZIONE = var_sequenza
       and   var_tipo_tributo is not null
       and   var_tipo_comunicazione is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "DETTAGLI_COMUNICAZIONE" if children still exist in "ATTIVITA_ELABORAZIONE"
      open  cfk1_dettagli_comunicazione(OLD_TIPO_TRIBUTO,
                                        OLD_TIPO_COMUNICAZIONE,
                                        OLD_SEQUENZA);
      fetch cfk1_dettagli_comunicazione into dummy;
      found := cfk1_dettagli_comunicazione%FOUND;
      close cfk1_dettagli_comunicazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Attivita Elaborazione. La registrazione di DETTAGLI COMUNICAZIONE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETTAGLI_COMUNICAZIONE_PD */
/

-- Tigger DETTAGLI_COMUNICAZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DETTAGLI_COMUNICAZIONE

create or replace trigger DETTAGLI_COMUNICAZIONE_TD
before DELETE
on DETTAGLI_COMUNICAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ATTIVITA_ELABORAZIONE

      DETTAGLI_COMUNICAZIONE_PD(:OLD.TIPO_TRIBUTO,
                                :OLD.TIPO_COMUNICAZIONE,
                                :OLD.SEQUENZA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETTAGLI_COMUNICAZIONE_TD */
/

-- Procedure DETTAGLI_ELABORAZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DETTAGLI_ELABORAZIONE

create or replace procedure DETTAGLI_ELABORAZIONE_PI
(new_elaborazione_id IN number,
 new_pratica IN number,
 new_cod_fiscale IN varchar,
 new_stampa_id IN number,
 new_documentale_id IN number,
 new_tipografia_id IN number,
 new_avviso_agid_id IN number,
 new_appio_id IN number,
 new_anagr_id IN number,
 new_controllo_at_id IN number,
 new_allineamento_at_id IN number,
 new_ni IN number,
 new_ni_erede IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ELABORAZIONI_MASSIVE"
   cursor cpk1_dettagli_elaborazione(var_elaborazione_id number) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk2_dettagli_elaborazione(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk3_dettagli_elaborazione(var_stampa_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_stampa_id
       and   var_stampa_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk4_dettagli_elaborazione(var_documentale_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_documentale_id
       and   var_documentale_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk5_dettagli_elaborazione(var_tipografia_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_tipografia_id
       and   var_tipografia_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk6_dettagli_elaborazione(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk7_dettagli_elaborazione(var_avviso_agid_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_avviso_agid_id
       and   var_avviso_agid_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk8_dettagli_elaborazione(var_appio_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_appio_id
       and   var_appio_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk9_dettagli_elaborazione(var_anagr_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_anagr_id
       and   var_anagr_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk10_dettagli_elaborazione(var_controllo_at_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_controllo_at_id
       and   var_controllo_at_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk11_dettagli_elaborazione(var_allineamento_at_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_allineamento_at_id
       and   var_allineamento_at_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "EREDI_SOGGETTO"
   cursor cpk12_dettagli_elaborazione(var_ni number,
                                      var_ni_erede number) is
      select 1
      from   EREDI_SOGGETTO
      where  NI = var_ni
       and   NI_EREDE = var_ni_erede
       and   var_ni is not null
       and   var_ni_erede is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ELABORAZIONI_MASSIVE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_ELABORAZIONE_ID is not null then
            open  cpk1_dettagli_elaborazione(NEW_ELABORAZIONE_ID);
            fetch cpk1_dettagli_elaborazione into dummy;
            found := cpk1_dettagli_elaborazione%FOUND;
            close cpk1_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Elaborazioni Massive. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_PRATICA is not null then
            open  cpk2_dettagli_elaborazione(NEW_PRATICA);
            fetch cpk2_dettagli_elaborazione into dummy;
            found := cpk2_dettagli_elaborazione%FOUND;
            close cpk2_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_STAMPA_ID is not null then
            open  cpk3_dettagli_elaborazione(NEW_STAMPA_ID);
            fetch cpk3_dettagli_elaborazione into dummy;
            found := cpk3_dettagli_elaborazione%FOUND;
            close cpk3_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_DOCUMENTALE_ID is not null then
            open  cpk4_dettagli_elaborazione(NEW_DOCUMENTALE_ID);
            fetch cpk4_dettagli_elaborazione into dummy;
            found := cpk4_dettagli_elaborazione%FOUND;
            close cpk4_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_TIPOGRAFIA_ID is not null then
            open  cpk5_dettagli_elaborazione(NEW_TIPOGRAFIA_ID);
            fetch cpk5_dettagli_elaborazione into dummy;
            found := cpk5_dettagli_elaborazione%FOUND;
            close cpk5_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_COD_FISCALE is not null then
            open  cpk6_dettagli_elaborazione(NEW_COD_FISCALE);
            fetch cpk6_dettagli_elaborazione into dummy;
            found := cpk6_dettagli_elaborazione%FOUND;
            close cpk6_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_AVVISO_AGID_ID is not null then
            open  cpk7_dettagli_elaborazione(NEW_AVVISO_AGID_ID);
            fetch cpk7_dettagli_elaborazione into dummy;
            found := cpk7_dettagli_elaborazione%FOUND;
            close cpk7_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_APPIO_ID is not null then
            open  cpk8_dettagli_elaborazione(NEW_APPIO_ID);
            fetch cpk8_dettagli_elaborazione into dummy;
            found := cpk8_dettagli_elaborazione%FOUND;
            close cpk8_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_ANAGR_ID is not null then
            open  cpk9_dettagli_elaborazione(NEW_ANAGR_ID);
            fetch cpk9_dettagli_elaborazione into dummy;
            found := cpk9_dettagli_elaborazione%FOUND;
            close cpk9_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_CONTROLLO_AT_ID is not null then
            open  cpk10_dettagli_elaborazione(NEW_CONTROLLO_AT_ID);
            fetch cpk10_dettagli_elaborazione into dummy;
            found := cpk10_dettagli_elaborazione%FOUND;
            close cpk10_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_ALLINEAMENTO_AT_ID is not null then
            open  cpk11_dettagli_elaborazione(NEW_ALLINEAMENTO_AT_ID);
            fetch cpk11_dettagli_elaborazione into dummy;
            found := cpk11_dettagli_elaborazione%FOUND;
            close cpk11_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "EREDI_SOGGETTO" deve esistere quando si inserisce su "DETTAGLI_ELABORAZIONE"
         if NEW_NI is not null and
            NEW_NI_EREDE is not null then
            open  cpk12_dettagli_elaborazione(NEW_NI,
                                              NEW_NI_EREDE);
            fetch cpk12_dettagli_elaborazione into dummy;
            found := cpk12_dettagli_elaborazione%FOUND;
            close cpk12_dettagli_elaborazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Eredi Soggetto. La registrazione Dettagli Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETTAGLI_ELABORAZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DETTAGLI_ELABORAZIONE
/* End Trigger: DETTAGLI_ELABORAZIONE_TC */

-- Procedure DETTAGLI_ELABORAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DETTAGLI_ELABORAZIONE

create or replace procedure DETTAGLI_ELABORAZIONE_PU
(old_dettaglio_id IN number,
 old_elaborazione_id IN number,
 old_pratica IN number,
 old_cod_fiscale IN varchar,
 old_stampa_id IN number,
 old_documentale_id IN number,
 old_tipografia_id IN number,
 old_avviso_agid_id IN number,
 old_appio_id IN number,
 old_anagr_id IN number,
 old_controllo_at_id IN number,
 old_allineamento_at_id IN number,
 old_ni IN number,
 old_ni_erede IN number,
 new_dettaglio_id IN number,
 new_elaborazione_id IN number,
 new_pratica IN number,
 new_cod_fiscale IN varchar,
 new_stampa_id IN number,
 new_documentale_id IN number,
 new_tipografia_id IN number,
 new_avviso_agid_id IN number,
 new_appio_id IN number,
 new_anagr_id IN number,
 new_controllo_at_id IN number,
 new_allineamento_at_id IN number,
 new_ni IN number,
 new_ni_erede IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ELABORAZIONI_MASSIVE"
   cursor cpk1_dettagli_elaborazione(var_elaborazione_id number) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk2_dettagli_elaborazione(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk3_dettagli_elaborazione(var_stampa_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_stampa_id
       and   var_stampa_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk4_dettagli_elaborazione(var_documentale_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_documentale_id
       and   var_documentale_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk5_dettagli_elaborazione(var_tipografia_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_tipografia_id
       and   var_tipografia_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk6_dettagli_elaborazione(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk7_dettagli_elaborazione(var_avviso_agid_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_avviso_agid_id
       and   var_avviso_agid_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk8_dettagli_elaborazione(var_appio_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_appio_id
       and   var_appio_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk9_dettagli_elaborazione(var_anagr_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_anagr_id
       and   var_anagr_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk10_dettagli_elaborazione(var_controllo_at_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_controllo_at_id
       and   var_controllo_at_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk11_dettagli_elaborazione(var_allineamento_at_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_allineamento_at_id
       and   var_allineamento_at_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "EREDI_SOGGETTO"
   cursor cpk12_dettagli_elaborazione(var_ni number,
                                      var_ni_erede number) is
      select 1
      from   EREDI_SOGGETTO
      where  NI = var_ni
       and   NI_EREDE = var_ni_erede
       and   var_ni is not null
       and   var_ni_erede is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ELABORAZIONI_MASSIVE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_ELABORAZIONE_ID is not null and ( seq = 0 )
         and (   (NEW_ELABORAZIONE_ID != OLD_ELABORAZIONE_ID or OLD_ELABORAZIONE_ID is null) ) then
            open  cpk1_dettagli_elaborazione(NEW_ELABORAZIONE_ID);
            fetch cpk1_dettagli_elaborazione into dummy;
            found := cpk1_dettagli_elaborazione%FOUND;
            close cpk1_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Elaborazioni Massive. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk2_dettagli_elaborazione(NEW_PRATICA);
            fetch cpk2_dettagli_elaborazione into dummy;
            found := cpk2_dettagli_elaborazione%FOUND;
            close cpk2_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_STAMPA_ID is not null and ( seq = 0 )
         and (   (NEW_STAMPA_ID != OLD_STAMPA_ID or OLD_STAMPA_ID is null) ) then
            open  cpk3_dettagli_elaborazione(NEW_STAMPA_ID);
            fetch cpk3_dettagli_elaborazione into dummy;
            found := cpk3_dettagli_elaborazione%FOUND;
            close cpk3_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_DOCUMENTALE_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTALE_ID != OLD_DOCUMENTALE_ID or OLD_DOCUMENTALE_ID is null) ) then
            open  cpk4_dettagli_elaborazione(NEW_DOCUMENTALE_ID);
            fetch cpk4_dettagli_elaborazione into dummy;
            found := cpk4_dettagli_elaborazione%FOUND;
            close cpk4_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_TIPOGRAFIA_ID is not null and ( seq = 0 )
         and (   (NEW_TIPOGRAFIA_ID != OLD_TIPOGRAFIA_ID or OLD_TIPOGRAFIA_ID is null) ) then
            open  cpk5_dettagli_elaborazione(NEW_TIPOGRAFIA_ID);
            fetch cpk5_dettagli_elaborazione into dummy;
            found := cpk5_dettagli_elaborazione%FOUND;
            close cpk5_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk6_dettagli_elaborazione(NEW_COD_FISCALE);
            fetch cpk6_dettagli_elaborazione into dummy;
            found := cpk6_dettagli_elaborazione%FOUND;
            close cpk6_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_AVVISO_AGID_ID is not null and ( seq = 0 )
         and (   (NEW_AVVISO_AGID_ID != OLD_AVVISO_AGID_ID or OLD_AVVISO_AGID_ID is null) ) then
            open  cpk7_dettagli_elaborazione(NEW_AVVISO_AGID_ID);
            fetch cpk7_dettagli_elaborazione into dummy;
            found := cpk7_dettagli_elaborazione%FOUND;
            close cpk7_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_APPIO_ID is not null and ( seq = 0 )
         and (   (NEW_APPIO_ID != OLD_APPIO_ID or OLD_APPIO_ID is null) ) then
            open  cpk8_dettagli_elaborazione(NEW_APPIO_ID);
            fetch cpk8_dettagli_elaborazione into dummy;
            found := cpk8_dettagli_elaborazione%FOUND;
            close cpk8_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_ANAGR_ID is not null and ( seq = 0 )
         and (   (NEW_ANAGR_ID != OLD_ANAGR_ID or OLD_ANAGR_ID is null) ) then
            open  cpk9_dettagli_elaborazione(NEW_ANAGR_ID);
            fetch cpk9_dettagli_elaborazione into dummy;
            found := cpk9_dettagli_elaborazione%FOUND;
            close cpk9_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_CONTROLLO_AT_ID is not null and ( seq = 0 )
         and (   (NEW_CONTROLLO_AT_ID != OLD_CONTROLLO_AT_ID or OLD_CONTROLLO_AT_ID is null) ) then
            open  cpk10_dettagli_elaborazione(NEW_CONTROLLO_AT_ID);
            fetch cpk10_dettagli_elaborazione into dummy;
            found := cpk10_dettagli_elaborazione%FOUND;
            close cpk10_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_ALLINEAMENTO_AT_ID is not null and ( seq = 0 )
         and (   (NEW_ALLINEAMENTO_AT_ID != OLD_ALLINEAMENTO_AT_ID or OLD_ALLINEAMENTO_AT_ID is null) ) then
            open  cpk11_dettagli_elaborazione(NEW_ALLINEAMENTO_AT_ID);
            fetch cpk11_dettagli_elaborazione into dummy;
            found := cpk11_dettagli_elaborazione%FOUND;
            close cpk11_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "EREDI_SOGGETTO" deve esistere quando si modifica "DETTAGLI_ELABORAZIONE"
         if  NEW_NI is not null and
             NEW_NI_EREDE is not null and ( seq = 0 )
         and (   (NEW_NI != OLD_NI or OLD_NI is null)
              or (NEW_NI_EREDE != OLD_NI_EREDE or OLD_NI_EREDE is null) ) then
            open  cpk12_dettagli_elaborazione(NEW_NI,
                                              NEW_NI_EREDE);
            fetch cpk12_dettagli_elaborazione into dummy;
            found := cpk12_dettagli_elaborazione%FOUND;
            close cpk12_dettagli_elaborazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Eredi Soggetto. La registrazione Dettagli Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DETTAGLI_ELABORAZIONE_PU */
/

-- Trigger DETTAGLI_ELABORAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DETTAGLI_ELABORAZIONE

create or replace trigger DETTAGLI_ELABORAZIONE_TIU
before INSERT
    or UPDATE
on DETTAGLI_ELABORAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DETTAGLI_ELABORAZIONE_PU(:OLD.DETTAGLIO_ID,
                                  :OLD.ELABORAZIONE_ID,
                                  :OLD.PRATICA,
                                  :OLD.COD_FISCALE,
                                  :OLD.STAMPA_ID,
                                  :OLD.DOCUMENTALE_ID,
                                  :OLD.TIPOGRAFIA_ID,
                                  :OLD.AVVISO_AGID_ID,
                                  :OLD.APPIO_ID,
                                  :OLD.ANAGR_ID,
                                  :OLD.CONTROLLO_AT_ID,
                                  :OLD.ALLINEAMENTO_AT_ID,
                                  :OLD.NI,
                                  :OLD.NI_EREDE,
                         :NEW.DETTAGLIO_ID,
                         :NEW.ELABORAZIONE_ID,
                         :NEW.PRATICA,
                         :NEW.COD_FISCALE,
                         :NEW.STAMPA_ID,
                         :NEW.DOCUMENTALE_ID,
                         :NEW.TIPOGRAFIA_ID,
                         :NEW.AVVISO_AGID_ID,
                         :NEW.APPIO_ID,
                         :NEW.ANAGR_ID,
                         :NEW.CONTROLLO_AT_ID,
                         :NEW.ALLINEAMENTO_AT_ID,
                         :NEW.NI,
                         :NEW.NI_EREDE);
         null;
      end if;
      if INSERTING then
         DETTAGLI_ELABORAZIONE_PI(:NEW.ELABORAZIONE_ID,
                                  :NEW.PRATICA,
                                  :NEW.COD_FISCALE,
                                  :NEW.STAMPA_ID,
                                  :NEW.DOCUMENTALE_ID,
                                  :NEW.TIPOGRAFIA_ID,
                                  :NEW.AVVISO_AGID_ID,
                                  :NEW.APPIO_ID,
                                  :NEW.ANAGR_ID,
                                  :NEW.CONTROLLO_AT_ID,
                                  :NEW.ALLINEAMENTO_AT_ID,
                                  :NEW.NI,
                                  :NEW.NI_EREDE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DETTAGLI_ELABORAZIONE"
            cursor cpk_dettagli_elaborazione(var_DETTAGLIO_ID number) is
               select 1
                 from   DETTAGLI_ELABORAZIONE
                where  DETTAGLIO_ID = var_DETTAGLIO_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DETTAGLI_ELABORAZIONE"
               if :new.DETTAGLIO_ID is not null then
                  open  cpk_dettagli_elaborazione(:new.DETTAGLIO_ID);
                  fetch cpk_dettagli_elaborazione into dummy;
                  found := cpk_dettagli_elaborazione%FOUND;
                  close cpk_dettagli_elaborazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DETTAGLIO_ID||
                               '" gia'' presente in Dettagli Elaborazione. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DETTAGLI_ELABORAZIONE_TIU */
/

-- Procedure DOCUMENTI_CARICATI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DOCUMENTI_CARICATI

create or replace procedure DOCUMENTI_CARICATI_PI
(new_titolo_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TITOLI_DOCUMENTO"
   cursor cpk1_documenti_caricati(var_titolo_documento number) is
      select 1
      from   TITOLI_DOCUMENTO
      where  TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TITOLI_DOCUMENTO" deve esistere quando si inserisce su "DOCUMENTI_CARICATI"
         if NEW_TITOLO_DOCUMENTO is not null then
            open  cpk1_documenti_caricati(NEW_TITOLO_DOCUMENTO);
            fetch cpk1_documenti_caricati into dummy;
            found := cpk1_documenti_caricati%FOUND;
            close cpk1_documenti_caricati;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Titoli Documento. La registrazione DOCUMENTI_CARICATI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DOCUMENTI_CARICATI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DOCUMENTI_CARICATI
/* End Trigger: DOCUMENTI_CARICATI_TC */

-- Procedure DOCUMENTI_CARICATI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DOCUMENTI_CARICATI

create or replace procedure DOCUMENTI_CARICATI_PU
(old_documento_id IN number,
 old_titolo_documento IN number,
 new_documento_id IN number,
 new_titolo_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TITOLI_DOCUMENTO"
   cursor cpk1_documenti_caricati(var_titolo_documento number) is
      select 1
      from   TITOLI_DOCUMENTO
      where  TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE_CARICAMENTO"
   cursor cfk1_documenti_caricati(var_documento_id number) is
      select 1
      from   ANOMALIE_CARICAMENTO
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "ATTRIBUTI_OGCO"
   cursor cfk2_documenti_caricati(var_documento_id number) is
      select 1
      from   ATTRIBUTI_OGCO
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "RID_IMPAGATI"
   cursor cfk3_documenti_caricati(var_documento_id number) is
      select 1
      from   RID_IMPAGATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DOCUMENTI_CARICATI_MULTI"
   cursor cfk4_documenti_caricati(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI_MULTI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "VERSAMENTI"
   cursor cfk5_documenti_caricati(var_documento_id number) is
      select 1
      from   VERSAMENTI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "CONFERIMENTI_CER"
   cursor cfk6_documenti_caricati(var_documento_id number) is
      select 1
      from   CONFERIMENTI_CER
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_METRICI_TESTATE"
   cursor cfk7_documenti_caricati(var_documento_id number) is
      select 1
      from   DATI_METRICI_TESTATE
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "LOCAZIONI_TESTATE"
   cursor cfk8_documenti_caricati(var_documento_id number) is
      select 1
      from   LOCAZIONI_TESTATE
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "UTENZE_FORNITURE"
   cursor cfk9_documenti_caricati(var_documento_id number) is
      select 1
      from   UTENZE_FORNITURE
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk10_documenti_caricati(var_documento_id number) is
      select 1
      from   SAM_RISPOSTE
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "SVUOTAMENTI"
   cursor cfk11_documenti_caricati(var_documento_id number) is
      select 1
      from   SVUOTAMENTI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TITOLI_DOCUMENTO" deve esistere quando si modifica "DOCUMENTI_CARICATI"
         if  NEW_TITOLO_DOCUMENTO is not null and ( seq = 0 )
         and (   (NEW_TITOLO_DOCUMENTO != OLD_TITOLO_DOCUMENTO or OLD_TITOLO_DOCUMENTO is null) ) then
            open  cpk1_documenti_caricati(NEW_TITOLO_DOCUMENTO);
            fetch cpk1_documenti_caricati into dummy;
            found := cpk1_documenti_caricati%FOUND;
            close cpk1_documenti_caricati;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Titoli Documento. La registrazione DOCUMENTI_CARICATI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "ANOMALIE_CARICAMENTO"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk1_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk1_documenti_caricati into dummy;
         found := cfk1_documenti_caricati%FOUND;
         close cfk1_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ANOMALIE_CARICAMENTO. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "ATTRIBUTI_OGCO"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk2_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk2_documenti_caricati into dummy;
         found := cfk2_documenti_caricati%FOUND;
         close cfk2_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Attributi OGCO. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "RID_IMPAGATI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk3_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk3_documenti_caricati into dummy;
         found := cfk3_documenti_caricati%FOUND;
         close cfk3_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su RID_IMPAGATI. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "DOCUMENTI_CARICATI_MULTI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk4_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk4_documenti_caricati into dummy;
         found := cfk4_documenti_caricati%FOUND;
         close cfk4_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DOCUMENTI_CARICATI_MULTI. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "VERSAMENTI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk5_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk5_documenti_caricati into dummy;
         found := cfk5_documenti_caricati%FOUND;
         close cfk5_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Versamenti. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "CONFERIMENTI_CER"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk6_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk6_documenti_caricati into dummy;
         found := cfk6_documenti_caricati%FOUND;
         close cfk6_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Conferimenti CER. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "DATI_METRICI_TESTATE"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk7_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk7_documenti_caricati into dummy;
         found := cfk7_documenti_caricati%FOUND;
         close cfk7_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DATI_METRICI_TESTATE. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "LOCAZIONI_TESTATE"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk8_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk8_documenti_caricati into dummy;
         found := cfk8_documenti_caricati%FOUND;
         close cfk8_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su LOCAZIONI_TESTATE. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "UTENZE_FORNITURE"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk9_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk9_documenti_caricati into dummy;
         found := cfk9_documenti_caricati%FOUND;
         close cfk9_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su UTENZE_FORNITURE. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "SAM_RISPOSTE"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk10_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk10_documenti_caricati into dummy;
         found := cfk10_documenti_caricati%FOUND;
         close cfk10_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile se esistono referenze su "SVUOTAMENTI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         open  cfk11_documenti_caricati(OLD_DOCUMENTO_ID);
         fetch cfk11_documenti_caricati into dummy;
         found := cfk11_documenti_caricati%FOUND;
         close cfk11_documenti_caricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Svuotamenti. La registrazione di DOCUMENTI_CARICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DOCUMENTI_CARICATI_PU */
/

-- Trigger DOCUMENTI_CARICATI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DOCUMENTI_CARICATI

create or replace trigger DOCUMENTI_CARICATI_TIU
before INSERT
    or UPDATE
on DOCUMENTI_CARICATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.documento_id is null then
      DOCUMENTI_CARICATI_NR(:new.documento_id);
   end if;


   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DOCUMENTI_CARICATI_PU(:OLD.DOCUMENTO_ID,
                               :OLD.TITOLO_DOCUMENTO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.TITOLO_DOCUMENTO);
         null;
      end if;
      if INSERTING then
         DOCUMENTI_CARICATI_PI(:NEW.TITOLO_DOCUMENTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DOCUMENTI_CARICATI"
            cursor cpk_documenti_caricati(var_DOCUMENTO_ID number) is
               select 1
                 from   DOCUMENTI_CARICATI
                where  DOCUMENTO_ID = var_DOCUMENTO_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DOCUMENTI_CARICATI"
               if :new.DOCUMENTO_ID is not null then
                  open  cpk_documenti_caricati(:new.DOCUMENTO_ID);
                  fetch cpk_documenti_caricati into dummy;
                  found := cpk_documenti_caricati%FOUND;
                  close cpk_documenti_caricati;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||
                               '" gia'' presente in DOCUMENTI_CARICATI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DOCUMENTI_CARICATI_TIU */
/

-- Procedure DOCUMENTI_CARICATI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table DOCUMENTI_CARICATI

create or replace procedure DOCUMENTI_CARICATI_PD
(old_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ANOMALIE_CARICAMENTO"
   cursor cfk1_documenti_caricati(var_documento_id number) is
      select 1
      from   ANOMALIE_CARICAMENTO
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "ATTRIBUTI_OGCO"
   cursor cfk2_documenti_caricati(var_documento_id number) is
      select 1
      from   ATTRIBUTI_OGCO
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "RID_IMPAGATI"
   cursor cfk3_documenti_caricati(var_documento_id number) is
      select 1
      from   RID_IMPAGATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DOCUMENTI_CARICATI_MULTI"
   cursor cfk4_documenti_caricati(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI_MULTI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk5_documenti_caricati(var_documento_id number) is
      select 1
      from   VERSAMENTI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "CONFERIMENTI_CER"
   cursor cfk6_documenti_caricati(var_documento_id number) is
      select 1
      from   CONFERIMENTI_CER
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_METRICI_TESTATE"
   cursor cfk7_documenti_caricati(var_documento_id number) is
      select 1
      from   DATI_METRICI_TESTATE
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "LOCAZIONI_TESTATE"
   cursor cfk8_documenti_caricati(var_documento_id number) is
      select 1
      from   LOCAZIONI_TESTATE
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "UTENZE_FORNITURE"
   cursor cfk9_documenti_caricati(var_documento_id number) is
      select 1
      from   UTENZE_FORNITURE
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk10_documenti_caricati(var_documento_id number) is
      select 1
      from   SAM_RISPOSTE
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "SVUOTAMENTI"
   cursor cfk11_documenti_caricati(var_documento_id number) is
      select 1
      from   SVUOTAMENTI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "ANOMALIE_CARICAMENTO"
      open  cfk1_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk1_documenti_caricati into dummy;
      found := cfk1_documenti_caricati%FOUND;
      close cfk1_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ANOMALIE_CARICAMENTO. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "ATTRIBUTI_OGCO"
      open  cfk2_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk2_documenti_caricati into dummy;
      found := cfk2_documenti_caricati%FOUND;
      close cfk2_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Attributi OGCO. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "RID_IMPAGATI"
      open  cfk3_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk3_documenti_caricati into dummy;
      found := cfk3_documenti_caricati%FOUND;
      close cfk3_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su RID_IMPAGATI. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "DOCUMENTI_CARICATI_MULTI"
      open  cfk4_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk4_documenti_caricati into dummy;
      found := cfk4_documenti_caricati%FOUND;
      close cfk4_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DOCUMENTI_CARICATI_MULTI. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "VERSAMENTI"
      open  cfk5_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk5_documenti_caricati into dummy;
      found := cfk5_documenti_caricati%FOUND;
      close cfk5_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "CONFERIMENTI_CER"
      open  cfk6_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk6_documenti_caricati into dummy;
      found := cfk6_documenti_caricati%FOUND;
      close cfk6_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Conferimenti CER. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "DATI_METRICI_TESTATE"
      open  cfk7_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk7_documenti_caricati into dummy;
      found := cfk7_documenti_caricati%FOUND;
      close cfk7_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DATI_METRICI_TESTATE. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "LOCAZIONI_TESTATE"
      open  cfk8_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk8_documenti_caricati into dummy;
      found := cfk8_documenti_caricati%FOUND;
      close cfk8_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su LOCAZIONI_TESTATE. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "UTENZE_FORNITURE"
      open  cfk9_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk9_documenti_caricati into dummy;
      found := cfk9_documenti_caricati%FOUND;
      close cfk9_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su UTENZE_FORNITURE. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "SAM_RISPOSTE"
      open  cfk10_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk10_documenti_caricati into dummy;
      found := cfk10_documenti_caricati%FOUND;
      close cfk10_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "DOCUMENTI_CARICATI" if children still exist in "SVUOTAMENTI"
      open  cfk11_documenti_caricati(OLD_DOCUMENTO_ID);
      fetch cfk11_documenti_caricati into dummy;
      found := cfk11_documenti_caricati%FOUND;
      close cfk11_documenti_caricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Svuotamenti. La registrazione di DOCUMENTI_CARICATI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DOCUMENTI_CARICATI_PD */
/

-- Tigger DOCUMENTI_CARICATI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DOCUMENTI_CARICATI

create or replace trigger DOCUMENTI_CARICATI_TD
before DELETE
on DOCUMENTI_CARICATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ANOMALIE_CARICAMENTO

      -- Child Restrict Table: ATTRIBUTI_OGCO

      -- Child Restrict Table: RID_IMPAGATI

      -- Child Restrict Table: DOCUMENTI_CARICATI_MULTI

      -- Child Restrict Table: VERSAMENTI

      -- Child Restrict Table: CONFERIMENTI_CER

      -- Child Restrict Table: DATI_METRICI_TESTATE

      -- Child Restrict Table: LOCAZIONI_TESTATE

      -- Child Restrict Table: UTENZE_FORNITURE

      -- Child Restrict Table: SAM_RISPOSTE

      -- Child Restrict Table: SVUOTAMENTI

      DOCUMENTI_CARICATI_PD(:OLD.DOCUMENTO_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DOCUMENTI_CARICATI_TD */
/

-- Procedure DOCUMENTI_CARICATI_MULTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DOCUMENTI_CARICATI_MULTI

create or replace procedure DOCUMENTI_CARICATI_MULTI_PI
(new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk1_documenti_caricati_multi(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "DOCUMENTI_CARICATI_MULTI"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk1_documenti_caricati_multi(NEW_DOCUMENTO_ID);
            fetch cpk1_documenti_caricati_multi into dummy;
            found := cpk1_documenti_caricati_multi%FOUND;
            close cpk1_documenti_caricati_multi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione DOCUMENTI_CARICATI_MULTI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DOCUMENTI_CARICATI_MULTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DOCUMENTI_CARICATI_MULTI
/* End Trigger: DOCUMENTI_CARICATI_MULTI_TC */

-- Procedure DOCUMENTI_CARICATI_MULTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DOCUMENTI_CARICATI_MULTI

create or replace procedure DOCUMENTI_CARICATI_MULTI_PU
(old_documento_id IN number,
 old_documento_multi_id IN number,
 new_documento_id IN number,
 new_documento_multi_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk1_documenti_caricati_multi(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_documenti_caricati_multi(var_documento_id number,
                                        var_documento_multi_id number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   var_documento_id is not null
       and   var_documento_multi_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "DOCUMENTI_CARICATI_MULTI"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk1_documenti_caricati_multi(NEW_DOCUMENTO_ID);
            fetch cpk1_documenti_caricati_multi into dummy;
            found := cpk1_documenti_caricati_multi%FOUND;
            close cpk1_documenti_caricati_multi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione DOCUMENTI_CARICATI_MULTI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DOCUMENTI_CARICATI_MULTI" non modificabile se esistono referenze su "PRATICHE_TRIBUTO"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) or
         (OLD_DOCUMENTO_MULTI_ID != NEW_DOCUMENTO_MULTI_ID) then
         open  cfk1_documenti_caricati_multi(OLD_DOCUMENTO_ID,
                                             OLD_DOCUMENTO_MULTI_ID);
         fetch cfk1_documenti_caricati_multi into dummy;
         found := cfk1_documenti_caricati_multi%FOUND;
         close cfk1_documenti_caricati_multi;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di DOCUMENTI_CARICATI_MULTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DOCUMENTI_CARICATI_MULTI_PU */
/

-- Trigger DOCUMENTI_CARICATI_MULTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DOCUMENTI_CARICATI_MULTI

create or replace trigger DOCUMENTI_CARICATI_MULTI_TIU
before INSERT
    or UPDATE
on DOCUMENTI_CARICATI_MULTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      DOCUMENTI_CARICATI_MULTI_NR(:new.documento_id,:new.documento_multi_id);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DOCUMENTI_CARICATI_MULTI_PU(:OLD.DOCUMENTO_ID,
                                     :OLD.DOCUMENTO_MULTI_ID,
                         :NEW.DOCUMENTO_ID,
                         :NEW.DOCUMENTO_MULTI_ID);
         null;
      end if;
      if INSERTING then
         DOCUMENTI_CARICATI_MULTI_PI(:NEW.DOCUMENTO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DOCUMENTI_CARICATI_MULTI"
            cursor cpk_documenti_caricati_multi(var_DOCUMENTO_ID number,
                                                var_DOCUMENTO_MULTI_ID number) is
               select 1
                 from   DOCUMENTI_CARICATI_MULTI
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       DOCUMENTO_MULTI_ID = var_DOCUMENTO_MULTI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DOCUMENTI_CARICATI_MULTI"
               if :new.DOCUMENTO_ID is not null and
                  :new.DOCUMENTO_MULTI_ID is not null then
                  open  cpk_documenti_caricati_multi(:new.DOCUMENTO_ID,
                                                     :new.DOCUMENTO_MULTI_ID);
                  fetch cpk_documenti_caricati_multi into dummy;
                  found := cpk_documenti_caricati_multi%FOUND;
                  close cpk_documenti_caricati_multi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.DOCUMENTO_MULTI_ID||
                               '" gia'' presente in DOCUMENTI_CARICATI_MULTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DOCUMENTI_CARICATI_MULTI_TIU */
/

-- Procedure DOCUMENTI_CARICATI_MULTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table DOCUMENTI_CARICATI_MULTI

create or replace procedure DOCUMENTI_CARICATI_MULTI_PD
(old_documento_id IN number,
 old_documento_multi_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DOCUMENTI_CARICATI_MULTI_PD */
/

-- Tigger DOCUMENTI_CARICATI_MULTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DOCUMENTI_CARICATI_MULTI

create or replace trigger DOCUMENTI_CARICATI_MULTI_TD
before DELETE
on DOCUMENTI_CARICATI_MULTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            DOCUMENTI_CARICATI_MULTI_FI(:new.documento_id,:new.documento_multi_id);
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      DOCUMENTI_CARICATI_MULTI_PD(:OLD.DOCUMENTO_ID,
                                  :OLD.DOCUMENTO_MULTI_ID);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Set parent code of "DOCUMENTI_CARICATI_MULTI" to NULL in child "PRATICHE_TRIBUTO"
      update PRATICHE_TRIBUTO
       set   DOCUMENTO_ID = NULL,
             DOCUMENTO_MULTI_ID = NULL
      where  DOCUMENTO_ID = :OLD.DOCUMENTO_ID
       and   DOCUMENTO_MULTI_ID = :OLD.DOCUMENTO_MULTI_ID;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DOCUMENTI_CARICATI_MULTI_TD */
/

-- Procedure DOCUMENTI_CONTRIBUENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table DOCUMENTI_CONTRIBUENTE

create or replace procedure DOCUMENTI_CONTRIBUENTE_PI
(new_cod_fiscale IN varchar,
 new_pratica IN number,
 new_ruolo IN number,
 new_tipo_canale IN number,
 new_sequenza_principale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_documenti_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk2_documenti_contribuente(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk3_documenti_contribuente(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_CANALE"
   cursor cpk4_documenti_contribuente(var_tipo_canale number) is
      select 1
      from   TIPI_CANALE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CONTRIBUENTE"
   cursor cpk5_documenti_contribuente(var_cod_fiscale varchar,
                                      var_sequenza_principale number) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   SEQUENZA = var_sequenza_principale
       and   var_cod_fiscale is not null
       and   var_sequenza_principale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "DOCUMENTI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null then
            open  cpk1_documenti_contribuente(NEW_COD_FISCALE);
            fetch cpk1_documenti_contribuente into dummy;
            found := cpk1_documenti_contribuente%FOUND;
            close cpk1_documenti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Documenti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "DOCUMENTI_CONTRIBUENTE"
         if NEW_PRATICA is not null then
            open  cpk2_documenti_contribuente(NEW_PRATICA);
            fetch cpk2_documenti_contribuente into dummy;
            found := cpk2_documenti_contribuente%FOUND;
            close cpk2_documenti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Documenti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "DOCUMENTI_CONTRIBUENTE"
         if NEW_RUOLO is not null then
            open  cpk3_documenti_contribuente(NEW_RUOLO);
            fetch cpk3_documenti_contribuente into dummy;
            found := cpk3_documenti_contribuente%FOUND;
            close cpk3_documenti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Documenti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CANALE" deve esistere quando si inserisce su "DOCUMENTI_CONTRIBUENTE"
         if NEW_TIPO_CANALE is not null then
            open  cpk4_documenti_contribuente(NEW_TIPO_CANALE);
            fetch cpk4_documenti_contribuente into dummy;
            found := cpk4_documenti_contribuente%FOUND;
            close cpk4_documenti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Canale. La registrazione Documenti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CONTRIBUENTE" deve esistere quando si inserisce su "DOCUMENTI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null and
            NEW_SEQUENZA_PRINCIPALE is not null then
            open  cpk5_documenti_contribuente(NEW_COD_FISCALE,
                                              NEW_SEQUENZA_PRINCIPALE);
            fetch cpk5_documenti_contribuente into dummy;
            found := cpk5_documenti_contribuente%FOUND;
            close cpk5_documenti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Documenti Contribuente. La registrazione Documenti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DOCUMENTI_CONTRIBUENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table DOCUMENTI_CONTRIBUENTE

create or replace trigger DOCUMENTI_CONTRIBUENTE_TB
before INSERT
    or UPDATE
    or DELETE
on DOCUMENTI_CONTRIBUENTE
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: DOCUMENTI_CONTRIBUENTE_TB */
/

create or replace trigger DOCUMENTI_CONTRIBUENTE_TC
after INSERT
   or UPDATE
   or DELETE
on DOCUMENTI_CONTRIBUENTE
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: DOCUMENTI_CONTRIBUENTE_TC */
/

-- Procedure DOCUMENTI_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table DOCUMENTI_CONTRIBUENTE

create or replace procedure DOCUMENTI_CONTRIBUENTE_PU
(old_cod_fiscale IN varchar,
 old_sequenza IN number,
 old_pratica IN number,
 old_ruolo IN number,
 old_tipo_canale IN number,
 old_sequenza_principale IN number,
 new_cod_fiscale IN varchar,
 new_sequenza IN number,
 new_pratica IN number,
 new_ruolo IN number,
 new_tipo_canale IN number,
 new_sequenza_principale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_documenti_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk2_documenti_contribuente(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk3_documenti_contribuente(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_CANALE"
   cursor cpk4_documenti_contribuente(var_tipo_canale number) is
      select 1
      from   TIPI_CANALE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CONTRIBUENTE"
   cursor cpk5_documenti_contribuente(var_cod_fiscale varchar,
                                      var_sequenza_principale number) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   SEQUENZA = var_sequenza_principale
       and   var_cod_fiscale is not null
       and   var_sequenza_principale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "DOCUMENTI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_documenti_contribuente(NEW_COD_FISCALE);
            fetch cpk1_documenti_contribuente into dummy;
            found := cpk1_documenti_contribuente%FOUND;
            close cpk1_documenti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Documenti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "DOCUMENTI_CONTRIBUENTE"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk2_documenti_contribuente(NEW_PRATICA);
            fetch cpk2_documenti_contribuente into dummy;
            found := cpk2_documenti_contribuente%FOUND;
            close cpk2_documenti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Documenti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "DOCUMENTI_CONTRIBUENTE"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk3_documenti_contribuente(NEW_RUOLO);
            fetch cpk3_documenti_contribuente into dummy;
            found := cpk3_documenti_contribuente%FOUND;
            close cpk3_documenti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Documenti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CANALE" deve esistere quando si modifica "DOCUMENTI_CONTRIBUENTE"
         if  NEW_TIPO_CANALE is not null and ( seq = 0 )
         and (   (NEW_TIPO_CANALE != OLD_TIPO_CANALE or OLD_TIPO_CANALE is null) ) then
            open  cpk4_documenti_contribuente(NEW_TIPO_CANALE);
            fetch cpk4_documenti_contribuente into dummy;
            found := cpk4_documenti_contribuente%FOUND;
            close cpk4_documenti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Canale. La registrazione Documenti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CONTRIBUENTE" deve esistere quando si modifica "DOCUMENTI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and
             NEW_SEQUENZA_PRINCIPALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_SEQUENZA_PRINCIPALE != OLD_SEQUENZA_PRINCIPALE or OLD_SEQUENZA_PRINCIPALE is null) ) then
            open  cpk5_documenti_contribuente(NEW_COD_FISCALE,
                                              NEW_SEQUENZA_PRINCIPALE);
            fetch cpk5_documenti_contribuente into dummy;
            found := cpk5_documenti_contribuente%FOUND;
            close cpk5_documenti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Documenti Contribuente. La registrazione Documenti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: DOCUMENTI_CONTRIBUENTE_PU */
/

-- Trigger DOCUMENTI_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table DOCUMENTI_CONTRIBUENTE

create or replace trigger DOCUMENTI_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on DOCUMENTI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
       DOCUMENTI_CONTRIBUENTE_NR (:new.cod_fiscale,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         DOCUMENTI_CONTRIBUENTE_PU(:OLD.COD_FISCALE,
                                   :OLD.SEQUENZA,
                                   :OLD.PRATICA,
                                   :OLD.RUOLO,
                                   :OLD.TIPO_CANALE,
                                   :OLD.SEQUENZA_PRINCIPALE,
                         :NEW.COD_FISCALE,
                         :NEW.SEQUENZA,
                         :NEW.PRATICA,
                         :NEW.RUOLO,
                         :NEW.TIPO_CANALE,
                         :NEW.SEQUENZA_PRINCIPALE);
         null;
      end if;
      if INSERTING then
         DOCUMENTI_CONTRIBUENTE_PI(:NEW.COD_FISCALE,
                                   :NEW.PRATICA,
                                   :NEW.RUOLO,
                                   :NEW.TIPO_CANALE,
                                   :NEW.SEQUENZA_PRINCIPALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "DOCUMENTI_CONTRIBUENTE"
            cursor cpk_documenti_contribuente(var_COD_FISCALE varchar,
                                              var_SEQUENZA number) is
               select 1
                 from   DOCUMENTI_CONTRIBUENTE
                where  COD_FISCALE = var_COD_FISCALE and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "DOCUMENTI_CONTRIBUENTE"
               if :new.COD_FISCALE is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_documenti_contribuente(:new.COD_FISCALE,
                                                   :new.SEQUENZA);
                  fetch cpk_documenti_contribuente into dummy;
                  found := cpk_documenti_contribuente%FOUND;
                  close cpk_documenti_contribuente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Documenti Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DOCUMENTI_CONTRIBUENTE_TIU */
/

-- Tigger DOCUMENTI_CONTRIBUENTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table DOCUMENTI_CONTRIBUENTE

create or replace trigger DOCUMENTI_CONTRIBUENTE_TD
before DELETE
on DOCUMENTI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      DOCUMENTI_CONTRIBUENTE_PD(:OLD.COD_FISCALE,
                                :OLD.SEQUENZA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
         a_istruzione := 'select 0 from documenti_contribuente where cod_fiscale = '''
                         ||:old.cod_fiscale||''' and sequenza_principale = '
                         ||:old.sequenza;
         a_messaggio := 'Esistono riferimenti di Allegati su Documenti Contribuente. La registrazione di Documenti Contribuente non e'' eliminabile.';
         IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;

   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: DOCUMENTI_CONTRIBUENTE_TD */
/

-- Procedure EDIFICI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table EDIFICI

create or replace procedure EDIFICI_PI
(new_amministratore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk1_edifici(var_amministratore number) is
      select 1
      from   SOGGETTI
      where  NI = var_amministratore
       and   var_amministratore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "EDIFICI"
         if NEW_AMMINISTRATORE is not null then
            open  cpk1_edifici(NEW_AMMINISTRATORE);
            fetch cpk1_edifici into dummy;
            found := cpk1_edifici%FOUND;
            close cpk1_edifici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Edifici non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EDIFICI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table EDIFICI
/* End Trigger: EDIFICI_TC */

-- Procedure EDIFICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table EDIFICI

create or replace procedure EDIFICI_PU
(old_edificio IN number,
 old_amministratore IN number,
 new_edificio IN number,
 new_amministratore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk1_edifici(var_amministratore number) is
      select 1
      from   SOGGETTI
      where  NI = var_amministratore
       and   var_amministratore is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI"
   cursor cfk1_edifici(var_edificio number) is
      select 1
      from   OGGETTI
      where  EDIFICIO = var_edificio
       and   var_edificio is not null;

   --  Declaration of UpdateParentRestrict constraint for "CIVICI_EDIFICIO"
   cursor cfk2_edifici(var_edificio number) is
      select 1
      from   CIVICI_EDIFICIO
      where  EDIFICIO = var_edificio
       and   var_edificio is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "EDIFICI"
         if  NEW_AMMINISTRATORE is not null and ( seq = 0 )
         and (   (NEW_AMMINISTRATORE != OLD_AMMINISTRATORE or OLD_AMMINISTRATORE is null) ) then
            open  cpk1_edifici(NEW_AMMINISTRATORE);
            fetch cpk1_edifici into dummy;
            found := cpk1_edifici%FOUND;
            close cpk1_edifici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Edifici non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "EDIFICI" non modificabile se esistono referenze su "OGGETTI"
      if (OLD_EDIFICIO != NEW_EDIFICIO) then
         open  cfk1_edifici(OLD_EDIFICIO);
         fetch cfk1_edifici into dummy;
         found := cfk1_edifici%FOUND;
         close cfk1_edifici;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Edifici non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "EDIFICI" non modificabile se esistono referenze su "CIVICI_EDIFICIO"
      if (OLD_EDIFICIO != NEW_EDIFICIO) then
         open  cfk2_edifici(OLD_EDIFICIO);
         fetch cfk2_edifici into dummy;
         found := cfk2_edifici%FOUND;
         close cfk2_edifici;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Civici Edificio. La registrazione di Edifici non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EDIFICI_PU */
/

-- Trigger EDIFICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table EDIFICI

create or replace trigger EDIFICI_TIU
before INSERT
    or UPDATE
on EDIFICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         EDIFICI_PU(:OLD.EDIFICIO,
                    :OLD.AMMINISTRATORE,
                         :NEW.EDIFICIO,
                         :NEW.AMMINISTRATORE);
         null;
      end if;
      if INSERTING then
         EDIFICI_PI(:NEW.AMMINISTRATORE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "EDIFICI"
            cursor cpk_edifici(var_EDIFICIO number) is
               select 1
                 from   EDIFICI
                where  EDIFICIO = var_EDIFICIO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "EDIFICI"
               if :new.EDIFICIO is not null then
                  open  cpk_edifici(:new.EDIFICIO);
                  fetch cpk_edifici into dummy;
                  found := cpk_edifici%FOUND;
                  close cpk_edifici;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.EDIFICIO||
                               '" gia'' presente in Edifici. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: EDIFICI_TIU */
/

-- Procedure EDIFICI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table EDIFICI

create or replace procedure EDIFICI_PD
(old_edificio IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI"
   cursor cfk1_edifici(var_edificio number) is
      select 1
      from   OGGETTI
      where  EDIFICIO = var_edificio
       and   var_edificio is not null;

   --  Declaration of DeleteParentRestrict constraint for "CIVICI_EDIFICIO"
   cursor cfk2_edifici(var_edificio number) is
      select 1
      from   CIVICI_EDIFICIO
      where  EDIFICIO = var_edificio
       and   var_edificio is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "EDIFICI" if children still exist in "OGGETTI"
      open  cfk1_edifici(OLD_EDIFICIO);
      fetch cfk1_edifici into dummy;
      found := cfk1_edifici%FOUND;
      close cfk1_edifici;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Edifici non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "EDIFICI" if children still exist in "CIVICI_EDIFICIO"
      open  cfk2_edifici(OLD_EDIFICIO);
      fetch cfk2_edifici into dummy;
      found := cfk2_edifici%FOUND;
      close cfk2_edifici;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Civici Edificio. La registrazione di Edifici non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EDIFICI_PD */
/

-- Tigger EDIFICI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table EDIFICI

create or replace trigger EDIFICI_TD
before DELETE
on EDIFICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI

      -- Child Restrict Table: CIVICI_EDIFICIO

      EDIFICI_PD(:OLD.EDIFICIO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: EDIFICI_TD */
/

-- Procedure ELABORAZIONI_MASSIVE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ELABORAZIONI_MASSIVE

create or replace procedure ELABORAZIONI_MASSIVE_PI
(new_tipo_tributo IN varchar,
 new_ruolo IN number,
 new_gruppo_tributo IN varchar,
 new_tipo_elaborazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk1_elaborazioni_massive(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_elaborazioni_massive(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "GRUPPI_TRIBUTO"
   cursor cpk3_elaborazioni_massive(var_gruppo_tributo varchar,
                                    var_tipo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  GRUPPO_TRIBUTO = var_gruppo_tributo
       and   TIPO_TRIBUTO = var_tipo_tributo
       and   var_gruppo_tributo is not null
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ELABORAZIONE"
   cursor cpk4_elaborazioni_massive(var_tipo_elaborazione varchar) is
      select 1
      from   TIPI_ELABORAZIONE
      where  TIPO_ELABORAZIONE = var_tipo_elaborazione
       and   var_tipo_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "ELABORAZIONI_MASSIVE"
         if NEW_RUOLO is not null then
            open  cpk1_elaborazioni_massive(NEW_RUOLO);
            fetch cpk1_elaborazioni_massive into dummy;
            found := cpk1_elaborazioni_massive%FOUND;
            close cpk1_elaborazioni_massive;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Elaborazioni Massive non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "ELABORAZIONI_MASSIVE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_elaborazioni_massive(NEW_TIPO_TRIBUTO);
            fetch cpk2_elaborazioni_massive into dummy;
            found := cpk2_elaborazioni_massive%FOUND;
            close cpk2_elaborazioni_massive;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Elaborazioni Massive non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_TRIBUTO" deve esistere quando si inserisce su "ELABORAZIONI_MASSIVE"
         if NEW_GRUPPO_TRIBUTO is not null and
            NEW_TIPO_TRIBUTO is not null then
            open  cpk3_elaborazioni_massive(NEW_GRUPPO_TRIBUTO,
                                            NEW_TIPO_TRIBUTO);
            fetch cpk3_elaborazioni_massive into dummy;
            found := cpk3_elaborazioni_massive%FOUND;
            close cpk3_elaborazioni_massive;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Gruppi_tributo. La registrazione Elaborazioni Massive non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ELABORAZIONE" deve esistere quando si inserisce su "ELABORAZIONI_MASSIVE"
         if NEW_TIPO_ELABORAZIONE is not null then
            open  cpk4_elaborazioni_massive(NEW_TIPO_ELABORAZIONE);
            fetch cpk4_elaborazioni_massive into dummy;
            found := cpk4_elaborazioni_massive%FOUND;
            close cpk4_elaborazioni_massive;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi_Elaborazione. La registrazione Elaborazioni Massive non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ELABORAZIONI_MASSIVE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ELABORAZIONI_MASSIVE
/* End Trigger: ELABORAZIONI_MASSIVE_TC */

-- Procedure ELABORAZIONI_MASSIVE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ELABORAZIONI_MASSIVE

create or replace procedure ELABORAZIONI_MASSIVE_PU
(old_elaborazione_id IN number,
 old_tipo_tributo IN varchar,
 old_ruolo IN number,
 old_gruppo_tributo IN varchar,
 old_tipo_elaborazione IN varchar,
 new_elaborazione_id IN number,
 new_tipo_tributo IN varchar,
 new_ruolo IN number,
 new_gruppo_tributo IN varchar,
 new_tipo_elaborazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk1_elaborazioni_massive(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_elaborazioni_massive(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "GRUPPI_TRIBUTO"
   cursor cpk3_elaborazioni_massive(var_gruppo_tributo varchar,
                                    var_tipo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  GRUPPO_TRIBUTO = var_gruppo_tributo
       and   TIPO_TRIBUTO = var_tipo_tributo
       and   var_gruppo_tributo is not null
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ELABORAZIONE"
   cursor cpk4_elaborazioni_massive(var_tipo_elaborazione varchar) is
      select 1
      from   TIPI_ELABORAZIONE
      where  TIPO_ELABORAZIONE = var_tipo_elaborazione
       and   var_tipo_elaborazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_INTERROGAZIONI"
   cursor cfk1_elaborazioni_massive(var_elaborazione_id number) is
      select 1
      from   SAM_INTERROGAZIONI
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "ELABORAZIONI_MASSIVE"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk1_elaborazioni_massive(NEW_RUOLO);
            fetch cpk1_elaborazioni_massive into dummy;
            found := cpk1_elaborazioni_massive%FOUND;
            close cpk1_elaborazioni_massive;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Elaborazioni Massive non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "ELABORAZIONI_MASSIVE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_elaborazioni_massive(NEW_TIPO_TRIBUTO);
            fetch cpk2_elaborazioni_massive into dummy;
            found := cpk2_elaborazioni_massive%FOUND;
            close cpk2_elaborazioni_massive;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Elaborazioni Massive non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_TRIBUTO" deve esistere quando si modifica "ELABORAZIONI_MASSIVE"
         if  NEW_GRUPPO_TRIBUTO is not null and
             NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_GRUPPO_TRIBUTO != OLD_GRUPPO_TRIBUTO or OLD_GRUPPO_TRIBUTO is null)
              or (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk3_elaborazioni_massive(NEW_GRUPPO_TRIBUTO,
                                            NEW_TIPO_TRIBUTO);
            fetch cpk3_elaborazioni_massive into dummy;
            found := cpk3_elaborazioni_massive%FOUND;
            close cpk3_elaborazioni_massive;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Gruppi_tributo. La registrazione Elaborazioni Massive non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ELABORAZIONE" deve esistere quando si modifica "ELABORAZIONI_MASSIVE"
         if  NEW_TIPO_ELABORAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_ELABORAZIONE != OLD_TIPO_ELABORAZIONE or OLD_TIPO_ELABORAZIONE is null) ) then
            open  cpk4_elaborazioni_massive(NEW_TIPO_ELABORAZIONE);
            fetch cpk4_elaborazioni_massive into dummy;
            found := cpk4_elaborazioni_massive%FOUND;
            close cpk4_elaborazioni_massive;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi_Elaborazione. La registrazione Elaborazioni Massive non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "ELABORAZIONI_MASSIVE" non modificabile se esistono referenze su "SAM_INTERROGAZIONI"
      if (OLD_ELABORAZIONE_ID != NEW_ELABORAZIONE_ID) then
         open  cfk1_elaborazioni_massive(OLD_ELABORAZIONE_ID);
         fetch cfk1_elaborazioni_massive into dummy;
         found := cfk1_elaborazioni_massive%FOUND;
         close cfk1_elaborazioni_massive;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_INTERROGAZIONI. La registrazione di Elaborazioni Massive non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ELABORAZIONI_MASSIVE_PU */
/

-- Trigger ELABORAZIONI_MASSIVE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ELABORAZIONI_MASSIVE

create or replace trigger ELABORAZIONI_MASSIVE_TIU
before INSERT
    or UPDATE
on ELABORAZIONI_MASSIVE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ELABORAZIONI_MASSIVE_PU(:OLD.ELABORAZIONE_ID,
                                 :OLD.TIPO_TRIBUTO,
                                 :OLD.RUOLO,
                                 :OLD.GRUPPO_TRIBUTO,
                                 :OLD.TIPO_ELABORAZIONE,
                         :NEW.ELABORAZIONE_ID,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.RUOLO,
                         :NEW.GRUPPO_TRIBUTO,
                         :NEW.TIPO_ELABORAZIONE);
         null;
      end if;
      if INSERTING then
         ELABORAZIONI_MASSIVE_PI(:NEW.TIPO_TRIBUTO,
                                 :NEW.RUOLO,
                                 :NEW.GRUPPO_TRIBUTO,
                                 :NEW.TIPO_ELABORAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ELABORAZIONI_MASSIVE"
            cursor cpk_elaborazioni_massive(var_ELABORAZIONE_ID number) is
               select 1
                 from   ELABORAZIONI_MASSIVE
                where  ELABORAZIONE_ID = var_ELABORAZIONE_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ELABORAZIONI_MASSIVE"
               if :new.ELABORAZIONE_ID is not null then
                  open  cpk_elaborazioni_massive(:new.ELABORAZIONE_ID);
                  fetch cpk_elaborazioni_massive into dummy;
                  found := cpk_elaborazioni_massive%FOUND;
                  close cpk_elaborazioni_massive;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ELABORAZIONE_ID||
                               '" gia'' presente in Elaborazioni Massive. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "ELABORAZIONI_MASSIVE" for all children in "ATTIVITA_ELABORAZIONE"
         if (:OLD.ELABORAZIONE_ID != :NEW.ELABORAZIONE_ID) then
            update ATTIVITA_ELABORAZIONE
             set   ELABORAZIONE_ID = :NEW.ELABORAZIONE_ID
            where  ELABORAZIONE_ID = :OLD.ELABORAZIONE_ID;
         end if;

         --  Modify parent code of "ELABORAZIONI_MASSIVE" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.ELABORAZIONE_ID != :NEW.ELABORAZIONE_ID) then
            update DETTAGLI_ELABORAZIONE
             set   ELABORAZIONE_ID = :NEW.ELABORAZIONE_ID
            where  ELABORAZIONE_ID = :OLD.ELABORAZIONE_ID;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ELABORAZIONI_MASSIVE_TIU */
/

-- Procedure ELABORAZIONI_MASSIVE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table ELABORAZIONI_MASSIVE

create or replace procedure ELABORAZIONI_MASSIVE_PD
(old_elaborazione_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ATTIVITA_ELABORAZIONE"
   cursor cfk1_elaborazioni_massive(var_elaborazione_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk2_elaborazioni_massive(var_elaborazione_id number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "ELABORAZIONI_MASSIVE" if children still exist in "ATTIVITA_ELABORAZIONE"
      open  cfk1_elaborazioni_massive(OLD_ELABORAZIONE_ID);
      fetch cfk1_elaborazioni_massive into dummy;
      found := cfk1_elaborazioni_massive%FOUND;
      close cfk1_elaborazioni_massive;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Attivita Elaborazione. La registrazione di Elaborazioni Massive non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "ELABORAZIONI_MASSIVE" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk2_elaborazioni_massive(OLD_ELABORAZIONE_ID);
      fetch cfk2_elaborazioni_massive into dummy;
      found := cfk2_elaborazioni_massive%FOUND;
      close cfk2_elaborazioni_massive;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Elaborazioni Massive non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ELABORAZIONI_MASSIVE_PD */
/

-- Tigger ELABORAZIONI_MASSIVE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table ELABORAZIONI_MASSIVE

create or replace trigger ELABORAZIONI_MASSIVE_TD
before DELETE
on ELABORAZIONI_MASSIVE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ATTIVITA_ELABORAZIONE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      ELABORAZIONI_MASSIVE_PD(:OLD.ELABORAZIONE_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "SAM_INTERROGAZIONI"
      delete SAM_INTERROGAZIONI
      where  ELABORAZIONE_ID = :OLD.ELABORAZIONE_ID;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ELABORAZIONI_MASSIVE_TD */
/

-- Procedure EREDI_SOGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table EREDI_SOGGETTO

create or replace procedure EREDI_SOGGETTO_PI
(new_ni IN number,
 new_ni_erede IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk1_eredi_soggetto(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk2_eredi_soggetto(var_ni_erede number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni_erede
       and   var_ni_erede is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "EREDI_SOGGETTO"
         if NEW_NI is not null then
            open  cpk1_eredi_soggetto(NEW_NI);
            fetch cpk1_eredi_soggetto into dummy;
            found := cpk1_eredi_soggetto%FOUND;
            close cpk1_eredi_soggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Eredi Soggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "EREDI_SOGGETTO"
         if NEW_NI_EREDE is not null then
            open  cpk2_eredi_soggetto(NEW_NI_EREDE);
            fetch cpk2_eredi_soggetto into dummy;
            found := cpk2_eredi_soggetto%FOUND;
            close cpk2_eredi_soggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Eredi Soggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EREDI_SOGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table EREDI_SOGGETTO
/* End Trigger: EREDI_SOGGETTO_TC */

-- Procedure EREDI_SOGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table EREDI_SOGGETTO

create or replace procedure EREDI_SOGGETTO_PU
(old_ni IN number,
 old_ni_erede IN number,
 new_ni IN number,
 new_ni_erede IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk1_eredi_soggetto(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk2_eredi_soggetto(var_ni_erede number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni_erede
       and   var_ni_erede is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "EREDI_SOGGETTO"
         if  NEW_NI is not null and ( seq = 0 )
         and (   (NEW_NI != OLD_NI or OLD_NI is null) ) then
            open  cpk1_eredi_soggetto(NEW_NI);
            fetch cpk1_eredi_soggetto into dummy;
            found := cpk1_eredi_soggetto%FOUND;
            close cpk1_eredi_soggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Eredi Soggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "EREDI_SOGGETTO"
         if  NEW_NI_EREDE is not null and ( seq = 0 )
         and (   (NEW_NI_EREDE != OLD_NI_EREDE or OLD_NI_EREDE is null) ) then
            open  cpk2_eredi_soggetto(NEW_NI_EREDE);
            fetch cpk2_eredi_soggetto into dummy;
            found := cpk2_eredi_soggetto%FOUND;
            close cpk2_eredi_soggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Eredi Soggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SOGGETTI" non modificabile sul figlio: "EREDI_SOGGETTO"
      if (OLD_NI_EREDE != NEW_NI_EREDE) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Soggetti non e'' modificabile su Eredi Soggetto.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EREDI_SOGGETTO_PU */
/

-- Trigger EREDI_SOGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table EREDI_SOGGETTO

create or replace trigger EREDI_SOGGETTO_TIU
before INSERT
    or UPDATE
on EREDI_SOGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
         :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         EREDI_SOGGETTO_PU(:OLD.NI,
                           :OLD.NI_EREDE,
                         :NEW.NI,
                         :NEW.NI_EREDE);
         null;
      end if;
      if INSERTING then
         EREDI_SOGGETTO_PI(:NEW.NI,
                           :NEW.NI_EREDE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "EREDI_SOGGETTO"
            cursor cpk_eredi_soggetto(var_NI number,
                                      var_NI_EREDE number) is
               select 1
                 from   EREDI_SOGGETTO
                where  NI = var_NI and
                       NI_EREDE = var_NI_EREDE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "EREDI_SOGGETTO"
               if :new.NI is not null and
                  :new.NI_EREDE is not null then
                  open  cpk_eredi_soggetto(:new.NI,
                                           :new.NI_EREDE);
                  fetch cpk_eredi_soggetto into dummy;
                  found := cpk_eredi_soggetto%FOUND;
                  close cpk_eredi_soggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.NI||' '||
                               :new.NI_EREDE||
                               '" gia'' presente in Eredi Soggetto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "EREDI_SOGGETTO" for all children in "DETTAGLI_ELABORAZIONE"
         if (:OLD.NI != :NEW.NI) or
            (:OLD.NI_EREDE != :NEW.NI_EREDE) then
            update DETTAGLI_ELABORAZIONE
             set   NI = :NEW.NI,
                   NI_EREDE = :NEW.NI_EREDE
            where  NI = :OLD.NI
             and   NI_EREDE = :OLD.NI_EREDE;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: EREDI_SOGGETTO_TIU */
/

-- Procedure EREDI_SOGGETTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table EREDI_SOGGETTO

create or replace procedure EREDI_SOGGETTO_PD
(old_ni IN number,
 old_ni_erede IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk1_eredi_soggetto(var_ni number,
                              var_ni_erede number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  NI = var_ni
       and   NI_EREDE = var_ni_erede
       and   var_ni is not null
       and   var_ni_erede is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "EREDI_SOGGETTO" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk1_eredi_soggetto(OLD_NI,
                                OLD_NI_EREDE);
      fetch cfk1_eredi_soggetto into dummy;
      found := cfk1_eredi_soggetto%FOUND;
      close cfk1_eredi_soggetto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Eredi Soggetto non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EREDI_SOGGETTO_PD */
/

-- Tigger EREDI_SOGGETTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table EREDI_SOGGETTO

create or replace trigger EREDI_SOGGETTO_TD
before DELETE
on EREDI_SOGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

      EREDI_SOGGETTO_PD(:OLD.NI,
                        :OLD.NI_EREDE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: EREDI_SOGGETTO_TD */
/

-- Procedure ETICHETTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ETICHETTE

create or replace procedure ETICHETTE_PU
(old_etichetta IN number,
 new_etichetta IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ETICHETTE_PU */
/

-- Trigger ETICHETTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ETICHETTE

create or replace trigger ETICHETTE_TIU
before INSERT
    or UPDATE
on ETICHETTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ETICHETTE_PU(:OLD.ETICHETTA,
                         :NEW.ETICHETTA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ETICHETTE"
            cursor cpk_etichette(var_ETICHETTA number) is
               select 1
                 from   ETICHETTE
                where  ETICHETTA = var_ETICHETTA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ETICHETTE"
               if :new.ETICHETTA is not null then
                  open  cpk_etichette(:new.ETICHETTA);
                  fetch cpk_etichette into dummy;
                  found := cpk_etichette%FOUND;
                  close cpk_etichette;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ETICHETTA||
                               '" gia'' presente in Etichette. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ETICHETTE_TIU */
/

-- Procedure EVENTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table EVENTI

create or replace procedure EVENTI_PI
(new_tipo_evento IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_EVENTO"
   cursor cpk1_eventi(var_tipo_evento varchar) is
      select 1
      from   TIPI_EVENTO
      where  TIPO_EVENTO = var_tipo_evento
       and   var_tipo_evento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_EVENTO" deve esistere quando si inserisce su "EVENTI"
         if NEW_TIPO_EVENTO is not null then
            open  cpk1_eventi(NEW_TIPO_EVENTO);
            fetch cpk1_eventi into dummy;
            found := cpk1_eventi%FOUND;
            close cpk1_eventi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Evento. La registrazione Eventi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EVENTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table EVENTI
/* End Trigger: EVENTI_TC */

-- Procedure EVENTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table EVENTI

create or replace procedure EVENTI_PU
(old_tipo_evento IN varchar,
 old_sequenza IN number,
 new_tipo_evento IN varchar,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_EVENTO"
   cursor cpk1_eventi(var_tipo_evento varchar) is
      select 1
      from   TIPI_EVENTO
      where  TIPO_EVENTO = var_tipo_evento
       and   var_tipo_evento is not null;

   --  Declaration of UpdateParentRestrict constraint for "EVENTI_CONTRIBUENTE"
   cursor cfk1_eventi(var_tipo_evento varchar,
                      var_sequenza number) is
      select 1
      from   EVENTI_CONTRIBUENTE
      where  TIPO_EVENTO = var_tipo_evento
       and   SEQUENZA = var_sequenza
       and   var_tipo_evento is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_EVENTO" deve esistere quando si modifica "EVENTI"
         if  NEW_TIPO_EVENTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_EVENTO != OLD_TIPO_EVENTO or OLD_TIPO_EVENTO is null) ) then
            open  cpk1_eventi(NEW_TIPO_EVENTO);
            fetch cpk1_eventi into dummy;
            found := cpk1_eventi%FOUND;
            close cpk1_eventi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Evento. La registrazione Eventi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "EVENTI" non modificabile se esistono referenze su "EVENTI_CONTRIBUENTE"
      if (OLD_TIPO_EVENTO != NEW_TIPO_EVENTO) or
         (OLD_SEQUENZA != NEW_SEQUENZA) then
         open  cfk1_eventi(OLD_TIPO_EVENTO,
                           OLD_SEQUENZA);
         fetch cfk1_eventi into dummy;
         found := cfk1_eventi%FOUND;
         close cfk1_eventi;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Eventi Contribuente. La registrazione di Eventi non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EVENTI_PU */
/

-- Trigger EVENTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table EVENTI

create or replace trigger EVENTI_TIU
before INSERT
    or UPDATE
on EVENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       EVENTI_NR (:new.tipo_evento,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         EVENTI_PU(:OLD.TIPO_EVENTO,
                   :OLD.SEQUENZA,
                         :NEW.TIPO_EVENTO,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         EVENTI_PI(:NEW.TIPO_EVENTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "EVENTI"
            cursor cpk_eventi(var_TIPO_EVENTO varchar,
                              var_SEQUENZA number) is
               select 1
                 from   EVENTI
                where  TIPO_EVENTO = var_TIPO_EVENTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "EVENTI"
               if :new.TIPO_EVENTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_eventi(:new.TIPO_EVENTO,
                                   :new.SEQUENZA);
                  fetch cpk_eventi into dummy;
                  found := cpk_eventi%FOUND;
                  close cpk_eventi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_EVENTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Eventi. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: EVENTI_TIU */
/

-- Procedure EVENTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table EVENTI

create or replace procedure EVENTI_PD
(old_tipo_evento IN varchar,
 old_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "EVENTI_CONTRIBUENTE"
   cursor cfk1_eventi(var_tipo_evento varchar,
                      var_sequenza number) is
      select 1
      from   EVENTI_CONTRIBUENTE
      where  TIPO_EVENTO = var_tipo_evento
       and   SEQUENZA = var_sequenza
       and   var_tipo_evento is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "EVENTI" if children still exist in "EVENTI_CONTRIBUENTE"
      open  cfk1_eventi(OLD_TIPO_EVENTO,
                        OLD_SEQUENZA);
      fetch cfk1_eventi into dummy;
      found := cfk1_eventi%FOUND;
      close cfk1_eventi;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Eventi Contribuente. La registrazione di Eventi non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EVENTI_PD */
/

-- Tigger EVENTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table EVENTI

create or replace trigger EVENTI_TD
before DELETE
on EVENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: EVENTI_CONTRIBUENTE

      EVENTI_PD(:OLD.TIPO_EVENTO,
                :OLD.SEQUENZA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: EVENTI_TD */
/

-- Procedure EVENTI_CONTRIBUENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table EVENTI_CONTRIBUENTE

create or replace procedure EVENTI_CONTRIBUENTE_PI
(new_cod_fiscale IN varchar,
 new_tipo_evento IN varchar,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_eventi_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "EVENTI"
   cursor cpk2_eventi_contribuente(var_tipo_evento varchar,
                                   var_sequenza number) is
      select 1
      from   EVENTI
      where  TIPO_EVENTO = var_tipo_evento
       and   SEQUENZA = var_sequenza
       and   var_tipo_evento is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "EVENTI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null then
            open  cpk1_eventi_contribuente(NEW_COD_FISCALE);
            fetch cpk1_eventi_contribuente into dummy;
            found := cpk1_eventi_contribuente%FOUND;
            close cpk1_eventi_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Eventi Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "EVENTI" deve esistere quando si inserisce su "EVENTI_CONTRIBUENTE"
         if NEW_TIPO_EVENTO is not null and
            NEW_SEQUENZA is not null then
            open  cpk2_eventi_contribuente(NEW_TIPO_EVENTO,
                                           NEW_SEQUENZA);
            fetch cpk2_eventi_contribuente into dummy;
            found := cpk2_eventi_contribuente%FOUND;
            close cpk2_eventi_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Eventi. La registrazione Eventi Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EVENTI_CONTRIBUENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table EVENTI_CONTRIBUENTE
/* End Trigger: EVENTI_CONTRIBUENTE_TC */

-- Procedure EVENTI_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table EVENTI_CONTRIBUENTE

create or replace procedure EVENTI_CONTRIBUENTE_PU
(old_cod_fiscale IN varchar,
 old_tipo_evento IN varchar,
 old_sequenza IN number,
 new_cod_fiscale IN varchar,
 new_tipo_evento IN varchar,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_eventi_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "EVENTI"
   cursor cpk2_eventi_contribuente(var_tipo_evento varchar,
                                   var_sequenza number) is
      select 1
      from   EVENTI
      where  TIPO_EVENTO = var_tipo_evento
       and   SEQUENZA = var_sequenza
       and   var_tipo_evento is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "EVENTI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_eventi_contribuente(NEW_COD_FISCALE);
            fetch cpk1_eventi_contribuente into dummy;
            found := cpk1_eventi_contribuente%FOUND;
            close cpk1_eventi_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Eventi Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "EVENTI" deve esistere quando si modifica "EVENTI_CONTRIBUENTE"
         if  NEW_TIPO_EVENTO is not null and
             NEW_SEQUENZA is not null and ( seq = 0 )
         and (   (NEW_TIPO_EVENTO != OLD_TIPO_EVENTO or OLD_TIPO_EVENTO is null)
              or (NEW_SEQUENZA != OLD_SEQUENZA or OLD_SEQUENZA is null) ) then
            open  cpk2_eventi_contribuente(NEW_TIPO_EVENTO,
                                           NEW_SEQUENZA);
            fetch cpk2_eventi_contribuente into dummy;
            found := cpk2_eventi_contribuente%FOUND;
            close cpk2_eventi_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Eventi. La registrazione Eventi Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EVENTI_CONTRIBUENTE_PU */
/

-- Trigger EVENTI_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table EVENTI_CONTRIBUENTE

create or replace trigger EVENTI_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on EVENTI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         EVENTI_CONTRIBUENTE_PU(:OLD.COD_FISCALE,
                                :OLD.TIPO_EVENTO,
                                :OLD.SEQUENZA,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_EVENTO,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         EVENTI_CONTRIBUENTE_PI(:NEW.COD_FISCALE,
                                :NEW.TIPO_EVENTO,
                                :NEW.SEQUENZA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "EVENTI_CONTRIBUENTE"
            cursor cpk_eventi_contribuente(var_COD_FISCALE varchar,
                                           var_TIPO_EVENTO varchar,
                                           var_SEQUENZA number) is
               select 1
                 from   EVENTI_CONTRIBUENTE
                where  COD_FISCALE = var_COD_FISCALE and
                       TIPO_EVENTO = var_TIPO_EVENTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "EVENTI_CONTRIBUENTE"
               if :new.COD_FISCALE is not null and
                  :new.TIPO_EVENTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_eventi_contribuente(:new.COD_FISCALE,
                                                :new.TIPO_EVENTO,
                                                :new.SEQUENZA);
                  fetch cpk_eventi_contribuente into dummy;
                  found := cpk_eventi_contribuente%FOUND;
                  close cpk_eventi_contribuente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.TIPO_EVENTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Eventi Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: EVENTI_CONTRIBUENTE_TIU */
/

-- Procedure EXPORT_PERSONALIZZATI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table EXPORT_PERSONALIZZATI

create or replace procedure EXPORT_PERSONALIZZATI_PI
(new_tipo_export IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_EXPORT"
   cursor cpk1_export_personalizzati(var_tipo_export number) is
      select 1
      from   TIPI_EXPORT
      where  TIPO_EXPORT = var_tipo_export
       and   var_tipo_export is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_EXPORT" deve esistere quando si inserisce su "EXPORT_PERSONALIZZATI"
         if NEW_TIPO_EXPORT is not null then
            open  cpk1_export_personalizzati(NEW_TIPO_EXPORT);
            fetch cpk1_export_personalizzati into dummy;
            found := cpk1_export_personalizzati%FOUND;
            close cpk1_export_personalizzati;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su TIPI_EXPORT. La registrazione EXPORT_PERSONALIZZATI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EXPORT_PERSONALIZZATI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table EXPORT_PERSONALIZZATI
/* End Trigger: EXPORT_PERSONALIZZATI_TC */

-- Procedure EXPORT_PERSONALIZZATI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table EXPORT_PERSONALIZZATI

create or replace procedure EXPORT_PERSONALIZZATI_PU
(old_tipo_export IN number,
 old_codice_istat IN varchar,
 new_tipo_export IN number,
 new_codice_istat IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_EXPORT"
   cursor cpk1_export_personalizzati(var_tipo_export number) is
      select 1
      from   TIPI_EXPORT
      where  TIPO_EXPORT = var_tipo_export
       and   var_tipo_export is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_EXPORT" deve esistere quando si modifica "EXPORT_PERSONALIZZATI"
         if  NEW_TIPO_EXPORT is not null and ( seq = 0 )
         and (   (NEW_TIPO_EXPORT != OLD_TIPO_EXPORT or OLD_TIPO_EXPORT is null) ) then
            open  cpk1_export_personalizzati(NEW_TIPO_EXPORT);
            fetch cpk1_export_personalizzati into dummy;
            found := cpk1_export_personalizzati%FOUND;
            close cpk1_export_personalizzati;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su TIPI_EXPORT. La registrazione EXPORT_PERSONALIZZATI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: EXPORT_PERSONALIZZATI_PU */
/

-- Trigger EXPORT_PERSONALIZZATI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table EXPORT_PERSONALIZZATI

create or replace trigger EXPORT_PERSONALIZZATI_TIU
before INSERT
    or UPDATE
on EXPORT_PERSONALIZZATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         EXPORT_PERSONALIZZATI_PU(:OLD.TIPO_EXPORT,
                                  :OLD.CODICE_ISTAT,
                         :NEW.TIPO_EXPORT,
                         :NEW.CODICE_ISTAT);
         null;
      end if;
      if INSERTING then
         EXPORT_PERSONALIZZATI_PI(:NEW.TIPO_EXPORT);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "EXPORT_PERSONALIZZATI"
            cursor cpk_export_personalizzati(var_TIPO_EXPORT number,
                                             var_CODICE_ISTAT varchar) is
               select 1
                 from   EXPORT_PERSONALIZZATI
                where  TIPO_EXPORT = var_TIPO_EXPORT and
                       CODICE_ISTAT = var_CODICE_ISTAT;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "EXPORT_PERSONALIZZATI"
               if :new.TIPO_EXPORT is not null and
                  :new.CODICE_ISTAT is not null then
                  open  cpk_export_personalizzati(:new.TIPO_EXPORT,
                                                  :new.CODICE_ISTAT);
                  fetch cpk_export_personalizzati into dummy;
                  found := cpk_export_personalizzati%FOUND;
                  close cpk_export_personalizzati;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_EXPORT||' '||
                               :new.CODICE_ISTAT||
                               '" gia'' presente in EXPORT_PERSONALIZZATI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: EXPORT_PERSONALIZZATI_TIU */
/

-- Procedure FAMILIARI_OGIM_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table FAMILIARI_OGIM

create or replace procedure FAMILIARI_OGIM_PI
(new_oggetto_imposta IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_IMPOSTA"
   cursor cpk1_familiari_ogim(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si inserisce su "FAMILIARI_OGIM"
         if NEW_OGGETTO_IMPOSTA is not null then
            open  cpk1_familiari_ogim(NEW_OGGETTO_IMPOSTA);
            fetch cpk1_familiari_ogim into dummy;
            found := cpk1_familiari_ogim%FOUND;
            close cpk1_familiari_ogim;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Familiari OGIM non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FAMILIARI_OGIM_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table FAMILIARI_OGIM
/* End Trigger: FAMILIARI_OGIM_TC */

-- Procedure FAMILIARI_OGIM_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FAMILIARI_OGIM

create or replace procedure FAMILIARI_OGIM_PU
(old_oggetto_imposta IN number,
 old_dal IN date,
 new_oggetto_imposta IN number,
 new_dal IN date)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_IMPOSTA"
   cursor cpk1_familiari_ogim(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si modifica "FAMILIARI_OGIM"
         if  NEW_OGGETTO_IMPOSTA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_IMPOSTA != OLD_OGGETTO_IMPOSTA or OLD_OGGETTO_IMPOSTA is null) ) then
            open  cpk1_familiari_ogim(NEW_OGGETTO_IMPOSTA);
            fetch cpk1_familiari_ogim into dummy;
            found := cpk1_familiari_ogim%FOUND;
            close cpk1_familiari_ogim;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Familiari OGIM non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FAMILIARI_OGIM_PU */
/

-- Trigger FAMILIARI_OGIM_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FAMILIARI_OGIM

create or replace trigger FAMILIARI_OGIM_TIU
before INSERT
    or UPDATE
on FAMILIARI_OGIM
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FAMILIARI_OGIM_PU(:OLD.OGGETTO_IMPOSTA,
                           :OLD.DAL,
                         :NEW.OGGETTO_IMPOSTA,
                         :NEW.DAL);
         null;
      end if;
      if INSERTING then
         FAMILIARI_OGIM_PI(:NEW.OGGETTO_IMPOSTA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FAMILIARI_OGIM"
            cursor cpk_familiari_ogim(var_OGGETTO_IMPOSTA number,
                                      var_DAL date) is
               select 1
                 from   FAMILIARI_OGIM
                where  OGGETTO_IMPOSTA = var_OGGETTO_IMPOSTA and
                       DAL = var_DAL;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FAMILIARI_OGIM"
               if :new.OGGETTO_IMPOSTA is not null and
                  :new.DAL is not null then
                  open  cpk_familiari_ogim(:new.OGGETTO_IMPOSTA,
                                           :new.DAL);
                  fetch cpk_familiari_ogim into dummy;
                  found := cpk_familiari_ogim%FOUND;
                  close cpk_familiari_ogim;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO_IMPOSTA||' '||
                               :new.DAL||
                               '" gia'' presente in Familiari OGIM. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FAMILIARI_OGIM_TIU */
/

-- Procedure FAMILIARI_PRATICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table FAMILIARI_PRATICA

create or replace procedure FAMILIARI_PRATICA_PI
(new_pratica IN number,
 new_ni IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_familiari_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk2_familiari_pratica(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "FAMILIARI_PRATICA"
         if NEW_PRATICA is not null then
            open  cpk1_familiari_pratica(NEW_PRATICA);
            fetch cpk1_familiari_pratica into dummy;
            found := cpk1_familiari_pratica%FOUND;
            close cpk1_familiari_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Familiari_pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "FAMILIARI_PRATICA"
         if NEW_NI is not null then
            open  cpk2_familiari_pratica(NEW_NI);
            fetch cpk2_familiari_pratica into dummy;
            found := cpk2_familiari_pratica%FOUND;
            close cpk2_familiari_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Familiari_pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FAMILIARI_PRATICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table FAMILIARI_PRATICA
/* End Trigger: FAMILIARI_PRATICA_TC */

-- Procedure FAMILIARI_PRATICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FAMILIARI_PRATICA

create or replace procedure FAMILIARI_PRATICA_PU
(old_pratica IN number,
 old_ni IN number,
 new_pratica IN number,
 new_ni IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_familiari_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk2_familiari_pratica(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "FAMILIARI_PRATICA"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_familiari_pratica(NEW_PRATICA);
            fetch cpk1_familiari_pratica into dummy;
            found := cpk1_familiari_pratica%FOUND;
            close cpk1_familiari_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Familiari_pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "FAMILIARI_PRATICA"
         if  NEW_NI is not null and ( seq = 0 )
         and (   (NEW_NI != OLD_NI or OLD_NI is null) ) then
            open  cpk2_familiari_pratica(NEW_NI);
            fetch cpk2_familiari_pratica into dummy;
            found := cpk2_familiari_pratica%FOUND;
            close cpk2_familiari_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Familiari_pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FAMILIARI_PRATICA_PU */
/

-- Trigger FAMILIARI_PRATICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FAMILIARI_PRATICA

create or replace trigger FAMILIARI_PRATICA_TIU
before INSERT
    or UPDATE
on FAMILIARI_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FAMILIARI_PRATICA_PU(:OLD.PRATICA,
                              :OLD.NI,
                         :NEW.PRATICA,
                         :NEW.NI);
         null;
      end if;
      if INSERTING then
         FAMILIARI_PRATICA_PI(:NEW.PRATICA,
                              :NEW.NI);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FAMILIARI_PRATICA"
            cursor cpk_familiari_pratica(var_PRATICA number,
                                         var_NI number) is
               select 1
                 from   FAMILIARI_PRATICA
                where  PRATICA = var_PRATICA and
                       NI = var_NI;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FAMILIARI_PRATICA"
               if :new.PRATICA is not null and
                  :new.NI is not null then
                  open  cpk_familiari_pratica(:new.PRATICA,
                                              :new.NI);
                  fetch cpk_familiari_pratica into dummy;
                  found := cpk_familiari_pratica%FOUND;
                  close cpk_familiari_pratica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||' '||
                               :new.NI||
                               '" gia'' presente in Familiari_pratica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FAMILIARI_PRATICA_TIU */
/

-- Procedure FAMILIARI_SGRA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table FAMILIARI_SGRA

create or replace procedure FAMILIARI_SGRA_PI
(new_ruolo IN number,
 new_cod_fiscale IN varchar,
 new_sequenza IN number,
 new_sequenza_sgravio IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SGRAVI"
   cursor cpk1_familiari_sgra(var_ruolo number,
                              var_cod_fiscale varchar,
                              var_sequenza number,
                              var_sequenza_sgravio number) is
      select 1
      from   SGRAVI
      where  RUOLO = var_ruolo
       and   COD_FISCALE = var_cod_fiscale
       and   SEQUENZA = var_sequenza
       and   SEQUENZA_SGRAVIO = var_sequenza_sgravio
       and   var_ruolo is not null
       and   var_cod_fiscale is not null
       and   var_sequenza is not null
       and   var_sequenza_sgravio is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SGRAVI" deve esistere quando si inserisce su "FAMILIARI_SGRA"
         if NEW_RUOLO is not null and
            NEW_COD_FISCALE is not null and
            NEW_SEQUENZA is not null and
            NEW_SEQUENZA_SGRAVIO is not null then
            open  cpk1_familiari_sgra(NEW_RUOLO,
                                      NEW_COD_FISCALE,
                                      NEW_SEQUENZA,
                                      NEW_SEQUENZA_SGRAVIO);
            fetch cpk1_familiari_sgra into dummy;
            found := cpk1_familiari_sgra%FOUND;
            close cpk1_familiari_sgra;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Sgravi. La registrazione Familiari_Sgra non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FAMILIARI_SGRA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table FAMILIARI_SGRA
/* End Trigger: FAMILIARI_SGRA_TC */

-- Procedure FAMILIARI_SGRA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FAMILIARI_SGRA

create or replace procedure FAMILIARI_SGRA_PU
(old_ruolo IN number,
 old_cod_fiscale IN varchar,
 old_sequenza IN number,
 old_sequenza_sgravio IN number,
 old_dal IN date,
 new_ruolo IN number,
 new_cod_fiscale IN varchar,
 new_sequenza IN number,
 new_sequenza_sgravio IN number,
 new_dal IN date)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SGRAVI"
   cursor cpk1_familiari_sgra(var_ruolo number,
                              var_cod_fiscale varchar,
                              var_sequenza number,
                              var_sequenza_sgravio number) is
      select 1
      from   SGRAVI
      where  RUOLO = var_ruolo
       and   COD_FISCALE = var_cod_fiscale
       and   SEQUENZA = var_sequenza
       and   SEQUENZA_SGRAVIO = var_sequenza_sgravio
       and   var_ruolo is not null
       and   var_cod_fiscale is not null
       and   var_sequenza is not null
       and   var_sequenza_sgravio is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SGRAVI" deve esistere quando si modifica "FAMILIARI_SGRA"
         if  NEW_RUOLO is not null and
             NEW_COD_FISCALE is not null and
             NEW_SEQUENZA is not null and
             NEW_SEQUENZA_SGRAVIO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null)
              or (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_SEQUENZA != OLD_SEQUENZA or OLD_SEQUENZA is null)
              or (NEW_SEQUENZA_SGRAVIO != OLD_SEQUENZA_SGRAVIO or OLD_SEQUENZA_SGRAVIO is null) ) then
            open  cpk1_familiari_sgra(NEW_RUOLO,
                                      NEW_COD_FISCALE,
                                      NEW_SEQUENZA,
                                      NEW_SEQUENZA_SGRAVIO);
            fetch cpk1_familiari_sgra into dummy;
            found := cpk1_familiari_sgra%FOUND;
            close cpk1_familiari_sgra;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Sgravi. La registrazione Familiari_Sgra non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FAMILIARI_SGRA_PU */
/

-- Trigger FAMILIARI_SGRA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FAMILIARI_SGRA

create or replace trigger FAMILIARI_SGRA_TIU
before INSERT
    or UPDATE
on FAMILIARI_SGRA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FAMILIARI_SGRA_PU(:OLD.RUOLO,
                           :OLD.COD_FISCALE,
                           :OLD.SEQUENZA,
                           :OLD.SEQUENZA_SGRAVIO,
                           :OLD.DAL,
                         :NEW.RUOLO,
                         :NEW.COD_FISCALE,
                         :NEW.SEQUENZA,
                         :NEW.SEQUENZA_SGRAVIO,
                         :NEW.DAL);
         null;
      end if;
      if INSERTING then
         FAMILIARI_SGRA_PI(:NEW.RUOLO,
                           :NEW.COD_FISCALE,
                           :NEW.SEQUENZA,
                           :NEW.SEQUENZA_SGRAVIO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FAMILIARI_SGRA"
            cursor cpk_familiari_sgra(var_RUOLO number,
                                      var_COD_FISCALE varchar,
                                      var_SEQUENZA number,
                                      var_SEQUENZA_SGRAVIO number,
                                      var_DAL date) is
               select 1
                 from   FAMILIARI_SGRA
                where  RUOLO = var_RUOLO and
                       COD_FISCALE = var_COD_FISCALE and
                       SEQUENZA = var_SEQUENZA and
                       SEQUENZA_SGRAVIO = var_SEQUENZA_SGRAVIO and
                       DAL = var_DAL;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FAMILIARI_SGRA"
               if :new.RUOLO is not null and
                  :new.COD_FISCALE is not null and
                  :new.SEQUENZA is not null and
                  :new.SEQUENZA_SGRAVIO is not null and
                  :new.DAL is not null then
                  open  cpk_familiari_sgra(:new.RUOLO,
                                           :new.COD_FISCALE,
                                           :new.SEQUENZA,
                                           :new.SEQUENZA_SGRAVIO,
                                           :new.DAL);
                  fetch cpk_familiari_sgra into dummy;
                  found := cpk_familiari_sgra%FOUND;
                  close cpk_familiari_sgra;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RUOLO||' '||
                               :new.COD_FISCALE||' '||
                               :new.SEQUENZA||' '||
                               :new.SEQUENZA_SGRAVIO||' '||
                               :new.DAL||
                               '" gia'' presente in Familiari_Sgra. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FAMILIARI_SGRA_TIU */
/

-- Procedure FAMILIARI_SOGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table FAMILIARI_SOGGETTO

create or replace procedure FAMILIARI_SOGGETTO_PI
(new_ni IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk1_familiari_soggetto(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "FAMILIARI_SOGGETTO"
         if NEW_NI is not null then
            open  cpk1_familiari_soggetto(NEW_NI);
            fetch cpk1_familiari_soggetto into dummy;
            found := cpk1_familiari_soggetto%FOUND;
            close cpk1_familiari_soggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Familiari Soggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FAMILIARI_SOGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table FAMILIARI_SOGGETTO
/* End Trigger: FAMILIARI_SOGGETTO_TC */

-- Procedure FAMILIARI_SOGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FAMILIARI_SOGGETTO

create or replace procedure FAMILIARI_SOGGETTO_PU
(old_ni IN number,
 old_anno IN number,
 old_dal IN date,
 new_ni IN number,
 new_anno IN number,
 new_dal IN date)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk1_familiari_soggetto(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "FAMILIARI_SOGGETTO"
         if  NEW_NI is not null and ( seq = 0 )
         and (   (NEW_NI != OLD_NI or OLD_NI is null) ) then
            open  cpk1_familiari_soggetto(NEW_NI);
            fetch cpk1_familiari_soggetto into dummy;
            found := cpk1_familiari_soggetto%FOUND;
            close cpk1_familiari_soggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Familiari Soggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FAMILIARI_SOGGETTO_PU */
/

-- Trigger FAMILIARI_SOGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FAMILIARI_SOGGETTO

create or replace trigger FAMILIARI_SOGGETTO_TIU
before INSERT
    or UPDATE
on FAMILIARI_SOGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

      IF :new.data_variazione is null THEN  -- Disabilitata in data 17/12/2004 e riabilitata il 7/7/2005
         :new.data_variazione := trunc(sysdate);
      END IF;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FAMILIARI_SOGGETTO_PU(:OLD.NI,
                               :OLD.ANNO,
                               :OLD.DAL,
                         :NEW.NI,
                         :NEW.ANNO,
                         :NEW.DAL);
         null;
      end if;
      if INSERTING then
         FAMILIARI_SOGGETTO_PI(:NEW.NI);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FAMILIARI_SOGGETTO"
            cursor cpk_familiari_soggetto(var_NI number,
                                          var_ANNO number,
                                          var_DAL date) is
               select 1
                 from   FAMILIARI_SOGGETTO
                where  NI = var_NI and
                       ANNO = var_ANNO and
                       DAL = var_DAL;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FAMILIARI_SOGGETTO"
               if :new.NI is not null and
                  :new.ANNO is not null and
                  :new.DAL is not null then
                  open  cpk_familiari_soggetto(:new.NI,
                                               :new.ANNO,
                                               :new.DAL);
                  fetch cpk_familiari_soggetto into dummy;
                  found := cpk_familiari_soggetto%FOUND;
                  close cpk_familiari_soggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.NI||' '||
                               :new.ANNO||' '||
                               :new.DAL||
                               '" gia'' presente in Familiari Soggetto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FAMILIARI_SOGGETTO_TIU */
/

-- Procedure FATTURE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table FATTURE

create or replace procedure FATTURE_PI
(new_cod_fiscale IN varchar,
 new_fattura_rif IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FATTURE"
   cursor cpk1_fatture(var_fattura_rif number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura_rif
       and   var_fattura_rif is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk2_fatture(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "FATTURE" deve esistere quando si inserisce su "FATTURE"
         if NEW_FATTURA_RIF is not null then
            open  cpk1_fatture(NEW_FATTURA_RIF);
            fetch cpk1_fatture into dummy;
            found := cpk1_fatture%FOUND;
            close cpk1_fatture;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione Fatture non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "FATTURE"
         if NEW_COD_FISCALE is not null then
            open  cpk2_fatture(NEW_COD_FISCALE);
            fetch cpk2_fatture into dummy;
            found := cpk2_fatture%FOUND;
            close cpk2_fatture;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Fatture non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FATTURE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table FATTURE

create or replace trigger FATTURE_TB
before INSERT
    or UPDATE
    or DELETE
on FATTURE
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: FATTURE_TB */
/

create or replace trigger FATTURE_TC
after INSERT
   or UPDATE
   or DELETE
on FATTURE
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: FATTURE_TC */
/

-- Procedure FATTURE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FATTURE

create or replace procedure FATTURE_PU
(old_fattura IN number,
 old_cod_fiscale IN varchar,
 old_fattura_rif IN number,
 new_fattura IN number,
 new_cod_fiscale IN varchar,
 new_fattura_rif IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FATTURE"
   cursor cpk1_fatture(var_fattura_rif number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura_rif
       and   var_fattura_rif is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk2_fatture(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Declaration of UpdateParentRestrict constraint for "VERSAMENTI"
   cursor cfk1_fatture(var_fattura number) is
      select 1
      from   VERSAMENTI
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_IMPOSTA"
   cursor cfk2_fatture(var_fattura number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Declaration of UpdateParentRestrict constraint for "SGRAVI"
   cursor cfk3_fatture(var_fattura number) is
      select 1
      from   SGRAVI
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Declaration of UpdateParentRestrict constraint for "RID_IMPAGATI"
   cursor cfk4_fatture(var_fattura number) is
      select 1
      from   RID_IMPAGATI
      where  FATTURA = var_fattura
       and   var_fattura is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "FATTURE" deve esistere quando si modifica "FATTURE"
         if  NEW_FATTURA_RIF is not null and ( seq = 0 )
         and (   (NEW_FATTURA_RIF != OLD_FATTURA_RIF or OLD_FATTURA_RIF is null) ) then
            open  cpk1_fatture(NEW_FATTURA_RIF);
            fetch cpk1_fatture into dummy;
            found := cpk1_fatture%FOUND;
            close cpk1_fatture;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione Fatture non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "FATTURE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk2_fatture(NEW_COD_FISCALE);
            fetch cpk2_fatture into dummy;
            found := cpk2_fatture%FOUND;
            close cpk2_fatture;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Fatture non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "FATTURE" non modificabile se esistono referenze su "VERSAMENTI"
      if (OLD_FATTURA != NEW_FATTURA) then
         open  cfk1_fatture(OLD_FATTURA);
         fetch cfk1_fatture into dummy;
         found := cfk1_fatture%FOUND;
         close cfk1_fatture;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Fatture non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FATTURE" non modificabile se esistono referenze su "OGGETTI_IMPOSTA"
      if (OLD_FATTURA != NEW_FATTURA) then
         open  cfk2_fatture(OLD_FATTURA);
         fetch cfk2_fatture into dummy;
         found := cfk2_fatture%FOUND;
         close cfk2_fatture;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Imposta. La registrazione di Fatture non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FATTURE" non modificabile se esistono referenze su "SGRAVI"
      if (OLD_FATTURA != NEW_FATTURA) then
         open  cfk3_fatture(OLD_FATTURA);
         fetch cfk3_fatture into dummy;
         found := cfk3_fatture%FOUND;
         close cfk3_fatture;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sgravi. La registrazione di Fatture non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FATTURE" non modificabile se esistono referenze su "RID_IMPAGATI"
      if (OLD_FATTURA != NEW_FATTURA) then
         open  cfk4_fatture(OLD_FATTURA);
         fetch cfk4_fatture into dummy;
         found := cfk4_fatture%FOUND;
         close cfk4_fatture;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su RID_IMPAGATI. La registrazione di Fatture non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FATTURE_PU */
/

-- Trigger FATTURE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FATTURE

create or replace trigger FATTURE_TIU
before INSERT
    or UPDATE
on FATTURE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.fattura is null then
      FATTURE_NR(:new.fattura);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FATTURE_PU(:OLD.FATTURA,
                    :OLD.COD_FISCALE,
                    :OLD.FATTURA_RIF,
                         :NEW.FATTURA,
                         :NEW.COD_FISCALE,
                         :NEW.FATTURA_RIF);
         null;
      end if;
      if INSERTING then
         FATTURE_PI(:NEW.COD_FISCALE,
                    :NEW.FATTURA_RIF);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FATTURE"
            cursor cpk_fatture(var_FATTURA number) is
               select 1
                 from   FATTURE
                where  FATTURA = var_FATTURA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FATTURE"
               if :new.FATTURA is not null then
                  open  cpk_fatture(:new.FATTURA);
                  fetch cpk_fatture into dummy;
                  found := cpk_fatture%FOUND;
                  close cpk_fatture;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.FATTURA||
                               '" gia'' presente in Fatture. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin -- Set PostEvent Check REFERENTIAL Integrity at Level 0
      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
      IF IntegrityPackage.GetNestLevel = 0 THEN
         --
         -- Integrità Referenziale di Esistenza FK
         --
         IF INSERTING THEN
            --
            -- Integrità Referenziale di Esistenza su insert FK
            --
            IF :new.fattura_rif is NOT null THEN
               a_istruzione := 'select 1 from fatture where fattura = '
                               || :new.fattura_rif;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;
         ELSIF UPDATING THEN
            IF nvl(:new.fattura_rif,-1) != nvl(:old.fattura_rif ,-1) THEN
               --
               -- Integrità Referenziale di Esistenza su update FK
               --
               IF :new.fattura_rif is NOT null THEN
                  a_istruzione := 'select 1 from fatture where fattura = '
                                  ||:new.fattura_rif;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;
         END IF;
      END IF;
      IF UPDATING THEN
         IF :new.fattura != :old.fattura THEN
            --
            -- Integrità Referenziale su update PK
            --

            /* Caso di RESTRICT UPDATE */

               a_istruzione := 'select 0 from fatture where fattura_rif = '
                               ||:old.fattura ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

            /* Caso di CASCADE UPDATE

               a_istruzione := 'update fatture set fattura_rif ='
                               ||:new.fattura ||' where fattura_rif = '
                               ||:old.fattura;
               a_messaggio := '';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            */

         END IF;
      END IF;
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FATTURE_TIU */
/

-- Procedure FATTURE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table FATTURE

create or replace procedure FATTURE_PD
(old_fattura IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk1_fatture(var_fattura number) is
      select 1
      from   VERSAMENTI
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_IMPOSTA"
   cursor cfk2_fatture(var_fattura number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Declaration of DeleteParentRestrict constraint for "SGRAVI"
   cursor cfk3_fatture(var_fattura number) is
      select 1
      from   SGRAVI
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Declaration of DeleteParentRestrict constraint for "RID_IMPAGATI"
   cursor cfk4_fatture(var_fattura number) is
      select 1
      from   RID_IMPAGATI
      where  FATTURA = var_fattura
       and   var_fattura is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "FATTURE" if children still exist in "VERSAMENTI"
      open  cfk1_fatture(OLD_FATTURA);
      fetch cfk1_fatture into dummy;
      found := cfk1_fatture%FOUND;
      close cfk1_fatture;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Fatture non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FATTURE" if children still exist in "OGGETTI_IMPOSTA"
      open  cfk2_fatture(OLD_FATTURA);
      fetch cfk2_fatture into dummy;
      found := cfk2_fatture%FOUND;
      close cfk2_fatture;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Imposta. La registrazione di Fatture non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FATTURE" if children still exist in "SGRAVI"
      open  cfk3_fatture(OLD_FATTURA);
      fetch cfk3_fatture into dummy;
      found := cfk3_fatture%FOUND;
      close cfk3_fatture;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sgravi. La registrazione di Fatture non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FATTURE" if children still exist in "RID_IMPAGATI"
      open  cfk4_fatture(OLD_FATTURA);
      fetch cfk4_fatture into dummy;
      found := cfk4_fatture%FOUND;
      close cfk4_fatture;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su RID_IMPAGATI. La registrazione di Fatture non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FATTURE_PD */
/

-- Tigger FATTURE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table FATTURE

create or replace trigger FATTURE_TD
before DELETE
on FATTURE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: VERSAMENTI

      -- Child Restrict Table: OGGETTI_IMPOSTA

      -- Child Restrict Table: SGRAVI

      -- Child Restrict Table: RID_IMPAGATI

      FATTURE_PD(:OLD.FATTURA);

   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
            DECLARE a_istruzione  varchar2(2000);
                    a_messaggio   varchar2(2000);
            BEGIN
               a_messaggio := 'Esistono riferimenti su Fatture. La registrazione di Fatture non e'' eliminabile.';
               a_istruzione := 'select 0 from fatture where fattura_rif = '
                               ||:old.fattura;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
            END;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FATTURE_TD */
/

-- Procedure FONTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FONTI

create or replace procedure FONTI_PU
(old_fonte IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "DENUNCE_ICI"
   cursor cfk1_fonti(var_fonte number) is
      select 1
      from   DENUNCE_ICI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk2_fonti(var_fonte number) is
      select 1
      from   OGGETTI_PRATICA
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI"
   cursor cfk3_fonti(var_fonte number) is
      select 1
      from   OGGETTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "VERSAMENTI"
   cursor cfk4_fonti(var_fonte number) is
      select 1
      from   VERSAMENTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "SOGGETTI"
   cursor cfk5_fonti(var_fonte number) is
      select 1
      from   SOGGETTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "STORICO_SOGGETTI"
   cursor cfk6_fonti(var_fonte number) is
      select 1
      from   STORICO_SOGGETTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "DENUNCE_TASI"
   cursor cfk7_fonti(var_fonte number) is
      select 1
      from   DENUNCE_TASI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "WRK_DOCFA_TESTATA"
   cursor cfk8_fonti(var_fonte number) is
      select 1
      from   WRK_DOCFA_TESTATA
      where  FONTE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "FONTI" non modificabile se esistono referenze su "DENUNCE_ICI"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk1_fonti(OLD_FONTE);
         fetch cfk1_fonti into dummy;
         found := cfk1_fonti%FOUND;
         close cfk1_fonti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Denunce ICI. La registrazione di Fonti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FONTI" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk2_fonti(OLD_FONTE);
         fetch cfk2_fonti into dummy;
         found := cfk2_fonti%FOUND;
         close cfk2_fonti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Fonti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FONTI" non modificabile se esistono referenze su "OGGETTI"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk3_fonti(OLD_FONTE);
         fetch cfk3_fonti into dummy;
         found := cfk3_fonti%FOUND;
         close cfk3_fonti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Fonti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FONTI" non modificabile se esistono referenze su "VERSAMENTI"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk4_fonti(OLD_FONTE);
         fetch cfk4_fonti into dummy;
         found := cfk4_fonti%FOUND;
         close cfk4_fonti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Fonti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FONTI" non modificabile se esistono referenze su "SOGGETTI"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk5_fonti(OLD_FONTE);
         fetch cfk5_fonti into dummy;
         found := cfk5_fonti%FOUND;
         close cfk5_fonti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Soggetti. La registrazione di Fonti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FONTI" non modificabile se esistono referenze su "STORICO_SOGGETTI"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk6_fonti(OLD_FONTE);
         fetch cfk6_fonti into dummy;
         found := cfk6_fonti%FOUND;
         close cfk6_fonti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Storico Soggetti. La registrazione di Fonti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FONTI" non modificabile se esistono referenze su "DENUNCE_TASI"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk7_fonti(OLD_FONTE);
         fetch cfk7_fonti into dummy;
         found := cfk7_fonti%FOUND;
         close cfk7_fonti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Denunce TASI. La registrazione di Fonti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "FONTI" non modificabile se esistono referenze su "WRK_DOCFA_TESTATA"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk8_fonti(OLD_FONTE);
         fetch cfk8_fonti into dummy;
         found := cfk8_fonti%FOUND;
         close cfk8_fonti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WRK_DOCFA_TESTATA. La registrazione di Fonti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FONTI_PU */
/

-- Trigger FONTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FONTI

create or replace trigger FONTI_TIU
before INSERT
    or UPDATE
on FONTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FONTI_PU(:OLD.FONTE,
                         :NEW.FONTE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FONTI"
            cursor cpk_fonti(var_FONTE number) is
               select 1
                 from   FONTI
                where  FONTE = var_FONTE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FONTI"
               if :new.FONTE is not null then
                  open  cpk_fonti(:new.FONTE);
                  fetch cpk_fonti into dummy;
                  found := cpk_fonti%FOUND;
                  close cpk_fonti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.FONTE||
                               '" gia'' presente in Fonti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FONTI_TIU */
/

-- Procedure FONTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table FONTI

create or replace procedure FONTI_PD
(old_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DENUNCE_ICI"
   cursor cfk1_fonti(var_fonte number) is
      select 1
      from   DENUNCE_ICI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk2_fonti(var_fonte number) is
      select 1
      from   OGGETTI_PRATICA
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI"
   cursor cfk3_fonti(var_fonte number) is
      select 1
      from   OGGETTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk4_fonti(var_fonte number) is
      select 1
      from   VERSAMENTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of DeleteParentRestrict constraint for "SOGGETTI"
   cursor cfk5_fonti(var_fonte number) is
      select 1
      from   SOGGETTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of DeleteParentRestrict constraint for "STORICO_SOGGETTI"
   cursor cfk6_fonti(var_fonte number) is
      select 1
      from   STORICO_SOGGETTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of DeleteParentRestrict constraint for "DENUNCE_TASI"
   cursor cfk7_fonti(var_fonte number) is
      select 1
      from   DENUNCE_TASI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of DeleteParentRestrict constraint for "WRK_DOCFA_TESTATA"
   cursor cfk8_fonti(var_fonte number) is
      select 1
      from   WRK_DOCFA_TESTATA
      where  FONTE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "FONTI" if children still exist in "DENUNCE_ICI"
      open  cfk1_fonti(OLD_FONTE);
      fetch cfk1_fonti into dummy;
      found := cfk1_fonti%FOUND;
      close cfk1_fonti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Denunce ICI. La registrazione di Fonti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FONTI" if children still exist in "OGGETTI_PRATICA"
      open  cfk2_fonti(OLD_FONTE);
      fetch cfk2_fonti into dummy;
      found := cfk2_fonti%FOUND;
      close cfk2_fonti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Fonti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FONTI" if children still exist in "OGGETTI"
      open  cfk3_fonti(OLD_FONTE);
      fetch cfk3_fonti into dummy;
      found := cfk3_fonti%FOUND;
      close cfk3_fonti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Fonti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FONTI" if children still exist in "VERSAMENTI"
      open  cfk4_fonti(OLD_FONTE);
      fetch cfk4_fonti into dummy;
      found := cfk4_fonti%FOUND;
      close cfk4_fonti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Fonti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FONTI" if children still exist in "SOGGETTI"
      open  cfk5_fonti(OLD_FONTE);
      fetch cfk5_fonti into dummy;
      found := cfk5_fonti%FOUND;
      close cfk5_fonti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Soggetti. La registrazione di Fonti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FONTI" if children still exist in "STORICO_SOGGETTI"
      open  cfk6_fonti(OLD_FONTE);
      fetch cfk6_fonti into dummy;
      found := cfk6_fonti%FOUND;
      close cfk6_fonti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Storico Soggetti. La registrazione di Fonti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FONTI" if children still exist in "DENUNCE_TASI"
      open  cfk7_fonti(OLD_FONTE);
      fetch cfk7_fonti into dummy;
      found := cfk7_fonti%FOUND;
      close cfk7_fonti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Denunce TASI. La registrazione di Fonti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "FONTI" if children still exist in "WRK_DOCFA_TESTATA"
      open  cfk8_fonti(OLD_FONTE);
      fetch cfk8_fonti into dummy;
      found := cfk8_fonti%FOUND;
      close cfk8_fonti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WRK_DOCFA_TESTATA. La registrazione di Fonti non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FONTI_PD */
/

-- Tigger FONTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table FONTI

create or replace trigger FONTI_TD
before DELETE
on FONTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DENUNCE_ICI

      -- Child Restrict Table: OGGETTI_PRATICA

      -- Child Restrict Table: OGGETTI

      -- Child Restrict Table: VERSAMENTI

      -- Child Restrict Table: SOGGETTI

      -- Child Restrict Table: STORICO_SOGGETTI

      -- Child Restrict Table: DENUNCE_TASI

      -- Child Restrict Table: WRK_DOCFA_TESTATA

      FONTI_PD(:OLD.FONTE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FONTI_TD */
/

-- Procedure FORNITURE_AE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FORNITURE_AE

create or replace procedure FORNITURE_AE_PU
(old_documento_id IN number,
 old_progressivo IN number,
 new_documento_id IN number,
 new_progressivo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FORNITURE_AE_PU */
/

-- Trigger FORNITURE_AE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FORNITURE_AE

create or replace trigger FORNITURE_AE_TIU
before INSERT
    or UPDATE
on FORNITURE_AE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.progressivo is null then
      FORNITURE_AE_NR (:new.documento_id,:new.progressivo);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FORNITURE_AE_PU(:OLD.DOCUMENTO_ID,
                         :OLD.PROGRESSIVO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.PROGRESSIVO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FORNITURE_AE"
            cursor cpk_forniture_ae(var_DOCUMENTO_ID number,
                                    var_PROGRESSIVO number) is
               select 1
                 from   FORNITURE_AE
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FORNITURE_AE"
               if :new.DOCUMENTO_ID is not null and
                  :new.PROGRESSIVO is not null then
                  open  cpk_forniture_ae(:new.DOCUMENTO_ID,
                                         :new.PROGRESSIVO);
                  fetch cpk_forniture_ae into dummy;
                  found := cpk_forniture_ae%FOUND;
                  close cpk_forniture_ae;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.PROGRESSIVO||
                               '" gia'' presente in FORNITURE_AE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FORNITURE_AE_TIU */
/

-- Procedure FTP_LOG_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table FTP_LOG

create or replace procedure FTP_LOG_PI
(new_id_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FTP_TRASMISSIONI"
   cursor cpk1_ftp_log(var_id_documento number) is
      select 1
      from   FTP_TRASMISSIONI
      where  ID_DOCUMENTO = var_id_documento
       and   var_id_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "FTP_TRASMISSIONI" deve esistere quando si inserisce su "FTP_LOG"
         if NEW_ID_DOCUMENTO is not null then
            open  cpk1_ftp_log(NEW_ID_DOCUMENTO);
            fetch cpk1_ftp_log into dummy;
            found := cpk1_ftp_log%FOUND;
            close cpk1_ftp_log;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su FTP_TRASMISSIONI. La registrazione FTP_LOG non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FTP_LOG_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table FTP_LOG
/* End Trigger: FTP_LOG_TC */

-- Procedure FTP_LOG_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FTP_LOG

create or replace procedure FTP_LOG_PU
(old_id_documento IN number,
 old_sequenza IN number,
 new_id_documento IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FTP_TRASMISSIONI"
   cursor cpk1_ftp_log(var_id_documento number) is
      select 1
      from   FTP_TRASMISSIONI
      where  ID_DOCUMENTO = var_id_documento
       and   var_id_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "FTP_TRASMISSIONI" deve esistere quando si modifica "FTP_LOG"
         if  NEW_ID_DOCUMENTO is not null and ( seq = 0 )
         and (   (NEW_ID_DOCUMENTO != OLD_ID_DOCUMENTO or OLD_ID_DOCUMENTO is null) ) then
            open  cpk1_ftp_log(NEW_ID_DOCUMENTO);
            fetch cpk1_ftp_log into dummy;
            found := cpk1_ftp_log%FOUND;
            close cpk1_ftp_log;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su FTP_TRASMISSIONI. La registrazione FTP_LOG non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FTP_LOG_PU */
/

-- Trigger FTP_LOG_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FTP_LOG

create or replace trigger FTP_LOG_TIU
before INSERT
    or UPDATE
on FTP_LOG
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
      FTP_LOG_NR(:new.id_documento, :new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FTP_LOG_PU(:OLD.ID_DOCUMENTO,
                    :OLD.SEQUENZA,
                         :NEW.ID_DOCUMENTO,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         FTP_LOG_PI(:NEW.ID_DOCUMENTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FTP_LOG"
            cursor cpk_ftp_log(var_ID_DOCUMENTO number,
                               var_SEQUENZA number) is
               select 1
                 from   FTP_LOG
                where  ID_DOCUMENTO = var_ID_DOCUMENTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FTP_LOG"
               if :new.ID_DOCUMENTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_ftp_log(:new.ID_DOCUMENTO,
                                    :new.SEQUENZA);
                  fetch cpk_ftp_log into dummy;
                  found := cpk_ftp_log%FOUND;
                  close cpk_ftp_log;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_DOCUMENTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in FTP_LOG. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FTP_LOG_TIU */
/

-- Procedure FTP_TRASMISSIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table FTP_TRASMISSIONI

create or replace procedure FTP_TRASMISSIONI_PU
(old_id_documento IN number,
 new_id_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "FTP_LOG"
   cursor cfk1_ftp_trasmissioni(var_id_documento number) is
      select 1
      from   FTP_LOG
      where  ID_DOCUMENTO = var_id_documento
       and   var_id_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "FTP_TRASMISSIONI" non modificabile se esistono referenze su "FTP_LOG"
      if (OLD_ID_DOCUMENTO != NEW_ID_DOCUMENTO) then
         open  cfk1_ftp_trasmissioni(OLD_ID_DOCUMENTO);
         fetch cfk1_ftp_trasmissioni into dummy;
         found := cfk1_ftp_trasmissioni%FOUND;
         close cfk1_ftp_trasmissioni;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su FTP_LOG. La registrazione di FTP_TRASMISSIONI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FTP_TRASMISSIONI_PU */
/

-- Trigger FTP_TRASMISSIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table FTP_TRASMISSIONI

create or replace trigger FTP_TRASMISSIONI_TIU
before INSERT
    or UPDATE
on FTP_TRASMISSIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id_documento is null then
      FTP_TRASMISSIONI_NR(:new.id_documento);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         FTP_TRASMISSIONI_PU(:OLD.ID_DOCUMENTO,
                         :NEW.ID_DOCUMENTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "FTP_TRASMISSIONI"
            cursor cpk_ftp_trasmissioni(var_ID_DOCUMENTO number) is
               select 1
                 from   FTP_TRASMISSIONI
                where  ID_DOCUMENTO = var_ID_DOCUMENTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "FTP_TRASMISSIONI"
               if :new.ID_DOCUMENTO is not null then
                  open  cpk_ftp_trasmissioni(:new.ID_DOCUMENTO);
                  fetch cpk_ftp_trasmissioni into dummy;
                  found := cpk_ftp_trasmissioni%FOUND;
                  close cpk_ftp_trasmissioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_DOCUMENTO||
                               '" gia'' presente in FTP_TRASMISSIONI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FTP_TRASMISSIONI_TIU */
/

-- Procedure FTP_TRASMISSIONI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table FTP_TRASMISSIONI

create or replace procedure FTP_TRASMISSIONI_PD
(old_id_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "FTP_LOG"
   cursor cfk1_ftp_trasmissioni(var_id_documento number) is
      select 1
      from   FTP_LOG
      where  ID_DOCUMENTO = var_id_documento
       and   var_id_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "FTP_TRASMISSIONI" if children still exist in "FTP_LOG"
      open  cfk1_ftp_trasmissioni(OLD_ID_DOCUMENTO);
      fetch cfk1_ftp_trasmissioni into dummy;
      found := cfk1_ftp_trasmissioni%FOUND;
      close cfk1_ftp_trasmissioni;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su FTP_LOG. La registrazione di FTP_TRASMISSIONI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: FTP_TRASMISSIONI_PD */
/

-- Tigger FTP_TRASMISSIONI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table FTP_TRASMISSIONI

create or replace trigger FTP_TRASMISSIONI_TD
before DELETE
on FTP_TRASMISSIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: FTP_LOG

      FTP_TRASMISSIONI_PD(:OLD.ID_DOCUMENTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: FTP_TRASMISSIONI_TD */
/

-- Procedure GRUPPI_SANZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table GRUPPI_SANZIONE

create or replace procedure GRUPPI_SANZIONE_PU
(old_gruppo_sanzione IN number,
 new_gruppo_sanzione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SANZIONI"
   cursor cfk1_gruppi_sanzione(var_gruppo_sanzione number) is
      select 1
      from   SANZIONI
      where  GRUPPO_SANZIONE = var_gruppo_sanzione
       and   var_gruppo_sanzione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "GRUPPI_SANZIONE" non modificabile se esistono referenze su "SANZIONI"
      if (OLD_GRUPPO_SANZIONE != NEW_GRUPPO_SANZIONE) then
         open  cfk1_gruppi_sanzione(OLD_GRUPPO_SANZIONE);
         fetch cfk1_gruppi_sanzione into dummy;
         found := cfk1_gruppi_sanzione%FOUND;
         close cfk1_gruppi_sanzione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sanzioni. La registrazione di Gruppi Sanzione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: GRUPPI_SANZIONE_PU */
/

-- Trigger GRUPPI_SANZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table GRUPPI_SANZIONE

create or replace trigger GRUPPI_SANZIONE_TIU
before INSERT
    or UPDATE
on GRUPPI_SANZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         GRUPPI_SANZIONE_PU(:OLD.GRUPPO_SANZIONE,
                         :NEW.GRUPPO_SANZIONE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "GRUPPI_SANZIONE"
            cursor cpk_gruppi_sanzione(var_GRUPPO_SANZIONE number) is
               select 1
                 from   GRUPPI_SANZIONE
                where  GRUPPO_SANZIONE = var_GRUPPO_SANZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "GRUPPI_SANZIONE"
               if :new.GRUPPO_SANZIONE is not null then
                  open  cpk_gruppi_sanzione(:new.GRUPPO_SANZIONE);
                  fetch cpk_gruppi_sanzione into dummy;
                  found := cpk_gruppi_sanzione%FOUND;
                  close cpk_gruppi_sanzione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.GRUPPO_SANZIONE||
                               '" gia'' presente in Gruppi Sanzione. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: GRUPPI_SANZIONE_TIU */
/

-- Procedure GRUPPI_SANZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table GRUPPI_SANZIONE

create or replace procedure GRUPPI_SANZIONE_PD
(old_gruppo_sanzione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SANZIONI"
   cursor cfk1_gruppi_sanzione(var_gruppo_sanzione number) is
      select 1
      from   SANZIONI
      where  GRUPPO_SANZIONE = var_gruppo_sanzione
       and   var_gruppo_sanzione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "GRUPPI_SANZIONE" if children still exist in "SANZIONI"
      open  cfk1_gruppi_sanzione(OLD_GRUPPO_SANZIONE);
      fetch cfk1_gruppi_sanzione into dummy;
      found := cfk1_gruppi_sanzione%FOUND;
      close cfk1_gruppi_sanzione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sanzioni. La registrazione di Gruppi Sanzione non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: GRUPPI_SANZIONE_PD */
/

-- Tigger GRUPPI_SANZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table GRUPPI_SANZIONE

create or replace trigger GRUPPI_SANZIONE_TD
before DELETE
on GRUPPI_SANZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SANZIONI

      GRUPPI_SANZIONE_PD(:OLD.GRUPPO_SANZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: GRUPPI_SANZIONE_TD */
/

-- Procedure GRUPPI_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table GRUPPI_TRIBUTO

create or replace procedure GRUPPI_TRIBUTO_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_gruppi_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "GRUPPI_TRIBUTO"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_gruppi_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk1_gruppi_tributo into dummy;
            found := cpk1_gruppi_tributo%FOUND;
            close cpk1_gruppi_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Gruppi_tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: GRUPPI_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table GRUPPI_TRIBUTO
/* End Trigger: GRUPPI_TRIBUTO_TC */

-- Procedure GRUPPI_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table GRUPPI_TRIBUTO

create or replace procedure GRUPPI_TRIBUTO_PU
(old_tipo_tributo IN varchar,
 old_gruppo_tributo IN varchar,
 new_tipo_tributo IN varchar,
 new_gruppo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_gruppi_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "ELABORAZIONI_MASSIVE"
   cursor cfk1_gruppi_tributo(var_gruppo_tributo varchar,
                              var_tipo_tributo varchar) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  GRUPPO_TRIBUTO = var_gruppo_tributo
       and   TIPO_TRIBUTO = var_tipo_tributo
       and   var_gruppo_tributo is not null
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "CODICI_TRIBUTO"
   cursor cfk2_gruppi_tributo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   CODICI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "SCADENZE"
   cursor cfk3_gruppi_tributo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   SCADENZE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "LIMITI_CALCOLO"
   cursor cfk4_gruppi_tributo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   LIMITI_CALCOLO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "GRUPPI_TRIBUTO"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_gruppi_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk1_gruppi_tributo into dummy;
            found := cpk1_gruppi_tributo%FOUND;
            close cpk1_gruppi_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Gruppi_tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "GRUPPI_TRIBUTO" non modificabile se esistono referenze su "ELABORAZIONI_MASSIVE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_GRUPPO_TRIBUTO != NEW_GRUPPO_TRIBUTO) then
         open  cfk1_gruppi_tributo(OLD_GRUPPO_TRIBUTO,
                                   OLD_TIPO_TRIBUTO);
         fetch cfk1_gruppi_tributo into dummy;
         found := cfk1_gruppi_tributo%FOUND;
         close cfk1_gruppi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Elaborazioni Massive. La registrazione di Gruppi_tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "GRUPPI_TRIBUTO" non modificabile se esistono referenze su "CODICI_TRIBUTO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_GRUPPO_TRIBUTO != NEW_GRUPPO_TRIBUTO) then
         open  cfk2_gruppi_tributo(OLD_TIPO_TRIBUTO,
                                   OLD_GRUPPO_TRIBUTO);
         fetch cfk2_gruppi_tributo into dummy;
         found := cfk2_gruppi_tributo%FOUND;
         close cfk2_gruppi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Codici Tributo. La registrazione di Gruppi_tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "GRUPPI_TRIBUTO" non modificabile se esistono referenze su "SCADENZE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_GRUPPO_TRIBUTO != NEW_GRUPPO_TRIBUTO) then
         open  cfk3_gruppi_tributo(OLD_TIPO_TRIBUTO,
                                   OLD_GRUPPO_TRIBUTO);
         fetch cfk3_gruppi_tributo into dummy;
         found := cfk3_gruppi_tributo%FOUND;
         close cfk3_gruppi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Scadenze. La registrazione di Gruppi_tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "GRUPPI_TRIBUTO" non modificabile se esistono referenze su "LIMITI_CALCOLO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_GRUPPO_TRIBUTO != NEW_GRUPPO_TRIBUTO) then
         open  cfk4_gruppi_tributo(OLD_TIPO_TRIBUTO,
                                   OLD_GRUPPO_TRIBUTO);
         fetch cfk4_gruppi_tributo into dummy;
         found := cfk4_gruppi_tributo%FOUND;
         close cfk4_gruppi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Limiti calcolo. La registrazione di Gruppi_tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: GRUPPI_TRIBUTO_PU */
/

-- Trigger GRUPPI_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table GRUPPI_TRIBUTO

create or replace trigger GRUPPI_TRIBUTO_TIU
before INSERT
    or UPDATE
on GRUPPI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         GRUPPI_TRIBUTO_PU(:OLD.TIPO_TRIBUTO,
                           :OLD.GRUPPO_TRIBUTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.GRUPPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         GRUPPI_TRIBUTO_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "GRUPPI_TRIBUTO"
            cursor cpk_gruppi_tributo(var_TIPO_TRIBUTO varchar,
                                      var_GRUPPO_TRIBUTO varchar) is
               select 1
                 from   GRUPPI_TRIBUTO
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       GRUPPO_TRIBUTO = var_GRUPPO_TRIBUTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "GRUPPI_TRIBUTO"
               if :new.TIPO_TRIBUTO is not null and
                  :new.GRUPPO_TRIBUTO is not null then
                  open  cpk_gruppi_tributo(:new.TIPO_TRIBUTO,
                                           :new.GRUPPO_TRIBUTO);
                  fetch cpk_gruppi_tributo into dummy;
                  found := cpk_gruppi_tributo%FOUND;
                  close cpk_gruppi_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.GRUPPO_TRIBUTO||
                               '" gia'' presente in Gruppi_tributo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: GRUPPI_TRIBUTO_TIU */
/

-- Procedure GRUPPI_TRIBUTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table GRUPPI_TRIBUTO

create or replace procedure GRUPPI_TRIBUTO_PD
(old_tipo_tributo IN varchar,
 old_gruppo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ELABORAZIONI_MASSIVE"
   cursor cfk1_gruppi_tributo(var_gruppo_tributo varchar,
                              var_tipo_tributo varchar) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  GRUPPO_TRIBUTO = var_gruppo_tributo
       and   TIPO_TRIBUTO = var_tipo_tributo
       and   var_gruppo_tributo is not null
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "CODICI_TRIBUTO"
   cursor cfk2_gruppi_tributo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   CODICI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SCADENZE"
   cursor cfk3_gruppi_tributo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   SCADENZE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "LIMITI_CALCOLO"
   cursor cfk4_gruppi_tributo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   LIMITI_CALCOLO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "GRUPPI_TRIBUTO" if children still exist in "ELABORAZIONI_MASSIVE"
      open  cfk1_gruppi_tributo(OLD_GRUPPO_TRIBUTO,
                                OLD_TIPO_TRIBUTO);
      fetch cfk1_gruppi_tributo into dummy;
      found := cfk1_gruppi_tributo%FOUND;
      close cfk1_gruppi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Elaborazioni Massive. La registrazione di Gruppi_tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "GRUPPI_TRIBUTO" if children still exist in "CODICI_TRIBUTO"
      open  cfk2_gruppi_tributo(OLD_TIPO_TRIBUTO,
                                OLD_GRUPPO_TRIBUTO);
      fetch cfk2_gruppi_tributo into dummy;
      found := cfk2_gruppi_tributo%FOUND;
      close cfk2_gruppi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Codici Tributo. La registrazione di Gruppi_tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "GRUPPI_TRIBUTO" if children still exist in "SCADENZE"
      open  cfk3_gruppi_tributo(OLD_TIPO_TRIBUTO,
                                OLD_GRUPPO_TRIBUTO);
      fetch cfk3_gruppi_tributo into dummy;
      found := cfk3_gruppi_tributo%FOUND;
      close cfk3_gruppi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Scadenze. La registrazione di Gruppi_tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "GRUPPI_TRIBUTO" if children still exist in "LIMITI_CALCOLO"
      open  cfk4_gruppi_tributo(OLD_TIPO_TRIBUTO,
                                OLD_GRUPPO_TRIBUTO);
      fetch cfk4_gruppi_tributo into dummy;
      found := cfk4_gruppi_tributo%FOUND;
      close cfk4_gruppi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Limiti calcolo. La registrazione di Gruppi_tributo non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: GRUPPI_TRIBUTO_PD */
/

-- Tigger GRUPPI_TRIBUTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table GRUPPI_TRIBUTO

create or replace trigger GRUPPI_TRIBUTO_TD
before DELETE
on GRUPPI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ELABORAZIONI_MASSIVE

      -- Child Restrict Table: CODICI_TRIBUTO

      -- Child Restrict Table: SCADENZE

      -- Child Restrict Table: LIMITI_CALCOLO

      GRUPPI_TRIBUTO_PD(:OLD.TIPO_TRIBUTO,
                        :OLD.GRUPPO_TRIBUTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: GRUPPI_TRIBUTO_TD */
/

-- Procedure IMPRESE_ARTI_PROFESSIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table IMPRESE_ARTI_PROFESSIONI

create or replace procedure IMPRESE_ARTI_PROFESSIONI_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_imprese_arti_professioni(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "IMPRESE_ARTI_PROFESSIONI"
         if NEW_PRATICA is not null then
            open  cpk1_imprese_arti_professioni(NEW_PRATICA);
            fetch cpk1_imprese_arti_professioni into dummy;
            found := cpk1_imprese_arti_professioni%FOUND;
            close cpk1_imprese_arti_professioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Imprese Arti Professioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: IMPRESE_ARTI_PROFESSIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table IMPRESE_ARTI_PROFESSIONI
/* End Trigger: IMPRESE_ARTI_PROFESSIONI_TC */

-- Procedure IMPRESE_ARTI_PROFESSIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table IMPRESE_ARTI_PROFESSIONI

create or replace procedure IMPRESE_ARTI_PROFESSIONI_PU
(old_pratica IN number,
 old_sequenza IN number,
 new_pratica IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_imprese_arti_professioni(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "IMPRESE_ARTI_PROFESSIONI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_imprese_arti_professioni(NEW_PRATICA);
            fetch cpk1_imprese_arti_professioni into dummy;
            found := cpk1_imprese_arti_professioni%FOUND;
            close cpk1_imprese_arti_professioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Imprese Arti Professioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: IMPRESE_ARTI_PROFESSIONI_PU */
/

-- Trigger IMPRESE_ARTI_PROFESSIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table IMPRESE_ARTI_PROFESSIONI

create or replace trigger IMPRESE_ARTI_PROFESSIONI_TIU
before INSERT
    or UPDATE
on IMPRESE_ARTI_PROFESSIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       IMPRESE_ARTI_PROFESSIONI_NR (:new.pratica,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         IMPRESE_ARTI_PROFESSIONI_PU(:OLD.PRATICA,
                                     :OLD.SEQUENZA,
                         :NEW.PRATICA,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         IMPRESE_ARTI_PROFESSIONI_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "IMPRESE_ARTI_PROFESSIONI"
            cursor cpk_imprese_arti_professioni(var_PRATICA number,
                                                var_SEQUENZA number) is
               select 1
                 from   IMPRESE_ARTI_PROFESSIONI
                where  PRATICA = var_PRATICA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "IMPRESE_ARTI_PROFESSIONI"
               if :new.PRATICA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_imprese_arti_professioni(:new.PRATICA,
                                                     :new.SEQUENZA);
                  fetch cpk_imprese_arti_professioni into dummy;
                  found := cpk_imprese_arti_professioni%FOUND;
                  close cpk_imprese_arti_professioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Imprese Arti Professioni. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: IMPRESE_ARTI_PROFESSIONI_TIU */
/

-- Procedure INTERESSI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table INTERESSI

create or replace procedure INTERESSI_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_interessi(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "INTERESSI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_interessi(NEW_TIPO_TRIBUTO);
            fetch cpk1_interessi into dummy;
            found := cpk1_interessi%FOUND;
            close cpk1_interessi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Interessi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: INTERESSI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table INTERESSI
/* End Trigger: INTERESSI_TC */

-- Procedure INTERESSI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table INTERESSI

create or replace procedure INTERESSI_PU
(old_tipo_tributo IN varchar,
 old_sequenza IN number,
 new_tipo_tributo IN varchar,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_interessi(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "INTERESSI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_interessi(NEW_TIPO_TRIBUTO);
            fetch cpk1_interessi into dummy;
            found := cpk1_interessi%FOUND;
            close cpk1_interessi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Interessi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: INTERESSI_PU */
/

-- Trigger INTERESSI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table INTERESSI

create or replace trigger INTERESSI_TIU
before INSERT
    or UPDATE
on INTERESSI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
       INTERESSI_DI (:new.data_inizio,:new.data_fine);
   end;

   if INSERTING and :new.sequenza is null then
       INTERESSI_NR (:new.tipo_tributo,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         INTERESSI_PU(:OLD.TIPO_TRIBUTO,
                      :OLD.SEQUENZA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         INTERESSI_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "INTERESSI"
            cursor cpk_interessi(var_TIPO_TRIBUTO varchar,
                                 var_SEQUENZA number) is
               select 1
                 from   INTERESSI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "INTERESSI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_interessi(:new.TIPO_TRIBUTO,
                                      :new.SEQUENZA);
                  fetch cpk_interessi into dummy;
                  found := cpk_interessi%FOUND;
                  close cpk_interessi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Interessi. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: INTERESSI_TIU */
/

-- Procedure ITER_PRATICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table ITER_PRATICA

create or replace procedure ITER_PRATICA_PI
(new_pratica IN number,
 new_stato IN varchar,
 new_tipo_atto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_iter_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_STATO"
   cursor cpk2_iter_pratica(var_stato varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_stato
       and   var_stato is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ATTO"
   cursor cpk3_iter_pratica(var_tipo_atto number) is
      select 1
      from   TIPI_ATTO
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "ITER_PRATICA"
         if NEW_PRATICA is not null then
            open  cpk1_iter_pratica(NEW_PRATICA);
            fetch cpk1_iter_pratica into dummy;
            found := cpk1_iter_pratica%FOUND;
            close cpk1_iter_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Iter Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si inserisce su "ITER_PRATICA"
         if NEW_STATO is not null then
            open  cpk2_iter_pratica(NEW_STATO);
            fetch cpk2_iter_pratica into dummy;
            found := cpk2_iter_pratica%FOUND;
            close cpk2_iter_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione Iter Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTO" deve esistere quando si inserisce su "ITER_PRATICA"
         if NEW_TIPO_ATTO is not null then
            open  cpk3_iter_pratica(NEW_TIPO_ATTO);
            fetch cpk3_iter_pratica into dummy;
            found := cpk3_iter_pratica%FOUND;
            close cpk3_iter_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Atto. La registrazione Iter Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ITER_PRATICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table ITER_PRATICA
/* End Trigger: ITER_PRATICA_TC */

-- Procedure ITER_PRATICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table ITER_PRATICA

create or replace procedure ITER_PRATICA_PU
(old_iter_pratica IN number,
 old_pratica IN number,
 old_stato IN varchar,
 old_tipo_atto IN number,
 new_iter_pratica IN number,
 new_pratica IN number,
 new_stato IN varchar,
 new_tipo_atto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_iter_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_STATO"
   cursor cpk2_iter_pratica(var_stato varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_stato
       and   var_stato is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ATTO"
   cursor cpk3_iter_pratica(var_tipo_atto number) is
      select 1
      from   TIPI_ATTO
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "ITER_PRATICA"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_iter_pratica(NEW_PRATICA);
            fetch cpk1_iter_pratica into dummy;
            found := cpk1_iter_pratica%FOUND;
            close cpk1_iter_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Iter Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si modifica "ITER_PRATICA"
         if  NEW_STATO is not null and ( seq = 0 )
         and (   (NEW_STATO != OLD_STATO or OLD_STATO is null) ) then
            open  cpk2_iter_pratica(NEW_STATO);
            fetch cpk2_iter_pratica into dummy;
            found := cpk2_iter_pratica%FOUND;
            close cpk2_iter_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione Iter Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTO" deve esistere quando si modifica "ITER_PRATICA"
         if  NEW_TIPO_ATTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_ATTO != OLD_TIPO_ATTO or OLD_TIPO_ATTO is null) ) then
            open  cpk3_iter_pratica(NEW_TIPO_ATTO);
            fetch cpk3_iter_pratica into dummy;
            found := cpk3_iter_pratica%FOUND;
            close cpk3_iter_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Atto. La registrazione Iter Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: ITER_PRATICA_PU */
/

-- Trigger ITER_PRATICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table ITER_PRATICA

create or replace trigger ITER_PRATICA_TIU
before INSERT
    or UPDATE
on ITER_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.iter_pratica is null then
      ITER_PRATICA_NR(:new.iter_pratica);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         ITER_PRATICA_PU(:OLD.ITER_PRATICA,
                         :OLD.PRATICA,
                         :OLD.STATO,
                         :OLD.TIPO_ATTO,
                         :NEW.ITER_PRATICA,
                         :NEW.PRATICA,
                         :NEW.STATO,
                         :NEW.TIPO_ATTO);
         null;
      end if;
      if INSERTING then
         ITER_PRATICA_PI(:NEW.PRATICA,
                         :NEW.STATO,
                         :NEW.TIPO_ATTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "ITER_PRATICA"
            cursor cpk_iter_pratica(var_ITER_PRATICA number) is
               select 1
                 from   ITER_PRATICA
                where  ITER_PRATICA = var_ITER_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "ITER_PRATICA"
               if :new.ITER_PRATICA is not null then
                  open  cpk_iter_pratica(:new.ITER_PRATICA);
                  fetch cpk_iter_pratica into dummy;
                  found := cpk_iter_pratica%FOUND;
                  close cpk_iter_pratica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ITER_PRATICA||
                               '" gia'' presente in Iter Pratica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: ITER_PRATICA_TIU */
/

-- Procedure LIMITI_CALCOLO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table LIMITI_CALCOLO

create or replace procedure LIMITI_CALCOLO_PI
(new_tipo_tributo IN varchar,
 new_gruppo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_limiti_calcolo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "GRUPPI_TRIBUTO"
   cursor cpk2_limiti_calcolo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "LIMITI_CALCOLO"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_limiti_calcolo(NEW_TIPO_TRIBUTO);
            fetch cpk1_limiti_calcolo into dummy;
            found := cpk1_limiti_calcolo%FOUND;
            close cpk1_limiti_calcolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Limiti calcolo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_TRIBUTO" deve esistere quando si inserisce su "LIMITI_CALCOLO"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_GRUPPO_TRIBUTO is not null then
            open  cpk2_limiti_calcolo(NEW_TIPO_TRIBUTO,
                                      NEW_GRUPPO_TRIBUTO);
            fetch cpk2_limiti_calcolo into dummy;
            found := cpk2_limiti_calcolo%FOUND;
            close cpk2_limiti_calcolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Gruppi_tributo. La registrazione Limiti calcolo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LIMITI_CALCOLO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table LIMITI_CALCOLO
/* End Trigger: LIMITI_CALCOLO_TC */

-- Procedure LIMITI_CALCOLO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table LIMITI_CALCOLO

create or replace procedure LIMITI_CALCOLO_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_sequenza IN number,
 old_gruppo_tributo IN varchar,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_sequenza IN number,
 new_gruppo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_limiti_calcolo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "GRUPPI_TRIBUTO"
   cursor cpk2_limiti_calcolo(var_tipo_tributo varchar,
                              var_gruppo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "LIMITI_CALCOLO"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_limiti_calcolo(NEW_TIPO_TRIBUTO);
            fetch cpk1_limiti_calcolo into dummy;
            found := cpk1_limiti_calcolo%FOUND;
            close cpk1_limiti_calcolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Limiti calcolo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_TRIBUTO" deve esistere quando si modifica "LIMITI_CALCOLO"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_GRUPPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_GRUPPO_TRIBUTO != OLD_GRUPPO_TRIBUTO or OLD_GRUPPO_TRIBUTO is null) ) then
            open  cpk2_limiti_calcolo(NEW_TIPO_TRIBUTO,
                                      NEW_GRUPPO_TRIBUTO);
            fetch cpk2_limiti_calcolo into dummy;
            found := cpk2_limiti_calcolo%FOUND;
            close cpk2_limiti_calcolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Gruppi_tributo. La registrazione Limiti calcolo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "GRUPPI_TRIBUTO" non modificabile sul figlio: "LIMITI_CALCOLO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_GRUPPO_TRIBUTO != NEW_GRUPPO_TRIBUTO) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Gruppi_tributo non e'' modificabile su Limiti calcolo.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LIMITI_CALCOLO_PU */
/

-- Trigger LIMITI_CALCOLO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table LIMITI_CALCOLO

create or replace trigger LIMITI_CALCOLO_TIU
before INSERT
    or UPDATE
on LIMITI_CALCOLO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       LIMITI_CALCOLO_NR(:new.tipo_tributo,:new.anno,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         LIMITI_CALCOLO_PU(:OLD.TIPO_TRIBUTO,
                           :OLD.ANNO,
                           :OLD.SEQUENZA,
                           :OLD.GRUPPO_TRIBUTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.SEQUENZA,
                         :NEW.GRUPPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         LIMITI_CALCOLO_PI(:NEW.TIPO_TRIBUTO,
                           :NEW.GRUPPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "LIMITI_CALCOLO"
            cursor cpk_limiti_calcolo(var_TIPO_TRIBUTO varchar,
                                      var_ANNO number,
                                      var_SEQUENZA number) is
               select 1
                 from   LIMITI_CALCOLO
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "LIMITI_CALCOLO"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_limiti_calcolo(:new.TIPO_TRIBUTO,
                                           :new.ANNO,
                                           :new.SEQUENZA);
                  fetch cpk_limiti_calcolo into dummy;
                  found := cpk_limiti_calcolo%FOUND;
                  close cpk_limiti_calcolo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Limiti calcolo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: LIMITI_CALCOLO_TIU */
/

-- Procedure LOCAZIONI_CONTRATTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table LOCAZIONI_CONTRATTI

create or replace procedure LOCAZIONI_CONTRATTI_PI
(new_testate_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "LOCAZIONI_TESTATE"
   cursor cpk1_locazioni_contratti(var_testate_id number) is
      select 1
      from   LOCAZIONI_TESTATE
      where  TESTATE_ID = var_testate_id
       and   var_testate_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "LOCAZIONI_TESTATE" deve esistere quando si inserisce su "LOCAZIONI_CONTRATTI"
         if NEW_TESTATE_ID is not null then
            open  cpk1_locazioni_contratti(NEW_TESTATE_ID);
            fetch cpk1_locazioni_contratti into dummy;
            found := cpk1_locazioni_contratti%FOUND;
            close cpk1_locazioni_contratti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su LOCAZIONI_TESTATE. La registrazione LOCAZIONI_CONTRATTI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_CONTRATTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table LOCAZIONI_CONTRATTI
/* End Trigger: LOCAZIONI_CONTRATTI_TC */

-- Procedure LOCAZIONI_CONTRATTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table LOCAZIONI_CONTRATTI

create or replace procedure LOCAZIONI_CONTRATTI_PU
(old_contratti_id IN number,
 old_testate_id IN number,
 new_contratti_id IN number,
 new_testate_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "LOCAZIONI_TESTATE"
   cursor cpk1_locazioni_contratti(var_testate_id number) is
      select 1
      from   LOCAZIONI_TESTATE
      where  TESTATE_ID = var_testate_id
       and   var_testate_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "LOCAZIONI_IMMOBILI"
   cursor cfk1_locazioni_contratti(var_contratti_id number) is
      select 1
      from   LOCAZIONI_IMMOBILI
      where  CONTRATTI_ID = var_contratti_id
       and   var_contratti_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "LOCAZIONI_SOGGETTI"
   cursor cfk2_locazioni_contratti(var_contratti_id number) is
      select 1
      from   LOCAZIONI_SOGGETTI
      where  CONTRATTI_ID = var_contratti_id
       and   var_contratti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "LOCAZIONI_TESTATE" deve esistere quando si modifica "LOCAZIONI_CONTRATTI"
         if  NEW_TESTATE_ID is not null and ( seq = 0 )
         and (   (NEW_TESTATE_ID != OLD_TESTATE_ID or OLD_TESTATE_ID is null) ) then
            open  cpk1_locazioni_contratti(NEW_TESTATE_ID);
            fetch cpk1_locazioni_contratti into dummy;
            found := cpk1_locazioni_contratti%FOUND;
            close cpk1_locazioni_contratti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su LOCAZIONI_TESTATE. La registrazione LOCAZIONI_CONTRATTI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "LOCAZIONI_CONTRATTI" non modificabile se esistono referenze su "LOCAZIONI_IMMOBILI"
      if (OLD_CONTRATTI_ID != NEW_CONTRATTI_ID) then
         open  cfk1_locazioni_contratti(OLD_CONTRATTI_ID);
         fetch cfk1_locazioni_contratti into dummy;
         found := cfk1_locazioni_contratti%FOUND;
         close cfk1_locazioni_contratti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su LOCAZIONI_IMMOBILI. La registrazione di LOCAZIONI_CONTRATTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "LOCAZIONI_CONTRATTI" non modificabile se esistono referenze su "LOCAZIONI_SOGGETTI"
      if (OLD_CONTRATTI_ID != NEW_CONTRATTI_ID) then
         open  cfk2_locazioni_contratti(OLD_CONTRATTI_ID);
         fetch cfk2_locazioni_contratti into dummy;
         found := cfk2_locazioni_contratti%FOUND;
         close cfk2_locazioni_contratti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su LOCAZIONI_SOGGETTI. La registrazione di LOCAZIONI_CONTRATTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_CONTRATTI_PU */
/

-- Trigger LOCAZIONI_CONTRATTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table LOCAZIONI_CONTRATTI

create or replace trigger LOCAZIONI_CONTRATTI_TIU
before INSERT
    or UPDATE
on LOCAZIONI_CONTRATTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         LOCAZIONI_CONTRATTI_PU(:OLD.CONTRATTI_ID,
                                :OLD.TESTATE_ID,
                         :NEW.CONTRATTI_ID,
                         :NEW.TESTATE_ID);
         null;
      end if;
      if INSERTING then
         LOCAZIONI_CONTRATTI_PI(:NEW.TESTATE_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "LOCAZIONI_CONTRATTI"
            cursor cpk_locazioni_contratti(var_CONTRATTI_ID number) is
               select 1
                 from   LOCAZIONI_CONTRATTI
                where  CONTRATTI_ID = var_CONTRATTI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "LOCAZIONI_CONTRATTI"
               if :new.CONTRATTI_ID is not null then
                  open  cpk_locazioni_contratti(:new.CONTRATTI_ID);
                  fetch cpk_locazioni_contratti into dummy;
                  found := cpk_locazioni_contratti%FOUND;
                  close cpk_locazioni_contratti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.CONTRATTI_ID||
                               '" gia'' presente in LOCAZIONI_CONTRATTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: LOCAZIONI_CONTRATTI_TIU */
/

-- Procedure LOCAZIONI_CONTRATTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table LOCAZIONI_CONTRATTI

create or replace procedure LOCAZIONI_CONTRATTI_PD
(old_contratti_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "LOCAZIONI_IMMOBILI"
   cursor cfk1_locazioni_contratti(var_contratti_id number) is
      select 1
      from   LOCAZIONI_IMMOBILI
      where  CONTRATTI_ID = var_contratti_id
       and   var_contratti_id is not null;

   --  Declaration of DeleteParentRestrict constraint for "LOCAZIONI_SOGGETTI"
   cursor cfk2_locazioni_contratti(var_contratti_id number) is
      select 1
      from   LOCAZIONI_SOGGETTI
      where  CONTRATTI_ID = var_contratti_id
       and   var_contratti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "LOCAZIONI_CONTRATTI" if children still exist in "LOCAZIONI_IMMOBILI"
      open  cfk1_locazioni_contratti(OLD_CONTRATTI_ID);
      fetch cfk1_locazioni_contratti into dummy;
      found := cfk1_locazioni_contratti%FOUND;
      close cfk1_locazioni_contratti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su LOCAZIONI_IMMOBILI. La registrazione di LOCAZIONI_CONTRATTI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "LOCAZIONI_CONTRATTI" if children still exist in "LOCAZIONI_SOGGETTI"
      open  cfk2_locazioni_contratti(OLD_CONTRATTI_ID);
      fetch cfk2_locazioni_contratti into dummy;
      found := cfk2_locazioni_contratti%FOUND;
      close cfk2_locazioni_contratti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su LOCAZIONI_SOGGETTI. La registrazione di LOCAZIONI_CONTRATTI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_CONTRATTI_PD */
/

-- Tigger LOCAZIONI_CONTRATTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table LOCAZIONI_CONTRATTI

create or replace trigger LOCAZIONI_CONTRATTI_TD
before DELETE
on LOCAZIONI_CONTRATTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: LOCAZIONI_IMMOBILI

      -- Child Restrict Table: LOCAZIONI_SOGGETTI

      LOCAZIONI_CONTRATTI_PD(:OLD.CONTRATTI_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: LOCAZIONI_CONTRATTI_TD */
/

-- Procedure LOCAZIONI_IMMOBILI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table LOCAZIONI_IMMOBILI

create or replace procedure LOCAZIONI_IMMOBILI_PI
(new_contratti_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "LOCAZIONI_CONTRATTI"
   cursor cpk1_locazioni_immobili(var_contratti_id number) is
      select 1
      from   LOCAZIONI_CONTRATTI
      where  CONTRATTI_ID = var_contratti_id
       and   var_contratti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "LOCAZIONI_CONTRATTI" deve esistere quando si inserisce su "LOCAZIONI_IMMOBILI"
         if NEW_CONTRATTI_ID is not null then
            open  cpk1_locazioni_immobili(NEW_CONTRATTI_ID);
            fetch cpk1_locazioni_immobili into dummy;
            found := cpk1_locazioni_immobili%FOUND;
            close cpk1_locazioni_immobili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su LOCAZIONI_CONTRATTI. La registrazione LOCAZIONI_IMMOBILI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_IMMOBILI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table LOCAZIONI_IMMOBILI
/* End Trigger: LOCAZIONI_IMMOBILI_TC */

-- Procedure LOCAZIONI_IMMOBILI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table LOCAZIONI_IMMOBILI

create or replace procedure LOCAZIONI_IMMOBILI_PU
(old_immobili_id IN number,
 old_contratti_id IN number,
 new_immobili_id IN number,
 new_contratti_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "LOCAZIONI_CONTRATTI"
   cursor cpk1_locazioni_immobili(var_contratti_id number) is
      select 1
      from   LOCAZIONI_CONTRATTI
      where  CONTRATTI_ID = var_contratti_id
       and   var_contratti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "LOCAZIONI_CONTRATTI" deve esistere quando si modifica "LOCAZIONI_IMMOBILI"
         if  NEW_CONTRATTI_ID is not null and ( seq = 0 )
         and (   (NEW_CONTRATTI_ID != OLD_CONTRATTI_ID or OLD_CONTRATTI_ID is null) ) then
            open  cpk1_locazioni_immobili(NEW_CONTRATTI_ID);
            fetch cpk1_locazioni_immobili into dummy;
            found := cpk1_locazioni_immobili%FOUND;
            close cpk1_locazioni_immobili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su LOCAZIONI_CONTRATTI. La registrazione LOCAZIONI_IMMOBILI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_IMMOBILI_PU */
/

-- Trigger LOCAZIONI_IMMOBILI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table LOCAZIONI_IMMOBILI

create or replace trigger LOCAZIONI_IMMOBILI_TIU
before INSERT
    or UPDATE
on LOCAZIONI_IMMOBILI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         LOCAZIONI_IMMOBILI_PU(:OLD.IMMOBILI_ID,
                               :OLD.CONTRATTI_ID,
                         :NEW.IMMOBILI_ID,
                         :NEW.CONTRATTI_ID);
         null;
      end if;
      if INSERTING then
         LOCAZIONI_IMMOBILI_PI(:NEW.CONTRATTI_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "LOCAZIONI_IMMOBILI"
            cursor cpk_locazioni_immobili(var_IMMOBILI_ID number) is
               select 1
                 from   LOCAZIONI_IMMOBILI
                where  IMMOBILI_ID = var_IMMOBILI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "LOCAZIONI_IMMOBILI"
               if :new.IMMOBILI_ID is not null then
                  open  cpk_locazioni_immobili(:new.IMMOBILI_ID);
                  fetch cpk_locazioni_immobili into dummy;
                  found := cpk_locazioni_immobili%FOUND;
                  close cpk_locazioni_immobili;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.IMMOBILI_ID||
                               '" gia'' presente in LOCAZIONI_IMMOBILI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: LOCAZIONI_IMMOBILI_TIU */
/

-- Procedure LOCAZIONI_SOGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table LOCAZIONI_SOGGETTI

create or replace procedure LOCAZIONI_SOGGETTI_PI
(new_contratti_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "LOCAZIONI_CONTRATTI"
   cursor cpk1_locazioni_soggetti(var_contratti_id number) is
      select 1
      from   LOCAZIONI_CONTRATTI
      where  CONTRATTI_ID = var_contratti_id
       and   var_contratti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "LOCAZIONI_CONTRATTI" deve esistere quando si inserisce su "LOCAZIONI_SOGGETTI"
         if NEW_CONTRATTI_ID is not null then
            open  cpk1_locazioni_soggetti(NEW_CONTRATTI_ID);
            fetch cpk1_locazioni_soggetti into dummy;
            found := cpk1_locazioni_soggetti%FOUND;
            close cpk1_locazioni_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su LOCAZIONI_CONTRATTI. La registrazione LOCAZIONI_SOGGETTI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_SOGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table LOCAZIONI_SOGGETTI
/* End Trigger: LOCAZIONI_SOGGETTI_TC */

-- Procedure LOCAZIONI_SOGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table LOCAZIONI_SOGGETTI

create or replace procedure LOCAZIONI_SOGGETTI_PU
(old_soggetti_id IN number,
 old_contratti_id IN number,
 new_soggetti_id IN number,
 new_contratti_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "LOCAZIONI_CONTRATTI"
   cursor cpk1_locazioni_soggetti(var_contratti_id number) is
      select 1
      from   LOCAZIONI_CONTRATTI
      where  CONTRATTI_ID = var_contratti_id
       and   var_contratti_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "LOCAZIONI_CONTRATTI" deve esistere quando si modifica "LOCAZIONI_SOGGETTI"
         if  NEW_CONTRATTI_ID is not null and ( seq = 0 )
         and (   (NEW_CONTRATTI_ID != OLD_CONTRATTI_ID or OLD_CONTRATTI_ID is null) ) then
            open  cpk1_locazioni_soggetti(NEW_CONTRATTI_ID);
            fetch cpk1_locazioni_soggetti into dummy;
            found := cpk1_locazioni_soggetti%FOUND;
            close cpk1_locazioni_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su LOCAZIONI_CONTRATTI. La registrazione LOCAZIONI_SOGGETTI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_SOGGETTI_PU */
/

-- Trigger LOCAZIONI_SOGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table LOCAZIONI_SOGGETTI

create or replace trigger LOCAZIONI_SOGGETTI_TIU
before INSERT
    or UPDATE
on LOCAZIONI_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         LOCAZIONI_SOGGETTI_PU(:OLD.SOGGETTI_ID,
                               :OLD.CONTRATTI_ID,
                         :NEW.SOGGETTI_ID,
                         :NEW.CONTRATTI_ID);
         null;
      end if;
      if INSERTING then
         LOCAZIONI_SOGGETTI_PI(:NEW.CONTRATTI_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "LOCAZIONI_SOGGETTI"
            cursor cpk_locazioni_soggetti(var_SOGGETTI_ID number) is
               select 1
                 from   LOCAZIONI_SOGGETTI
                where  SOGGETTI_ID = var_SOGGETTI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "LOCAZIONI_SOGGETTI"
               if :new.SOGGETTI_ID is not null then
                  open  cpk_locazioni_soggetti(:new.SOGGETTI_ID);
                  fetch cpk_locazioni_soggetti into dummy;
                  found := cpk_locazioni_soggetti%FOUND;
                  close cpk_locazioni_soggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.SOGGETTI_ID||
                               '" gia'' presente in LOCAZIONI_SOGGETTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: LOCAZIONI_SOGGETTI_TIU */
/

-- Procedure LOCAZIONI_TESTATE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table LOCAZIONI_TESTATE

create or replace procedure LOCAZIONI_TESTATE_PI
(new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk1_locazioni_testate(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "LOCAZIONI_TESTATE"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk1_locazioni_testate(NEW_DOCUMENTO_ID);
            fetch cpk1_locazioni_testate into dummy;
            found := cpk1_locazioni_testate%FOUND;
            close cpk1_locazioni_testate;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione LOCAZIONI_TESTATE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_TESTATE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table LOCAZIONI_TESTATE
/* End Trigger: LOCAZIONI_TESTATE_TC */

-- Procedure LOCAZIONI_TESTATE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table LOCAZIONI_TESTATE

create or replace procedure LOCAZIONI_TESTATE_PU
(old_testate_id IN number,
 old_documento_id IN number,
 new_testate_id IN number,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk1_locazioni_testate(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "LOCAZIONI_CONTRATTI"
   cursor cfk1_locazioni_testate(var_testate_id number) is
      select 1
      from   LOCAZIONI_CONTRATTI
      where  TESTATE_ID = var_testate_id
       and   var_testate_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "LOCAZIONI_TESTATE"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk1_locazioni_testate(NEW_DOCUMENTO_ID);
            fetch cpk1_locazioni_testate into dummy;
            found := cpk1_locazioni_testate%FOUND;
            close cpk1_locazioni_testate;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione LOCAZIONI_TESTATE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DOCUMENTI_CARICATI" non modificabile sul figlio: "LOCAZIONI_TESTATE"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di DOCUMENTI_CARICATI non e'' modificabile su LOCAZIONI_TESTATE.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "LOCAZIONI_TESTATE" non modificabile se esistono referenze su "LOCAZIONI_CONTRATTI"
      if (OLD_TESTATE_ID != NEW_TESTATE_ID) then
         open  cfk1_locazioni_testate(OLD_TESTATE_ID);
         fetch cfk1_locazioni_testate into dummy;
         found := cfk1_locazioni_testate%FOUND;
         close cfk1_locazioni_testate;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su LOCAZIONI_CONTRATTI. La registrazione di LOCAZIONI_TESTATE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_TESTATE_PU */
/

-- Trigger LOCAZIONI_TESTATE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table LOCAZIONI_TESTATE

create or replace trigger LOCAZIONI_TESTATE_TIU
before INSERT
    or UPDATE
on LOCAZIONI_TESTATE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         LOCAZIONI_TESTATE_PU(:OLD.TESTATE_ID,
                              :OLD.DOCUMENTO_ID,
                         :NEW.TESTATE_ID,
                         :NEW.DOCUMENTO_ID);
         null;
      end if;
      if INSERTING then
         LOCAZIONI_TESTATE_PI(:NEW.DOCUMENTO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "LOCAZIONI_TESTATE"
            cursor cpk_locazioni_testate(var_TESTATE_ID number) is
               select 1
                 from   LOCAZIONI_TESTATE
                where  TESTATE_ID = var_TESTATE_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "LOCAZIONI_TESTATE"
               if :new.TESTATE_ID is not null then
                  open  cpk_locazioni_testate(:new.TESTATE_ID);
                  fetch cpk_locazioni_testate into dummy;
                  found := cpk_locazioni_testate%FOUND;
                  close cpk_locazioni_testate;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TESTATE_ID||
                               '" gia'' presente in LOCAZIONI_TESTATE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: LOCAZIONI_TESTATE_TIU */
/

-- Procedure LOCAZIONI_TESTATE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table LOCAZIONI_TESTATE

create or replace procedure LOCAZIONI_TESTATE_PD
(old_testate_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "LOCAZIONI_CONTRATTI"
   cursor cfk1_locazioni_testate(var_testate_id number) is
      select 1
      from   LOCAZIONI_CONTRATTI
      where  TESTATE_ID = var_testate_id
       and   var_testate_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "LOCAZIONI_TESTATE" if children still exist in "LOCAZIONI_CONTRATTI"
      open  cfk1_locazioni_testate(OLD_TESTATE_ID);
      fetch cfk1_locazioni_testate into dummy;
      found := cfk1_locazioni_testate%FOUND;
      close cfk1_locazioni_testate;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su LOCAZIONI_CONTRATTI. La registrazione di LOCAZIONI_TESTATE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_TESTATE_PD */
/

-- Tigger LOCAZIONI_TESTATE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table LOCAZIONI_TESTATE

create or replace trigger LOCAZIONI_TESTATE_TD
before DELETE
on LOCAZIONI_TESTATE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: LOCAZIONI_CONTRATTI

      LOCAZIONI_TESTATE_PD(:OLD.TESTATE_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: LOCAZIONI_TESTATE_TD */
/

-- Procedure LOCAZIONI_TIPI_TRACCIATO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table LOCAZIONI_TIPI_TRACCIATO

create or replace procedure LOCAZIONI_TIPI_TRACCIATO_PI
(new_titolo_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TITOLI_DOCUMENTO"
   cursor cpk1_locazioni_tipi_tracciato(var_titolo_documento number) is
      select 1
      from   TITOLI_DOCUMENTO
      where  TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TITOLI_DOCUMENTO" deve esistere quando si inserisce su "LOCAZIONI_TIPI_TRACCIATO"
         if NEW_TITOLO_DOCUMENTO is not null then
            open  cpk1_locazioni_tipi_tracciato(NEW_TITOLO_DOCUMENTO);
            fetch cpk1_locazioni_tipi_tracciato into dummy;
            found := cpk1_locazioni_tipi_tracciato%FOUND;
            close cpk1_locazioni_tipi_tracciato;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Titoli Documento. La registrazione LOCAZIONI_TIPI_TRACCIATO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_TIPI_TRACCIATO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table LOCAZIONI_TIPI_TRACCIATO
/* End Trigger: LOCAZIONI_TIPI_TRACCIATO_TC */

-- Procedure LOCAZIONI_TIPI_TRACCIATO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table LOCAZIONI_TIPI_TRACCIATO

create or replace procedure LOCAZIONI_TIPI_TRACCIATO_PU
(old_tipo_tracciato IN number,
 old_titolo_documento IN number,
 new_tipo_tracciato IN number,
 new_titolo_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TITOLI_DOCUMENTO"
   cursor cpk1_locazioni_tipi_tracciato(var_titolo_documento number) is
      select 1
      from   TITOLI_DOCUMENTO
      where  TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TITOLI_DOCUMENTO" deve esistere quando si modifica "LOCAZIONI_TIPI_TRACCIATO"
         if  NEW_TITOLO_DOCUMENTO is not null and ( seq = 0 )
         and (   (NEW_TITOLO_DOCUMENTO != OLD_TITOLO_DOCUMENTO or OLD_TITOLO_DOCUMENTO is null) ) then
            open  cpk1_locazioni_tipi_tracciato(NEW_TITOLO_DOCUMENTO);
            fetch cpk1_locazioni_tipi_tracciato into dummy;
            found := cpk1_locazioni_tipi_tracciato%FOUND;
            close cpk1_locazioni_tipi_tracciato;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Titoli Documento. La registrazione LOCAZIONI_TIPI_TRACCIATO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: LOCAZIONI_TIPI_TRACCIATO_PU */
/

-- Trigger LOCAZIONI_TIPI_TRACCIATO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table LOCAZIONI_TIPI_TRACCIATO

create or replace trigger LOCAZIONI_TIPI_TRACCIATO_TIU
before INSERT
    or UPDATE
on LOCAZIONI_TIPI_TRACCIATO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         LOCAZIONI_TIPI_TRACCIATO_PU(:OLD.TIPO_TRACCIATO,
                                     :OLD.TITOLO_DOCUMENTO,
                         :NEW.TIPO_TRACCIATO,
                         :NEW.TITOLO_DOCUMENTO);
         null;
      end if;
      if INSERTING then
         LOCAZIONI_TIPI_TRACCIATO_PI(:NEW.TITOLO_DOCUMENTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "LOCAZIONI_TIPI_TRACCIATO"
            cursor cpk_locazioni_tipi_tracciato(var_TIPO_TRACCIATO number) is
               select 1
                 from   LOCAZIONI_TIPI_TRACCIATO
                where  TIPO_TRACCIATO = var_TIPO_TRACCIATO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "LOCAZIONI_TIPI_TRACCIATO"
               if :new.TIPO_TRACCIATO is not null then
                  open  cpk_locazioni_tipi_tracciato(:new.TIPO_TRACCIATO);
                  fetch cpk_locazioni_tipi_tracciato into dummy;
                  found := cpk_locazioni_tipi_tracciato%FOUND;
                  close cpk_locazioni_tipi_tracciato;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRACCIATO||
                               '" gia'' presente in LOCAZIONI_TIPI_TRACCIATO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: LOCAZIONI_TIPI_TRACCIATO_TIU */
/

-- Procedure MAGGIORI_DETRAZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table MAGGIORI_DETRAZIONI

create or replace procedure MAGGIORI_DETRAZIONI_PI
(new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_motivo_detrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_maggiori_detrazioni(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DETRAZIONI"
   cursor cpk2_maggiori_detrazioni(var_tipo_tributo varchar,
                                   var_anno number) is
      select 1
      from   DETRAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   var_tipo_tributo is not null
       and   var_anno is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MOTIVI_DETRAZIONE"
   cursor cpk3_maggiori_detrazioni(var_tipo_tributo varchar,
                                   var_motivo_detrazione number) is
      select 1
      from   MOTIVI_DETRAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "MAGGIORI_DETRAZIONI"
         if NEW_COD_FISCALE is not null then
            open  cpk1_maggiori_detrazioni(NEW_COD_FISCALE);
            fetch cpk1_maggiori_detrazioni into dummy;
            found := cpk1_maggiori_detrazioni%FOUND;
            close cpk1_maggiori_detrazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Maggiori Detrazioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DETRAZIONI" deve esistere quando si inserisce su "MAGGIORI_DETRAZIONI"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_ANNO is not null then
            open  cpk2_maggiori_detrazioni(NEW_TIPO_TRIBUTO,
                                           NEW_ANNO);
            fetch cpk2_maggiori_detrazioni into dummy;
            found := cpk2_maggiori_detrazioni%FOUND;
            close cpk2_maggiori_detrazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Detrazioni. La registrazione Maggiori Detrazioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_DETRAZIONE" deve esistere quando si inserisce su "MAGGIORI_DETRAZIONI"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_MOTIVO_DETRAZIONE is not null then
            open  cpk3_maggiori_detrazioni(NEW_TIPO_TRIBUTO,
                                           NEW_MOTIVO_DETRAZIONE);
            fetch cpk3_maggiori_detrazioni into dummy;
            found := cpk3_maggiori_detrazioni%FOUND;
            close cpk3_maggiori_detrazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Motivi Detrazione. La registrazione Maggiori Detrazioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MAGGIORI_DETRAZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table MAGGIORI_DETRAZIONI
/* End Trigger: MAGGIORI_DETRAZIONI_TC */

-- Procedure MAGGIORI_DETRAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MAGGIORI_DETRAZIONI

create or replace procedure MAGGIORI_DETRAZIONI_PU
(old_cod_fiscale IN varchar,
 old_tipo_tributo IN varchar,
 old_anno IN number,
 old_motivo_detrazione IN number,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_motivo_detrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_maggiori_detrazioni(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DETRAZIONI"
   cursor cpk2_maggiori_detrazioni(var_tipo_tributo varchar,
                                   var_anno number) is
      select 1
      from   DETRAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   var_tipo_tributo is not null
       and   var_anno is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MOTIVI_DETRAZIONE"
   cursor cpk3_maggiori_detrazioni(var_tipo_tributo varchar,
                                   var_motivo_detrazione number) is
      select 1
      from   MOTIVI_DETRAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "MAGGIORI_DETRAZIONI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_maggiori_detrazioni(NEW_COD_FISCALE);
            fetch cpk1_maggiori_detrazioni into dummy;
            found := cpk1_maggiori_detrazioni%FOUND;
            close cpk1_maggiori_detrazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Maggiori Detrazioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DETRAZIONI" deve esistere quando si modifica "MAGGIORI_DETRAZIONI"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_ANNO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_ANNO != OLD_ANNO or OLD_ANNO is null) ) then
            open  cpk2_maggiori_detrazioni(NEW_TIPO_TRIBUTO,
                                           NEW_ANNO);
            fetch cpk2_maggiori_detrazioni into dummy;
            found := cpk2_maggiori_detrazioni%FOUND;
            close cpk2_maggiori_detrazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Detrazioni. La registrazione Maggiori Detrazioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_DETRAZIONE" deve esistere quando si modifica "MAGGIORI_DETRAZIONI"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_MOTIVO_DETRAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_MOTIVO_DETRAZIONE != OLD_MOTIVO_DETRAZIONE or OLD_MOTIVO_DETRAZIONE is null) ) then
            open  cpk3_maggiori_detrazioni(NEW_TIPO_TRIBUTO,
                                           NEW_MOTIVO_DETRAZIONE);
            fetch cpk3_maggiori_detrazioni into dummy;
            found := cpk3_maggiori_detrazioni%FOUND;
            close cpk3_maggiori_detrazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Motivi Detrazione. La registrazione Maggiori Detrazioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "DETRAZIONI" non modificabile sul figlio: "MAGGIORI_DETRAZIONI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_ANNO != NEW_ANNO) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Detrazioni non e'' modificabile su Maggiori Detrazioni.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MAGGIORI_DETRAZIONI_PU */
/

-- Trigger MAGGIORI_DETRAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MAGGIORI_DETRAZIONI

create or replace trigger MAGGIORI_DETRAZIONI_TIU
before INSERT
    or UPDATE
on MAGGIORI_DETRAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         MAGGIORI_DETRAZIONI_PU(:OLD.COD_FISCALE,
                                :OLD.TIPO_TRIBUTO,
                                :OLD.ANNO,
                                :OLD.MOTIVO_DETRAZIONE,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.MOTIVO_DETRAZIONE);
         null;
      end if;
      if INSERTING then
         MAGGIORI_DETRAZIONI_PI(:NEW.COD_FISCALE,
                                :NEW.TIPO_TRIBUTO,
                                :NEW.ANNO,
                                :NEW.MOTIVO_DETRAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MAGGIORI_DETRAZIONI"
            cursor cpk_maggiori_detrazioni(var_COD_FISCALE varchar,
                                           var_TIPO_TRIBUTO varchar,
                                           var_ANNO number) is
               select 1
                 from   MAGGIORI_DETRAZIONI
                where  COD_FISCALE = var_COD_FISCALE and
                       TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MAGGIORI_DETRAZIONI"
               if :new.COD_FISCALE is not null and
                  :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null then
                  open  cpk_maggiori_detrazioni(:new.COD_FISCALE,
                                                :new.TIPO_TRIBUTO,
                                                :new.ANNO);
                  fetch cpk_maggiori_detrazioni into dummy;
                  found := cpk_maggiori_detrazioni%FOUND;
                  close cpk_maggiori_detrazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||
                               '" gia'' presente in Maggiori Detrazioni. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MAGGIORI_DETRAZIONI_TIU */
/

-- Procedure MODELLI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table MODELLI

create or replace procedure MODELLI_PI
(new_tipo_tributo IN varchar,
 new_descrizione_ord IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_modelli(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_MODELLO"
   cursor cpk2_modelli(var_descrizione_ord varchar) is
      select 1
      from   TIPI_MODELLO
      where  TIPO_MODELLO = var_descrizione_ord
       and   var_descrizione_ord is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "MODELLI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_modelli(NEW_TIPO_TRIBUTO);
            fetch cpk1_modelli into dummy;
            found := cpk1_modelli%FOUND;
            close cpk1_modelli;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Modelli non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_MODELLO" deve esistere quando si inserisce su "MODELLI"
         if NEW_DESCRIZIONE_ORD is not null then
            open  cpk2_modelli(NEW_DESCRIZIONE_ORD);
            fetch cpk2_modelli into dummy;
            found := cpk2_modelli%FOUND;
            close cpk2_modelli;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Modello. La registrazione Modelli non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MODELLI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table MODELLI
/* End Trigger: MODELLI_TC */

-- Procedure MODELLI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MODELLI

create or replace procedure MODELLI_PU
(old_modello IN number,
 old_tipo_tributo IN varchar,
 old_descrizione_ord IN varchar,
 new_modello IN number,
 new_tipo_tributo IN varchar,
 new_descrizione_ord IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_modelli(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_MODELLO"
   cursor cpk2_modelli(var_descrizione_ord varchar) is
      select 1
      from   TIPI_MODELLO
      where  TIPO_MODELLO = var_descrizione_ord
       and   var_descrizione_ord is not null;

   --  Declaration of UpdateParentRestrict constraint for "MODELLI_VERSIONE"
   cursor cfk1_modelli(var_modello number) is
      select 1
      from   MODELLI_VERSIONE
      where  MODELLO = var_modello
       and   var_modello is not null;

   --  Declaration of UpdateParentRestrict constraint for "ATTIVITA_ELABORAZIONE"
   cursor cfk2_modelli(var_modello number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  MODELLO = var_modello
       and   var_modello is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "MODELLI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_modelli(NEW_TIPO_TRIBUTO);
            fetch cpk1_modelli into dummy;
            found := cpk1_modelli%FOUND;
            close cpk1_modelli;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Modelli non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_MODELLO" deve esistere quando si modifica "MODELLI"
         if  NEW_DESCRIZIONE_ORD is not null and ( seq = 0 )
         and (   (NEW_DESCRIZIONE_ORD != OLD_DESCRIZIONE_ORD or OLD_DESCRIZIONE_ORD is null) ) then
            open  cpk2_modelli(NEW_DESCRIZIONE_ORD);
            fetch cpk2_modelli into dummy;
            found := cpk2_modelli%FOUND;
            close cpk2_modelli;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Modello. La registrazione Modelli non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "TIPI_MODELLO" non modificabile sul figlio: "MODELLI"
      if (OLD_DESCRIZIONE_ORD != NEW_DESCRIZIONE_ORD) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Tipi Modello non e'' modificabile su Modelli.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "MODELLI" non modificabile se esistono referenze su "MODELLI_VERSIONE"
      if (OLD_MODELLO != NEW_MODELLO) then
         open  cfk1_modelli(OLD_MODELLO);
         fetch cfk1_modelli into dummy;
         found := cfk1_modelli%FOUND;
         close cfk1_modelli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su MODELLI_VERSIONE. La registrazione di Modelli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "MODELLI" non modificabile se esistono referenze su "ATTIVITA_ELABORAZIONE"
      if (OLD_MODELLO != NEW_MODELLO) then
         open  cfk2_modelli(OLD_MODELLO);
         fetch cfk2_modelli into dummy;
         found := cfk2_modelli%FOUND;
         close cfk2_modelli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Attivita Elaborazione. La registrazione di Modelli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MODELLI_PU */
/

-- Trigger MODELLI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MODELLI

create or replace trigger MODELLI_TIU
before INSERT
    or UPDATE
on MODELLI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.modello is null then
       MODELLI_NR (:new.modello);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         MODELLI_PU(:OLD.MODELLO,
                    :OLD.TIPO_TRIBUTO,
                    :OLD.DESCRIZIONE_ORD,
                         :NEW.MODELLO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.DESCRIZIONE_ORD);
         null;
      end if;
      if INSERTING then
         MODELLI_PI(:NEW.TIPO_TRIBUTO,
                    :NEW.DESCRIZIONE_ORD);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MODELLI"
            cursor cpk_modelli(var_MODELLO number) is
               select 1
                 from   MODELLI
                where  MODELLO = var_MODELLO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MODELLI"
               if :new.MODELLO is not null then
                  open  cpk_modelli(:new.MODELLO);
                  fetch cpk_modelli into dummy;
                  found := cpk_modelli%FOUND;
                  close cpk_modelli;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.MODELLO||
                               '" gia'' presente in Modelli. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "MODELLI" for all children in "MODELLI_DETTAGLIO"
         if (:OLD.MODELLO != :NEW.MODELLO) then
            update MODELLI_DETTAGLIO
             set   MODELLO = :NEW.MODELLO
            where  MODELLO = :OLD.MODELLO;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MODELLI_TIU */
/

-- Procedure MODELLI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table MODELLI

create or replace procedure MODELLI_PD
(old_modello IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "MODELLI_DETTAGLIO"
   cursor cfk1_modelli(var_modello number) is
      select 1
      from   MODELLI_DETTAGLIO
      where  MODELLO = var_modello
       and   var_modello is not null;

   --  Declaration of DeleteParentRestrict constraint for "MODELLI_VERSIONE"
   cursor cfk2_modelli(var_modello number) is
      select 1
      from   MODELLI_VERSIONE
      where  MODELLO = var_modello
       and   var_modello is not null;

   --  Declaration of DeleteParentRestrict constraint for "ATTIVITA_ELABORAZIONE"
   cursor cfk3_modelli(var_modello number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  MODELLO = var_modello
       and   var_modello is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "MODELLI" if children still exist in "MODELLI_DETTAGLIO"
      open  cfk1_modelli(OLD_MODELLO);
      fetch cfk1_modelli into dummy;
      found := cfk1_modelli%FOUND;
      close cfk1_modelli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su MODELLI_DETTAGLIO. La registrazione di Modelli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "MODELLI" if children still exist in "MODELLI_VERSIONE"
      open  cfk2_modelli(OLD_MODELLO);
      fetch cfk2_modelli into dummy;
      found := cfk2_modelli%FOUND;
      close cfk2_modelli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su MODELLI_VERSIONE. La registrazione di Modelli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "MODELLI" if children still exist in "ATTIVITA_ELABORAZIONE"
      open  cfk3_modelli(OLD_MODELLO);
      fetch cfk3_modelli into dummy;
      found := cfk3_modelli%FOUND;
      close cfk3_modelli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Attivita Elaborazione. La registrazione di Modelli non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MODELLI_PD */
/

-- Tigger MODELLI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table MODELLI

create or replace trigger MODELLI_TD
before DELETE
on MODELLI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: MODELLI_DETTAGLIO

      -- Child Restrict Table: MODELLI_VERSIONE

      -- Child Restrict Table: ATTIVITA_ELABORAZIONE

      MODELLI_PD(:OLD.MODELLO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MODELLI_TD */
/

-- Procedure MODELLI_DETTAGLIO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table MODELLI_DETTAGLIO

create or replace procedure MODELLI_DETTAGLIO_PI
(new_modello IN number,
 new_parametro_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MODELLI"
   cursor cpk1_modelli_dettaglio(var_modello number) is
      select 1
      from   MODELLI
      where  MODELLO = var_modello
       and   var_modello is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_MODELLO_PARAMETRI"
   cursor cpk2_modelli_dettaglio(var_parametro_id number) is
      select 1
      from   TIPI_MODELLO_PARAMETRI
      where  PARAMETRO_ID = var_parametro_id
       and   var_parametro_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "MODELLI" deve esistere quando si inserisce su "MODELLI_DETTAGLIO"
         if NEW_MODELLO is not null then
            open  cpk1_modelli_dettaglio(NEW_MODELLO);
            fetch cpk1_modelli_dettaglio into dummy;
            found := cpk1_modelli_dettaglio%FOUND;
            close cpk1_modelli_dettaglio;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Modelli. La registrazione MODELLI_DETTAGLIO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_MODELLO_PARAMETRI" deve esistere quando si inserisce su "MODELLI_DETTAGLIO"
         if NEW_PARAMETRO_ID is not null then
            open  cpk2_modelli_dettaglio(NEW_PARAMETRO_ID);
            fetch cpk2_modelli_dettaglio into dummy;
            found := cpk2_modelli_dettaglio%FOUND;
            close cpk2_modelli_dettaglio;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Modello Parametri. La registrazione MODELLI_DETTAGLIO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MODELLI_DETTAGLIO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table MODELLI_DETTAGLIO
/* End Trigger: MODELLI_DETTAGLIO_TC */

-- Procedure MODELLI_DETTAGLIO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MODELLI_DETTAGLIO

create or replace procedure MODELLI_DETTAGLIO_PU
(old_modello IN number,
 old_parametro_id IN number,
 new_modello IN number,
 new_parametro_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MODELLI"
   cursor cpk1_modelli_dettaglio(var_modello number) is
      select 1
      from   MODELLI
      where  MODELLO = var_modello
       and   var_modello is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_MODELLO_PARAMETRI"
   cursor cpk2_modelli_dettaglio(var_parametro_id number) is
      select 1
      from   TIPI_MODELLO_PARAMETRI
      where  PARAMETRO_ID = var_parametro_id
       and   var_parametro_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "MODELLI" deve esistere quando si modifica "MODELLI_DETTAGLIO"
         if  NEW_MODELLO is not null and ( seq = 0 )
         and (   (NEW_MODELLO != OLD_MODELLO or OLD_MODELLO is null) ) then
            open  cpk1_modelli_dettaglio(NEW_MODELLO);
            fetch cpk1_modelli_dettaglio into dummy;
            found := cpk1_modelli_dettaglio%FOUND;
            close cpk1_modelli_dettaglio;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Modelli. La registrazione MODELLI_DETTAGLIO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_MODELLO_PARAMETRI" deve esistere quando si modifica "MODELLI_DETTAGLIO"
         if  NEW_PARAMETRO_ID is not null and ( seq = 0 )
         and (   (NEW_PARAMETRO_ID != OLD_PARAMETRO_ID or OLD_PARAMETRO_ID is null) ) then
            open  cpk2_modelli_dettaglio(NEW_PARAMETRO_ID);
            fetch cpk2_modelli_dettaglio into dummy;
            found := cpk2_modelli_dettaglio%FOUND;
            close cpk2_modelli_dettaglio;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Modello Parametri. La registrazione MODELLI_DETTAGLIO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MODELLI_DETTAGLIO_PU */
/

-- Trigger MODELLI_DETTAGLIO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MODELLI_DETTAGLIO

create or replace trigger MODELLI_DETTAGLIO_TIU
before INSERT
    or UPDATE
on MODELLI_DETTAGLIO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         MODELLI_DETTAGLIO_PU(:OLD.MODELLO,
                              :OLD.PARAMETRO_ID,
                         :NEW.MODELLO,
                         :NEW.PARAMETRO_ID);
         null;
      end if;
      if INSERTING then
         MODELLI_DETTAGLIO_PI(:NEW.MODELLO,
                              :NEW.PARAMETRO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MODELLI_DETTAGLIO"
            cursor cpk_modelli_dettaglio(var_MODELLO number,
                                         var_PARAMETRO_ID number) is
               select 1
                 from   MODELLI_DETTAGLIO
                where  MODELLO = var_MODELLO and
                       PARAMETRO_ID = var_PARAMETRO_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MODELLI_DETTAGLIO"
               if :new.MODELLO is not null and
                  :new.PARAMETRO_ID is not null then
                  open  cpk_modelli_dettaglio(:new.MODELLO,
                                              :new.PARAMETRO_ID);
                  fetch cpk_modelli_dettaglio into dummy;
                  found := cpk_modelli_dettaglio%FOUND;
                  close cpk_modelli_dettaglio;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.MODELLO||' '||
                               :new.PARAMETRO_ID||
                               '" gia'' presente in MODELLI_DETTAGLIO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MODELLI_DETTAGLIO_TIU */
/

-- Procedure MODELLI_VERSIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table MODELLI_VERSIONE

create or replace procedure MODELLI_VERSIONE_PI
(new_modello IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MODELLI"
   cursor cpk1_modelli_versione(var_modello number) is
      select 1
      from   MODELLI
      where  MODELLO = var_modello
       and   var_modello is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "MODELLI" deve esistere quando si inserisce su "MODELLI_VERSIONE"
         if NEW_MODELLO is not null then
            open  cpk1_modelli_versione(NEW_MODELLO);
            fetch cpk1_modelli_versione into dummy;
            found := cpk1_modelli_versione%FOUND;
            close cpk1_modelli_versione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Modelli. La registrazione MODELLI_VERSIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MODELLI_VERSIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table MODELLI_VERSIONE
/* End Trigger: MODELLI_VERSIONE_TC */

-- Procedure MODELLI_VERSIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MODELLI_VERSIONE

create or replace procedure MODELLI_VERSIONE_PU
(old_versione_id IN number,
 old_modello IN number,
 new_versione_id IN number,
 new_modello IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MODELLI"
   cursor cpk1_modelli_versione(var_modello number) is
      select 1
      from   MODELLI
      where  MODELLO = var_modello
       and   var_modello is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "MODELLI" deve esistere quando si modifica "MODELLI_VERSIONE"
         if  NEW_MODELLO is not null and ( seq = 0 )
         and (   (NEW_MODELLO != OLD_MODELLO or OLD_MODELLO is null) ) then
            open  cpk1_modelli_versione(NEW_MODELLO);
            fetch cpk1_modelli_versione into dummy;
            found := cpk1_modelli_versione%FOUND;
            close cpk1_modelli_versione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Modelli. La registrazione MODELLI_VERSIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MODELLI_VERSIONE_PU */
/

-- Trigger MODELLI_VERSIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MODELLI_VERSIONE

create or replace trigger MODELLI_VERSIONE_TIU
before INSERT
    or UPDATE
on MODELLI_VERSIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.versione_id is null then
      MODELLI_VERSIONE_NR(:new.versione_id);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         MODELLI_VERSIONE_PU(:OLD.VERSIONE_ID,
                             :OLD.MODELLO,
                         :NEW.VERSIONE_ID,
                         :NEW.MODELLO);
         null;
      end if;
      if INSERTING then
         MODELLI_VERSIONE_PI(:NEW.MODELLO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MODELLI_VERSIONE"
            cursor cpk_modelli_versione(var_VERSIONE_ID number) is
               select 1
                 from   MODELLI_VERSIONE
                where  VERSIONE_ID = var_VERSIONE_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MODELLI_VERSIONE"
               if :new.VERSIONE_ID is not null then
                  open  cpk_modelli_versione(:new.VERSIONE_ID);
                  fetch cpk_modelli_versione into dummy;
                  found := cpk_modelli_versione%FOUND;
                  close cpk_modelli_versione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.VERSIONE_ID||
                               '" gia'' presente in MODELLI_VERSIONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MODELLI_VERSIONE_TIU */
/

-- Procedure MOLTIPLICATORI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table MOLTIPLICATORI

create or replace procedure MOLTIPLICATORI_PI
(new_categoria_catasto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE_CATASTO"
   cursor cpk1_moltiplicatori(var_categoria_catasto varchar) is
      select 1
      from   CATEGORIE_CATASTO
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CATEGORIE_CATASTO" deve esistere quando si inserisce su "MOLTIPLICATORI"
         if NEW_CATEGORIA_CATASTO is not null then
            open  cpk1_moltiplicatori(NEW_CATEGORIA_CATASTO);
            fetch cpk1_moltiplicatori into dummy;
            found := cpk1_moltiplicatori%FOUND;
            close cpk1_moltiplicatori;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie Catasto. La registrazione Moltiplicatori non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOLTIPLICATORI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table MOLTIPLICATORI
/* End Trigger: MOLTIPLICATORI_TC */

-- Procedure MOLTIPLICATORI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MOLTIPLICATORI

create or replace procedure MOLTIPLICATORI_PU
(old_anno IN number,
 old_categoria_catasto IN varchar,
 new_anno IN number,
 new_categoria_catasto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE_CATASTO"
   cursor cpk1_moltiplicatori(var_categoria_catasto varchar) is
      select 1
      from   CATEGORIE_CATASTO
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Declaration of UpdateParentRestrict constraint for "RELAZIONI_OGGETTI_CALCOLO"
   cursor cfk1_moltiplicatori(var_anno number,
                              var_categoria_catasto varchar) is
      select 1
      from   RELAZIONI_OGGETTI_CALCOLO
      where  ANNO = var_anno
       and   CATEGORIA_CATASTO = var_categoria_catasto
       and   var_anno is not null
       and   var_categoria_catasto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CATEGORIE_CATASTO" deve esistere quando si modifica "MOLTIPLICATORI"
         if  NEW_CATEGORIA_CATASTO is not null and ( seq = 0 )
         and (   (NEW_CATEGORIA_CATASTO != OLD_CATEGORIA_CATASTO or OLD_CATEGORIA_CATASTO is null) ) then
            open  cpk1_moltiplicatori(NEW_CATEGORIA_CATASTO);
            fetch cpk1_moltiplicatori into dummy;
            found := cpk1_moltiplicatori%FOUND;
            close cpk1_moltiplicatori;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie Catasto. La registrazione Moltiplicatori non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "MOLTIPLICATORI" non modificabile se esistono referenze su "RELAZIONI_OGGETTI_CALCOLO"
      if (OLD_ANNO != NEW_ANNO) or
         (OLD_CATEGORIA_CATASTO != NEW_CATEGORIA_CATASTO) then
         open  cfk1_moltiplicatori(OLD_ANNO,
                                   OLD_CATEGORIA_CATASTO);
         fetch cfk1_moltiplicatori into dummy;
         found := cfk1_moltiplicatori%FOUND;
         close cfk1_moltiplicatori;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su RELAZIONI_OGGETTI_CALCOLO. La registrazione di Moltiplicatori non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOLTIPLICATORI_PU */
/

-- Trigger MOLTIPLICATORI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MOLTIPLICATORI

create or replace trigger MOLTIPLICATORI_TIU
before INSERT
    or UPDATE
on MOLTIPLICATORI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         MOLTIPLICATORI_PU(:OLD.ANNO,
                           :OLD.CATEGORIA_CATASTO,
                         :NEW.ANNO,
                         :NEW.CATEGORIA_CATASTO);
         null;
      end if;
      if INSERTING then
         MOLTIPLICATORI_PI(:NEW.CATEGORIA_CATASTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MOLTIPLICATORI"
            cursor cpk_moltiplicatori(var_ANNO number,
                                      var_CATEGORIA_CATASTO varchar) is
               select 1
                 from   MOLTIPLICATORI
                where  ANNO = var_ANNO and
                       CATEGORIA_CATASTO = var_CATEGORIA_CATASTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MOLTIPLICATORI"
               if :new.ANNO is not null and
                  :new.CATEGORIA_CATASTO is not null then
                  open  cpk_moltiplicatori(:new.ANNO,
                                           :new.CATEGORIA_CATASTO);
                  fetch cpk_moltiplicatori into dummy;
                  found := cpk_moltiplicatori%FOUND;
                  close cpk_moltiplicatori;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANNO||' '||
                               :new.CATEGORIA_CATASTO||
                               '" gia'' presente in Moltiplicatori. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOLTIPLICATORI_TIU */
/

-- Procedure MOLTIPLICATORI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table MOLTIPLICATORI

create or replace procedure MOLTIPLICATORI_PD
(old_anno IN number,
 old_categoria_catasto IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "RELAZIONI_OGGETTI_CALCOLO"
   cursor cfk1_moltiplicatori(var_anno number,
                              var_categoria_catasto varchar) is
      select 1
      from   RELAZIONI_OGGETTI_CALCOLO
      where  ANNO = var_anno
       and   CATEGORIA_CATASTO = var_categoria_catasto
       and   var_anno is not null
       and   var_categoria_catasto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "MOLTIPLICATORI" if children still exist in "RELAZIONI_OGGETTI_CALCOLO"
      open  cfk1_moltiplicatori(OLD_ANNO,
                                OLD_CATEGORIA_CATASTO);
      fetch cfk1_moltiplicatori into dummy;
      found := cfk1_moltiplicatori%FOUND;
      close cfk1_moltiplicatori;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su RELAZIONI_OGGETTI_CALCOLO. La registrazione di Moltiplicatori non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOLTIPLICATORI_PD */
/

-- Tigger MOLTIPLICATORI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table MOLTIPLICATORI

create or replace trigger MOLTIPLICATORI_TD
before DELETE
on MOLTIPLICATORI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: RELAZIONI_OGGETTI_CALCOLO

      MOLTIPLICATORI_PD(:OLD.ANNO,
                        :OLD.CATEGORIA_CATASTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOLTIPLICATORI_TD */
/

-- Procedure MOTIVI_COMPENSAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MOTIVI_COMPENSAZIONE

create or replace procedure MOTIVI_COMPENSAZIONE_PU
(old_motivo_compensazione IN number,
 new_motivo_compensazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "COMPENSAZIONI_RUOLO"
   cursor cfk1_motivi_compensazione(var_motivo_compensazione number) is
      select 1
      from   COMPENSAZIONI_RUOLO
      where  MOTIVO_COMPENSAZIONE = var_motivo_compensazione
       and   var_motivo_compensazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "COMPENSAZIONI"
   cursor cfk2_motivi_compensazione(var_motivo_compensazione number) is
      select 1
      from   COMPENSAZIONI
      where  MOTIVO_COMPENSAZIONE = var_motivo_compensazione
       and   var_motivo_compensazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "MOTIVI_COMPENSAZIONE" non modificabile se esistono referenze su "COMPENSAZIONI_RUOLO"
      if (OLD_MOTIVO_COMPENSAZIONE != NEW_MOTIVO_COMPENSAZIONE) then
         open  cfk1_motivi_compensazione(OLD_MOTIVO_COMPENSAZIONE);
         fetch cfk1_motivi_compensazione into dummy;
         found := cfk1_motivi_compensazione%FOUND;
         close cfk1_motivi_compensazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Compensazioni Ruolo. La registrazione di Motivi Compensazione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "MOTIVI_COMPENSAZIONE" non modificabile se esistono referenze su "COMPENSAZIONI"
      if (OLD_MOTIVO_COMPENSAZIONE != NEW_MOTIVO_COMPENSAZIONE) then
         open  cfk2_motivi_compensazione(OLD_MOTIVO_COMPENSAZIONE);
         fetch cfk2_motivi_compensazione into dummy;
         found := cfk2_motivi_compensazione%FOUND;
         close cfk2_motivi_compensazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Compensazioni. La registrazione di Motivi Compensazione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_COMPENSAZIONE_PU */
/

-- Trigger MOTIVI_COMPENSAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MOTIVI_COMPENSAZIONE

create or replace trigger MOTIVI_COMPENSAZIONE_TIU
before INSERT
    or UPDATE
on MOTIVI_COMPENSAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         MOTIVI_COMPENSAZIONE_PU(:OLD.MOTIVO_COMPENSAZIONE,
                         :NEW.MOTIVO_COMPENSAZIONE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MOTIVI_COMPENSAZIONE"
            cursor cpk_motivi_compensazione(var_MOTIVO_COMPENSAZIONE number) is
               select 1
                 from   MOTIVI_COMPENSAZIONE
                where  MOTIVO_COMPENSAZIONE = var_MOTIVO_COMPENSAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MOTIVI_COMPENSAZIONE"
               if :new.MOTIVO_COMPENSAZIONE is not null then
                  open  cpk_motivi_compensazione(:new.MOTIVO_COMPENSAZIONE);
                  fetch cpk_motivi_compensazione into dummy;
                  found := cpk_motivi_compensazione%FOUND;
                  close cpk_motivi_compensazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.MOTIVO_COMPENSAZIONE||
                               '" gia'' presente in Motivi Compensazione. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOTIVI_COMPENSAZIONE_TIU */
/

-- Procedure MOTIVI_COMPENSAZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table MOTIVI_COMPENSAZIONE

create or replace procedure MOTIVI_COMPENSAZIONE_PD
(old_motivo_compensazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "COMPENSAZIONI_RUOLO"
   cursor cfk1_motivi_compensazione(var_motivo_compensazione number) is
      select 1
      from   COMPENSAZIONI_RUOLO
      where  MOTIVO_COMPENSAZIONE = var_motivo_compensazione
       and   var_motivo_compensazione is not null;

   --  Declaration of DeleteParentRestrict constraint for "COMPENSAZIONI"
   cursor cfk2_motivi_compensazione(var_motivo_compensazione number) is
      select 1
      from   COMPENSAZIONI
      where  MOTIVO_COMPENSAZIONE = var_motivo_compensazione
       and   var_motivo_compensazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "MOTIVI_COMPENSAZIONE" if children still exist in "COMPENSAZIONI_RUOLO"
      open  cfk1_motivi_compensazione(OLD_MOTIVO_COMPENSAZIONE);
      fetch cfk1_motivi_compensazione into dummy;
      found := cfk1_motivi_compensazione%FOUND;
      close cfk1_motivi_compensazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Compensazioni Ruolo. La registrazione di Motivi Compensazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "MOTIVI_COMPENSAZIONE" if children still exist in "COMPENSAZIONI"
      open  cfk2_motivi_compensazione(OLD_MOTIVO_COMPENSAZIONE);
      fetch cfk2_motivi_compensazione into dummy;
      found := cfk2_motivi_compensazione%FOUND;
      close cfk2_motivi_compensazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Compensazioni. La registrazione di Motivi Compensazione non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_COMPENSAZIONE_PD */
/

-- Tigger MOTIVI_COMPENSAZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table MOTIVI_COMPENSAZIONE

create or replace trigger MOTIVI_COMPENSAZIONE_TD
before DELETE
on MOTIVI_COMPENSAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: COMPENSAZIONI_RUOLO

      -- Child Restrict Table: COMPENSAZIONI

      MOTIVI_COMPENSAZIONE_PD(:OLD.MOTIVO_COMPENSAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOTIVI_COMPENSAZIONE_TD */
/

-- Procedure MOTIVI_DETRAZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table MOTIVI_DETRAZIONE

create or replace procedure MOTIVI_DETRAZIONE_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_motivi_detrazione(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "MOTIVI_DETRAZIONE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_motivi_detrazione(NEW_TIPO_TRIBUTO);
            fetch cpk1_motivi_detrazione into dummy;
            found := cpk1_motivi_detrazione%FOUND;
            close cpk1_motivi_detrazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Motivi Detrazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_DETRAZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table MOTIVI_DETRAZIONE
/* End Trigger: MOTIVI_DETRAZIONE_TC */

-- Procedure MOTIVI_DETRAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MOTIVI_DETRAZIONE

create or replace procedure MOTIVI_DETRAZIONE_PU
(old_tipo_tributo IN varchar,
 old_motivo_detrazione IN number,
 new_tipo_tributo IN varchar,
 new_motivo_detrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_motivi_detrazione(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "MAGGIORI_DETRAZIONI"
   cursor cfk1_motivi_detrazione(var_tipo_tributo varchar,
                                 var_motivo_detrazione number) is
      select 1
      from   MAGGIORI_DETRAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "DETRAZIONI_OGCO"
   cursor cfk2_motivi_detrazione(var_tipo_tributo varchar,
                                 var_motivo_detrazione number) is
      select 1
      from   DETRAZIONI_OGCO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "DETRAZIONI_MOBILI"
   cursor cfk3_motivi_detrazione(var_tipo_tributo varchar,
                                 var_motivo_detrazione number) is
      select 1
      from   DETRAZIONI_MOBILI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "MOTIVI_DETRAZIONE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_motivi_detrazione(NEW_TIPO_TRIBUTO);
            fetch cpk1_motivi_detrazione into dummy;
            found := cpk1_motivi_detrazione%FOUND;
            close cpk1_motivi_detrazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Motivi Detrazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "MOTIVI_DETRAZIONE" non modificabile se esistono referenze su "MAGGIORI_DETRAZIONI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_MOTIVO_DETRAZIONE != NEW_MOTIVO_DETRAZIONE) then
         open  cfk1_motivi_detrazione(OLD_TIPO_TRIBUTO,
                                      OLD_MOTIVO_DETRAZIONE);
         fetch cfk1_motivi_detrazione into dummy;
         found := cfk1_motivi_detrazione%FOUND;
         close cfk1_motivi_detrazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Maggiori Detrazioni. La registrazione di Motivi Detrazione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "MOTIVI_DETRAZIONE" non modificabile se esistono referenze su "DETRAZIONI_OGCO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_MOTIVO_DETRAZIONE != NEW_MOTIVO_DETRAZIONE) then
         open  cfk2_motivi_detrazione(OLD_TIPO_TRIBUTO,
                                      OLD_MOTIVO_DETRAZIONE);
         fetch cfk2_motivi_detrazione into dummy;
         found := cfk2_motivi_detrazione%FOUND;
         close cfk2_motivi_detrazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Detrazioni Oggetti Contribuente. La registrazione di Motivi Detrazione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "MOTIVI_DETRAZIONE" non modificabile se esistono referenze su "DETRAZIONI_MOBILI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_MOTIVO_DETRAZIONE != NEW_MOTIVO_DETRAZIONE) then
         open  cfk3_motivi_detrazione(OLD_TIPO_TRIBUTO,
                                      OLD_MOTIVO_DETRAZIONE);
         fetch cfk3_motivi_detrazione into dummy;
         found := cfk3_motivi_detrazione%FOUND;
         close cfk3_motivi_detrazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Detrazioni Mobili. La registrazione di Motivi Detrazione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_DETRAZIONE_PU */
/

-- Trigger MOTIVI_DETRAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MOTIVI_DETRAZIONE

create or replace trigger MOTIVI_DETRAZIONE_TIU
before INSERT
    or UPDATE
on MOTIVI_DETRAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         MOTIVI_DETRAZIONE_PU(:OLD.TIPO_TRIBUTO,
                              :OLD.MOTIVO_DETRAZIONE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.MOTIVO_DETRAZIONE);
         null;
      end if;
      if INSERTING then
         MOTIVI_DETRAZIONE_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MOTIVI_DETRAZIONE"
            cursor cpk_motivi_detrazione(var_TIPO_TRIBUTO varchar,
                                         var_MOTIVO_DETRAZIONE number) is
               select 1
                 from   MOTIVI_DETRAZIONE
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       MOTIVO_DETRAZIONE = var_MOTIVO_DETRAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MOTIVI_DETRAZIONE"
               if :new.TIPO_TRIBUTO is not null and
                  :new.MOTIVO_DETRAZIONE is not null then
                  open  cpk_motivi_detrazione(:new.TIPO_TRIBUTO,
                                              :new.MOTIVO_DETRAZIONE);
                  fetch cpk_motivi_detrazione into dummy;
                  found := cpk_motivi_detrazione%FOUND;
                  close cpk_motivi_detrazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.MOTIVO_DETRAZIONE||
                               '" gia'' presente in Motivi Detrazione. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOTIVI_DETRAZIONE_TIU */
/

-- Procedure MOTIVI_DETRAZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table MOTIVI_DETRAZIONE

create or replace procedure MOTIVI_DETRAZIONE_PD
(old_tipo_tributo IN varchar,
 old_motivo_detrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "MAGGIORI_DETRAZIONI"
   cursor cfk1_motivi_detrazione(var_tipo_tributo varchar,
                                 var_motivo_detrazione number) is
      select 1
      from   MAGGIORI_DETRAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETRAZIONI_OGCO"
   cursor cfk2_motivi_detrazione(var_tipo_tributo varchar,
                                 var_motivo_detrazione number) is
      select 1
      from   DETRAZIONI_OGCO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETRAZIONI_MOBILI"
   cursor cfk3_motivi_detrazione(var_tipo_tributo varchar,
                                 var_motivo_detrazione number) is
      select 1
      from   DETRAZIONI_MOBILI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   MOTIVO_DETRAZIONE = var_motivo_detrazione
       and   var_tipo_tributo is not null
       and   var_motivo_detrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "MOTIVI_DETRAZIONE" if children still exist in "MAGGIORI_DETRAZIONI"
      open  cfk1_motivi_detrazione(OLD_TIPO_TRIBUTO,
                                   OLD_MOTIVO_DETRAZIONE);
      fetch cfk1_motivi_detrazione into dummy;
      found := cfk1_motivi_detrazione%FOUND;
      close cfk1_motivi_detrazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Maggiori Detrazioni. La registrazione di Motivi Detrazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "MOTIVI_DETRAZIONE" if children still exist in "DETRAZIONI_OGCO"
      open  cfk2_motivi_detrazione(OLD_TIPO_TRIBUTO,
                                   OLD_MOTIVO_DETRAZIONE);
      fetch cfk2_motivi_detrazione into dummy;
      found := cfk2_motivi_detrazione%FOUND;
      close cfk2_motivi_detrazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Detrazioni Oggetti Contribuente. La registrazione di Motivi Detrazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "MOTIVI_DETRAZIONE" if children still exist in "DETRAZIONI_MOBILI"
      open  cfk3_motivi_detrazione(OLD_TIPO_TRIBUTO,
                                   OLD_MOTIVO_DETRAZIONE);
      fetch cfk3_motivi_detrazione into dummy;
      found := cfk3_motivi_detrazione%FOUND;
      close cfk3_motivi_detrazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Detrazioni Mobili. La registrazione di Motivi Detrazione non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_DETRAZIONE_PD */
/

-- Tigger MOTIVI_DETRAZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table MOTIVI_DETRAZIONE

create or replace trigger MOTIVI_DETRAZIONE_TD
before DELETE
on MOTIVI_DETRAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: MAGGIORI_DETRAZIONI

      -- Child Restrict Table: DETRAZIONI_OGCO

      -- Child Restrict Table: DETRAZIONI_MOBILI

      MOTIVI_DETRAZIONE_PD(:OLD.TIPO_TRIBUTO,
                           :OLD.MOTIVO_DETRAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOTIVI_DETRAZIONE_TD */
/

-- Procedure MOTIVI_PRATICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table MOTIVI_PRATICA

create or replace procedure MOTIVI_PRATICA_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_motivi_pratica(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "MOTIVI_PRATICA"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_motivi_pratica(NEW_TIPO_TRIBUTO);
            fetch cpk1_motivi_pratica into dummy;
            found := cpk1_motivi_pratica%FOUND;
            close cpk1_motivi_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Motivi Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_PRATICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table MOTIVI_PRATICA
/* End Trigger: MOTIVI_PRATICA_TC */

-- Procedure MOTIVI_PRATICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MOTIVI_PRATICA

create or replace procedure MOTIVI_PRATICA_PU
(old_tipo_tributo IN varchar,
 old_sequenza IN number,
 new_tipo_tributo IN varchar,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_motivi_pratica(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "MOTIVI_PRATICA"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_motivi_pratica(NEW_TIPO_TRIBUTO);
            fetch cpk1_motivi_pratica into dummy;
            found := cpk1_motivi_pratica%FOUND;
            close cpk1_motivi_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Motivi Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_PRATICA_PU */
/

-- Trigger MOTIVI_PRATICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MOTIVI_PRATICA

create or replace trigger MOTIVI_PRATICA_TIU
before INSERT
    or UPDATE
on MOTIVI_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       MOTIVI_PRATICA_NR (:new.tipo_tributo,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity at Level 0
      if UPDATING then
         MOTIVI_PRATICA_PU(:OLD.TIPO_TRIBUTO,
                           :OLD.SEQUENZA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.SEQUENZA);
         null;
      end if;
	if INSERTING then
         MOTIVI_PRATICA_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MOTIVI_PRATICA"
            cursor cpk_motivi_pratica(var_TIPO_TRIBUTO varchar,
                                      var_SEQUENZA number) is
               select 1
                 from   MOTIVI_PRATICA
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MOTIVI_PRATICA"
               if :new.TIPO_TRIBUTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_motivi_pratica(:new.TIPO_TRIBUTO,
                                           :new.SEQUENZA);
                  fetch cpk_motivi_pratica into dummy;
                  found := cpk_motivi_pratica%FOUND;
                  close cpk_motivi_pratica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Motivi Pratica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOTIVI_PRATICA_TIU */
/

-- Procedure MOTIVI_SGRAVIO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table MOTIVI_SGRAVIO

create or replace procedure MOTIVI_SGRAVIO_PU
(old_motivo_sgravio IN number,
 new_motivo_sgravio IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SGRAVI"
   cursor cfk1_motivi_sgravio(var_motivo_sgravio number) is
      select 1
      from   SGRAVI
      where  MOTIVO_SGRAVIO = var_motivo_sgravio
       and   var_motivo_sgravio is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "MOTIVI_SGRAVIO" non modificabile se esistono referenze su "SGRAVI"
      if (OLD_MOTIVO_SGRAVIO != NEW_MOTIVO_SGRAVIO) then
         open  cfk1_motivi_sgravio(OLD_MOTIVO_SGRAVIO);
         fetch cfk1_motivi_sgravio into dummy;
         found := cfk1_motivi_sgravio%FOUND;
         close cfk1_motivi_sgravio;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sgravi. La registrazione di Motivi Sgravio non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_SGRAVIO_PU */
/

-- Trigger MOTIVI_SGRAVIO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table MOTIVI_SGRAVIO

create or replace trigger MOTIVI_SGRAVIO_TIU
before INSERT
    or UPDATE
on MOTIVI_SGRAVIO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         MOTIVI_SGRAVIO_PU(:OLD.MOTIVO_SGRAVIO,
                         :NEW.MOTIVO_SGRAVIO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "MOTIVI_SGRAVIO"
            cursor cpk_motivi_sgravio(var_MOTIVO_SGRAVIO number) is
               select 1
                 from   MOTIVI_SGRAVIO
                where  MOTIVO_SGRAVIO = var_MOTIVO_SGRAVIO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "MOTIVI_SGRAVIO"
               if :new.MOTIVO_SGRAVIO is not null then
                  open  cpk_motivi_sgravio(:new.MOTIVO_SGRAVIO);
                  fetch cpk_motivi_sgravio into dummy;
                  found := cpk_motivi_sgravio%FOUND;
                  close cpk_motivi_sgravio;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.MOTIVO_SGRAVIO||
                               '" gia'' presente in Motivi Sgravio. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOTIVI_SGRAVIO_TIU */
/

-- Procedure MOTIVI_SGRAVIO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table MOTIVI_SGRAVIO

create or replace procedure MOTIVI_SGRAVIO_PD
(old_motivo_sgravio IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SGRAVI"
   cursor cfk1_motivi_sgravio(var_motivo_sgravio number) is
      select 1
      from   SGRAVI
      where  MOTIVO_SGRAVIO = var_motivo_sgravio
       and   var_motivo_sgravio is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "MOTIVI_SGRAVIO" if children still exist in "SGRAVI"
      open  cfk1_motivi_sgravio(OLD_MOTIVO_SGRAVIO);
      fetch cfk1_motivi_sgravio into dummy;
      found := cfk1_motivi_sgravio%FOUND;
      close cfk1_motivi_sgravio;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sgravi. La registrazione di Motivi Sgravio non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: MOTIVI_SGRAVIO_PD */
/

-- Tigger MOTIVI_SGRAVIO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table MOTIVI_SGRAVIO

create or replace trigger MOTIVI_SGRAVIO_TD
before DELETE
on MOTIVI_SGRAVIO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SGRAVI

      MOTIVI_SGRAVIO_PD(:OLD.MOTIVO_SGRAVIO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: MOTIVI_SGRAVIO_TD */
/

-- Procedure NOTIFICHE_OGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table NOTIFICHE_OGGETTO

create or replace procedure NOTIFICHE_OGGETTO_PI
(new_oggetto IN number,
 new_cod_fiscale IN varchar,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk1_notifiche_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk2_notifiche_oggetto(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk3_notifiche_oggetto(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "NOTIFICHE_OGGETTO"
         if NEW_OGGETTO is not null then
            open  cpk1_notifiche_oggetto(NEW_OGGETTO);
            fetch cpk1_notifiche_oggetto into dummy;
            found := cpk1_notifiche_oggetto%FOUND;
            close cpk1_notifiche_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Notifiche_oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "NOTIFICHE_OGGETTO"
         if NEW_COD_FISCALE is not null then
            open  cpk2_notifiche_oggetto(NEW_COD_FISCALE);
            fetch cpk2_notifiche_oggetto into dummy;
            found := cpk2_notifiche_oggetto%FOUND;
            close cpk2_notifiche_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Notifiche_oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "NOTIFICHE_OGGETTO"
         if NEW_PRATICA is not null then
            open  cpk3_notifiche_oggetto(NEW_PRATICA);
            fetch cpk3_notifiche_oggetto into dummy;
            found := cpk3_notifiche_oggetto%FOUND;
            close cpk3_notifiche_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Notifiche_oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: NOTIFICHE_OGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table NOTIFICHE_OGGETTO
/* End Trigger: NOTIFICHE_OGGETTO_TC */

-- Procedure NOTIFICHE_OGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table NOTIFICHE_OGGETTO

create or replace procedure NOTIFICHE_OGGETTO_PU
(old_oggetto IN number,
 old_cod_fiscale IN varchar,
 old_pratica IN number,
 new_oggetto IN number,
 new_cod_fiscale IN varchar,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk1_notifiche_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk2_notifiche_oggetto(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk3_notifiche_oggetto(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "NOTIFICHE_OGGETTO"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk1_notifiche_oggetto(NEW_OGGETTO);
            fetch cpk1_notifiche_oggetto into dummy;
            found := cpk1_notifiche_oggetto%FOUND;
            close cpk1_notifiche_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Notifiche_oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "NOTIFICHE_OGGETTO"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk2_notifiche_oggetto(NEW_COD_FISCALE);
            fetch cpk2_notifiche_oggetto into dummy;
            found := cpk2_notifiche_oggetto%FOUND;
            close cpk2_notifiche_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Notifiche_oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "NOTIFICHE_OGGETTO"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk3_notifiche_oggetto(NEW_PRATICA);
            fetch cpk3_notifiche_oggetto into dummy;
            found := cpk3_notifiche_oggetto%FOUND;
            close cpk3_notifiche_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Notifiche_oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: NOTIFICHE_OGGETTO_PU */
/

-- Trigger NOTIFICHE_OGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table NOTIFICHE_OGGETTO

create or replace trigger NOTIFICHE_OGGETTO_TIU
before INSERT
    or UPDATE
on NOTIFICHE_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         NOTIFICHE_OGGETTO_PU(:OLD.OGGETTO,
                              :OLD.COD_FISCALE,
                              :OLD.PRATICA,
                         :NEW.OGGETTO,
                         :NEW.COD_FISCALE,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         NOTIFICHE_OGGETTO_PI(:NEW.OGGETTO,
                              :NEW.COD_FISCALE,
                              :NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "NOTIFICHE_OGGETTO"
            cursor cpk_notifiche_oggetto(var_OGGETTO number,
                                         var_COD_FISCALE varchar) is
               select 1
                 from   NOTIFICHE_OGGETTO
                where  OGGETTO = var_OGGETTO and
                       COD_FISCALE = var_COD_FISCALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "NOTIFICHE_OGGETTO"
               if :new.OGGETTO is not null and
                  :new.COD_FISCALE is not null then
                  open  cpk_notifiche_oggetto(:new.OGGETTO,
                                              :new.COD_FISCALE);
                  fetch cpk_notifiche_oggetto into dummy;
                  found := cpk_notifiche_oggetto%FOUND;
                  close cpk_notifiche_oggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||' '||
                               :new.COD_FISCALE||
                               '" gia'' presente in Notifiche_oggetto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: NOTIFICHE_OGGETTO_TIU */
/

-- Procedure OGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table OGGETTI

create or replace procedure OGGETTI_PI
(new_edificio IN number,
 new_tipo_oggetto IN number,
 new_cod_via IN number,
 new_categoria_catasto IN varchar,
 new_tipo_uso IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "EDIFICI"
   cursor cpk1_oggetti(var_edificio number) is
      select 1
      from   EDIFICI
      where  EDIFICIO = var_edificio
       and   var_edificio is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FONTI"
   cursor cpk2_oggetti(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_OGGETTO"
   cursor cpk3_oggetti(var_tipo_oggetto number) is
      select 1
      from   TIPI_OGGETTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_USO"
   cursor cpk4_oggetti(var_tipo_uso number) is
      select 1
      from   TIPI_USO
      where  TIPO_USO = var_tipo_uso
       and   var_tipo_uso is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE"
   cursor cpk5_oggetti(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE_CATASTO"
   cursor cpk6_oggetti(var_categoria_catasto varchar) is
      select 1
      from   CATEGORIE_CATASTO
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "EDIFICI" deve esistere quando si inserisce su "OGGETTI"
         if NEW_EDIFICIO is not null then
            open  cpk1_oggetti(NEW_EDIFICIO);
            fetch cpk1_oggetti into dummy;
            found := cpk1_oggetti%FOUND;
            close cpk1_oggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Edifici. La registrazione Oggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si inserisce su "OGGETTI"
         if NEW_FONTE is not null then
            open  cpk2_oggetti(NEW_FONTE);
            fetch cpk2_oggetti into dummy;
            found := cpk2_oggetti%FOUND;
            close cpk2_oggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Oggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_OGGETTO" deve esistere quando si inserisce su "OGGETTI"
         if NEW_TIPO_OGGETTO is not null then
            open  cpk3_oggetti(NEW_TIPO_OGGETTO);
            fetch cpk3_oggetti into dummy;
            found := cpk3_oggetti%FOUND;
            close cpk3_oggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Oggetto. La registrazione Oggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_USO" deve esistere quando si inserisce su "OGGETTI"
         if NEW_TIPO_USO is not null then
            open  cpk4_oggetti(NEW_TIPO_USO);
            fetch cpk4_oggetti into dummy;
            found := cpk4_oggetti%FOUND;
            close cpk4_oggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Uso. La registrazione Oggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si inserisce su "OGGETTI"
         if NEW_COD_VIA is not null then
            open  cpk5_oggetti(NEW_COD_VIA);
            fetch cpk5_oggetti into dummy;
            found := cpk5_oggetti%FOUND;
            close cpk5_oggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Oggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE_CATASTO" deve esistere quando si inserisce su "OGGETTI"
         if NEW_CATEGORIA_CATASTO is not null then
            open  cpk6_oggetti(NEW_CATEGORIA_CATASTO);
            fetch cpk6_oggetti into dummy;
            found := cpk6_oggetti%FOUND;
            close cpk6_oggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie Catasto. La registrazione Oggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table OGGETTI
/* End Trigger: OGGETTI_TC */

-- Procedure OGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table OGGETTI

create or replace procedure OGGETTI_PU
(old_oggetto IN number,
 old_edificio IN number,
 old_tipo_oggetto IN number,
 old_cod_via IN number,
 old_categoria_catasto IN varchar,
 old_tipo_uso IN number,
 old_fonte IN number,
 new_oggetto IN number,
 new_edificio IN number,
 new_tipo_oggetto IN number,
 new_cod_via IN number,
 new_categoria_catasto IN varchar,
 new_tipo_uso IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "EDIFICI"
   cursor cpk1_oggetti(var_edificio number) is
      select 1
      from   EDIFICI
      where  EDIFICIO = var_edificio
       and   var_edificio is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FONTI"
   cursor cpk2_oggetti(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_OGGETTO"
   cursor cpk3_oggetti(var_tipo_oggetto number) is
      select 1
      from   TIPI_OGGETTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_USO"
   cursor cpk4_oggetti(var_tipo_uso number) is
      select 1
      from   TIPI_USO
      where  TIPO_USO = var_tipo_uso
       and   var_tipo_uso is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE"
   cursor cpk5_oggetti(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE_CATASTO"
   cursor cpk6_oggetti(var_categoria_catasto varchar) is
      select 1
      from   CATEGORIE_CATASTO
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_oggetti(var_oggetto number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "RIFERIMENTI_OGGETTO"
   cursor cfk2_oggetti(var_oggetto number) is
      select 1
      from   RIFERIMENTI_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk3_oggetti(var_oggetto number) is
      select 1
      from   UTILIZZI_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "CIVICI_OGGETTO"
   cursor cfk4_oggetti(var_oggetto number) is
      select 1
      from   CIVICI_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "PARTIZIONI_OGGETTO"
   cursor cfk5_oggetti(var_oggetto number) is
      select 1
      from   PARTIZIONI_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "NOTIFICHE_OGGETTO"
   cursor cfk6_oggetti(var_oggetto number) is
      select 1
      from   NOTIFICHE_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_IMMOBILI"
   cursor cfk7_oggetti(var_oggetto number) is
      select 1
      from   SUCCESSIONI_IMMOBILI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE"
   cursor cfk8_oggetti(var_oggetto number) is
      select 1
      from   ANOMALIE
      where  ID_OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "CODICI_RFID"
   cursor cfk9_oggetti(var_oggetto number) is
      select 1
      from   CODICI_RFID
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "EDIFICI" deve esistere quando si modifica "OGGETTI"
         if  NEW_EDIFICIO is not null and ( seq = 0 )
         and (   (NEW_EDIFICIO != OLD_EDIFICIO or OLD_EDIFICIO is null) ) then
            open  cpk1_oggetti(NEW_EDIFICIO);
            fetch cpk1_oggetti into dummy;
            found := cpk1_oggetti%FOUND;
            close cpk1_oggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Edifici. La registrazione Oggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si modifica "OGGETTI"
         if  NEW_FONTE is not null and ( seq = 0 )
         and (   (NEW_FONTE != OLD_FONTE or OLD_FONTE is null) ) then
            open  cpk2_oggetti(NEW_FONTE);
            fetch cpk2_oggetti into dummy;
            found := cpk2_oggetti%FOUND;
            close cpk2_oggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Oggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_OGGETTO" deve esistere quando si modifica "OGGETTI"
         if  NEW_TIPO_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_OGGETTO != OLD_TIPO_OGGETTO or OLD_TIPO_OGGETTO is null) ) then
            open  cpk3_oggetti(NEW_TIPO_OGGETTO);
            fetch cpk3_oggetti into dummy;
            found := cpk3_oggetti%FOUND;
            close cpk3_oggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Oggetto. La registrazione Oggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_USO" deve esistere quando si modifica "OGGETTI"
         if  NEW_TIPO_USO is not null and ( seq = 0 )
         and (   (NEW_TIPO_USO != OLD_TIPO_USO or OLD_TIPO_USO is null) ) then
            open  cpk4_oggetti(NEW_TIPO_USO);
            fetch cpk4_oggetti into dummy;
            found := cpk4_oggetti%FOUND;
            close cpk4_oggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Uso. La registrazione Oggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si modifica "OGGETTI"
         if  NEW_COD_VIA is not null and ( seq = 0 )
         and (   (NEW_COD_VIA != OLD_COD_VIA or OLD_COD_VIA is null) ) then
            open  cpk5_oggetti(NEW_COD_VIA);
            fetch cpk5_oggetti into dummy;
            found := cpk5_oggetti%FOUND;
            close cpk5_oggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Oggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE_CATASTO" deve esistere quando si modifica "OGGETTI"
         if  NEW_CATEGORIA_CATASTO is not null and ( seq = 0 )
         and (   (NEW_CATEGORIA_CATASTO != OLD_CATEGORIA_CATASTO or OLD_CATEGORIA_CATASTO is null) ) then
            open  cpk6_oggetti(NEW_CATEGORIA_CATASTO);
            fetch cpk6_oggetti into dummy;
            found := cpk6_oggetti%FOUND;
            close cpk6_oggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie Catasto. La registrazione Oggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk1_oggetti(OLD_OGGETTO);
         fetch cfk1_oggetti into dummy;
         found := cfk1_oggetti%FOUND;
         close cfk1_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "RIFERIMENTI_OGGETTO"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk2_oggetti(OLD_OGGETTO);
         fetch cfk2_oggetti into dummy;
         found := cfk2_oggetti%FOUND;
         close cfk2_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Riferimenti Oggetto. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "UTILIZZI_OGGETTO"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk3_oggetti(OLD_OGGETTO);
         fetch cfk3_oggetti into dummy;
         found := cfk3_oggetti%FOUND;
         close cfk3_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "CIVICI_OGGETTO"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk4_oggetti(OLD_OGGETTO);
         fetch cfk4_oggetti into dummy;
         found := cfk4_oggetti%FOUND;
         close cfk4_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Civici Oggetto. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "PARTIZIONI_OGGETTO"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk5_oggetti(OLD_OGGETTO);
         fetch cfk5_oggetti into dummy;
         found := cfk5_oggetti%FOUND;
         close cfk5_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Partizioni Oggetto. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "NOTIFICHE_OGGETTO"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk6_oggetti(OLD_OGGETTO);
         fetch cfk6_oggetti into dummy;
         found := cfk6_oggetti%FOUND;
         close cfk6_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Notifiche_oggetto. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "SUCCESSIONI_IMMOBILI"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk7_oggetti(OLD_OGGETTO);
         fetch cfk7_oggetti into dummy;
         found := cfk7_oggetti%FOUND;
         close cfk7_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUCCESSIONI_IMMOBILI. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "ANOMALIE"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk8_oggetti(OLD_OGGETTO);
         fetch cfk8_oggetti into dummy;
         found := cfk8_oggetti%FOUND;
         close cfk8_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ANOMALIE. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI" non modificabile se esistono referenze su "CODICI_RFID"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk9_oggetti(OLD_OGGETTO);
         fetch cfk9_oggetti into dummy;
         found := cfk9_oggetti%FOUND;
         close cfk9_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Codici RFID. La registrazione di Oggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_PU */
/

-- Trigger OGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table OGGETTI

create or replace trigger OGGETTI_TIU
before INSERT
    or UPDATE
on OGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);

      if nvl(:new.foglio,' ')		!= nvl(:old.foglio,' ')
      or nvl(:new.numero,' ')		!= nvl(:old.numero,' ')
      or nvl(:new.subalterno,' ') 	!= nvl(:old.subalterno,' ')
      or nvl(:new.sezione,' ') 		!= nvl(:old.sezione,' ')
      or nvl(:new.zona,' ')		!= nvl(:old.zona,' ') Then
         :new.estremi_catasto := lpad(nvl(:new.sezione,' '),3,' ')||
				 lpad(nvl(:new.foglio,' '),5,' ')||
			 	 lpad(nvl(:new.numero,' '),5,' ')||
				 lpad(nvl(:new.subalterno,' '),4,' ')||
			 	 lpad(nvl(:new.zona,' '),3,' ');
      OGGETTI_DI(:new.estremi_catasto);
      end if;
   end;

   if INSERTING and :new.oggetto is null then
      OGGETTI_NR(:new.oggetto);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         OGGETTI_PU(:OLD.OGGETTO,
                    :OLD.EDIFICIO,
                    :OLD.TIPO_OGGETTO,
                    :OLD.COD_VIA,
                    :OLD.CATEGORIA_CATASTO,
                    :OLD.TIPO_USO,
                    :OLD.FONTE,
                         :NEW.OGGETTO,
                         :NEW.EDIFICIO,
                         :NEW.TIPO_OGGETTO,
                         :NEW.COD_VIA,
                         :NEW.CATEGORIA_CATASTO,
                         :NEW.TIPO_USO,
                         :NEW.FONTE);
         null;
      end if;
      if INSERTING then
         OGGETTI_PI(:NEW.EDIFICIO,
                    :NEW.TIPO_OGGETTO,
                    :NEW.COD_VIA,
                    :NEW.CATEGORIA_CATASTO,
                    :NEW.TIPO_USO,
                    :NEW.FONTE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "OGGETTI"
            cursor cpk_oggetti(var_OGGETTO number) is
               select 1
                 from   OGGETTI
                where  OGGETTO = var_OGGETTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "OGGETTI"
               if :new.OGGETTO is not null then
                  open  cpk_oggetti(:new.OGGETTO);
                  fetch cpk_oggetti into dummy;
                  found := cpk_oggetti%FOUND;
                  close cpk_oggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||
                               '" gia'' presente in Oggetti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "OGGETTI" for all children in "ANOMALIE_ICI"
         if (:OLD.OGGETTO != :NEW.OGGETTO) then
            update ANOMALIE_ICI
             set   OGGETTO = :NEW.OGGETTO
            where  OGGETTO = :OLD.OGGETTO;
         end if;

         --  Modify parent code of "OGGETTI" for all children in "ANOMALIE_CARICAMENTO"
         if (:OLD.OGGETTO != :NEW.OGGETTO) then
            update ANOMALIE_CARICAMENTO
             set   OGGETTO = :NEW.OGGETTO
            where  OGGETTO = :OLD.OGGETTO;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            OGGETTI_FI (:new.oggetto,:old.indirizzo_localita,:old.cod_via,:old.num_civ,
                        :old.suffisso,
                        :new.indirizzo_localita,:new.cod_via,:new.num_civ,:new.suffisso);
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_TIU */
/

-- Procedure OGGETTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI

create or replace procedure OGGETTI_PD
(old_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_oggetti(var_oggetto number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of DeleteParentRestrict constraint for "RIFERIMENTI_OGGETTO"
   cursor cfk2_oggetti(var_oggetto number) is
      select 1
      from   RIFERIMENTI_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of DeleteParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk3_oggetti(var_oggetto number) is
      select 1
      from   UTILIZZI_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of DeleteParentRestrict constraint for "PARTIZIONI_OGGETTO"
   cursor cfk4_oggetti(var_oggetto number) is
      select 1
      from   PARTIZIONI_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of DeleteParentRestrict constraint for "NOTIFICHE_OGGETTO"
   cursor cfk5_oggetti(var_oggetto number) is
      select 1
      from   NOTIFICHE_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of DeleteParentRestrict constraint for "CODICI_RFID"
   cursor cfk6_oggetti(var_oggetto number) is
      select 1
      from   CODICI_RFID
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "OGGETTI" if children still exist in "OGGETTI_PRATICA"
      open  cfk1_oggetti(OLD_OGGETTO);
      fetch cfk1_oggetti into dummy;
      found := cfk1_oggetti%FOUND;
      close cfk1_oggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Oggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "OGGETTI" if children still exist in "RIFERIMENTI_OGGETTO"
      open  cfk2_oggetti(OLD_OGGETTO);
      fetch cfk2_oggetti into dummy;
      found := cfk2_oggetti%FOUND;
      close cfk2_oggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Riferimenti Oggetto. La registrazione di Oggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "OGGETTI" if children still exist in "UTILIZZI_OGGETTO"
      open  cfk3_oggetti(OLD_OGGETTO);
      fetch cfk3_oggetti into dummy;
      found := cfk3_oggetti%FOUND;
      close cfk3_oggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Oggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "OGGETTI" if children still exist in "PARTIZIONI_OGGETTO"
      open  cfk4_oggetti(OLD_OGGETTO);
      fetch cfk4_oggetti into dummy;
      found := cfk4_oggetti%FOUND;
      close cfk4_oggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Partizioni Oggetto. La registrazione di Oggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "OGGETTI" if children still exist in "NOTIFICHE_OGGETTO"
      open  cfk5_oggetti(OLD_OGGETTO);
      fetch cfk5_oggetti into dummy;
      found := cfk5_oggetti%FOUND;
      close cfk5_oggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Notifiche_oggetto. La registrazione di Oggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "OGGETTI" if children still exist in "CODICI_RFID"
      open  cfk6_oggetti(OLD_OGGETTO);
      fetch cfk6_oggetti into dummy;
      found := cfk6_oggetti%FOUND;
      close cfk6_oggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Codici RFID. La registrazione di Oggetti non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_PD */
/

-- Tigger OGGETTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI

create or replace trigger OGGETTI_TD
before DELETE
on OGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI_PRATICA

      -- Child Restrict Table: RIFERIMENTI_OGGETTO

      -- Child Restrict Table: UTILIZZI_OGGETTO

      -- Child Restrict Table: PARTIZIONI_OGGETTO

      -- Child Restrict Table: NOTIFICHE_OGGETTO

      -- Child Restrict Table: CODICI_RFID

      OGGETTI_PD(:OLD.OGGETTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "CIVICI_OGGETTO"
      delete CIVICI_OGGETTO
      where  OGGETTO = :OLD.OGGETTO;

      --  Delete all children in "ANOMALIE_ICI"
      delete ANOMALIE_ICI
      where  OGGETTO = :OLD.OGGETTO;

      --  Delete all children in "ANOMALIE_CARICAMENTO"
      delete ANOMALIE_CARICAMENTO
      where  OGGETTO = :OLD.OGGETTO;

      --  Delete all children in "ANOMALIE"
      delete ANOMALIE
      where  ID_OGGETTO = :OLD.OGGETTO;

      --  Set parent code of "OGGETTI" to NULL in child "SUCCESSIONI_IMMOBILI"
      update SUCCESSIONI_IMMOBILI
       set   OGGETTO = NULL
      where  OGGETTO = :OLD.OGGETTO;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_TD */
/

-- Procedure OGGETTI_CONTRIBUENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table OGGETTI_CONTRIBUENTE

create or replace procedure OGGETTI_CONTRIBUENTE_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_oggetti_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk2_oggetti_contribuente(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "OGGETTI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null then
            open  cpk1_oggetti_contribuente(NEW_COD_FISCALE);
            fetch cpk1_oggetti_contribuente into dummy;
            found := cpk1_oggetti_contribuente%FOUND;
            close cpk1_oggetti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Oggetti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "OGGETTI_CONTRIBUENTE"
         if NEW_OGGETTO_PRATICA is not null then
            open  cpk2_oggetti_contribuente(NEW_OGGETTO_PRATICA);
            fetch cpk2_oggetti_contribuente into dummy;
            found := cpk2_oggetti_contribuente%FOUND;
            close cpk2_oggetti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_CONTRIBUENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table OGGETTI_CONTRIBUENTE

create or replace trigger OGGETTI_CONTRIBUENTE_tb
before INSERT
    or UPDATE
    or DELETE
on OGGETTI_CONTRIBUENTE
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: OGGETTI_CONTRIBUENTE_TB */
/

create or replace trigger OGGETTI_CONTRIBUENTE_tc
after INSERT
   or UPDATE
   or DELETE
on OGGETTI_CONTRIBUENTE
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: OGGETTI_CONTRIBUENTE_TC */
/

-- Procedure OGGETTI_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table OGGETTI_CONTRIBUENTE

create or replace procedure OGGETTI_CONTRIBUENTE_PU
(old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number,
 new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_oggetti_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk2_oggetti_contribuente(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "OGGETTI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_oggetti_contribuente(NEW_COD_FISCALE);
            fetch cpk1_oggetti_contribuente into dummy;
            found := cpk1_oggetti_contribuente%FOUND;
            close cpk1_oggetti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Oggetti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "OGGETTI_CONTRIBUENTE"
         if  NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk2_oggetti_contribuente(NEW_OGGETTO_PRATICA);
            fetch cpk2_oggetti_contribuente into dummy;
            found := cpk2_oggetti_contribuente%FOUND;
            close cpk2_oggetti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_CONTRIBUENTE_PU */
/

-- Trigger OGGETTI_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table OGGETTI_CONTRIBUENTE

create or replace trigger OGGETTI_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on OGGETTI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      OGGETTI_CONTRIBUENTE_DI (:new.oggetto_pratica,:new.data_decorrenza,:new.data_cessazione,
                               :new.mesi_possesso,:new.mesi_esclusione,:new.mesi_riduzione,
                               :new.mesi_aliquota_ridotta,:new.flag_ab_principale);
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         OGGETTI_CONTRIBUENTE_PU(:OLD.COD_FISCALE,
                                 :OLD.OGGETTO_PRATICA,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA);
         null;
      end if;
      if INSERTING then
         OGGETTI_CONTRIBUENTE_PI(:NEW.COD_FISCALE,
                                 :NEW.OGGETTO_PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "OGGETTI_CONTRIBUENTE"
            cursor cpk_oggetti_contribuente(var_COD_FISCALE varchar,
                                            var_OGGETTO_PRATICA number) is
               select 1
                 from   OGGETTI_CONTRIBUENTE
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "OGGETTI_CONTRIBUENTE"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO_PRATICA is not null then
                  open  cpk_oggetti_contribuente(:new.COD_FISCALE,
                                                 :new.OGGETTO_PRATICA);
                  fetch cpk_oggetti_contribuente into dummy;
                  found := cpk_oggetti_contribuente%FOUND;
                  close cpk_oggetti_contribuente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO_PRATICA||
                               '" gia'' presente in Oggetti Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "OGGETTI_CONTRIBUENTE" for all children in "OGGETTI_IMPOSTA"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO_PRATICA != :NEW.OGGETTO_PRATICA) then
            update OGGETTI_IMPOSTA
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO_PRATICA = :NEW.OGGETTO_PRATICA
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
         end if;

         --  Modify parent code of "OGGETTI_CONTRIBUENTE" for all children in "DETRAZIONI_OGCO"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO_PRATICA != :NEW.OGGETTO_PRATICA) then
            update DETRAZIONI_OGCO
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO_PRATICA = :NEW.OGGETTO_PRATICA
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
         end if;

         --  Modify parent code of "OGGETTI_CONTRIBUENTE" for all children in "ALIQUOTE_OGCO"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO_PRATICA != :NEW.OGGETTO_PRATICA) then
            update ALIQUOTE_OGCO
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO_PRATICA = :NEW.OGGETTO_PRATICA
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
         end if;

         --  Modify parent code of "OGGETTI_CONTRIBUENTE" for all children in "PERIODI_IMPONIBILE"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO_PRATICA != :NEW.OGGETTO_PRATICA) then
            update PERIODI_IMPONIBILE
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO_PRATICA = :NEW.OGGETTO_PRATICA
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
         end if;

         --  Modify parent code of "OGGETTI_CONTRIBUENTE" for all children in "DETRAZIONI_IMPONIBILE"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO_PRATICA != :NEW.OGGETTO_PRATICA) then
            update DETRAZIONI_IMPONIBILE
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO_PRATICA = :NEW.OGGETTO_PRATICA
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
         end if;

         --  Modify parent code of "OGGETTI_CONTRIBUENTE" for all children in "ATTRIBUTI_OGCO"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO_PRATICA != :NEW.OGGETTO_PRATICA) then
            update ATTRIBUTI_OGCO
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO_PRATICA = :NEW.OGGETTO_PRATICA
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
         end if;

         --  Modify parent code of "OGGETTI_CONTRIBUENTE" for all children in "OGGETTI_OGIM"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO_PRATICA != :NEW.OGGETTO_PRATICA) then
            update OGGETTI_OGIM
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO_PRATICA = :NEW.OGGETTO_PRATICA
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
         end if;

         --  Modify parent code of "OGGETTI_CONTRIBUENTE" for all children in "ANOMALIE_PRATICHE"
         if (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.OGGETTO_PRATICA != :NEW.OGGETTO_PRATICA) then
            update ANOMALIE_PRATICHE
             set   COD_FISCALE = :NEW.COD_FISCALE,
                   OGGETTO_PRATICA = :NEW.OGGETTO_PRATICA
            where  COD_FISCALE = :OLD.COD_FISCALE
             and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_CONTRIBUENTE_TIU */
/

-- Procedure OGGETTI_CONTRIBUENTE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI_CONTRIBUENTE

create or replace procedure OGGETTI_CONTRIBUENTE_PD
(old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DETRAZIONI_OGCO"
   cursor cfk1_oggetti_contribuente(var_cod_fiscale varchar,
                                    var_oggetto_pratica number) is
      select 1
      from   DETRAZIONI_OGCO
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Declaration of DeleteParentRestrict constraint for "ALIQUOTE_OGCO"
   cursor cfk2_oggetti_contribuente(var_cod_fiscale varchar,
                                    var_oggetto_pratica number) is
      select 1
      from   ALIQUOTE_OGCO
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "OGGETTI_CONTRIBUENTE" if children still exist in "DETRAZIONI_OGCO"
      open  cfk1_oggetti_contribuente(OLD_COD_FISCALE,
                                      OLD_OGGETTO_PRATICA);
      fetch cfk1_oggetti_contribuente into dummy;
      found := cfk1_oggetti_contribuente%FOUND;
      close cfk1_oggetti_contribuente;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Detrazioni Oggetti Contribuente. La registrazione di Oggetti Contribuente non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "OGGETTI_CONTRIBUENTE" if children still exist in "ALIQUOTE_OGCO"
      open  cfk2_oggetti_contribuente(OLD_COD_FISCALE,
                                      OLD_OGGETTO_PRATICA);
      fetch cfk2_oggetti_contribuente into dummy;
      found := cfk2_oggetti_contribuente%FOUND;
      close cfk2_oggetti_contribuente;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Aliquote Oggetto Contribuente. La registrazione di Oggetti Contribuente non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_CONTRIBUENTE_PD */
/

-- Tigger OGGETTI_CONTRIBUENTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI_CONTRIBUENTE

create or replace trigger OGGETTI_CONTRIBUENTE_TD
before DELETE
on OGGETTI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DETRAZIONI_OGCO

      -- Child Restrict Table: ALIQUOTE_OGCO

      OGGETTI_CONTRIBUENTE_PD(:OLD.COD_FISCALE,
                              :OLD.OGGETTO_PRATICA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "OGGETTI_IMPOSTA"
      delete OGGETTI_IMPOSTA
      where  COD_FISCALE = :OLD.COD_FISCALE
       and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "PERIODI_IMPONIBILE"
      delete PERIODI_IMPONIBILE
      where  COD_FISCALE = :OLD.COD_FISCALE
       and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "DETRAZIONI_IMPONIBILE"
      delete DETRAZIONI_IMPONIBILE
      where  COD_FISCALE = :OLD.COD_FISCALE
       and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "ATTRIBUTI_OGCO"
      delete ATTRIBUTI_OGCO
      where  COD_FISCALE = :OLD.COD_FISCALE
       and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "OGGETTI_OGIM"
      delete OGGETTI_OGIM
      where  COD_FISCALE = :OLD.COD_FISCALE
       and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "ANOMALIE_PRATICHE"
      delete ANOMALIE_PRATICHE
      where  COD_FISCALE = :OLD.COD_FISCALE
       and   OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
      DECLARE
	    a_istruzione  varchar2(2000);
            a_messaggio   varchar2(2000);
      BEGIN
            a_istruzione := 'BEGIN CONTRIBUENTI_CHK_DEL('''||:old.cod_fiscale||''',null); end;';
            a_messaggio := '';
            IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;

   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_CONTRIBUENTE_TD */
/

-- Procedure OGGETTI_ICI_93_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table OGGETTI_ICI_93

create or replace procedure OGGETTI_ICI_93_PI
(new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk1_oggetti_ici_93(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "OGGETTI_ICI_93"
         if NEW_OGGETTO_PRATICA is not null then
            open  cpk1_oggetti_ici_93(NEW_OGGETTO_PRATICA);
            fetch cpk1_oggetti_ici_93 into dummy;
            found := cpk1_oggetti_ici_93%FOUND;
            close cpk1_oggetti_ici_93;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti ICI 93 non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_ICI_93_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table OGGETTI_ICI_93
/* End Trigger: OGGETTI_ICI_93_TC */

-- Procedure OGGETTI_ICI_93_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table OGGETTI_ICI_93

create or replace procedure OGGETTI_ICI_93_PU
(old_oggetto_pratica IN number,
 new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk1_oggetti_ici_93(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "OGGETTI_ICI_93"
         if  NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_oggetti_ici_93(NEW_OGGETTO_PRATICA);
            fetch cpk1_oggetti_ici_93 into dummy;
            found := cpk1_oggetti_ici_93%FOUND;
            close cpk1_oggetti_ici_93;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti ICI 93 non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_ICI_93_PU */
/

-- Trigger OGGETTI_ICI_93_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table OGGETTI_ICI_93

create or replace trigger OGGETTI_ICI_93_TIU
before INSERT
    or UPDATE
on OGGETTI_ICI_93
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         OGGETTI_ICI_93_PU(:OLD.OGGETTO_PRATICA,
                         :NEW.OGGETTO_PRATICA);
         null;
      end if;
      if INSERTING then
         OGGETTI_ICI_93_PI(:NEW.OGGETTO_PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "OGGETTI_ICI_93"
            cursor cpk_oggetti_ici_93(var_OGGETTO_PRATICA number) is
               select 1
                 from   OGGETTI_ICI_93
                where  OGGETTO_PRATICA = var_OGGETTO_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "OGGETTI_ICI_93"
               if :new.OGGETTO_PRATICA is not null then
                  open  cpk_oggetti_ici_93(:new.OGGETTO_PRATICA);
                  fetch cpk_oggetti_ici_93 into dummy;
                  found := cpk_oggetti_ici_93%FOUND;
                  close cpk_oggetti_ici_93;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO_PRATICA||
                               '" gia'' presente in Oggetti ICI 93. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_ICI_93_TIU */
/

-- Procedure OGGETTI_IMPOSTA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table OGGETTI_IMPOSTA

create or replace procedure OGGETTI_IMPOSTA_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_tipo_aliquota IN number,
 new_ruolo IN number,
 new_fattura IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_CONTRIBUENTE"
   cursor cpk1_oggetti_imposta(var_cod_fiscale varchar,
                               var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk2_oggetti_imposta(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ALIQUOTA"
   cursor cpk3_oggetti_imposta(var_tipo_tributo varchar,
                               var_tipo_aliquota number) is
      select 1
      from   TIPI_ALIQUOTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FATTURE"
   cursor cpk4_oggetti_imposta(var_fattura number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura
       and   var_fattura is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si inserisce su "OGGETTI_IMPOSTA"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO_PRATICA is not null then
            open  cpk1_oggetti_imposta(NEW_COD_FISCALE,
                                       NEW_OGGETTO_PRATICA);
            fetch cpk1_oggetti_imposta into dummy;
            found := cpk1_oggetti_imposta%FOUND;
            close cpk1_oggetti_imposta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Oggetti Imposta non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "OGGETTI_IMPOSTA"
         if NEW_RUOLO is not null then
            open  cpk2_oggetti_imposta(NEW_RUOLO);
            fetch cpk2_oggetti_imposta into dummy;
            found := cpk2_oggetti_imposta%FOUND;
            close cpk2_oggetti_imposta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Oggetti Imposta non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ALIQUOTA" deve esistere quando si inserisce su "OGGETTI_IMPOSTA"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_TIPO_ALIQUOTA is not null then
            open  cpk3_oggetti_imposta(NEW_TIPO_TRIBUTO,
                                       NEW_TIPO_ALIQUOTA);
            fetch cpk3_oggetti_imposta into dummy;
            found := cpk3_oggetti_imposta%FOUND;
            close cpk3_oggetti_imposta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Aliquota. La registrazione Oggetti Imposta non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FATTURE" deve esistere quando si inserisce su "OGGETTI_IMPOSTA"
         if NEW_FATTURA is not null then
            open  cpk4_oggetti_imposta(NEW_FATTURA);
            fetch cpk4_oggetti_imposta into dummy;
            found := cpk4_oggetti_imposta%FOUND;
            close cpk4_oggetti_imposta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione Oggetti Imposta non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_IMPOSTA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table OGGETTI_IMPOSTA
/* End Trigger: OGGETTI_IMPOSTA_TC */

-- Procedure OGGETTI_IMPOSTA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table OGGETTI_IMPOSTA

create or replace procedure OGGETTI_IMPOSTA_PU
(old_oggetto_imposta IN number,
 old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number,
 old_tipo_aliquota IN number,
 old_ruolo IN number,
 old_fattura IN number,
 old_tipo_tributo IN varchar,
 new_oggetto_imposta IN number,
 new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_tipo_aliquota IN number,
 new_ruolo IN number,
 new_fattura IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_CONTRIBUENTE"
   cursor cpk1_oggetti_imposta(var_cod_fiscale varchar,
                               var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk2_oggetti_imposta(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ALIQUOTA"
   cursor cpk3_oggetti_imposta(var_tipo_tributo varchar,
                               var_tipo_aliquota number) is
      select 1
      from   TIPI_ALIQUOTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FATTURE"
   cursor cpk4_oggetti_imposta(var_fattura number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Declaration of UpdateParentRestrict constraint for "RATE_IMPOSTA"
   cursor cfk1_oggetti_imposta(var_oggetto_imposta number) is
      select 1
      from   RATE_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Declaration of UpdateParentRestrict constraint for "VERSAMENTI"
   cursor cfk2_oggetti_imposta(var_oggetto_imposta number) is
      select 1
      from   VERSAMENTI
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Declaration of UpdateParentRestrict constraint for "RUOLI_CONTRIBUENTE"
   cursor cfk3_oggetti_imposta(var_oggetto_imposta number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Declaration of UpdateParentRestrict constraint for "FAMILIARI_OGIM"
   cursor cfk4_oggetti_imposta(var_oggetto_imposta number) is
      select 1
      from   FAMILIARI_OGIM
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Declaration of UpdateParentRestrict constraint for "DETRAZIONI_FIGLI_OGIM"
   cursor cfk5_oggetti_imposta(var_oggetto_imposta number) is
      select 1
      from   DETRAZIONI_FIGLI_OGIM
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si modifica "OGGETTI_IMPOSTA"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_oggetti_imposta(NEW_COD_FISCALE,
                                       NEW_OGGETTO_PRATICA);
            fetch cpk1_oggetti_imposta into dummy;
            found := cpk1_oggetti_imposta%FOUND;
            close cpk1_oggetti_imposta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Oggetti Imposta non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "OGGETTI_IMPOSTA"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk2_oggetti_imposta(NEW_RUOLO);
            fetch cpk2_oggetti_imposta into dummy;
            found := cpk2_oggetti_imposta%FOUND;
            close cpk2_oggetti_imposta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Oggetti Imposta non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ALIQUOTA" deve esistere quando si modifica "OGGETTI_IMPOSTA"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_TIPO_ALIQUOTA is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_TIPO_ALIQUOTA != OLD_TIPO_ALIQUOTA or OLD_TIPO_ALIQUOTA is null) ) then
            open  cpk3_oggetti_imposta(NEW_TIPO_TRIBUTO,
                                       NEW_TIPO_ALIQUOTA);
            fetch cpk3_oggetti_imposta into dummy;
            found := cpk3_oggetti_imposta%FOUND;
            close cpk3_oggetti_imposta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Aliquota. La registrazione Oggetti Imposta non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FATTURE" deve esistere quando si modifica "OGGETTI_IMPOSTA"
         if  NEW_FATTURA is not null and ( seq = 0 )
         and (   (NEW_FATTURA != OLD_FATTURA or OLD_FATTURA is null) ) then
            open  cpk4_oggetti_imposta(NEW_FATTURA);
            fetch cpk4_oggetti_imposta into dummy;
            found := cpk4_oggetti_imposta%FOUND;
            close cpk4_oggetti_imposta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione Oggetti Imposta non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "OGGETTI_IMPOSTA" non modificabile se esistono referenze su "RATE_IMPOSTA"
      if (OLD_OGGETTO_IMPOSTA != NEW_OGGETTO_IMPOSTA) then
         open  cfk1_oggetti_imposta(OLD_OGGETTO_IMPOSTA);
         fetch cfk1_oggetti_imposta into dummy;
         found := cfk1_oggetti_imposta%FOUND;
         close cfk1_oggetti_imposta;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Rate Imposta. La registrazione di Oggetti Imposta non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_IMPOSTA" non modificabile se esistono referenze su "VERSAMENTI"
      if (OLD_OGGETTO_IMPOSTA != NEW_OGGETTO_IMPOSTA) then
         open  cfk2_oggetti_imposta(OLD_OGGETTO_IMPOSTA);
         fetch cfk2_oggetti_imposta into dummy;
         found := cfk2_oggetti_imposta%FOUND;
         close cfk2_oggetti_imposta;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Oggetti Imposta non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_IMPOSTA" non modificabile se esistono referenze su "RUOLI_CONTRIBUENTE"
      if (OLD_OGGETTO_IMPOSTA != NEW_OGGETTO_IMPOSTA) then
         open  cfk3_oggetti_imposta(OLD_OGGETTO_IMPOSTA);
         fetch cfk3_oggetti_imposta into dummy;
         found := cfk3_oggetti_imposta%FOUND;
         close cfk3_oggetti_imposta;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Ruoli Contribuente. La registrazione di Oggetti Imposta non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_IMPOSTA" non modificabile se esistono referenze su "FAMILIARI_OGIM"
      if (OLD_OGGETTO_IMPOSTA != NEW_OGGETTO_IMPOSTA) then
         open  cfk4_oggetti_imposta(OLD_OGGETTO_IMPOSTA);
         fetch cfk4_oggetti_imposta into dummy;
         found := cfk4_oggetti_imposta%FOUND;
         close cfk4_oggetti_imposta;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Familiari OGIM. La registrazione di Oggetti Imposta non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_IMPOSTA" non modificabile se esistono referenze su "DETRAZIONI_FIGLI_OGIM"
      if (OLD_OGGETTO_IMPOSTA != NEW_OGGETTO_IMPOSTA) then
         open  cfk5_oggetti_imposta(OLD_OGGETTO_IMPOSTA);
         fetch cfk5_oggetti_imposta into dummy;
         found := cfk5_oggetti_imposta%FOUND;
         close cfk5_oggetti_imposta;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Detrazioni Figli OGIM. La registrazione di Oggetti Imposta non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_IMPOSTA_PU */
/

-- Trigger OGGETTI_IMPOSTA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table OGGETTI_IMPOSTA

create or replace trigger OGGETTI_IMPOSTA_TIU
before INSERT
    or UPDATE
on OGGETTI_IMPOSTA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      OGGETTI_IMPOSTA_DI(:new.tipo_aliquota,:new.aliquota,:new.oggetto_pratica,:new.tipo_tributo);
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.oggetto_imposta is null then
       OGGETTI_IMPOSTA_NR (:new.oggetto_imposta);
    end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         OGGETTI_IMPOSTA_PU(:OLD.OGGETTO_IMPOSTA,
                            :OLD.COD_FISCALE,
                            :OLD.OGGETTO_PRATICA,
                            :OLD.TIPO_ALIQUOTA,
                            :OLD.RUOLO,
                            :OLD.FATTURA,
                            :OLD.TIPO_TRIBUTO,
                         :NEW.OGGETTO_IMPOSTA,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.TIPO_ALIQUOTA,
                         :NEW.RUOLO,
                         :NEW.FATTURA,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         OGGETTI_IMPOSTA_PI(:NEW.COD_FISCALE,
                            :NEW.OGGETTO_PRATICA,
                            :NEW.TIPO_ALIQUOTA,
                            :NEW.RUOLO,
                            :NEW.FATTURA,
                            :NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "OGGETTI_IMPOSTA"
            cursor cpk_oggetti_imposta(var_OGGETTO_IMPOSTA number) is
               select 1
                 from   OGGETTI_IMPOSTA
                where  OGGETTO_IMPOSTA = var_OGGETTO_IMPOSTA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "OGGETTI_IMPOSTA"
               if :new.OGGETTO_IMPOSTA is not null then
                  open  cpk_oggetti_imposta(:new.OGGETTO_IMPOSTA);
                  fetch cpk_oggetti_imposta into dummy;
                  found := cpk_oggetti_imposta%FOUND;
                  close cpk_oggetti_imposta;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO_IMPOSTA||
                               '" gia'' presente in Oggetti Imposta. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            IF :new.flag_calcolo is null THEN
               OGGETTI_IMPOSTA_FI (:new.cod_fiscale,:new.anno,
                                   :old.oggetto_pratica,:new.oggetto_pratica,
                                   :old.imposta,:new.imposta,
				   :old.imposta_dovuta,:new.imposta_dovuta);
            END IF;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_IMPOSTA_TIU */
/

-- Procedure OGGETTI_IMPOSTA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI_IMPOSTA

create or replace procedure OGGETTI_IMPOSTA_PD
(old_oggetto_imposta IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk1_oggetti_imposta(var_oggetto_imposta number) is
      select 1
      from   VERSAMENTI
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_CONTRIBUENTE"
   cursor cfk2_oggetti_imposta(var_oggetto_imposta number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "OGGETTI_IMPOSTA" if children still exist in "VERSAMENTI"
      open  cfk1_oggetti_imposta(OLD_OGGETTO_IMPOSTA);
      fetch cfk1_oggetti_imposta into dummy;
      found := cfk1_oggetti_imposta%FOUND;
      close cfk1_oggetti_imposta;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Oggetti Imposta non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "OGGETTI_IMPOSTA" if children still exist in "RUOLI_CONTRIBUENTE"
      open  cfk2_oggetti_imposta(OLD_OGGETTO_IMPOSTA);
      fetch cfk2_oggetti_imposta into dummy;
      found := cfk2_oggetti_imposta%FOUND;
      close cfk2_oggetti_imposta;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Contribuente. La registrazione di Oggetti Imposta non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_IMPOSTA_PD */
/

-- Tigger OGGETTI_IMPOSTA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI_IMPOSTA

create or replace trigger OGGETTI_IMPOSTA_TD
before DELETE
on OGGETTI_IMPOSTA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            IF :old.flag_calcolo is null THEN
               OGGETTI_IMPOSTA_FI (:old.cod_fiscale,:old.anno,
                                   :old.oggetto_pratica,:new.oggetto_pratica,
                                   :old.imposta,:new.imposta,
				   :old.imposta_dovuta,:new.imposta_dovuta);
            END IF;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: VERSAMENTI

      -- Child Restrict Table: RUOLI_CONTRIBUENTE

      OGGETTI_IMPOSTA_PD(:OLD.OGGETTO_IMPOSTA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "RATE_IMPOSTA"
      delete RATE_IMPOSTA
      where  OGGETTO_IMPOSTA = :OLD.OGGETTO_IMPOSTA;

      --  Delete all children in "FAMILIARI_OGIM"
      delete FAMILIARI_OGIM
      where  OGGETTO_IMPOSTA = :OLD.OGGETTO_IMPOSTA;

      --  Delete all children in "DETRAZIONI_FIGLI_OGIM"
      delete DETRAZIONI_FIGLI_OGIM
      where  OGGETTO_IMPOSTA = :OLD.OGGETTO_IMPOSTA;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_IMPOSTA_TD */
/

-- Procedure OGGETTI_OGIM_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table OGGETTI_OGIM

create or replace procedure OGGETTI_OGIM_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_CONTRIBUENTE"
   cursor cpk1_oggetti_ogim(var_cod_fiscale varchar,
                            var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_oggetti_ogim(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si inserisce su "OGGETTI_OGIM"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO_PRATICA is not null then
            open  cpk1_oggetti_ogim(NEW_COD_FISCALE,
                                    NEW_OGGETTO_PRATICA);
            fetch cpk1_oggetti_ogim into dummy;
            found := cpk1_oggetti_ogim%FOUND;
            close cpk1_oggetti_ogim;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Oggetti OGIM non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "OGGETTI_OGIM"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_oggetti_ogim(NEW_TIPO_TRIBUTO);
            fetch cpk2_oggetti_ogim into dummy;
            found := cpk2_oggetti_ogim%FOUND;
            close cpk2_oggetti_ogim;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Oggetti OGIM non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_OGIM_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table OGGETTI_OGIM
/* End Trigger: OGGETTI_OGIM_TC */

-- Procedure OGGETTI_OGIM_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table OGGETTI_OGIM

create or replace procedure OGGETTI_OGIM_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_oggetto_pratica IN number,
 old_sequenza IN number,
 old_tipo_tributo IN varchar,
 new_cod_fiscale IN varchar,
 new_anno IN number,
 new_oggetto_pratica IN number,
 new_sequenza IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_CONTRIBUENTE"
   cursor cpk1_oggetti_ogim(var_cod_fiscale varchar,
                            var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_oggetti_ogim(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si modifica "OGGETTI_OGIM"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_oggetti_ogim(NEW_COD_FISCALE,
                                    NEW_OGGETTO_PRATICA);
            fetch cpk1_oggetti_ogim into dummy;
            found := cpk1_oggetti_ogim%FOUND;
            close cpk1_oggetti_ogim;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione Oggetti OGIM non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "OGGETTI_OGIM"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_oggetti_ogim(NEW_TIPO_TRIBUTO);
            fetch cpk2_oggetti_ogim into dummy;
            found := cpk2_oggetti_ogim%FOUND;
            close cpk2_oggetti_ogim;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Oggetti OGIM non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_OGIM_PU */
/

-- Trigger OGGETTI_OGIM_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table OGGETTI_OGIM

create or replace trigger OGGETTI_OGIM_TIU
before INSERT
    or UPDATE
on OGGETTI_OGIM
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         OGGETTI_OGIM_PU(:OLD.COD_FISCALE,
                         :OLD.ANNO,
                         :OLD.OGGETTO_PRATICA,
                         :OLD.SEQUENZA,
                         :OLD.TIPO_TRIBUTO,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.SEQUENZA,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         OGGETTI_OGIM_PI(:NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "OGGETTI_OGIM"
            cursor cpk_oggetti_ogim(var_COD_FISCALE varchar,
                                    var_ANNO number,
                                    var_OGGETTO_PRATICA number,
                                    var_SEQUENZA number) is
               select 1
                 from   OGGETTI_OGIM
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "OGGETTI_OGIM"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null and
                  :new.OGGETTO_PRATICA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_oggetti_ogim(:new.COD_FISCALE,
                                         :new.ANNO,
                                         :new.OGGETTO_PRATICA,
                                         :new.SEQUENZA);
                  fetch cpk_oggetti_ogim into dummy;
                  found := cpk_oggetti_ogim%FOUND;
                  close cpk_oggetti_ogim;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||' '||
                               :new.OGGETTO_PRATICA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Oggetti OGIM. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_OGIM_TIU */
/

-- Procedure OGGETTI_PRATICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table OGGETTI_PRATICA

create or replace procedure OGGETTI_PRATICA_PI
(new_oggetto IN number,
 new_pratica IN number,
 new_tributo IN number,
 new_categoria IN number,
 new_anno IN number,
 new_tipo_tariffa IN number,
 new_categoria_catasto IN varchar,
 new_fonte IN number,
 new_settore IN number,
 new_classe_sup IN number,
 new_oggetto_pratica_rif IN number,
 new_oggetto_pratica_rif_v IN number,
 new_tipo_oggetto IN number,
 new_oggetto_pratica_rif_ap IN number,
 new_tipo_riduzione IN number,
 new_tip_tipo_riduzione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk1_oggetti_pratica(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FONTI"
   cursor cpk2_oggetti_pratica(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE_CATASTO"
   cursor cpk3_oggetti_pratica(var_categoria_catasto varchar) is
      select 1
      from   CATEGORIE_CATASTO
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk4_oggetti_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_TRIBUTO"
   cursor cpk5_oggetti_pratica(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk6_oggetti_pratica(var_oggetto_pratica_rif number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica_rif
       and   var_oggetto_pratica_rif is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TARIFFE"
   cursor cpk7_oggetti_pratica(var_tributo number,
                               var_categoria number,
                               var_anno number,
                               var_tipo_tariffa number) is
      select 1
      from   TARIFFE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   ANNO = var_anno
       and   TIPO_TARIFFA = var_tipo_tariffa
       and   var_tributo is not null
       and   var_categoria is not null
       and   var_anno is not null
       and   var_tipo_tariffa is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CLASSI_SUPERFICIE"
   cursor cpk8_oggetti_pratica(var_anno number,
                               var_settore number,
                               var_classe_sup number) is
      select 1
      from   CLASSI_SUPERFICIE
      where  ANNO = var_anno
       and   SETTORE = var_settore
       and   CLASSE = var_classe_sup
       and   var_anno is not null
       and   var_settore is not null
       and   var_classe_sup is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SETTORI_ATTIVITA"
   cursor cpk9_oggetti_pratica(var_settore number) is
      select 1
      from   SETTORI_ATTIVITA
      where  SETTORE = var_settore
       and   var_settore is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk10_oggetti_pratica(var_oggetto_pratica_rif_v number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica_rif_v
       and   var_oggetto_pratica_rif_v is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_OGGETTO"
   cursor cpk11_oggetti_pratica(var_tipo_oggetto number) is
      select 1
      from   TIPI_OGGETTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk12_oggetti_pratica(var_oggetto_pratica_rif_ap number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica_rif_ap
       and   var_oggetto_pratica_rif_ap is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_RIDUZIONE"
   cursor cpk13_oggetti_pratica(var_tipo_riduzione number) is
      select 1
      from   TIPI_RIDUZIONE
      where  TIPO_RIDUZIONE = var_tipo_riduzione
       and   var_tipo_riduzione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ESENZIONE"
   cursor cpk14_oggetti_pratica(var_tip_tipo_riduzione number) is
      select 1
      from   TIPI_ESENZIONE
      where  TIPO_ESENZIONE = var_tip_tipo_riduzione
       and   var_tip_tipo_riduzione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_OGGETTO is not null then
            open  cpk1_oggetti_pratica(NEW_OGGETTO);
            fetch cpk1_oggetti_pratica into dummy;
            found := cpk1_oggetti_pratica%FOUND;
            close cpk1_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_FONTE is not null then
            open  cpk2_oggetti_pratica(NEW_FONTE);
            fetch cpk2_oggetti_pratica into dummy;
            found := cpk2_oggetti_pratica%FOUND;
            close cpk2_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE_CATASTO" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_CATEGORIA_CATASTO is not null then
            open  cpk3_oggetti_pratica(NEW_CATEGORIA_CATASTO);
            fetch cpk3_oggetti_pratica into dummy;
            found := cpk3_oggetti_pratica%FOUND;
            close cpk3_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie Catasto. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_PRATICA is not null then
            open  cpk4_oggetti_pratica(NEW_PRATICA);
            fetch cpk4_oggetti_pratica into dummy;
            found := cpk4_oggetti_pratica%FOUND;
            close cpk4_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_TRIBUTO is not null then
            open  cpk5_oggetti_pratica(NEW_TRIBUTO);
            fetch cpk5_oggetti_pratica into dummy;
            found := cpk5_oggetti_pratica%FOUND;
            close cpk5_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_OGGETTO_PRATICA_RIF is not null then
            open  cpk6_oggetti_pratica(NEW_OGGETTO_PRATICA_RIF);
            fetch cpk6_oggetti_pratica into dummy;
            found := cpk6_oggetti_pratica%FOUND;
            close cpk6_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TARIFFE" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_TRIBUTO is not null and
            NEW_CATEGORIA is not null and
            NEW_ANNO is not null and
            NEW_TIPO_TARIFFA is not null then
            open  cpk7_oggetti_pratica(NEW_TRIBUTO,
                                       NEW_CATEGORIA,
                                       NEW_ANNO,
                                       NEW_TIPO_TARIFFA);
            fetch cpk7_oggetti_pratica into dummy;
            found := cpk7_oggetti_pratica%FOUND;
            close cpk7_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tariffe. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CLASSI_SUPERFICIE" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_ANNO is not null and
            NEW_SETTORE is not null and
            NEW_CLASSE_SUP is not null then
            open  cpk8_oggetti_pratica(NEW_ANNO,
                                       NEW_SETTORE,
                                       NEW_CLASSE_SUP);
            fetch cpk8_oggetti_pratica into dummy;
            found := cpk8_oggetti_pratica%FOUND;
            close cpk8_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su CLASSI_SUPERFICIE. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SETTORI_ATTIVITA" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_SETTORE is not null then
            open  cpk9_oggetti_pratica(NEW_SETTORE);
            fetch cpk9_oggetti_pratica into dummy;
            found := cpk9_oggetti_pratica%FOUND;
            close cpk9_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SETTORI_ATTIVITA. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_OGGETTO_PRATICA_RIF_V is not null then
            open  cpk10_oggetti_pratica(NEW_OGGETTO_PRATICA_RIF_V);
            fetch cpk10_oggetti_pratica into dummy;
            found := cpk10_oggetti_pratica%FOUND;
            close cpk10_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_OGGETTO" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_TIPO_OGGETTO is not null then
            open  cpk11_oggetti_pratica(NEW_TIPO_OGGETTO);
            fetch cpk11_oggetti_pratica into dummy;
            found := cpk11_oggetti_pratica%FOUND;
            close cpk11_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Oggetto. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_OGGETTO_PRATICA_RIF_AP is not null then
            open  cpk12_oggetti_pratica(NEW_OGGETTO_PRATICA_RIF_AP);
            fetch cpk12_oggetti_pratica into dummy;
            found := cpk12_oggetti_pratica%FOUND;
            close cpk12_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_RIDUZIONE" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_TIPO_RIDUZIONE is not null then
            open  cpk13_oggetti_pratica(NEW_TIPO_RIDUZIONE);
            fetch cpk13_oggetti_pratica into dummy;
            found := cpk13_oggetti_pratica%FOUND;
            close cpk13_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su TIPI_RIDUZIONE. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ESENZIONE" deve esistere quando si inserisce su "OGGETTI_PRATICA"
         if NEW_TIP_TIPO_RIDUZIONE is not null then
            open  cpk14_oggetti_pratica(NEW_TIP_TIPO_RIDUZIONE);
            fetch cpk14_oggetti_pratica into dummy;
            found := cpk14_oggetti_pratica%FOUND;
            close cpk14_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su TIPI_ESENZIONE. La registrazione Oggetti Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_PRATICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table OGGETTI_PRATICA

create or replace trigger OGGETTI_PRATICA_TB
before INSERT
    or UPDATE
    or DELETE
on OGGETTI_PRATICA
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: OGGETTI_PRATICA_TB */
/

create or replace trigger OGGETTI_PRATICA_TC
after INSERT
   or UPDATE
   or DELETE
on OGGETTI_PRATICA
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: OGGETTI_PRATICA_TC */
/

-- Procedure OGGETTI_PRATICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table OGGETTI_PRATICA

create or replace procedure OGGETTI_PRATICA_PU
(old_oggetto_pratica IN number,
 old_oggetto IN number,
 old_pratica IN number,
 old_tributo IN number,
 old_categoria IN number,
 old_anno IN number,
 old_tipo_tariffa IN number,
 old_categoria_catasto IN varchar,
 old_fonte IN number,
 old_settore IN number,
 old_classe_sup IN number,
 old_oggetto_pratica_rif IN number,
 old_oggetto_pratica_rif_v IN number,
 old_tipo_oggetto IN number,
 old_oggetto_pratica_rif_ap IN number,
 old_tipo_riduzione IN number,
 old_tip_tipo_riduzione IN number,
 new_oggetto_pratica IN number,
 new_oggetto IN number,
 new_pratica IN number,
 new_tributo IN number,
 new_categoria IN number,
 new_anno IN number,
 new_tipo_tariffa IN number,
 new_categoria_catasto IN varchar,
 new_fonte IN number,
 new_settore IN number,
 new_classe_sup IN number,
 new_oggetto_pratica_rif IN number,
 new_oggetto_pratica_rif_v IN number,
 new_tipo_oggetto IN number,
 new_oggetto_pratica_rif_ap IN number,
 new_tipo_riduzione IN number,
 new_tip_tipo_riduzione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk1_oggetti_pratica(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FONTI"
   cursor cpk2_oggetti_pratica(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE_CATASTO"
   cursor cpk3_oggetti_pratica(var_categoria_catasto varchar) is
      select 1
      from   CATEGORIE_CATASTO
      where  CATEGORIA_CATASTO = var_categoria_catasto
       and   var_categoria_catasto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk4_oggetti_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_TRIBUTO"
   cursor cpk5_oggetti_pratica(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk6_oggetti_pratica(var_oggetto_pratica_rif number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica_rif
       and   var_oggetto_pratica_rif is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TARIFFE"
   cursor cpk7_oggetti_pratica(var_tributo number,
                               var_categoria number,
                               var_anno number,
                               var_tipo_tariffa number) is
      select 1
      from   TARIFFE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   ANNO = var_anno
       and   TIPO_TARIFFA = var_tipo_tariffa
       and   var_tributo is not null
       and   var_categoria is not null
       and   var_anno is not null
       and   var_tipo_tariffa is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CLASSI_SUPERFICIE"
   cursor cpk8_oggetti_pratica(var_anno number,
                               var_settore number,
                               var_classe_sup number) is
      select 1
      from   CLASSI_SUPERFICIE
      where  ANNO = var_anno
       and   SETTORE = var_settore
       and   CLASSE = var_classe_sup
       and   var_anno is not null
       and   var_settore is not null
       and   var_classe_sup is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SETTORI_ATTIVITA"
   cursor cpk9_oggetti_pratica(var_settore number) is
      select 1
      from   SETTORI_ATTIVITA
      where  SETTORE = var_settore
       and   var_settore is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk10_oggetti_pratica(var_oggetto_pratica_rif_v number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica_rif_v
       and   var_oggetto_pratica_rif_v is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_OGGETTO"
   cursor cpk11_oggetti_pratica(var_tipo_oggetto number) is
      select 1
      from   TIPI_OGGETTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk12_oggetti_pratica(var_oggetto_pratica_rif_ap number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica_rif_ap
       and   var_oggetto_pratica_rif_ap is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_RIDUZIONE"
   cursor cpk13_oggetti_pratica(var_tipo_riduzione number) is
      select 1
      from   TIPI_RIDUZIONE
      where  TIPO_RIDUZIONE = var_tipo_riduzione
       and   var_tipo_riduzione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ESENZIONE"
   cursor cpk14_oggetti_pratica(var_tip_tipo_riduzione number) is
      select 1
      from   TIPI_ESENZIONE
      where  TIPO_ESENZIONE = var_tip_tipo_riduzione
       and   var_tip_tipo_riduzione is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_CONTRIBUENTE"
   cursor cfk1_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_ICI_93"
   cursor cfk2_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_ICI_93
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SANZIONI_PRATICA"
   cursor cfk3_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   SANZIONI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "PARTIZIONI_OGGETTO_PRATICA"
   cursor cfk4_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   PARTIZIONI_OGGETTO_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "COSTI_STORICI"
   cursor cfk5_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   COSTI_STORICI
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "COMPENSAZIONI_RUOLO"
   cursor cfk6_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   COMPENSAZIONI_RUOLO
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SGRAVI"
   cursor cfk7_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   SGRAVI
      where  OGPR_SGRAVIO = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk1_oggetti_pratica(NEW_OGGETTO);
            fetch cpk1_oggetti_pratica into dummy;
            found := cpk1_oggetti_pratica%FOUND;
            close cpk1_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_FONTE is not null and ( seq = 0 )
         and (   (NEW_FONTE != OLD_FONTE or OLD_FONTE is null) ) then
            open  cpk2_oggetti_pratica(NEW_FONTE);
            fetch cpk2_oggetti_pratica into dummy;
            found := cpk2_oggetti_pratica%FOUND;
            close cpk2_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE_CATASTO" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_CATEGORIA_CATASTO is not null and ( seq = 0 )
         and (   (NEW_CATEGORIA_CATASTO != OLD_CATEGORIA_CATASTO or OLD_CATEGORIA_CATASTO is null) ) then
            open  cpk3_oggetti_pratica(NEW_CATEGORIA_CATASTO);
            fetch cpk3_oggetti_pratica into dummy;
            found := cpk3_oggetti_pratica%FOUND;
            close cpk3_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie Catasto. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk4_oggetti_pratica(NEW_PRATICA);
            fetch cpk4_oggetti_pratica into dummy;
            found := cpk4_oggetti_pratica%FOUND;
            close cpk4_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null) ) then
            open  cpk5_oggetti_pratica(NEW_TRIBUTO);
            fetch cpk5_oggetti_pratica into dummy;
            found := cpk5_oggetti_pratica%FOUND;
            close cpk5_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_OGGETTO_PRATICA_RIF is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA_RIF != OLD_OGGETTO_PRATICA_RIF or OLD_OGGETTO_PRATICA_RIF is null) ) then
            open  cpk6_oggetti_pratica(NEW_OGGETTO_PRATICA_RIF);
            fetch cpk6_oggetti_pratica into dummy;
            found := cpk6_oggetti_pratica%FOUND;
            close cpk6_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TARIFFE" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_TRIBUTO is not null and
             NEW_CATEGORIA is not null and
             NEW_ANNO is not null and
             NEW_TIPO_TARIFFA is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null)
              or (NEW_CATEGORIA != OLD_CATEGORIA or OLD_CATEGORIA is null)
              or (NEW_ANNO != OLD_ANNO or OLD_ANNO is null)
              or (NEW_TIPO_TARIFFA != OLD_TIPO_TARIFFA or OLD_TIPO_TARIFFA is null) ) then
            open  cpk7_oggetti_pratica(NEW_TRIBUTO,
                                       NEW_CATEGORIA,
                                       NEW_ANNO,
                                       NEW_TIPO_TARIFFA);
            fetch cpk7_oggetti_pratica into dummy;
            found := cpk7_oggetti_pratica%FOUND;
            close cpk7_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tariffe. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CLASSI_SUPERFICIE" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_ANNO is not null and
             NEW_SETTORE is not null and
             NEW_CLASSE_SUP is not null and ( seq = 0 )
         and (   (NEW_ANNO != OLD_ANNO or OLD_ANNO is null)
              or (NEW_SETTORE != OLD_SETTORE or OLD_SETTORE is null)
              or (NEW_CLASSE_SUP != OLD_CLASSE_SUP or OLD_CLASSE_SUP is null) ) then
            open  cpk8_oggetti_pratica(NEW_ANNO,
                                       NEW_SETTORE,
                                       NEW_CLASSE_SUP);
            fetch cpk8_oggetti_pratica into dummy;
            found := cpk8_oggetti_pratica%FOUND;
            close cpk8_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su CLASSI_SUPERFICIE. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SETTORI_ATTIVITA" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_SETTORE is not null and ( seq = 0 )
         and (   (NEW_SETTORE != OLD_SETTORE or OLD_SETTORE is null) ) then
            open  cpk9_oggetti_pratica(NEW_SETTORE);
            fetch cpk9_oggetti_pratica into dummy;
            found := cpk9_oggetti_pratica%FOUND;
            close cpk9_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SETTORI_ATTIVITA. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_OGGETTO_PRATICA_RIF_V is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA_RIF_V != OLD_OGGETTO_PRATICA_RIF_V or OLD_OGGETTO_PRATICA_RIF_V is null) ) then
            open  cpk10_oggetti_pratica(NEW_OGGETTO_PRATICA_RIF_V);
            fetch cpk10_oggetti_pratica into dummy;
            found := cpk10_oggetti_pratica%FOUND;
            close cpk10_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_OGGETTO" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_TIPO_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_OGGETTO != OLD_TIPO_OGGETTO or OLD_TIPO_OGGETTO is null) ) then
            open  cpk11_oggetti_pratica(NEW_TIPO_OGGETTO);
            fetch cpk11_oggetti_pratica into dummy;
            found := cpk11_oggetti_pratica%FOUND;
            close cpk11_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Oggetto. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_OGGETTO_PRATICA_RIF_AP is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA_RIF_AP != OLD_OGGETTO_PRATICA_RIF_AP or OLD_OGGETTO_PRATICA_RIF_AP is null) ) then
            open  cpk12_oggetti_pratica(NEW_OGGETTO_PRATICA_RIF_AP);
            fetch cpk12_oggetti_pratica into dummy;
            found := cpk12_oggetti_pratica%FOUND;
            close cpk12_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_RIDUZIONE" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_TIPO_RIDUZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_RIDUZIONE != OLD_TIPO_RIDUZIONE or OLD_TIPO_RIDUZIONE is null) ) then
            open  cpk13_oggetti_pratica(NEW_TIPO_RIDUZIONE);
            fetch cpk13_oggetti_pratica into dummy;
            found := cpk13_oggetti_pratica%FOUND;
            close cpk13_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su TIPI_RIDUZIONE. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ESENZIONE" deve esistere quando si modifica "OGGETTI_PRATICA"
         if  NEW_TIP_TIPO_RIDUZIONE is not null and ( seq = 0 )
         and (   (NEW_TIP_TIPO_RIDUZIONE != OLD_TIP_TIPO_RIDUZIONE or OLD_TIP_TIPO_RIDUZIONE is null) ) then
            open  cpk14_oggetti_pratica(NEW_TIP_TIPO_RIDUZIONE);
            fetch cpk14_oggetti_pratica into dummy;
            found := cpk14_oggetti_pratica%FOUND;
            close cpk14_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su TIPI_ESENZIONE. La registrazione Oggetti Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "OGGETTI_PRATICA" non modificabile se esistono referenze su "OGGETTI_CONTRIBUENTE"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         open  cfk1_oggetti_pratica(OLD_OGGETTO_PRATICA);
         fetch cfk1_oggetti_pratica into dummy;
         found := cfk1_oggetti_pratica%FOUND;
         close cfk1_oggetti_pratica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Contribuente. La registrazione di Oggetti Pratica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_PRATICA" non modificabile se esistono referenze su "OGGETTI_ICI_93"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         open  cfk2_oggetti_pratica(OLD_OGGETTO_PRATICA);
         fetch cfk2_oggetti_pratica into dummy;
         found := cfk2_oggetti_pratica%FOUND;
         close cfk2_oggetti_pratica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti ICI 93. La registrazione di Oggetti Pratica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_PRATICA" non modificabile se esistono referenze su "SANZIONI_PRATICA"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         open  cfk3_oggetti_pratica(OLD_OGGETTO_PRATICA);
         fetch cfk3_oggetti_pratica into dummy;
         found := cfk3_oggetti_pratica%FOUND;
         close cfk3_oggetti_pratica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sanzioni Pratica. La registrazione di Oggetti Pratica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_PRATICA" non modificabile se esistono referenze su "PARTIZIONI_OGGETTO_PRATICA"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         open  cfk4_oggetti_pratica(OLD_OGGETTO_PRATICA);
         fetch cfk4_oggetti_pratica into dummy;
         found := cfk4_oggetti_pratica%FOUND;
         close cfk4_oggetti_pratica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Partizioni Oggetto Pratica. La registrazione di Oggetti Pratica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_PRATICA" non modificabile se esistono referenze su "COSTI_STORICI"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         open  cfk5_oggetti_pratica(OLD_OGGETTO_PRATICA);
         fetch cfk5_oggetti_pratica into dummy;
         found := cfk5_oggetti_pratica%FOUND;
         close cfk5_oggetti_pratica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Costi Storici. La registrazione di Oggetti Pratica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_PRATICA" non modificabile se esistono referenze su "COMPENSAZIONI_RUOLO"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         open  cfk6_oggetti_pratica(OLD_OGGETTO_PRATICA);
         fetch cfk6_oggetti_pratica into dummy;
         found := cfk6_oggetti_pratica%FOUND;
         close cfk6_oggetti_pratica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Compensazioni Ruolo. La registrazione di Oggetti Pratica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "OGGETTI_PRATICA" non modificabile se esistono referenze su "SGRAVI"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         open  cfk7_oggetti_pratica(OLD_OGGETTO_PRATICA);
         fetch cfk7_oggetti_pratica into dummy;
         found := cfk7_oggetti_pratica%FOUND;
         close cfk7_oggetti_pratica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sgravi. La registrazione di Oggetti Pratica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_PRATICA_PU */
/

-- Trigger OGGETTI_PRATICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table OGGETTI_PRATICA

create or replace trigger OGGETTI_PRATICA_TIU
before INSERT
    or UPDATE
on OGGETTI_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      OGGETTI_PRATICA_DI (:new.inizio_concessione,:new.fine_concessione);
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.oggetto_pratica is null then
       OGGETTI_PRATICA_NR (:new.oggetto_pratica);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         OGGETTI_PRATICA_PU(:OLD.OGGETTO_PRATICA,
                            :OLD.OGGETTO,
                            :OLD.PRATICA,
                            :OLD.TRIBUTO,
                            :OLD.CATEGORIA,
                            :OLD.ANNO,
                            :OLD.TIPO_TARIFFA,
                            :OLD.CATEGORIA_CATASTO,
                            :OLD.FONTE,
                            :OLD.SETTORE,
                            :OLD.CLASSE_SUP,
                            :OLD.OGGETTO_PRATICA_RIF,
                            :OLD.OGGETTO_PRATICA_RIF_V,
                            :OLD.TIPO_OGGETTO,
                            :OLD.OGGETTO_PRATICA_RIF_AP,
                            :OLD.TIPO_RIDUZIONE,
                            :OLD.TIP_TIPO_RIDUZIONE,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.OGGETTO,
                         :NEW.PRATICA,
                         :NEW.TRIBUTO,
                         :NEW.CATEGORIA,
                         :NEW.ANNO,
                         :NEW.TIPO_TARIFFA,
                         :NEW.CATEGORIA_CATASTO,
                         :NEW.FONTE,
                         :NEW.SETTORE,
                         :NEW.CLASSE_SUP,
                         :NEW.OGGETTO_PRATICA_RIF,
                         :NEW.OGGETTO_PRATICA_RIF_V,
                         :NEW.TIPO_OGGETTO,
                         :NEW.OGGETTO_PRATICA_RIF_AP,
                         :NEW.TIPO_RIDUZIONE,
                         :NEW.TIP_TIPO_RIDUZIONE);
         null;
      end if;
      if INSERTING then
         OGGETTI_PRATICA_PI(:NEW.OGGETTO,
                            :NEW.PRATICA,
                            :NEW.TRIBUTO,
                            :NEW.CATEGORIA,
                            :NEW.ANNO,
                            :NEW.TIPO_TARIFFA,
                            :NEW.CATEGORIA_CATASTO,
                            :NEW.FONTE,
                            :NEW.SETTORE,
                            :NEW.CLASSE_SUP,
                            :NEW.OGGETTO_PRATICA_RIF,
                            :NEW.OGGETTO_PRATICA_RIF_V,
                            :NEW.TIPO_OGGETTO,
                            :NEW.OGGETTO_PRATICA_RIF_AP,
                            :NEW.TIPO_RIDUZIONE,
                            :NEW.TIP_TIPO_RIDUZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "OGGETTI_PRATICA"
            cursor cpk_oggetti_pratica(var_OGGETTO_PRATICA number) is
               select 1
                 from   OGGETTI_PRATICA
                where  OGGETTO_PRATICA = var_OGGETTO_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "OGGETTI_PRATICA"
               if :new.OGGETTO_PRATICA is not null then
                  open  cpk_oggetti_pratica(:new.OGGETTO_PRATICA);
                  fetch cpk_oggetti_pratica into dummy;
                  found := cpk_oggetti_pratica%FOUND;
                  close cpk_oggetti_pratica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO_PRATICA||
                               '" gia'' presente in Oggetti Pratica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin -- Set PostEvent Check REFERENTIAL Integrity at Level 0
      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
      IF IntegrityPackage.GetNestLevel = 0 THEN
         --
         -- Integrità Referenziale di Esistenza FK
         --
         IF INSERTING THEN
            --
            -- Integrità Referenziale di Esistenza su insert FK
            --

            a_istruzione := 'BEGIN AGGIORNA_TIPO_VIOLAZIONE('||:new.pratica||','||nvl(:new.oggetto_pratica_rif,-1)||',''I''); END;';
            a_messaggio := '';
            IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

            IF :new.oggetto_pratica_rif is NOT null THEN
               a_istruzione := 'select 1 from oggetti_pratica where oggetto_pratica = '
                               || :new.oggetto_pratica_rif;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;
            IF :new.oggetto_pratica_rif_v is NOT null THEN
               a_istruzione := 'select 1 from oggetti_pratica where oggetto_pratica = '
                               || :new.oggetto_pratica_rif_v;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;
            IF :new.oggetto_pratica_rif_ap is NOT null THEN
               a_istruzione := 'select 1 from oggetti_pratica where oggetto_pratica = '
                               || :new.oggetto_pratica_rif_ap;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;
         ELSIF UPDATING THEN
            IF nvl(:new.oggetto_pratica_rif,-1) != nvl(:old.oggetto_pratica_rif ,-1) THEN
               --
               -- Integrità Referenziale di Esistenza su update FK
               --
               IF :new.oggetto_pratica_rif is NOT null THEN
                  a_istruzione := 'select 1 from oggetti_pratica where oggetto_pratica = '
                                  ||:new.oggetto_pratica_rif;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;
            IF nvl(:new.oggetto_pratica_rif_v,-1) != nvl(:old.oggetto_pratica_rif_v ,-1) THEN
               --
               -- Integrità Referenziale di Esistenza su update FK
               --
               IF :new.oggetto_pratica_rif_v is NOT null THEN
                  a_istruzione := 'select 1 from oggetti_pratica where oggetto_pratica = '
                                  ||:new.oggetto_pratica_rif_v;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;
            IF nvl(:new.oggetto_pratica_rif_ap,-1) != nvl(:old.oggetto_pratica_rif_ap ,-1) THEN
               --
               -- Integrità Referenziale di Esistenza su update FK
               --
               IF :new.oggetto_pratica_rif_ap is NOT null THEN
                  a_istruzione := 'select 1 from oggetti_pratica where oggetto_pratica = '
                                  ||:new.oggetto_pratica_rif_ap;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;
         END IF;
      END IF;
      IF UPDATING THEN
         IF :new.oggetto_pratica != :old.oggetto_pratica THEN
            --
            -- Integrità Referenziale su update PK
            --

            /* Caso di RESTRICT UPDATE */

               a_istruzione := 'select 0 from oggetti_pratica where oggetto_pratica_rif = '
                               ||:old.oggetto_pratica ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

               a_istruzione := 'select 0 from oggetti_pratica where oggetto_pratica_rif_v = '
                               ||:old.oggetto_pratica ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

               a_istruzione := 'select 0 from oggetti_pratica where oggetto_pratica_rif_ap = '
                               ||:old.oggetto_pratica ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

            /* Caso di CASCADE UPDATE

               a_istruzione := 'update oggetti_pratica set oggetto_pratica_rif ='
                               ||:new.oggetto_pratica ||' where oggetto_pratica_rif = '
                               ||:old.oggetto_pratica;
               a_messaggio := '';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

               a_istruzione := 'update oggetti_pratica set oggetto_pratica_rif_v ='
                               ||:new.oggetto_pratica ||' where oggetto_pratica_rif_v = '
                               ||:old.oggetto_pratica;
               a_messaggio := '';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

               a_istruzione := 'update oggetti_pratica set oggetto_pratica_rif_ap ='
                               ||:new.oggetto_pratica ||' where oggetto_pratica_rif_ap = '
                               ||:old.oggetto_pratica;
               a_messaggio := '';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

            */

         END IF;
      END IF;
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_PRATICA_TIU */
/

-- Procedure OGGETTI_PRATICA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI_PRATICA

create or replace procedure OGGETTI_PRATICA_PD
(old_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "COMPENSAZIONI_RUOLO"
   cursor cfk1_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   COMPENSAZIONI_RUOLO
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Declaration of DeleteParentRestrict constraint for "SGRAVI"
   cursor cfk2_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   SGRAVI
      where  OGPR_SGRAVIO = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "OGGETTI_PRATICA" if children still exist in "COMPENSAZIONI_RUOLO"
      open  cfk1_oggetti_pratica(OLD_OGGETTO_PRATICA);
      fetch cfk1_oggetti_pratica into dummy;
      found := cfk1_oggetti_pratica%FOUND;
      close cfk1_oggetti_pratica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Compensazioni Ruolo. La registrazione di Oggetti Pratica non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "OGGETTI_PRATICA" if children still exist in "SGRAVI"
      open  cfk2_oggetti_pratica(OLD_OGGETTO_PRATICA);
      fetch cfk2_oggetti_pratica into dummy;
      found := cfk2_oggetti_pratica%FOUND;
      close cfk2_oggetti_pratica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sgravi. La registrazione di Oggetti Pratica non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_PRATICA_PD */
/

-- Tigger OGGETTI_PRATICA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI_PRATICA

create or replace trigger OGGETTI_PRATICA_TD
before DELETE
on OGGETTI_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE at Level 0

      -- Child Restrict Table: COMPENSAZIONI_RUOLO

      -- Child Restrict Table: SGRAVI

      OGGETTI_PRATICA_PD(:OLD.OGGETTO_PRATICA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "OGGETTI_CONTRIBUENTE"
      delete OGGETTI_CONTRIBUENTE
      where  OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "OGGETTI_ICI_93"
      delete OGGETTI_ICI_93
      where  OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "SANZIONI_PRATICA"
      delete SANZIONI_PRATICA
      where  OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "PARTIZIONI_OGGETTO_PRATICA"
      delete PARTIZIONI_OGGETTO_PRATICA
      where  OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;

      --  Delete all children in "COSTI_STORICI"
      delete COSTI_STORICI
      where  OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
       DECLARE a_istruzione  varchar2(2000);
               a_messaggio   varchar2(2000);
        BEGIN
	         BEGIN
               a_messaggio := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Oggetti Pratica non e'' eliminabile.';
               a_istruzione := 'select 0 from oggetti_pratica where oggetto_pratica_rif = '
                               ||:old.oggetto_pratica;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
             EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
             END;
             BEGIN
               a_messaggio := 'Esistono riferimenti su Oggetti Pratica (V). La registrazione di Oggetti Pratica non e'' eliminabile.';
               a_istruzione := 'select 0 from oggetti_pratica where oggetto_pratica_rif_v = '
                               ||:old.oggetto_pratica;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
             EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
             END;
             BEGIN
               a_messaggio := 'Esistono riferimenti su Oggetti Pratica (AP). La registrazione di Oggetti Pratica non e'' eliminabile.';
               a_istruzione := 'select 0 from oggetti_pratica where oggetto_pratica_rif_ap = '
                               ||:old.oggetto_pratica;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
             EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
             END;

             BEGIN
                 a_istruzione := 'BEGIN AGGIORNA_TIPO_VIOLAZIONE('||:old.pratica||','||nvl(:old.oggetto_pratica_rif,-1)||',''D''); END;';
                 a_messaggio := '';
         --   dbms_output.put_line (a_istruzione);
                 IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
             EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
             END;
        end;
    end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_PRATICA_TD */
/

-- Procedure OGGETTI_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table OGGETTI_TRIBUTO

create or replace procedure OGGETTI_TRIBUTO_PI
(new_tipo_tributo IN varchar,
 new_tipo_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_OGGETTO"
   cursor cpk1_oggetti_tributo(var_tipo_oggetto number) is
      select 1
      from   TIPI_OGGETTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_oggetti_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_OGGETTO" deve esistere quando si inserisce su "OGGETTI_TRIBUTO"
         if NEW_TIPO_OGGETTO is not null then
            open  cpk1_oggetti_tributo(NEW_TIPO_OGGETTO);
            fetch cpk1_oggetti_tributo into dummy;
            found := cpk1_oggetti_tributo%FOUND;
            close cpk1_oggetti_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Oggetto. La registrazione Oggetti Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "OGGETTI_TRIBUTO"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_oggetti_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk2_oggetti_tributo into dummy;
            found := cpk2_oggetti_tributo%FOUND;
            close cpk2_oggetti_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Oggetti Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table OGGETTI_TRIBUTO
/* End Trigger: OGGETTI_TRIBUTO_TC */

-- Procedure OGGETTI_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table OGGETTI_TRIBUTO

create or replace procedure OGGETTI_TRIBUTO_PU
(old_tipo_tributo IN varchar,
 old_tipo_oggetto IN number,
 new_tipo_tributo IN varchar,
 new_tipo_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_OGGETTO"
   cursor cpk1_oggetti_tributo(var_tipo_oggetto number) is
      select 1
      from   TIPI_OGGETTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_oggetti_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "RELAZIONI_OGGETTI_CALCOLO"
   cursor cfk1_oggetti_tributo(var_tipo_tributo varchar,
                               var_tipo_oggetto number) is
      select 1
      from   RELAZIONI_OGGETTI_CALCOLO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_tributo is not null
       and   var_tipo_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_OGGETTO" deve esistere quando si modifica "OGGETTI_TRIBUTO"
         if  NEW_TIPO_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_OGGETTO != OLD_TIPO_OGGETTO or OLD_TIPO_OGGETTO is null) ) then
            open  cpk1_oggetti_tributo(NEW_TIPO_OGGETTO);
            fetch cpk1_oggetti_tributo into dummy;
            found := cpk1_oggetti_tributo%FOUND;
            close cpk1_oggetti_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Oggetto. La registrazione Oggetti Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "OGGETTI_TRIBUTO"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_oggetti_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk2_oggetti_tributo into dummy;
            found := cpk2_oggetti_tributo%FOUND;
            close cpk2_oggetti_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Oggetti Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "OGGETTI_TRIBUTO" non modificabile se esistono referenze su "RELAZIONI_OGGETTI_CALCOLO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_TIPO_OGGETTO != NEW_TIPO_OGGETTO) then
         open  cfk1_oggetti_tributo(OLD_TIPO_TRIBUTO,
                                    OLD_TIPO_OGGETTO);
         fetch cfk1_oggetti_tributo into dummy;
         found := cfk1_oggetti_tributo%FOUND;
         close cfk1_oggetti_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su RELAZIONI_OGGETTI_CALCOLO. La registrazione di Oggetti Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_TRIBUTO_PU */
/

-- Trigger OGGETTI_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table OGGETTI_TRIBUTO

create or replace trigger OGGETTI_TRIBUTO_TIU
before INSERT
    or UPDATE
on OGGETTI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         OGGETTI_TRIBUTO_PU(:OLD.TIPO_TRIBUTO,
                            :OLD.TIPO_OGGETTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_OGGETTO);
         null;
      end if;
      if INSERTING then
         OGGETTI_TRIBUTO_PI(:NEW.TIPO_TRIBUTO,
                            :NEW.TIPO_OGGETTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "OGGETTI_TRIBUTO"
            cursor cpk_oggetti_tributo(var_TIPO_TRIBUTO varchar,
                                       var_TIPO_OGGETTO number) is
               select 1
                 from   OGGETTI_TRIBUTO
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       TIPO_OGGETTO = var_TIPO_OGGETTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "OGGETTI_TRIBUTO"
               if :new.TIPO_TRIBUTO is not null and
                  :new.TIPO_OGGETTO is not null then
                  open  cpk_oggetti_tributo(:new.TIPO_TRIBUTO,
                                            :new.TIPO_OGGETTO);
                  fetch cpk_oggetti_tributo into dummy;
                  found := cpk_oggetti_tributo%FOUND;
                  close cpk_oggetti_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.TIPO_OGGETTO||
                               '" gia'' presente in Oggetti Tributo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_TRIBUTO_TIU */
/

-- Procedure OGGETTI_TRIBUTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI_TRIBUTO

create or replace procedure OGGETTI_TRIBUTO_PD
(old_tipo_tributo IN varchar,
 old_tipo_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "RELAZIONI_OGGETTI_CALCOLO"
   cursor cfk1_oggetti_tributo(var_tipo_tributo varchar,
                               var_tipo_oggetto number) is
      select 1
      from   RELAZIONI_OGGETTI_CALCOLO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_tributo is not null
       and   var_tipo_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "OGGETTI_TRIBUTO" if children still exist in "RELAZIONI_OGGETTI_CALCOLO"
      open  cfk1_oggetti_tributo(OLD_TIPO_TRIBUTO,
                                 OLD_TIPO_OGGETTO);
      fetch cfk1_oggetti_tributo into dummy;
      found := cfk1_oggetti_tributo%FOUND;
      close cfk1_oggetti_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su RELAZIONI_OGGETTI_CALCOLO. La registrazione di Oggetti Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: OGGETTI_TRIBUTO_PD */
/

-- Tigger OGGETTI_TRIBUTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table OGGETTI_TRIBUTO

create or replace trigger OGGETTI_TRIBUTO_TD
before DELETE
on OGGETTI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: RELAZIONI_OGGETTI_CALCOLO

      OGGETTI_TRIBUTO_PD(:OLD.TIPO_TRIBUTO,
                         :OLD.TIPO_OGGETTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: OGGETTI_TRIBUTO_TD */
/

-- Procedure PARAMETRI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table PARAMETRI

create or replace procedure PARAMETRI_PU
(old_sessione IN number,
 old_nome_parametro IN varchar,
 old_progressivo IN number,
 new_sessione IN number,
 new_nome_parametro IN varchar,
 new_progressivo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARAMETRI_PU */
/

-- Trigger PARAMETRI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table PARAMETRI

create or replace trigger PARAMETRI_TIU
before INSERT
    or UPDATE
on PARAMETRI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.progressivo is null then
       PARAMETRI_NR (:new.sessione,:new.nome_parametro,:new.progressivo);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         PARAMETRI_PU(:OLD.SESSIONE,
                      :OLD.NOME_PARAMETRO,
                      :OLD.PROGRESSIVO,
                         :NEW.SESSIONE,
                         :NEW.NOME_PARAMETRO,
                         :NEW.PROGRESSIVO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "PARAMETRI"
            cursor cpk_parametri(var_SESSIONE number,
                                 var_NOME_PARAMETRO varchar,
                                 var_PROGRESSIVO number) is
               select 1
                 from   PARAMETRI
                where  SESSIONE = var_SESSIONE and
                       NOME_PARAMETRO = var_NOME_PARAMETRO and
                       PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "PARAMETRI"
               if :new.SESSIONE is not null and
                  :new.NOME_PARAMETRO is not null and
                  :new.PROGRESSIVO is not null then
                  open  cpk_parametri(:new.SESSIONE,
                                      :new.NOME_PARAMETRO,
                                      :new.PROGRESSIVO);
                  fetch cpk_parametri into dummy;
                  found := cpk_parametri%FOUND;
                  close cpk_parametri;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.SESSIONE||' '||
                               :new.NOME_PARAMETRO||' '||
                               :new.PROGRESSIVO||
                               '" gia'' presente in Parametri. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PARAMETRI_TIU */
/

-- Procedure PARAMETRI_EXPORT_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table PARAMETRI_EXPORT

create or replace procedure PARAMETRI_EXPORT_PI
(new_tipo_export IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_EXPORT"
   cursor cpk1_parametri_export(var_tipo_export number) is
      select 1
      from   TIPI_EXPORT
      where  TIPO_EXPORT = var_tipo_export
       and   var_tipo_export is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_EXPORT" deve esistere quando si inserisce su "PARAMETRI_EXPORT"
         if NEW_TIPO_EXPORT is not null then
            open  cpk1_parametri_export(NEW_TIPO_EXPORT);
            fetch cpk1_parametri_export into dummy;
            found := cpk1_parametri_export%FOUND;
            close cpk1_parametri_export;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su TIPI_EXPORT. La registrazione PARAMETRI_EXPORT non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARAMETRI_EXPORT_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table PARAMETRI_EXPORT
/* End Trigger: PARAMETRI_EXPORT_TC */

-- Procedure PARAMETRI_EXPORT_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table PARAMETRI_EXPORT

create or replace procedure PARAMETRI_EXPORT_PU
(old_tipo_export IN number,
 old_parametro_export IN number,
 new_tipo_export IN number,
 new_parametro_export IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_EXPORT"
   cursor cpk1_parametri_export(var_tipo_export number) is
      select 1
      from   TIPI_EXPORT
      where  TIPO_EXPORT = var_tipo_export
       and   var_tipo_export is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_EXPORT" deve esistere quando si modifica "PARAMETRI_EXPORT"
         if  NEW_TIPO_EXPORT is not null and ( seq = 0 )
         and (   (NEW_TIPO_EXPORT != OLD_TIPO_EXPORT or OLD_TIPO_EXPORT is null) ) then
            open  cpk1_parametri_export(NEW_TIPO_EXPORT);
            fetch cpk1_parametri_export into dummy;
            found := cpk1_parametri_export%FOUND;
            close cpk1_parametri_export;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su TIPI_EXPORT. La registrazione PARAMETRI_EXPORT non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARAMETRI_EXPORT_PU */
/

-- Trigger PARAMETRI_EXPORT_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table PARAMETRI_EXPORT

create or replace trigger PARAMETRI_EXPORT_TIU
before INSERT
    or UPDATE
on PARAMETRI_EXPORT
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         PARAMETRI_EXPORT_PU(:OLD.TIPO_EXPORT,
                             :OLD.PARAMETRO_EXPORT,
                         :NEW.TIPO_EXPORT,
                         :NEW.PARAMETRO_EXPORT);
         null;
      end if;
      if INSERTING then
         PARAMETRI_EXPORT_PI(:NEW.TIPO_EXPORT);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "PARAMETRI_EXPORT"
            cursor cpk_parametri_export(var_TIPO_EXPORT number,
                                        var_PARAMETRO_EXPORT number) is
               select 1
                 from   PARAMETRI_EXPORT
                where  TIPO_EXPORT = var_TIPO_EXPORT and
                       PARAMETRO_EXPORT = var_PARAMETRO_EXPORT;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "PARAMETRI_EXPORT"
               if :new.TIPO_EXPORT is not null and
                  :new.PARAMETRO_EXPORT is not null then
                  open  cpk_parametri_export(:new.TIPO_EXPORT,
                                             :new.PARAMETRO_EXPORT);
                  fetch cpk_parametri_export into dummy;
                  found := cpk_parametri_export%FOUND;
                  close cpk_parametri_export;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_EXPORT||' '||
                               :new.PARAMETRO_EXPORT||
                               '" gia'' presente in PARAMETRI_EXPORT. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PARAMETRI_EXPORT_TIU */
/

-- Procedure PARAMETRI_UTENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table PARAMETRI_UTENTE

create or replace procedure PARAMETRI_UTENTE_PI
(new_tipo_parametro IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_PARAMETRO"
   cursor cpk1_parametri_utente(var_tipo_parametro varchar) is
      select 1
      from   TIPI_PARAMETRO
      where  TIPO_PARAMETRO = var_tipo_parametro
       and   var_tipo_parametro is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_PARAMETRO" deve esistere quando si inserisce su "PARAMETRI_UTENTE"
         if NEW_TIPO_PARAMETRO is not null then
            open  cpk1_parametri_utente(NEW_TIPO_PARAMETRO);
            fetch cpk1_parametri_utente into dummy;
            found := cpk1_parametri_utente%FOUND;
            close cpk1_parametri_utente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi_Parametro. La registrazione Parametri Utente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARAMETRI_UTENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table PARAMETRI_UTENTE
/* End Trigger: PARAMETRI_UTENTE_TC */

-- Procedure PARAMETRI_UTENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table PARAMETRI_UTENTE

create or replace procedure PARAMETRI_UTENTE_PU
(old_id IN number,
 old_tipo_parametro IN varchar,
 new_id IN number,
 new_tipo_parametro IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_PARAMETRO"
   cursor cpk1_parametri_utente(var_tipo_parametro varchar) is
      select 1
      from   TIPI_PARAMETRO
      where  TIPO_PARAMETRO = var_tipo_parametro
       and   var_tipo_parametro is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_PARAMETRO" deve esistere quando si modifica "PARAMETRI_UTENTE"
         if  NEW_TIPO_PARAMETRO is not null and ( seq = 0 )
         and (   (NEW_TIPO_PARAMETRO != OLD_TIPO_PARAMETRO or OLD_TIPO_PARAMETRO is null) ) then
            open  cpk1_parametri_utente(NEW_TIPO_PARAMETRO);
            fetch cpk1_parametri_utente into dummy;
            found := cpk1_parametri_utente%FOUND;
            close cpk1_parametri_utente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi_Parametro. La registrazione Parametri Utente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARAMETRI_UTENTE_PU */
/

-- Trigger PARAMETRI_UTENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table PARAMETRI_UTENTE

create or replace trigger PARAMETRI_UTENTE_TIU
before INSERT
    or UPDATE
on PARAMETRI_UTENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id is null then
      PARAMETRI_UTENTE_NR(:new.id);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         PARAMETRI_UTENTE_PU(:OLD.ID,
                             :OLD.TIPO_PARAMETRO,
                         :NEW.ID,
                         :NEW.TIPO_PARAMETRO);
         null;
      end if;
      if INSERTING then
         PARAMETRI_UTENTE_PI(:NEW.TIPO_PARAMETRO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "PARAMETRI_UTENTE"
            cursor cpk_parametri_utente(var_ID number) is
               select 1
                 from   PARAMETRI_UTENTE
                where  ID = var_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "PARAMETRI_UTENTE"
               if :new.ID is not null then
                  open  cpk_parametri_utente(:new.ID);
                  fetch cpk_parametri_utente into dummy;
                  found := cpk_parametri_utente%FOUND;
                  close cpk_parametri_utente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID||
                               '" gia'' presente in Parametri Utente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PARAMETRI_UTENTE_TIU */
/

-- Procedure PARTIZIONI_OGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table PARTIZIONI_OGGETTO

create or replace procedure PARTIZIONI_OGGETTO_PI
(new_oggetto IN number,
 new_tipo_area IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk1_partizioni_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_AREA"
   cursor cpk2_partizioni_oggetto(var_tipo_area number) is
      select 1
      from   TIPI_AREA
      where  TIPO_AREA = var_tipo_area
       and   var_tipo_area is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "PARTIZIONI_OGGETTO"
         if NEW_OGGETTO is not null then
            open  cpk1_partizioni_oggetto(NEW_OGGETTO);
            fetch cpk1_partizioni_oggetto into dummy;
            found := cpk1_partizioni_oggetto%FOUND;
            close cpk1_partizioni_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Partizioni Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_AREA" deve esistere quando si inserisce su "PARTIZIONI_OGGETTO"
         if NEW_TIPO_AREA is not null then
            open  cpk2_partizioni_oggetto(NEW_TIPO_AREA);
            fetch cpk2_partizioni_oggetto into dummy;
            found := cpk2_partizioni_oggetto%FOUND;
            close cpk2_partizioni_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Area. La registrazione Partizioni Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARTIZIONI_OGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table PARTIZIONI_OGGETTO
/* End Trigger: PARTIZIONI_OGGETTO_TC */

-- Procedure PARTIZIONI_OGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table PARTIZIONI_OGGETTO

create or replace procedure PARTIZIONI_OGGETTO_PU
(old_oggetto IN number,
 old_sequenza IN number,
 old_tipo_area IN number,
 new_oggetto IN number,
 new_sequenza IN number,
 new_tipo_area IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk1_partizioni_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_AREA"
   cursor cpk2_partizioni_oggetto(var_tipo_area number) is
      select 1
      from   TIPI_AREA
      where  TIPO_AREA = var_tipo_area
       and   var_tipo_area is not null;

   --  Declaration of UpdateParentRestrict constraint for "CONSISTENZE_TRIBUTO"
   cursor cfk1_partizioni_oggetto(var_oggetto number,
                                  var_sequenza number) is
      select 1
      from   CONSISTENZE_TRIBUTO
      where  OGGETTO = var_oggetto
       and   SEQUENZA = var_sequenza
       and   var_oggetto is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "PARTIZIONI_OGGETTO"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk1_partizioni_oggetto(NEW_OGGETTO);
            fetch cpk1_partizioni_oggetto into dummy;
            found := cpk1_partizioni_oggetto%FOUND;
            close cpk1_partizioni_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Partizioni Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_AREA" deve esistere quando si modifica "PARTIZIONI_OGGETTO"
         if  NEW_TIPO_AREA is not null and ( seq = 0 )
         and (   (NEW_TIPO_AREA != OLD_TIPO_AREA or OLD_TIPO_AREA is null) ) then
            open  cpk2_partizioni_oggetto(NEW_TIPO_AREA);
            fetch cpk2_partizioni_oggetto into dummy;
            found := cpk2_partizioni_oggetto%FOUND;
            close cpk2_partizioni_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Area. La registrazione Partizioni Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "PARTIZIONI_OGGETTO" non modificabile se esistono referenze su "CONSISTENZE_TRIBUTO"
      if (OLD_OGGETTO != NEW_OGGETTO) or
         (OLD_SEQUENZA != NEW_SEQUENZA) then
         open  cfk1_partizioni_oggetto(OLD_OGGETTO,
                                       OLD_SEQUENZA);
         fetch cfk1_partizioni_oggetto into dummy;
         found := cfk1_partizioni_oggetto%FOUND;
         close cfk1_partizioni_oggetto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Consistenze Tributo. La registrazione di Partizioni Oggetto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARTIZIONI_OGGETTO_PU */
/

-- Trigger PARTIZIONI_OGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table PARTIZIONI_OGGETTO

create or replace trigger PARTIZIONI_OGGETTO_TIU
before INSERT
    or UPDATE
on PARTIZIONI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       PARTIZIONI_OGGETTO_NR (:new.oggetto,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         PARTIZIONI_OGGETTO_PU(:OLD.OGGETTO,
                               :OLD.SEQUENZA,
                               :OLD.TIPO_AREA,
                         :NEW.OGGETTO,
                         :NEW.SEQUENZA,
                         :NEW.TIPO_AREA);
         null;
      end if;
      if INSERTING then
         PARTIZIONI_OGGETTO_PI(:NEW.OGGETTO,
                               :NEW.TIPO_AREA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "PARTIZIONI_OGGETTO"
            cursor cpk_partizioni_oggetto(var_OGGETTO number,
                                          var_SEQUENZA number) is
               select 1
                 from   PARTIZIONI_OGGETTO
                where  OGGETTO = var_OGGETTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "PARTIZIONI_OGGETTO"
               if :new.OGGETTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_partizioni_oggetto(:new.OGGETTO,
                                               :new.SEQUENZA);
                  fetch cpk_partizioni_oggetto into dummy;
                  found := cpk_partizioni_oggetto%FOUND;
                  close cpk_partizioni_oggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Partizioni Oggetto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PARTIZIONI_OGGETTO_TIU */
/

-- Procedure PARTIZIONI_OGGETTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table PARTIZIONI_OGGETTO

create or replace procedure PARTIZIONI_OGGETTO_PD
(old_oggetto IN number,
 old_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CONSISTENZE_TRIBUTO"
   cursor cfk1_partizioni_oggetto(var_oggetto number,
                                  var_sequenza number) is
      select 1
      from   CONSISTENZE_TRIBUTO
      where  OGGETTO = var_oggetto
       and   SEQUENZA = var_sequenza
       and   var_oggetto is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "PARTIZIONI_OGGETTO" if children still exist in "CONSISTENZE_TRIBUTO"
      open  cfk1_partizioni_oggetto(OLD_OGGETTO,
                                    OLD_SEQUENZA);
      fetch cfk1_partizioni_oggetto into dummy;
      found := cfk1_partizioni_oggetto%FOUND;
      close cfk1_partizioni_oggetto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Consistenze Tributo. La registrazione di Partizioni Oggetto non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARTIZIONI_OGGETTO_PD */
/

-- Tigger PARTIZIONI_OGGETTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table PARTIZIONI_OGGETTO

create or replace trigger PARTIZIONI_OGGETTO_TD
before DELETE
on PARTIZIONI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CONSISTENZE_TRIBUTO

      PARTIZIONI_OGGETTO_PD(:OLD.OGGETTO,
                            :OLD.SEQUENZA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PARTIZIONI_OGGETTO_TD */
/

-- Procedure PARTIZIONI_OGGETTO_PRATICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table PARTIZIONI_OGGETTO_PRATICA

create or replace procedure PARTIZIONI_OGGETTO_PRATICA_PI
(new_oggetto_pratica IN number,
 new_tipo_area IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk1_partizioni_oggetto_pratic(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_AREA"
   cursor cpk2_partizioni_oggetto_pratic(var_tipo_area number) is
      select 1
      from   TIPI_AREA
      where  TIPO_AREA = var_tipo_area
       and   var_tipo_area is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "PARTIZIONI_OGGETTO_PRATICA"
         if NEW_OGGETTO_PRATICA is not null then
            open  cpk1_partizioni_oggetto_pratic(NEW_OGGETTO_PRATICA);
            fetch cpk1_partizioni_oggetto_pratic into dummy;
            found := cpk1_partizioni_oggetto_pratic%FOUND;
            close cpk1_partizioni_oggetto_pratic;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Partizioni Oggetto Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_AREA" deve esistere quando si inserisce su "PARTIZIONI_OGGETTO_PRATICA"
         if NEW_TIPO_AREA is not null then
            open  cpk2_partizioni_oggetto_pratic(NEW_TIPO_AREA);
            fetch cpk2_partizioni_oggetto_pratic into dummy;
            found := cpk2_partizioni_oggetto_pratic%FOUND;
            close cpk2_partizioni_oggetto_pratic;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Area. La registrazione Partizioni Oggetto Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARTIZIONI_OGGETTO_PRATICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table PARTIZIONI_OGGETTO_PRATICA
/* End Trigger: PARTIZIONI_OGGETTO_PRATICA_TC */

-- Procedure PARTIZIONI_OGGETTO_PRATICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table PARTIZIONI_OGGETTO_PRATICA

create or replace procedure PARTIZIONI_OGGETTO_PRATICA_PU
(old_oggetto_pratica IN number,
 old_sequenza IN number,
 old_tipo_area IN number,
 new_oggetto_pratica IN number,
 new_sequenza IN number,
 new_tipo_area IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk1_partizioni_oggetto_pratic(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_AREA"
   cursor cpk2_partizioni_oggetto_pratic(var_tipo_area number) is
      select 1
      from   TIPI_AREA
      where  TIPO_AREA = var_tipo_area
       and   var_tipo_area is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "PARTIZIONI_OGGETTO_PRATICA"
         if  NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_partizioni_oggetto_pratic(NEW_OGGETTO_PRATICA);
            fetch cpk1_partizioni_oggetto_pratic into dummy;
            found := cpk1_partizioni_oggetto_pratic%FOUND;
            close cpk1_partizioni_oggetto_pratic;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Partizioni Oggetto Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_AREA" deve esistere quando si modifica "PARTIZIONI_OGGETTO_PRATICA"
         if  NEW_TIPO_AREA is not null and ( seq = 0 )
         and (   (NEW_TIPO_AREA != OLD_TIPO_AREA or OLD_TIPO_AREA is null) ) then
            open  cpk2_partizioni_oggetto_pratic(NEW_TIPO_AREA);
            fetch cpk2_partizioni_oggetto_pratic into dummy;
            found := cpk2_partizioni_oggetto_pratic%FOUND;
            close cpk2_partizioni_oggetto_pratic;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Area. La registrazione Partizioni Oggetto Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PARTIZIONI_OGGETTO_PRATICA_PU */
/

-- Trigger PARTIZIONI_OGGETTO_PRATICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table PARTIZIONI_OGGETTO_PRATICA

create or replace trigger PARTIZIONI_OGGETTO_PRATICA_TIU
before INSERT
    or UPDATE
on PARTIZIONI_OGGETTO_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       PARTIZIONI_OGGETTO_PRATICA_NR (:new.oggetto_pratica,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity at Level 0
      if UPDATING then
         PARTIZIONI_OGGETTO_PRATICA_PU(:OLD.OGGETTO_PRATICA,
                                       :OLD.SEQUENZA,
                                       :OLD.TIPO_AREA,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.SEQUENZA,
                         :NEW.TIPO_AREA);
         null;
      end if;
	if INSERTING then
         PARTIZIONI_OGGETTO_PRATICA_PI(:NEW.OGGETTO_PRATICA,
                                       :NEW.TIPO_AREA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "PARTIZIONI_OGGETTO_PRATICA"
            cursor cpk_partizioni_oggetto_pratic(var_OGGETTO_PRATICA number,
                                                 var_SEQUENZA number) is
               select 1
                 from   PARTIZIONI_OGGETTO_PRATICA
                where  OGGETTO_PRATICA = var_OGGETTO_PRATICA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "PARTIZIONI_OGGETTO_PRATICA"
               if :new.OGGETTO_PRATICA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_partizioni_oggetto_pratic(:new.OGGETTO_PRATICA,
                                                      :new.SEQUENZA);
                  fetch cpk_partizioni_oggetto_pratic into dummy;
                  found := cpk_partizioni_oggetto_pratic%FOUND;
                  close cpk_partizioni_oggetto_pratic;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO_PRATICA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Partizioni Oggetto Pratica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PARTIZIONI_OGGETTO_PRATICA_TIU */
/

-- Procedure PERIODI_IMPONIBILE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table PERIODI_IMPONIBILE

create or replace procedure PERIODI_IMPONIBILE_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_CONTRIBUENTE"
   cursor cpk1_periodi_imponibile(var_cod_fiscale varchar,
                                  var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si inserisce su "PERIODI_IMPONIBILE"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO_PRATICA is not null then
            open  cpk1_periodi_imponibile(NEW_COD_FISCALE,
                                          NEW_OGGETTO_PRATICA);
            fetch cpk1_periodi_imponibile into dummy;
            found := cpk1_periodi_imponibile%FOUND;
            close cpk1_periodi_imponibile;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione PERIODI_IMPONIBILE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PERIODI_IMPONIBILE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table PERIODI_IMPONIBILE
/* End Trigger: PERIODI_IMPONIBILE_TC */

-- Procedure PERIODI_IMPONIBILE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table PERIODI_IMPONIBILE

create or replace procedure PERIODI_IMPONIBILE_PU
(old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number,
 old_anno IN number,
 old_da_mese IN number,
 new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number,
 new_anno IN number,
 new_da_mese IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_CONTRIBUENTE"
   cursor cpk1_periodi_imponibile(var_cod_fiscale varchar,
                                  var_oggetto_pratica number) is
      select 1
      from   OGGETTI_CONTRIBUENTE
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO_PRATICA = var_oggetto_pratica
       and   var_cod_fiscale is not null
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_CONTRIBUENTE" deve esistere quando si modifica "PERIODI_IMPONIBILE"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_periodi_imponibile(NEW_COD_FISCALE,
                                          NEW_OGGETTO_PRATICA);
            fetch cpk1_periodi_imponibile into dummy;
            found := cpk1_periodi_imponibile%FOUND;
            close cpk1_periodi_imponibile;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Contribuente. La registrazione PERIODI_IMPONIBILE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PERIODI_IMPONIBILE_PU */
/

-- Trigger PERIODI_IMPONIBILE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table PERIODI_IMPONIBILE

create or replace trigger PERIODI_IMPONIBILE_TIU
before INSERT
    or UPDATE
on PERIODI_IMPONIBILE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         PERIODI_IMPONIBILE_PU(:OLD.COD_FISCALE,
                               :OLD.OGGETTO_PRATICA,
                               :OLD.ANNO,
                               :OLD.DA_MESE,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.ANNO,
                         :NEW.DA_MESE);
         null;
      end if;
      if INSERTING then
         PERIODI_IMPONIBILE_PI(:NEW.COD_FISCALE,
                               :NEW.OGGETTO_PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "PERIODI_IMPONIBILE"
            cursor cpk_periodi_imponibile(var_COD_FISCALE varchar,
                                          var_OGGETTO_PRATICA number,
                                          var_ANNO number,
                                          var_DA_MESE number) is
               select 1
                 from   PERIODI_IMPONIBILE
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA and
                       ANNO = var_ANNO and
                       DA_MESE = var_DA_MESE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "PERIODI_IMPONIBILE"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO_PRATICA is not null and
                  :new.ANNO is not null and
                  :new.DA_MESE is not null then
                  open  cpk_periodi_imponibile(:new.COD_FISCALE,
                                               :new.OGGETTO_PRATICA,
                                               :new.ANNO,
                                               :new.DA_MESE);
                  fetch cpk_periodi_imponibile into dummy;
                  found := cpk_periodi_imponibile%FOUND;
                  close cpk_periodi_imponibile;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO_PRATICA||' '||
                               :new.ANNO||' '||
                               :new.DA_MESE||
                               '" gia'' presente in PERIODI_IMPONIBILE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PERIODI_IMPONIBILE_TIU */
/

-- Procedure PRATICHE_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table PRATICHE_TRIBUTO

create or replace procedure PRATICHE_TRIBUTO_PI
(new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_tipo_carica IN number,
 new_stato_accertamento IN varchar,
 new_pratica_rif IN number,
 new_tipo_atto IN number,
 new_documento_id IN number,
 new_documento_multi_id IN number,
 new_tipo_notifica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_pratiche_tributo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_pratiche_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_CARICA"
   cursor cpk3_pratiche_tributo(var_tipo_carica number) is
      select 1
      from   TIPI_CARICA
      where  TIPO_CARICA = var_tipo_carica
       and   var_tipo_carica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk4_pratiche_tributo(var_pratica_rif number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica_rif
       and   var_pratica_rif is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_STATO"
   cursor cpk5_pratiche_tributo(var_stato_accertamento varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_stato_accertamento
       and   var_stato_accertamento is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ATTO"
   cursor cpk6_pratiche_tributo(var_tipo_atto number) is
      select 1
      from   TIPI_ATTO
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI_MULTI"
   cursor cpk7_pratiche_tributo(var_documento_id number,
                                var_documento_multi_id number) is
      select 1
      from   DOCUMENTI_CARICATI_MULTI
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   var_documento_id is not null
       and   var_documento_multi_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_NOTIFICA"
   cursor cpk8_pratiche_tributo(var_tipo_notifica number) is
      select 1
      from   TIPI_NOTIFICA
      where  TIPO_NOTIFICA = var_tipo_notifica
       and   var_tipo_notifica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "PRATICHE_TRIBUTO"
         if NEW_COD_FISCALE is not null then
            open  cpk1_pratiche_tributo(NEW_COD_FISCALE);
            fetch cpk1_pratiche_tributo into dummy;
            found := cpk1_pratiche_tributo%FOUND;
            close cpk1_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Pratiche Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "PRATICHE_TRIBUTO"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_pratiche_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk2_pratiche_tributo into dummy;
            found := cpk2_pratiche_tributo%FOUND;
            close cpk2_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Pratiche Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CARICA" deve esistere quando si inserisce su "PRATICHE_TRIBUTO"
         if NEW_TIPO_CARICA is not null then
            open  cpk3_pratiche_tributo(NEW_TIPO_CARICA);
            fetch cpk3_pratiche_tributo into dummy;
            found := cpk3_pratiche_tributo%FOUND;
            close cpk3_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Carica. La registrazione Pratiche Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "PRATICHE_TRIBUTO"
         if NEW_PRATICA_RIF is not null then
            open  cpk4_pratiche_tributo(NEW_PRATICA_RIF);
            fetch cpk4_pratiche_tributo into dummy;
            found := cpk4_pratiche_tributo%FOUND;
            close cpk4_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Pratiche Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si inserisce su "PRATICHE_TRIBUTO"
         if NEW_STATO_ACCERTAMENTO is not null then
            open  cpk5_pratiche_tributo(NEW_STATO_ACCERTAMENTO);
            fetch cpk5_pratiche_tributo into dummy;
            found := cpk5_pratiche_tributo%FOUND;
            close cpk5_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione Pratiche Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTO" deve esistere quando si inserisce su "PRATICHE_TRIBUTO"
         if NEW_TIPO_ATTO is not null then
            open  cpk6_pratiche_tributo(NEW_TIPO_ATTO);
            fetch cpk6_pratiche_tributo into dummy;
            found := cpk6_pratiche_tributo%FOUND;
            close cpk6_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Atto. La registrazione Pratiche Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI_MULTI" deve esistere quando si inserisce su "PRATICHE_TRIBUTO"
         if NEW_DOCUMENTO_ID is not null and
            NEW_DOCUMENTO_MULTI_ID is not null then
            open  cpk7_pratiche_tributo(NEW_DOCUMENTO_ID,
                                        NEW_DOCUMENTO_MULTI_ID);
            fetch cpk7_pratiche_tributo into dummy;
            found := cpk7_pratiche_tributo%FOUND;
            close cpk7_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI_MULTI. La registrazione Pratiche Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_NOTIFICA" deve esistere quando si inserisce su "PRATICHE_TRIBUTO"
         if NEW_TIPO_NOTIFICA is not null then
            open  cpk8_pratiche_tributo(NEW_TIPO_NOTIFICA);
            fetch cpk8_pratiche_tributo into dummy;
            found := cpk8_pratiche_tributo%FOUND;
            close cpk8_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Notifica. La registrazione Pratiche Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PRATICHE_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table PRATICHE_TRIBUTO

create or replace trigger PRATICHE_TRIBUTO_TB
before INSERT
    or UPDATE
    or DELETE
on PRATICHE_TRIBUTO
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: PRATICHE_TRIBUTO_TB */
/

create or replace trigger PRATICHE_TRIBUTO_TC
after INSERT
   or UPDATE
   or DELETE
on PRATICHE_TRIBUTO
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: PRATICHE_TRIBUTO_TC */
/

-- Procedure PRATICHE_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table PRATICHE_TRIBUTO

create or replace procedure PRATICHE_TRIBUTO_PU
(old_pratica IN number,
 old_cod_fiscale IN varchar,
 old_tipo_tributo IN varchar,
 old_tipo_carica IN number,
 old_imposta_totale IN number,
 old_importo_totale IN number,
 old_importo_ridotto IN number,
 old_stato_accertamento IN varchar,
 old_pratica_rif IN number,
 old_imposta_dovuta_totale IN number,
 old_importo_ridotto_2 IN number,
 old_tipo_atto IN number,
 old_documento_id IN number,
 old_documento_multi_id IN number,
 old_tipo_notifica IN number,
 new_pratica IN number,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_tipo_carica IN number,
 new_imposta_totale IN number,
 new_importo_totale IN number,
 new_importo_ridotto IN number,
 new_stato_accertamento IN varchar,
 new_pratica_rif IN number,
 new_imposta_dovuta_totale IN number,
 new_importo_ridotto_2 IN number,
 new_tipo_atto IN number,
 new_documento_id IN number,
 new_documento_multi_id IN number,
 new_tipo_notifica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_pratiche_tributo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_pratiche_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_CARICA"
   cursor cpk3_pratiche_tributo(var_tipo_carica number) is
      select 1
      from   TIPI_CARICA
      where  TIPO_CARICA = var_tipo_carica
       and   var_tipo_carica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk4_pratiche_tributo(var_pratica_rif number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica_rif
       and   var_pratica_rif is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_STATO"
   cursor cpk5_pratiche_tributo(var_stato_accertamento varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_stato_accertamento
       and   var_stato_accertamento is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ATTO"
   cursor cpk6_pratiche_tributo(var_tipo_atto number) is
      select 1
      from   TIPI_ATTO
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI_MULTI"
   cursor cpk7_pratiche_tributo(var_documento_id number,
                                var_documento_multi_id number) is
      select 1
      from   DOCUMENTI_CARICATI_MULTI
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   var_documento_id is not null
       and   var_documento_multi_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_NOTIFICA"
   cursor cpk8_pratiche_tributo(var_tipo_notifica number) is
      select 1
      from   TIPI_NOTIFICA
      where  TIPO_NOTIFICA = var_tipo_notifica
       and   var_tipo_notifica is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_pratiche_tributo(var_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SANZIONI_PRATICA"
   cursor cfk2_pratiche_tributo(var_pratica number) is
      select 1
      from   SANZIONI_PRATICA
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "RUOLI_CONTRIBUENTE"
   cursor cfk3_pratiche_tributo(var_pratica number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "RAPPORTI_TRIBUTO"
   cursor cfk4_pratiche_tributo(var_pratica number) is
      select 1
      from   RAPPORTI_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "DENUNCE_ICI"
   cursor cfk5_pratiche_tributo(var_pratica number) is
      select 1
      from   DENUNCE_ICI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "DENUNCE_ICIAP"
   cursor cfk6_pratiche_tributo(var_pratica number) is
      select 1
      from   DENUNCE_ICIAP
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "VERSAMENTI"
   cursor cfk7_pratiche_tributo(var_pratica number) is
      select 1
      from   VERSAMENTI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "FAMILIARI_PRATICA"
   cursor cfk8_pratiche_tributo(var_pratica number) is
      select 1
      from   FAMILIARI_PRATICA
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "REDDITI_RIFERIMENTO"
   cursor cfk9_pratiche_tributo(var_pratica number) is
      select 1
      from   REDDITI_RIFERIMENTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "IMPRESE_ARTI_PROFESSIONI"
   cursor cfk10_pratiche_tributo(var_pratica number) is
      select 1
      from   IMPRESE_ARTI_PROFESSIONI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE_CONTITOLARI"
   cursor cfk11_pratiche_tributo(var_pratica number) is
      select 1
      from   ANOMALIE_CONTITOLARI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "NOTIFICHE_OGGETTO"
   cursor cfk12_pratiche_tributo(var_pratica number) is
      select 1
      from   NOTIFICHE_OGGETTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_DEFUNTI"
   cursor cfk13_pratiche_tributo(var_pratica number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_EREDI"
   cursor cfk14_pratiche_tributo(var_pratica number) is
      select 1
      from   SUCCESSIONI_EREDI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "DENUNCE_TASI"
   cursor cfk15_pratiche_tributo(var_pratica number) is
      select 1
      from   DENUNCE_TASI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_TRIBUTO_DEFUNTI"
   cursor cfk16_pratiche_tributo(var_pratica number) is
      select 1
      from   SUCCESSIONI_TRIBUTO_DEFUNTI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_TRIBUTO_EREDI"
   cursor cfk17_pratiche_tributo(var_pratica number) is
      select 1
      from   SUCCESSIONI_TRIBUTO_EREDI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "WEB_CALCOLO_INDIVIDUALE"
   cursor cfk18_pratiche_tributo(var_pratica number) is
      select 1
      from   WEB_CALCOLO_INDIVIDUALE
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "RATE_PRATICA"
   cursor cfk19_pratiche_tributo(var_pratica number) is
      select 1
      from   RATE_PRATICA
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "DOCUMENTI_CONTRIBUENTE"
   cursor cfk20_pratiche_tributo(var_pratica number) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "ITER_PRATICA"
   cursor cfk21_pratiche_tributo(var_pratica number) is
      select 1
      from   ITER_PRATICA
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk22_pratiche_tributo(var_pratica number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "CREDITI_RAVVEDIMENTO"
   cursor cfk23_pratiche_tributo(var_pratica number) is
      select 1
      from   CREDITI_RAVVEDIMENTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "DEBITI_RAVVEDIMENTO"
   cursor cfk24_pratiche_tributo(var_pratica number) is
      select 1
      from   DEBITI_RAVVEDIMENTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "CONTATTI_CONTRIBUENTE"
   cursor cfk25_pratiche_tributo(var_pratica number) is
      select 1
      from   CONTATTI_CONTRIBUENTE
      where  PRATICA_K = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  La colonna "IMPOSTA_TOTALE" non puo' essere modificata
      if OLD_IMPOSTA_TOTALE != NEW_IMPOSTA_TOTALE then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20001;
            errmsg := 'L''informazione Imposta Totale non puo'' essere modificata';
            raise integrity_error;
         end if;
      end if;

      --  La colonna "IMPORTO_TOTALE" non puo' essere modificata
      if OLD_IMPORTO_TOTALE != NEW_IMPORTO_TOTALE then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20001;
            errmsg := 'L''informazione Importo Totale non puo'' essere modificata';
            raise integrity_error;
         end if;
      end if;

      --  La colonna "IMPORTO_RIDOTTO" non puo' essere modificata
      if OLD_IMPORTO_RIDOTTO != NEW_IMPORTO_RIDOTTO then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20001;
            errmsg := 'L''informazione Importo Ridotto non puo'' essere modificata';
            raise integrity_error;
         end if;
      end if;

      --  La colonna "IMPOSTA_DOVUTA_TOTALE" non puo' essere modificata
      if OLD_IMPOSTA_DOVUTA_TOTALE != NEW_IMPOSTA_DOVUTA_TOTALE then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20001;
            errmsg := 'L''informazione Imposta Dovuta Totale non puo'' essere modificata';
            raise integrity_error;
         end if;
      end if;

      --  La colonna "IMPORTO_RIDOTTO_2" non puo' essere modificata
      if OLD_IMPORTO_RIDOTTO_2 != NEW_IMPORTO_RIDOTTO_2 then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20001;
            errmsg := 'L''informazione Importo Ridotto 2 non puo'' essere modificata';
            raise integrity_error;
         end if;
      end if;

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "PRATICHE_TRIBUTO"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_pratiche_tributo(NEW_COD_FISCALE);
            fetch cpk1_pratiche_tributo into dummy;
            found := cpk1_pratiche_tributo%FOUND;
            close cpk1_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Pratiche Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "PRATICHE_TRIBUTO"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_pratiche_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk2_pratiche_tributo into dummy;
            found := cpk2_pratiche_tributo%FOUND;
            close cpk2_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Pratiche Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_CARICA" deve esistere quando si modifica "PRATICHE_TRIBUTO"
         if  NEW_TIPO_CARICA is not null and ( seq = 0 )
         and (   (NEW_TIPO_CARICA != OLD_TIPO_CARICA or OLD_TIPO_CARICA is null) ) then
            open  cpk3_pratiche_tributo(NEW_TIPO_CARICA);
            fetch cpk3_pratiche_tributo into dummy;
            found := cpk3_pratiche_tributo%FOUND;
            close cpk3_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Carica. La registrazione Pratiche Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "PRATICHE_TRIBUTO"
         if  NEW_PRATICA_RIF is not null and ( seq = 0 )
         and (   (NEW_PRATICA_RIF != OLD_PRATICA_RIF or OLD_PRATICA_RIF is null) ) then
            open  cpk4_pratiche_tributo(NEW_PRATICA_RIF);
            fetch cpk4_pratiche_tributo into dummy;
            found := cpk4_pratiche_tributo%FOUND;
            close cpk4_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Pratiche Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si modifica "PRATICHE_TRIBUTO"
         if  NEW_STATO_ACCERTAMENTO is not null and ( seq = 0 )
         and (   (NEW_STATO_ACCERTAMENTO != OLD_STATO_ACCERTAMENTO or OLD_STATO_ACCERTAMENTO is null) ) then
            open  cpk5_pratiche_tributo(NEW_STATO_ACCERTAMENTO);
            fetch cpk5_pratiche_tributo into dummy;
            found := cpk5_pratiche_tributo%FOUND;
            close cpk5_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione Pratiche Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTO" deve esistere quando si modifica "PRATICHE_TRIBUTO"
         if  NEW_TIPO_ATTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_ATTO != OLD_TIPO_ATTO or OLD_TIPO_ATTO is null) ) then
            open  cpk6_pratiche_tributo(NEW_TIPO_ATTO);
            fetch cpk6_pratiche_tributo into dummy;
            found := cpk6_pratiche_tributo%FOUND;
            close cpk6_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Atto. La registrazione Pratiche Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI_MULTI" deve esistere quando si modifica "PRATICHE_TRIBUTO"
         if  NEW_DOCUMENTO_ID is not null and
             NEW_DOCUMENTO_MULTI_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null)
              or (NEW_DOCUMENTO_MULTI_ID != OLD_DOCUMENTO_MULTI_ID or OLD_DOCUMENTO_MULTI_ID is null) ) then
            open  cpk7_pratiche_tributo(NEW_DOCUMENTO_ID,
                                        NEW_DOCUMENTO_MULTI_ID);
            fetch cpk7_pratiche_tributo into dummy;
            found := cpk7_pratiche_tributo%FOUND;
            close cpk7_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI_MULTI. La registrazione Pratiche Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_NOTIFICA" deve esistere quando si modifica "PRATICHE_TRIBUTO"
         if  NEW_TIPO_NOTIFICA is not null and ( seq = 0 )
         and (   (NEW_TIPO_NOTIFICA != OLD_TIPO_NOTIFICA or OLD_TIPO_NOTIFICA is null) ) then
            open  cpk8_pratiche_tributo(NEW_TIPO_NOTIFICA);
            fetch cpk8_pratiche_tributo into dummy;
            found := cpk8_pratiche_tributo%FOUND;
            close cpk8_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Notifica. La registrazione Pratiche Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk1_pratiche_tributo(OLD_PRATICA);
         fetch cfk1_pratiche_tributo into dummy;
         found := cfk1_pratiche_tributo%FOUND;
         close cfk1_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "SANZIONI_PRATICA"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk2_pratiche_tributo(OLD_PRATICA);
         fetch cfk2_pratiche_tributo into dummy;
         found := cfk2_pratiche_tributo%FOUND;
         close cfk2_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sanzioni Pratica. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "RUOLI_CONTRIBUENTE"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk3_pratiche_tributo(OLD_PRATICA);
         fetch cfk3_pratiche_tributo into dummy;
         found := cfk3_pratiche_tributo%FOUND;
         close cfk3_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Ruoli Contribuente. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "RAPPORTI_TRIBUTO"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk4_pratiche_tributo(OLD_PRATICA);
         fetch cfk4_pratiche_tributo into dummy;
         found := cfk4_pratiche_tributo%FOUND;
         close cfk4_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Rapporti Tributo. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "DENUNCE_ICI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk5_pratiche_tributo(OLD_PRATICA);
         fetch cfk5_pratiche_tributo into dummy;
         found := cfk5_pratiche_tributo%FOUND;
         close cfk5_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Denunce ICI. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "DENUNCE_ICIAP"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk6_pratiche_tributo(OLD_PRATICA);
         fetch cfk6_pratiche_tributo into dummy;
         found := cfk6_pratiche_tributo%FOUND;
         close cfk6_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Denunce ICIAP. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "VERSAMENTI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk7_pratiche_tributo(OLD_PRATICA);
         fetch cfk7_pratiche_tributo into dummy;
         found := cfk7_pratiche_tributo%FOUND;
         close cfk7_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "FAMILIARI_PRATICA"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk8_pratiche_tributo(OLD_PRATICA);
         fetch cfk8_pratiche_tributo into dummy;
         found := cfk8_pratiche_tributo%FOUND;
         close cfk8_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Familiari_pratica. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "REDDITI_RIFERIMENTO"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk9_pratiche_tributo(OLD_PRATICA);
         fetch cfk9_pratiche_tributo into dummy;
         found := cfk9_pratiche_tributo%FOUND;
         close cfk9_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Redditi Riferimento. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "IMPRESE_ARTI_PROFESSIONI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk10_pratiche_tributo(OLD_PRATICA);
         fetch cfk10_pratiche_tributo into dummy;
         found := cfk10_pratiche_tributo%FOUND;
         close cfk10_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Imprese Arti Professioni. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "ANOMALIE_CONTITOLARI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk11_pratiche_tributo(OLD_PRATICA);
         fetch cfk11_pratiche_tributo into dummy;
         found := cfk11_pratiche_tributo%FOUND;
         close cfk11_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Anomalie Contitolari. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "NOTIFICHE_OGGETTO"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk12_pratiche_tributo(OLD_PRATICA);
         fetch cfk12_pratiche_tributo into dummy;
         found := cfk12_pratiche_tributo%FOUND;
         close cfk12_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Notifiche_oggetto. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "SUCCESSIONI_DEFUNTI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk13_pratiche_tributo(OLD_PRATICA);
         fetch cfk13_pratiche_tributo into dummy;
         found := cfk13_pratiche_tributo%FOUND;
         close cfk13_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUCCESSIONI_DEFUNTI. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "SUCCESSIONI_EREDI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk14_pratiche_tributo(OLD_PRATICA);
         fetch cfk14_pratiche_tributo into dummy;
         found := cfk14_pratiche_tributo%FOUND;
         close cfk14_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUCCESSIONI_EREDI. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "DENUNCE_TASI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk15_pratiche_tributo(OLD_PRATICA);
         fetch cfk15_pratiche_tributo into dummy;
         found := cfk15_pratiche_tributo%FOUND;
         close cfk15_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Denunce TASI. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "SUCCESSIONI_TRIBUTO_DEFUNTI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk16_pratiche_tributo(OLD_PRATICA);
         fetch cfk16_pratiche_tributo into dummy;
         found := cfk16_pratiche_tributo%FOUND;
         close cfk16_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Successioni Tributo Defunti. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "SUCCESSIONI_TRIBUTO_EREDI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk17_pratiche_tributo(OLD_PRATICA);
         fetch cfk17_pratiche_tributo into dummy;
         found := cfk17_pratiche_tributo%FOUND;
         close cfk17_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Successioni Tributo Eredi. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "WEB_CALCOLO_INDIVIDUALE"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk18_pratiche_tributo(OLD_PRATICA);
         fetch cfk18_pratiche_tributo into dummy;
         found := cfk18_pratiche_tributo%FOUND;
         close cfk18_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_CALCOLO_INDIVIDUALE. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "RATE_PRATICA"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk19_pratiche_tributo(OLD_PRATICA);
         fetch cfk19_pratiche_tributo into dummy;
         found := cfk19_pratiche_tributo%FOUND;
         close cfk19_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Rate Pratica. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "DOCUMENTI_CONTRIBUENTE"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk20_pratiche_tributo(OLD_PRATICA);
         fetch cfk20_pratiche_tributo into dummy;
         found := cfk20_pratiche_tributo%FOUND;
         close cfk20_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Documenti Contribuente. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "ITER_PRATICA"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk21_pratiche_tributo(OLD_PRATICA);
         fetch cfk21_pratiche_tributo into dummy;
         found := cfk21_pratiche_tributo%FOUND;
         close cfk21_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Iter Pratica. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "DETTAGLI_ELABORAZIONE"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk22_pratiche_tributo(OLD_PRATICA);
         fetch cfk22_pratiche_tributo into dummy;
         found := cfk22_pratiche_tributo%FOUND;
         close cfk22_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "CREDITI_RAVVEDIMENTO"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk23_pratiche_tributo(OLD_PRATICA);
         fetch cfk23_pratiche_tributo into dummy;
         found := cfk23_pratiche_tributo%FOUND;
         close cfk23_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su CREDITI_RAVVEDIMENTO. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "DEBITI_RAVVEDIMENTO"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk24_pratiche_tributo(OLD_PRATICA);
         fetch cfk24_pratiche_tributo into dummy;
         found := cfk24_pratiche_tributo%FOUND;
         close cfk24_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DEBITI_RAVVEDIMENTO. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "PRATICHE_TRIBUTO" non modificabile se esistono referenze su "CONTATTI_CONTRIBUENTE"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk25_pratiche_tributo(OLD_PRATICA);
         fetch cfk25_pratiche_tributo into dummy;
         found := cfk25_pratiche_tributo%FOUND;
         close cfk25_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Contatti Contribuente. La registrazione di Pratiche Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PRATICHE_TRIBUTO_PU */
/

-- Trigger PRATICHE_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table PRATICHE_TRIBUTO

create or replace trigger PRATICHE_TRIBUTO_TIU
before INSERT
    or UPDATE
on PRATICHE_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      PRATICHE_TRIBUTO_DI (:new.pratica,:new.tipo_pratica,:new.data,:new.data_notifica,
			   :new.flag_annullamento,:new.note);
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.pratica is null then
      PRATICHE_TRIBUTO_NR(:new.pratica);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         PRATICHE_TRIBUTO_PU(:OLD.PRATICA,
                             :OLD.COD_FISCALE,
                             :OLD.TIPO_TRIBUTO,
                             :OLD.TIPO_CARICA,
                             :OLD.IMPOSTA_TOTALE,
                             :OLD.IMPORTO_TOTALE,
                             :OLD.IMPORTO_RIDOTTO,
                             :OLD.STATO_ACCERTAMENTO,
                             :OLD.PRATICA_RIF,
                             :OLD.IMPOSTA_DOVUTA_TOTALE,
                             :OLD.IMPORTO_RIDOTTO_2,
                             :OLD.TIPO_ATTO,
                             :OLD.DOCUMENTO_ID,
                             :OLD.DOCUMENTO_MULTI_ID,
                             :OLD.TIPO_NOTIFICA,
                         :NEW.PRATICA,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_CARICA,
                         :NEW.IMPOSTA_TOTALE,
                         :NEW.IMPORTO_TOTALE,
                         :NEW.IMPORTO_RIDOTTO,
                         :NEW.STATO_ACCERTAMENTO,
                         :NEW.PRATICA_RIF,
                         :NEW.IMPOSTA_DOVUTA_TOTALE,
                         :NEW.IMPORTO_RIDOTTO_2,
                         :NEW.TIPO_ATTO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.DOCUMENTO_MULTI_ID,
                         :NEW.TIPO_NOTIFICA);
         null;
      end if;
      if INSERTING then
         PRATICHE_TRIBUTO_PI(:NEW.COD_FISCALE,
                             :NEW.TIPO_TRIBUTO,
                             :NEW.TIPO_CARICA,
                             :NEW.STATO_ACCERTAMENTO,
                             :NEW.PRATICA_RIF,
                             :NEW.TIPO_ATTO,
                             :NEW.DOCUMENTO_ID,
                             :NEW.DOCUMENTO_MULTI_ID,
                             :NEW.TIPO_NOTIFICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "PRATICHE_TRIBUTO"
            cursor cpk_pratiche_tributo(var_PRATICA number) is
               select 1
                 from   PRATICHE_TRIBUTO
                where  PRATICA = var_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "PRATICHE_TRIBUTO"
               if :new.PRATICA is not null then
                  open  cpk_pratiche_tributo(:new.PRATICA);
                  fetch cpk_pratiche_tributo into dummy;
                  found := cpk_pratiche_tributo%FOUND;
                  close cpk_pratiche_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||
                               '" gia'' presente in Pratiche Tributo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin -- Set PostEvent Check REFERENTIAL Integrity at Level 0
      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
      IF IntegrityPackage.GetNestLevel = 0 THEN
         --
         -- Integrità Referenziale di Esistenza FK
         --
         IF INSERTING THEN
            --
            -- Integrità Referenziale di Esistenza su insert FK
            --
            IF :new.pratica_rif is NOT null THEN
               a_istruzione := 'select 1 from pratiche_tributo where pratica = '
                               || :new.pratica_rif;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;
            BEGIN
--    dbms_output.put_line ('lancio');
                a_istruzione := 'BEGIN PRATICHE_TRIBUTO_FI('||
                                 :new.pratica||','''||
                                 :new.tipo_pratica||''','''||
                                 :old.stato_accertamento||''','''||
                                 :new.stato_accertamento||''','''||
                                 :old.tipo_atto||''','''||
                                 :new.tipo_atto||''','''||
                                 replace(:new.motivo,'''','''''')||''','''||
                                 replace(:new.note,'''','''''')||''','''||
                                 :new.utente||''','''||'I'||''','''||
                                 :old.flag_annullamento||''','''||
                                 :new.flag_annullamento||'''); end;'
;
--    dbms_output.put_line (a_istruzione);
                a_messaggio := '';
                IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END;
         ELSIF UPDATING THEN
            IF nvl(:new.pratica_rif,-1) != nvl(:old.pratica_rif ,-1) THEN
               --
               -- Integrità Referenziale di Esistenza su update FK
               --
               IF :new.pratica_rif is NOT null THEN
                  a_istruzione := 'select 1 from pratiche_tributo where pratica = '
                                  ||:new.pratica_rif;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;
         END IF;
      END IF;
      IF UPDATING THEN
         IF :new.pratica != :old.pratica THEN
            --
            -- Integrità Referenziale su update PK
            --

            /* Caso di RESTRICT UPDATE */

               a_istruzione := 'select 0 from pratiche_tributo where pratica_rif = '
                               ||:old.pratica ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

         END IF;
      END IF;
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
             PRATICHE_TRIBUTO_FI(:new.pratica,:new.tipo_pratica,:old.stato_accertamento,:new.stato_accertamento,:old.tipo_atto,:new.tipo_atto,:new.motivo,
                                 :new.note,:new.utente,'',:old.flag_annullamento,:new.flag_annullamento);
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PRATICHE_TRIBUTO_TIU */
/

-- Procedure PRATICHE_TRIBUTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table PRATICHE_TRIBUTO

create or replace procedure PRATICHE_TRIBUTO_PD
(old_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_CONTRIBUENTE"
   cursor cfk1_pratiche_tributo(var_pratica number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk2_pratiche_tributo(var_pratica number) is
      select 1
      from   VERSAMENTI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of DeleteParentRestrict constraint for "NOTIFICHE_OGGETTO"
   cursor cfk3_pratiche_tributo(var_pratica number) is
      select 1
      from   NOTIFICHE_OGGETTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of DeleteParentRestrict constraint for "RATE_PRATICA"
   cursor cfk4_pratiche_tributo(var_pratica number) is
      select 1
      from   RATE_PRATICA
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of DeleteParentRestrict constraint for "DOCUMENTI_CONTRIBUENTE"
   cursor cfk5_pratiche_tributo(var_pratica number) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_ELABORAZIONE"
   cursor cfk6_pratiche_tributo(var_pratica number) is
      select 1
      from   DETTAGLI_ELABORAZIONE
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
--   begin
--      PRATICHE_TRIBUTO_FI(old_pratica);
--   end;

   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "PRATICHE_TRIBUTO" if children still exist in "RUOLI_CONTRIBUENTE"
      open  cfk1_pratiche_tributo(OLD_PRATICA);
      fetch cfk1_pratiche_tributo into dummy;
      found := cfk1_pratiche_tributo%FOUND;
      close cfk1_pratiche_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Contribuente. La registrazione di Pratiche Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "PRATICHE_TRIBUTO" if children still exist in "VERSAMENTI"
      open  cfk2_pratiche_tributo(OLD_PRATICA);
      fetch cfk2_pratiche_tributo into dummy;
      found := cfk2_pratiche_tributo%FOUND;
      close cfk2_pratiche_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Pratiche Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "PRATICHE_TRIBUTO" if children still exist in "NOTIFICHE_OGGETTO"
      open  cfk3_pratiche_tributo(OLD_PRATICA);
      fetch cfk3_pratiche_tributo into dummy;
      found := cfk3_pratiche_tributo%FOUND;
      close cfk3_pratiche_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Notifiche_oggetto. La registrazione di Pratiche Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "PRATICHE_TRIBUTO" if children still exist in "RATE_PRATICA"
      open  cfk4_pratiche_tributo(OLD_PRATICA);
      fetch cfk4_pratiche_tributo into dummy;
      found := cfk4_pratiche_tributo%FOUND;
      close cfk4_pratiche_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Rate Pratica. La registrazione di Pratiche Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "PRATICHE_TRIBUTO" if children still exist in "DOCUMENTI_CONTRIBUENTE"
      open  cfk5_pratiche_tributo(OLD_PRATICA);
      fetch cfk5_pratiche_tributo into dummy;
      found := cfk5_pratiche_tributo%FOUND;
      close cfk5_pratiche_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Documenti Contribuente. La registrazione di Pratiche Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "PRATICHE_TRIBUTO" if children still exist in "DETTAGLI_ELABORAZIONE"
      open  cfk6_pratiche_tributo(OLD_PRATICA);
      fetch cfk6_pratiche_tributo into dummy;
      found := cfk6_pratiche_tributo%FOUND;
      close cfk6_pratiche_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dettagli Elaborazione. La registrazione di Pratiche Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: PRATICHE_TRIBUTO_PD */
/

-- Tigger PRATICHE_TRIBUTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table PRATICHE_TRIBUTO

create or replace trigger PRATICHE_TRIBUTO_TD
before DELETE
on PRATICHE_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set DATA Integrity on DELETE
      PRATICHE_TRIBUTO_DI(:old.pratica,:old.tipo_pratica,:old.data,:old.data_notifica,
			  :old.flag_annullamento,:old.note);
   end;
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
             PRATICHE_TRIBUTO_FI(:old.pratica,:old.tipo_pratica,:old.stato_accertamento,:old.stato_accertamento,:old.tipo_atto,:old.tipo_atto,:old.motivo,
                                 :old.note,:old.utente,'',:old.flag_annullamento,:old.flag_annullamento);
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE at Level 0

      -- Child Restrict Table: RUOLI_CONTRIBUENTE

      -- Child Restrict Table: VERSAMENTI

      -- Child Restrict Table: NOTIFICHE_OGGETTO

      -- Child Restrict Table: RATE_PRATICA

      -- Child Restrict Table: DOCUMENTI_CONTRIBUENTE

      -- Child Restrict Table: DETTAGLI_ELABORAZIONE

         PRATICHE_TRIBUTO_PD(:OLD.PRATICA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "OGGETTI_PRATICA"
      delete OGGETTI_PRATICA
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "SANZIONI_PRATICA"
      delete SANZIONI_PRATICA
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "DENUNCE_ICI"
      delete DENUNCE_ICI
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "DENUNCE_ICIAP"
      delete DENUNCE_ICIAP
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "FAMILIARI_PRATICA"
      delete FAMILIARI_PRATICA
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "REDDITI_RIFERIMENTO"
      delete REDDITI_RIFERIMENTO
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "IMPRESE_ARTI_PROFESSIONI"
      delete IMPRESE_ARTI_PROFESSIONI
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "ANOMALIE_CONTITOLARI"
      delete ANOMALIE_CONTITOLARI
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "DENUNCE_TASI"
      delete DENUNCE_TASI
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "WEB_CALCOLO_INDIVIDUALE"
      delete WEB_CALCOLO_INDIVIDUALE
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "ITER_PRATICA"
      delete ITER_PRATICA
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "STO_PRATICHE_TRIBUTO"
      delete STO_PRATICHE_TRIBUTO
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "CREDITI_RAVVEDIMENTO"
      delete CREDITI_RAVVEDIMENTO
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "DEBITI_RAVVEDIMENTO"
      delete DEBITI_RAVVEDIMENTO
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "CONTATTI_CONTRIBUENTE"
      delete CONTATTI_CONTRIBUENTE
      where  PRATICA_K = :OLD.PRATICA;

      --  Set parent code of "PRATICHE_TRIBUTO" to NULL in child "SUCCESSIONI_DEFUNTI"
      update SUCCESSIONI_DEFUNTI
       set   PRATICA = NULL
      where  PRATICA = :OLD.PRATICA;

      --  Set parent code of "PRATICHE_TRIBUTO" to NULL in child "SUCCESSIONI_EREDI"
      update SUCCESSIONI_EREDI
       set   PRATICA = NULL
      where  PRATICA = :OLD.PRATICA;

      --  Set parent code of "PRATICHE_TRIBUTO" to NULL in child "SUCCESSIONI_TRIBUTO_DEFUNTI"
      update SUCCESSIONI_TRIBUTO_DEFUNTI
       set   PRATICA = NULL
      where  PRATICA = :OLD.PRATICA;

      --  Set parent code of "PRATICHE_TRIBUTO" to NULL in child "SUCCESSIONI_TRIBUTO_EREDI"
      update SUCCESSIONI_TRIBUTO_EREDI
       set   PRATICA = NULL
      where  PRATICA = :OLD.PRATICA;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
         a_istruzione := 'select 0 from pratiche_tributo where pratica_rif = '
                         ||:old.pratica;
         a_messaggio := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Pratiche Tributo non e'' eliminabile.';
         IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;

      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
            a_istruzione := 'BEGIN CONTRIBUENTI_CHK_DEL(null,'||:old.pratica||'); end;';
            a_messaggio := '';
            IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;

   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: PRATICHE_TRIBUTO_TD */
/

-- Procedure RAPPORTI_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RAPPORTI_TRIBUTO

create or replace procedure RAPPORTI_TRIBUTO_PI
(new_pratica IN number,
 new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_rapporti_tributo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk2_rapporti_tributo(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "RAPPORTI_TRIBUTO"
         if NEW_COD_FISCALE is not null then
            open  cpk1_rapporti_tributo(NEW_COD_FISCALE);
            fetch cpk1_rapporti_tributo into dummy;
            found := cpk1_rapporti_tributo%FOUND;
            close cpk1_rapporti_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Rapporti Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "RAPPORTI_TRIBUTO"
         if NEW_PRATICA is not null then
            open  cpk2_rapporti_tributo(NEW_PRATICA);
            fetch cpk2_rapporti_tributo into dummy;
            found := cpk2_rapporti_tributo%FOUND;
            close cpk2_rapporti_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Rapporti Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RAPPORTI_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RAPPORTI_TRIBUTO
/* End Trigger: RAPPORTI_TRIBUTO_TC */

-- Procedure RAPPORTI_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RAPPORTI_TRIBUTO

create or replace procedure RAPPORTI_TRIBUTO_PU
(old_pratica IN number,
 old_sequenza IN number,
 old_cod_fiscale IN varchar,
 new_pratica IN number,
 new_sequenza IN number,
 new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_rapporti_tributo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk2_rapporti_tributo(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "RAPPORTI_TRIBUTO"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_rapporti_tributo(NEW_COD_FISCALE);
            fetch cpk1_rapporti_tributo into dummy;
            found := cpk1_rapporti_tributo%FOUND;
            close cpk1_rapporti_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Rapporti Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "RAPPORTI_TRIBUTO"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk2_rapporti_tributo(NEW_PRATICA);
            fetch cpk2_rapporti_tributo into dummy;
            found := cpk2_rapporti_tributo%FOUND;
            close cpk2_rapporti_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Rapporti Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RAPPORTI_TRIBUTO_PU */
/

-- Trigger RAPPORTI_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RAPPORTI_TRIBUTO

create or replace trigger RAPPORTI_TRIBUTO_TIU
before INSERT
    or UPDATE
on RAPPORTI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       RAPPORTI_TRIBUTO_NR (:new.pratica,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RAPPORTI_TRIBUTO_PU(:OLD.PRATICA,
                             :OLD.SEQUENZA,
                             :OLD.COD_FISCALE,
                         :NEW.PRATICA,
                         :NEW.SEQUENZA,
                         :NEW.COD_FISCALE);
         null;
      end if;
      if INSERTING then
         RAPPORTI_TRIBUTO_PI(:NEW.PRATICA,
                             :NEW.COD_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RAPPORTI_TRIBUTO"
            cursor cpk_rapporti_tributo(var_PRATICA number,
                                        var_SEQUENZA number) is
               select 1
                 from   RAPPORTI_TRIBUTO
                where  PRATICA = var_PRATICA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RAPPORTI_TRIBUTO"
               if :new.PRATICA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_rapporti_tributo(:new.PRATICA,
                                             :new.SEQUENZA);
                  fetch cpk_rapporti_tributo into dummy;
                  found := cpk_rapporti_tributo%FOUND;
                  close cpk_rapporti_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Rapporti Tributo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RAPPORTI_TRIBUTO_TIU */
/

-- Procedure RATE_IMPOSTA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RATE_IMPOSTA

create or replace procedure RATE_IMPOSTA_PI
(new_oggetto_imposta IN number,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_IMPOSTA"
   cursor cpk1_rate_imposta(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk2_rate_imposta(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk3_rate_imposta(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si inserisce su "RATE_IMPOSTA"
         if NEW_OGGETTO_IMPOSTA is not null then
            open  cpk1_rate_imposta(NEW_OGGETTO_IMPOSTA);
            fetch cpk1_rate_imposta into dummy;
            found := cpk1_rate_imposta%FOUND;
            close cpk1_rate_imposta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Rate Imposta non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "RATE_IMPOSTA"
         if NEW_COD_FISCALE is not null then
            open  cpk2_rate_imposta(NEW_COD_FISCALE);
            fetch cpk2_rate_imposta into dummy;
            found := cpk2_rate_imposta%FOUND;
            close cpk2_rate_imposta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Rate Imposta non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "RATE_IMPOSTA"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk3_rate_imposta(NEW_TIPO_TRIBUTO);
            fetch cpk3_rate_imposta into dummy;
            found := cpk3_rate_imposta%FOUND;
            close cpk3_rate_imposta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Rate Imposta non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RATE_IMPOSTA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RATE_IMPOSTA
/* End Trigger: RATE_IMPOSTA_TC */

-- Procedure RATE_IMPOSTA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RATE_IMPOSTA

create or replace procedure RATE_IMPOSTA_PU
(old_rata_imposta IN number,
 old_oggetto_imposta IN number,
 old_cod_fiscale IN varchar,
 old_tipo_tributo IN varchar,
 new_rata_imposta IN number,
 new_oggetto_imposta IN number,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_IMPOSTA"
   cursor cpk1_rate_imposta(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk2_rate_imposta(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk3_rate_imposta(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "VERSAMENTI"
   cursor cfk1_rate_imposta(var_rata_imposta number) is
      select 1
      from   VERSAMENTI
      where  RATA_IMPOSTA = var_rata_imposta
       and   var_rata_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si modifica "RATE_IMPOSTA"
         if  NEW_OGGETTO_IMPOSTA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_IMPOSTA != OLD_OGGETTO_IMPOSTA or OLD_OGGETTO_IMPOSTA is null) ) then
            open  cpk1_rate_imposta(NEW_OGGETTO_IMPOSTA);
            fetch cpk1_rate_imposta into dummy;
            found := cpk1_rate_imposta%FOUND;
            close cpk1_rate_imposta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Rate Imposta non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "RATE_IMPOSTA"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk2_rate_imposta(NEW_COD_FISCALE);
            fetch cpk2_rate_imposta into dummy;
            found := cpk2_rate_imposta%FOUND;
            close cpk2_rate_imposta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Rate Imposta non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "RATE_IMPOSTA"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk3_rate_imposta(NEW_TIPO_TRIBUTO);
            fetch cpk3_rate_imposta into dummy;
            found := cpk3_rate_imposta%FOUND;
            close cpk3_rate_imposta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Rate Imposta non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "RATE_IMPOSTA" non modificabile se esistono referenze su "VERSAMENTI"
      if (OLD_RATA_IMPOSTA != NEW_RATA_IMPOSTA) then
         open  cfk1_rate_imposta(OLD_RATA_IMPOSTA);
         fetch cfk1_rate_imposta into dummy;
         found := cfk1_rate_imposta%FOUND;
         close cfk1_rate_imposta;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Rate Imposta non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RATE_IMPOSTA_PU */
/

-- Trigger RATE_IMPOSTA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RATE_IMPOSTA

create or replace trigger RATE_IMPOSTA_TIU
before INSERT
    or UPDATE
on RATE_IMPOSTA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.rata_imposta is null then
       RATE_IMPOSTA_NR (:new.rata_imposta);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RATE_IMPOSTA_PU(:OLD.RATA_IMPOSTA,
                         :OLD.OGGETTO_IMPOSTA,
                         :OLD.COD_FISCALE,
                         :OLD.TIPO_TRIBUTO,
                         :NEW.RATA_IMPOSTA,
                         :NEW.OGGETTO_IMPOSTA,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         RATE_IMPOSTA_PI(:NEW.OGGETTO_IMPOSTA,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RATE_IMPOSTA"
            cursor cpk_rate_imposta(var_RATA_IMPOSTA number) is
               select 1
                 from   RATE_IMPOSTA
                where  RATA_IMPOSTA = var_RATA_IMPOSTA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RATE_IMPOSTA"
               if :new.RATA_IMPOSTA is not null then
                  open  cpk_rate_imposta(:new.RATA_IMPOSTA);
                  fetch cpk_rate_imposta into dummy;
                  found := cpk_rate_imposta%FOUND;
                  close cpk_rate_imposta;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RATA_IMPOSTA||
                               '" gia'' presente in Rate Imposta. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RATE_IMPOSTA_TIU */
/

-- Procedure RATE_IMPOSTA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table RATE_IMPOSTA

create or replace procedure RATE_IMPOSTA_PD
(old_rata_imposta IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk1_rate_imposta(var_rata_imposta number) is
      select 1
      from   VERSAMENTI
      where  RATA_IMPOSTA = var_rata_imposta
       and   var_rata_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "RATE_IMPOSTA" if children still exist in "VERSAMENTI"
      open  cfk1_rate_imposta(OLD_RATA_IMPOSTA);
      fetch cfk1_rate_imposta into dummy;
      found := cfk1_rate_imposta%FOUND;
      close cfk1_rate_imposta;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Rate Imposta non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RATE_IMPOSTA_PD */
/

-- Tigger RATE_IMPOSTA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table RATE_IMPOSTA

create or replace trigger RATE_IMPOSTA_TD
before DELETE
on RATE_IMPOSTA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: VERSAMENTI

      RATE_IMPOSTA_PD(:OLD.RATA_IMPOSTA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RATE_IMPOSTA_TD */
/

-- Procedure RATE_PRATICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RATE_PRATICA

create or replace procedure RATE_PRATICA_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_rate_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "RATE_PRATICA"
         if NEW_PRATICA is not null then
            open  cpk1_rate_pratica(NEW_PRATICA);
            fetch cpk1_rate_pratica into dummy;
            found := cpk1_rate_pratica%FOUND;
            close cpk1_rate_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Rate Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RATE_PRATICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RATE_PRATICA
/* End Trigger: RATE_PRATICA_TC */

-- Procedure RATE_PRATICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RATE_PRATICA

create or replace procedure RATE_PRATICA_PU
(old_rata_pratica IN number,
 old_pratica IN number,
 new_rata_pratica IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_rate_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "RATE_PRATICA"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_rate_pratica(NEW_PRATICA);
            fetch cpk1_rate_pratica into dummy;
            found := cpk1_rate_pratica%FOUND;
            close cpk1_rate_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Rate Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RATE_PRATICA_PU */
/

-- Trigger RATE_PRATICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RATE_PRATICA

create or replace trigger RATE_PRATICA_TIU
before INSERT
    or UPDATE
on RATE_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.rata_pratica is null then
       RATE_PRATICA_NR (:new.rata_pratica);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RATE_PRATICA_PU(:OLD.RATA_PRATICA,
                         :OLD.PRATICA,
                         :NEW.RATA_PRATICA,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         RATE_PRATICA_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RATE_PRATICA"
            cursor cpk_rate_pratica(var_RATA_PRATICA number) is
               select 1
                 from   RATE_PRATICA
                where  RATA_PRATICA = var_RATA_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RATE_PRATICA"
               if :new.RATA_PRATICA is not null then
                  open  cpk_rate_pratica(:new.RATA_PRATICA);
                  fetch cpk_rate_pratica into dummy;
                  found := cpk_rate_pratica%FOUND;
                  close cpk_rate_pratica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RATA_PRATICA||
                               '" gia'' presente in Rate Pratica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RATE_PRATICA_TIU */
/

-- Procedure RECAPITI_SOGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RECAPITI_SOGGETTO

create or replace procedure RECAPITI_SOGGETTO_PI
(new_ni IN number,
 new_tipo_recapito IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_RECAPITO"
   cursor cpk1_recapiti_soggetto(var_tipo_recapito number) is
      select 1
      from   TIPI_RECAPITO
      where  TIPO_RECAPITO = var_tipo_recapito
       and   var_tipo_recapito is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk2_recapiti_soggetto(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_RECAPITO" deve esistere quando si inserisce su "RECAPITI_SOGGETTO"
         if NEW_TIPO_RECAPITO is not null then
            open  cpk1_recapiti_soggetto(NEW_TIPO_RECAPITO);
            fetch cpk1_recapiti_soggetto into dummy;
            found := cpk1_recapiti_soggetto%FOUND;
            close cpk1_recapiti_soggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su TIPI_RECAPITO. La registrazione RECAPITI_SOGGETTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "RECAPITI_SOGGETTO"
         if NEW_NI is not null then
            open  cpk2_recapiti_soggetto(NEW_NI);
            fetch cpk2_recapiti_soggetto into dummy;
            found := cpk2_recapiti_soggetto%FOUND;
            close cpk2_recapiti_soggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione RECAPITI_SOGGETTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RECAPITI_SOGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RECAPITI_SOGGETTO
/* End Trigger: RECAPITI_SOGGETTO_TC */

-- Procedure RECAPITI_SOGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RECAPITI_SOGGETTO

create or replace procedure RECAPITI_SOGGETTO_PU
(old_id_recapito IN number,
 old_ni IN number,
 old_tipo_recapito IN number,
 new_id_recapito IN number,
 new_ni IN number,
 new_tipo_recapito IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_RECAPITO"
   cursor cpk1_recapiti_soggetto(var_tipo_recapito number) is
      select 1
      from   TIPI_RECAPITO
      where  TIPO_RECAPITO = var_tipo_recapito
       and   var_tipo_recapito is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk2_recapiti_soggetto(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_RECAPITO" deve esistere quando si modifica "RECAPITI_SOGGETTO"
         if  NEW_TIPO_RECAPITO is not null and ( seq = 0 )
         and (   (NEW_TIPO_RECAPITO != OLD_TIPO_RECAPITO or OLD_TIPO_RECAPITO is null) ) then
            open  cpk1_recapiti_soggetto(NEW_TIPO_RECAPITO);
            fetch cpk1_recapiti_soggetto into dummy;
            found := cpk1_recapiti_soggetto%FOUND;
            close cpk1_recapiti_soggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su TIPI_RECAPITO. La registrazione RECAPITI_SOGGETTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "RECAPITI_SOGGETTO"
         if  NEW_NI is not null and ( seq = 0 )
         and (   (NEW_NI != OLD_NI or OLD_NI is null) ) then
            open  cpk2_recapiti_soggetto(NEW_NI);
            fetch cpk2_recapiti_soggetto into dummy;
            found := cpk2_recapiti_soggetto%FOUND;
            close cpk2_recapiti_soggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione RECAPITI_SOGGETTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RECAPITI_SOGGETTO_PU */
/

-- Trigger RECAPITI_SOGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RECAPITI_SOGGETTO

create or replace trigger RECAPITI_SOGGETTO_TIU
before INSERT
    or UPDATE
on RECAPITI_SOGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id_recapito is null then
       RECAPITI_SOGGETTO_NR(:new.id_recapito);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RECAPITI_SOGGETTO_PU(:OLD.ID_RECAPITO,
                              :OLD.NI,
                              :OLD.TIPO_RECAPITO,
                         :NEW.ID_RECAPITO,
                         :NEW.NI,
                         :NEW.TIPO_RECAPITO);
         null;
      end if;
      if INSERTING then
         RECAPITI_SOGGETTO_PI(:NEW.NI,
                              :NEW.TIPO_RECAPITO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RECAPITI_SOGGETTO"
            cursor cpk_recapiti_soggetto(var_ID_RECAPITO number) is
               select 1
                 from   RECAPITI_SOGGETTO
                where  ID_RECAPITO = var_ID_RECAPITO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RECAPITI_SOGGETTO"
               if :new.ID_RECAPITO is not null then
                  open  cpk_recapiti_soggetto(:new.ID_RECAPITO);
                  fetch cpk_recapiti_soggetto into dummy;
                  found := cpk_recapiti_soggetto%FOUND;
                  close cpk_recapiti_soggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_RECAPITO||
                               '" gia'' presente in RECAPITI_SOGGETTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RECAPITI_SOGGETTO_TIU */
/

-- Procedure REDDITI_RIFERIMENTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table REDDITI_RIFERIMENTO

create or replace procedure REDDITI_RIFERIMENTO_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_redditi_riferimento(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "REDDITI_RIFERIMENTO"
         if NEW_PRATICA is not null then
            open  cpk1_redditi_riferimento(NEW_PRATICA);
            fetch cpk1_redditi_riferimento into dummy;
            found := cpk1_redditi_riferimento%FOUND;
            close cpk1_redditi_riferimento;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Redditi Riferimento non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: REDDITI_RIFERIMENTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table REDDITI_RIFERIMENTO
/* End Trigger: REDDITI_RIFERIMENTO_TC */

-- Procedure REDDITI_RIFERIMENTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table REDDITI_RIFERIMENTO

create or replace procedure REDDITI_RIFERIMENTO_PU
(old_pratica IN number,
 old_sequenza IN number,
 new_pratica IN number,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_redditi_riferimento(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "REDDITI_RIFERIMENTO"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_redditi_riferimento(NEW_PRATICA);
            fetch cpk1_redditi_riferimento into dummy;
            found := cpk1_redditi_riferimento%FOUND;
            close cpk1_redditi_riferimento;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Redditi Riferimento non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: REDDITI_RIFERIMENTO_PU */
/

-- Trigger REDDITI_RIFERIMENTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table REDDITI_RIFERIMENTO

create or replace trigger REDDITI_RIFERIMENTO_TIU
before INSERT
    or UPDATE
on REDDITI_RIFERIMENTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       REDDITI_RIFERIMENTO_NR (:new.pratica,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         REDDITI_RIFERIMENTO_PU(:OLD.PRATICA,
                                :OLD.SEQUENZA,
                         :NEW.PRATICA,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         REDDITI_RIFERIMENTO_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "REDDITI_RIFERIMENTO"
            cursor cpk_redditi_riferimento(var_PRATICA number,
                                           var_SEQUENZA number) is
               select 1
                 from   REDDITI_RIFERIMENTO
                where  PRATICA = var_PRATICA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "REDDITI_RIFERIMENTO"
               if :new.PRATICA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_redditi_riferimento(:new.PRATICA,
                                                :new.SEQUENZA);
                  fetch cpk_redditi_riferimento into dummy;
                  found := cpk_redditi_riferimento%FOUND;
                  close cpk_redditi_riferimento;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Redditi Riferimento. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: REDDITI_RIFERIMENTO_TIU */
/

-- Procedure RELAZIONI_OGGETTI_CALCOLO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RELAZIONI_OGGETTI_CALCOLO

create or replace procedure RELAZIONI_OGGETTI_CALCOLO_PI
(new_tipo_tributo IN varchar,
 new_anno IN number,
 new_tipo_oggetto IN number,
 new_categoria_catasto IN varchar,
 new_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ALIQUOTE"
   cursor cpk1_relazioni_oggetti_calcolo(var_tipo_tributo varchar,
                                         var_anno number,
                                         var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_anno is not null
       and   var_tipo_aliquota is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MOLTIPLICATORI"
   cursor cpk2_relazioni_oggetti_calcolo(var_anno number,
                                         var_categoria_catasto varchar) is
      select 1
      from   MOLTIPLICATORI
      where  ANNO = var_anno
       and   CATEGORIA_CATASTO = var_categoria_catasto
       and   var_anno is not null
       and   var_categoria_catasto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_TRIBUTO"
   cursor cpk3_relazioni_oggetti_calcolo(var_tipo_tributo varchar,
                                         var_tipo_oggetto number) is
      select 1
      from   OGGETTI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_tributo is not null
       and   var_tipo_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ALIQUOTE" deve esistere quando si inserisce su "RELAZIONI_OGGETTI_CALCOLO"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_ANNO is not null and
            NEW_TIPO_ALIQUOTA is not null then
            open  cpk1_relazioni_oggetti_calcolo(NEW_TIPO_TRIBUTO,
                                                 NEW_ANNO,
                                                 NEW_TIPO_ALIQUOTA);
            fetch cpk1_relazioni_oggetti_calcolo into dummy;
            found := cpk1_relazioni_oggetti_calcolo%FOUND;
            close cpk1_relazioni_oggetti_calcolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Aliquote. La registrazione RELAZIONI_OGGETTI_CALCOLO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOLTIPLICATORI" deve esistere quando si inserisce su "RELAZIONI_OGGETTI_CALCOLO"
         if NEW_ANNO is not null and
            NEW_CATEGORIA_CATASTO is not null then
            open  cpk2_relazioni_oggetti_calcolo(NEW_ANNO,
                                                 NEW_CATEGORIA_CATASTO);
            fetch cpk2_relazioni_oggetti_calcolo into dummy;
            found := cpk2_relazioni_oggetti_calcolo%FOUND;
            close cpk2_relazioni_oggetti_calcolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Moltiplicatori. La registrazione RELAZIONI_OGGETTI_CALCOLO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_TRIBUTO" deve esistere quando si inserisce su "RELAZIONI_OGGETTI_CALCOLO"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_TIPO_OGGETTO is not null then
            open  cpk3_relazioni_oggetti_calcolo(NEW_TIPO_TRIBUTO,
                                                 NEW_TIPO_OGGETTO);
            fetch cpk3_relazioni_oggetti_calcolo into dummy;
            found := cpk3_relazioni_oggetti_calcolo%FOUND;
            close cpk3_relazioni_oggetti_calcolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Tributo. La registrazione RELAZIONI_OGGETTI_CALCOLO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RELAZIONI_OGGETTI_CALCOLO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RELAZIONI_OGGETTI_CALCOLO
/* End Trigger: RELAZIONI_OGGETTI_CALCOLO_TC */

-- Procedure RELAZIONI_OGGETTI_CALCOLO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RELAZIONI_OGGETTI_CALCOLO

create or replace procedure RELAZIONI_OGGETTI_CALCOLO_PU
(old_id_relazione IN number,
 old_tipo_tributo IN varchar,
 old_anno IN number,
 old_tipo_oggetto IN number,
 old_categoria_catasto IN varchar,
 old_tipo_aliquota IN number,
 new_id_relazione IN number,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_tipo_oggetto IN number,
 new_categoria_catasto IN varchar,
 new_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ALIQUOTE"
   cursor cpk1_relazioni_oggetti_calcolo(var_tipo_tributo varchar,
                                         var_anno number,
                                         var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   ANNO = var_anno
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_anno is not null
       and   var_tipo_aliquota is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MOLTIPLICATORI"
   cursor cpk2_relazioni_oggetti_calcolo(var_anno number,
                                         var_categoria_catasto varchar) is
      select 1
      from   MOLTIPLICATORI
      where  ANNO = var_anno
       and   CATEGORIA_CATASTO = var_categoria_catasto
       and   var_anno is not null
       and   var_categoria_catasto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_TRIBUTO"
   cursor cpk3_relazioni_oggetti_calcolo(var_tipo_tributo varchar,
                                         var_tipo_oggetto number) is
      select 1
      from   OGGETTI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_tributo is not null
       and   var_tipo_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ALIQUOTE" deve esistere quando si modifica "RELAZIONI_OGGETTI_CALCOLO"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_ANNO is not null and
             NEW_TIPO_ALIQUOTA is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_ANNO != OLD_ANNO or OLD_ANNO is null)
              or (NEW_TIPO_ALIQUOTA != OLD_TIPO_ALIQUOTA or OLD_TIPO_ALIQUOTA is null) ) then
            open  cpk1_relazioni_oggetti_calcolo(NEW_TIPO_TRIBUTO,
                                                 NEW_ANNO,
                                                 NEW_TIPO_ALIQUOTA);
            fetch cpk1_relazioni_oggetti_calcolo into dummy;
            found := cpk1_relazioni_oggetti_calcolo%FOUND;
            close cpk1_relazioni_oggetti_calcolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Aliquote. La registrazione RELAZIONI_OGGETTI_CALCOLO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOLTIPLICATORI" deve esistere quando si modifica "RELAZIONI_OGGETTI_CALCOLO"
         if  NEW_ANNO is not null and
             NEW_CATEGORIA_CATASTO is not null and ( seq = 0 )
         and (   (NEW_ANNO != OLD_ANNO or OLD_ANNO is null)
              or (NEW_CATEGORIA_CATASTO != OLD_CATEGORIA_CATASTO or OLD_CATEGORIA_CATASTO is null) ) then
            open  cpk2_relazioni_oggetti_calcolo(NEW_ANNO,
                                                 NEW_CATEGORIA_CATASTO);
            fetch cpk2_relazioni_oggetti_calcolo into dummy;
            found := cpk2_relazioni_oggetti_calcolo%FOUND;
            close cpk2_relazioni_oggetti_calcolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Moltiplicatori. La registrazione RELAZIONI_OGGETTI_CALCOLO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_TRIBUTO" deve esistere quando si modifica "RELAZIONI_OGGETTI_CALCOLO"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_TIPO_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_TIPO_OGGETTO != OLD_TIPO_OGGETTO or OLD_TIPO_OGGETTO is null) ) then
            open  cpk3_relazioni_oggetti_calcolo(NEW_TIPO_TRIBUTO,
                                                 NEW_TIPO_OGGETTO);
            fetch cpk3_relazioni_oggetti_calcolo into dummy;
            found := cpk3_relazioni_oggetti_calcolo%FOUND;
            close cpk3_relazioni_oggetti_calcolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Tributo. La registrazione RELAZIONI_OGGETTI_CALCOLO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RELAZIONI_OGGETTI_CALCOLO_PU */
/

-- Trigger RELAZIONI_OGGETTI_CALCOLO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RELAZIONI_OGGETTI_CALCOLO

create or replace trigger RELAZIONI_OGGETTI_CALCOLO_TIU
before INSERT
    or UPDATE
on RELAZIONI_OGGETTI_CALCOLO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.id_relazione is null then
       RELAZIONI_OGGETTI_CALCOLO_NR(:new.ID_RELAZIONE);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RELAZIONI_OGGETTI_CALCOLO_PU(:OLD.ID_RELAZIONE,
                                      :OLD.TIPO_TRIBUTO,
                                      :OLD.ANNO,
                                      :OLD.TIPO_OGGETTO,
                                      :OLD.CATEGORIA_CATASTO,
                                      :OLD.TIPO_ALIQUOTA,
                         :NEW.ID_RELAZIONE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.TIPO_OGGETTO,
                         :NEW.CATEGORIA_CATASTO,
                         :NEW.TIPO_ALIQUOTA);
         null;
      end if;
      if INSERTING then
         RELAZIONI_OGGETTI_CALCOLO_PI(:NEW.TIPO_TRIBUTO,
                                      :NEW.ANNO,
                                      :NEW.TIPO_OGGETTO,
                                      :NEW.CATEGORIA_CATASTO,
                                      :NEW.TIPO_ALIQUOTA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RELAZIONI_OGGETTI_CALCOLO"
            cursor cpk_relazioni_oggetti_calcolo(var_ID_RELAZIONE number) is
               select 1
                 from   RELAZIONI_OGGETTI_CALCOLO
                where  ID_RELAZIONE = var_ID_RELAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RELAZIONI_OGGETTI_CALCOLO"
               if :new.ID_RELAZIONE is not null then
                  open  cpk_relazioni_oggetti_calcolo(:new.ID_RELAZIONE);
                  fetch cpk_relazioni_oggetti_calcolo into dummy;
                  found := cpk_relazioni_oggetti_calcolo%FOUND;
                  close cpk_relazioni_oggetti_calcolo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_RELAZIONE||
                               '" gia'' presente in RELAZIONI_OGGETTI_CALCOLO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RELAZIONI_OGGETTI_CALCOLO_TIU */
/

-- Procedure RID_IMPAGATI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RID_IMPAGATI

create or replace procedure RID_IMPAGATI_PI
(new_documento_id IN number,
 new_fattura IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_rid_impagati(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FATTURE"
   cursor cpk2_rid_impagati(var_fattura number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk3_rid_impagati(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "RID_IMPAGATI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_rid_impagati(NEW_TIPO_TRIBUTO);
            fetch cpk1_rid_impagati into dummy;
            found := cpk1_rid_impagati%FOUND;
            close cpk1_rid_impagati;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione RID_IMPAGATI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FATTURE" deve esistere quando si inserisce su "RID_IMPAGATI"
         if NEW_FATTURA is not null then
            open  cpk2_rid_impagati(NEW_FATTURA);
            fetch cpk2_rid_impagati into dummy;
            found := cpk2_rid_impagati%FOUND;
            close cpk2_rid_impagati;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione RID_IMPAGATI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "RID_IMPAGATI"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk3_rid_impagati(NEW_DOCUMENTO_ID);
            fetch cpk3_rid_impagati into dummy;
            found := cpk3_rid_impagati%FOUND;
            close cpk3_rid_impagati;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione RID_IMPAGATI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RID_IMPAGATI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RID_IMPAGATI
/* End Trigger: RID_IMPAGATI_TC */

-- Procedure RID_IMPAGATI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RID_IMPAGATI

create or replace procedure RID_IMPAGATI_PU
(old_documento_id IN number,
 old_fattura IN number,
 old_tipo_tributo IN varchar,
 new_documento_id IN number,
 new_fattura IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_rid_impagati(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FATTURE"
   cursor cpk2_rid_impagati(var_fattura number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk3_rid_impagati(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "RID_IMPAGATI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_rid_impagati(NEW_TIPO_TRIBUTO);
            fetch cpk1_rid_impagati into dummy;
            found := cpk1_rid_impagati%FOUND;
            close cpk1_rid_impagati;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione RID_IMPAGATI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FATTURE" deve esistere quando si modifica "RID_IMPAGATI"
         if  NEW_FATTURA is not null and ( seq = 0 )
         and (   (NEW_FATTURA != OLD_FATTURA or OLD_FATTURA is null) ) then
            open  cpk2_rid_impagati(NEW_FATTURA);
            fetch cpk2_rid_impagati into dummy;
            found := cpk2_rid_impagati%FOUND;
            close cpk2_rid_impagati;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione RID_IMPAGATI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "RID_IMPAGATI"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk3_rid_impagati(NEW_DOCUMENTO_ID);
            fetch cpk3_rid_impagati into dummy;
            found := cpk3_rid_impagati%FOUND;
            close cpk3_rid_impagati;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione RID_IMPAGATI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RID_IMPAGATI_PU */
/

-- Trigger RID_IMPAGATI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RID_IMPAGATI

create or replace trigger RID_IMPAGATI_TIU
before INSERT
    or UPDATE
on RID_IMPAGATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RID_IMPAGATI_PU(:OLD.DOCUMENTO_ID,
                         :OLD.FATTURA,
                         :OLD.TIPO_TRIBUTO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.FATTURA,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         RID_IMPAGATI_PI(:NEW.DOCUMENTO_ID,
                         :NEW.FATTURA,
                         :NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RID_IMPAGATI"
            cursor cpk_rid_impagati(var_DOCUMENTO_ID number,
                                    var_FATTURA number) is
               select 1
                 from   RID_IMPAGATI
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       FATTURA = var_FATTURA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RID_IMPAGATI"
               if :new.DOCUMENTO_ID is not null and
                  :new.FATTURA is not null then
                  open  cpk_rid_impagati(:new.DOCUMENTO_ID,
                                         :new.FATTURA);
                  fetch cpk_rid_impagati into dummy;
                  found := cpk_rid_impagati%FOUND;
                  close cpk_rid_impagati;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.FATTURA||
                               '" gia'' presente in RID_IMPAGATI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RID_IMPAGATI_TIU */
/

-- Procedure RIDUZIONI_CER_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RIDUZIONI_CER

create or replace procedure RIDUZIONI_CER_PI
(new_codice_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE_CER"
   cursor cpk1_riduzioni_cer(var_codice_cer varchar) is
      select 1
      from   CATEGORIE_CER
      where  CODICE_CER = var_codice_cer
       and   var_codice_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CATEGORIE_CER" deve esistere quando si inserisce su "RIDUZIONI_CER"
         if NEW_CODICE_CER is not null then
            open  cpk1_riduzioni_cer(NEW_CODICE_CER);
            fetch cpk1_riduzioni_cer into dummy;
            found := cpk1_riduzioni_cer%FOUND;
            close cpk1_riduzioni_cer;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie CER. La registrazione Riduzioni CER non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RIDUZIONI_CER_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RIDUZIONI_CER
/* End Trigger: RIDUZIONI_CER_TC */

-- Procedure RIDUZIONI_CER_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RIDUZIONI_CER

create or replace procedure RIDUZIONI_CER_PU
(old_anno IN number,
 old_tipo_utenza IN varchar,
 old_codice_cer IN varchar,
 new_anno IN number,
 new_tipo_utenza IN varchar,
 new_codice_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE_CER"
   cursor cpk1_riduzioni_cer(var_codice_cer varchar) is
      select 1
      from   CATEGORIE_CER
      where  CODICE_CER = var_codice_cer
       and   var_codice_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CATEGORIE_CER" deve esistere quando si modifica "RIDUZIONI_CER"
         if  NEW_CODICE_CER is not null and ( seq = 0 )
         and (   (NEW_CODICE_CER != OLD_CODICE_CER or OLD_CODICE_CER is null) ) then
            open  cpk1_riduzioni_cer(NEW_CODICE_CER);
            fetch cpk1_riduzioni_cer into dummy;
            found := cpk1_riduzioni_cer%FOUND;
            close cpk1_riduzioni_cer;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie CER. La registrazione Riduzioni CER non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RIDUZIONI_CER_PU */
/

-- Trigger RIDUZIONI_CER_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RIDUZIONI_CER

create or replace trigger RIDUZIONI_CER_TIU
before INSERT
    or UPDATE
on RIDUZIONI_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RIDUZIONI_CER_PU(:OLD.ANNO,
                          :OLD.TIPO_UTENZA,
                          :OLD.CODICE_CER,
                         :NEW.ANNO,
                         :NEW.TIPO_UTENZA,
                         :NEW.CODICE_CER);
         null;
      end if;
      if INSERTING then
         RIDUZIONI_CER_PI(:NEW.CODICE_CER);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RIDUZIONI_CER"
            cursor cpk_riduzioni_cer(var_ANNO number,
                                     var_TIPO_UTENZA varchar,
                                     var_CODICE_CER varchar) is
               select 1
                 from   RIDUZIONI_CER
                where  ANNO = var_ANNO and
                       TIPO_UTENZA = var_TIPO_UTENZA and
                       CODICE_CER = var_CODICE_CER;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RIDUZIONI_CER"
               if :new.ANNO is not null and
                  :new.TIPO_UTENZA is not null and
                  :new.CODICE_CER is not null then
                  open  cpk_riduzioni_cer(:new.ANNO,
                                          :new.TIPO_UTENZA,
                                          :new.CODICE_CER);
                  fetch cpk_riduzioni_cer into dummy;
                  found := cpk_riduzioni_cer%FOUND;
                  close cpk_riduzioni_cer;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANNO||' '||
                               :new.TIPO_UTENZA||' '||
                               :new.CODICE_CER||
                               '" gia'' presente in Riduzioni CER. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RIDUZIONI_CER_TIU */
/

-- Procedure RIFERIMENTI_OGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RIFERIMENTI_OGGETTO

create or replace procedure RIFERIMENTI_OGGETTO_PI
(new_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk1_riferimenti_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "RIFERIMENTI_OGGETTO"
         if NEW_OGGETTO is not null then
            open  cpk1_riferimenti_oggetto(NEW_OGGETTO);
            fetch cpk1_riferimenti_oggetto into dummy;
            found := cpk1_riferimenti_oggetto%FOUND;
            close cpk1_riferimenti_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Riferimenti Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RIFERIMENTI_OGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RIFERIMENTI_OGGETTO
/* End Trigger: RIFERIMENTI_OGGETTO_TC */

-- Procedure RIFERIMENTI_OGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RIFERIMENTI_OGGETTO

create or replace procedure RIFERIMENTI_OGGETTO_PU
(old_oggetto IN number,
 old_inizio_validita IN date,
 new_oggetto IN number,
 new_inizio_validita IN date)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk1_riferimenti_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "RIFERIMENTI_OGGETTO"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk1_riferimenti_oggetto(NEW_OGGETTO);
            fetch cpk1_riferimenti_oggetto into dummy;
            found := cpk1_riferimenti_oggetto%FOUND;
            close cpk1_riferimenti_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Riferimenti Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RIFERIMENTI_OGGETTO_PU */
/

-- Trigger RIFERIMENTI_OGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RIFERIMENTI_OGGETTO

create or replace trigger RIFERIMENTI_OGGETTO_TIU
before INSERT
    or UPDATE
on RIFERIMENTI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
      RIFERIMENTI_OGGETTO_DI(:new.inizio_validita,:new.fine_validita,:new.da_Anno,:new.a_anno);
   end;

   if INSERTING then
      :new.data_reg := trunc(sysdate);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RIFERIMENTI_OGGETTO_PU(:OLD.OGGETTO,
                                :OLD.INIZIO_VALIDITA,
                         :NEW.OGGETTO,
                         :NEW.INIZIO_VALIDITA);
         null;
      end if;
      if INSERTING then
         RIFERIMENTI_OGGETTO_PI(:NEW.OGGETTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RIFERIMENTI_OGGETTO"
            cursor cpk_riferimenti_oggetto(var_OGGETTO number,
                                           var_INIZIO_VALIDITA date) is
               select 1
                 from   RIFERIMENTI_OGGETTO
                where  OGGETTO = var_OGGETTO and
                       INIZIO_VALIDITA = var_INIZIO_VALIDITA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RIFERIMENTI_OGGETTO"
               if :new.OGGETTO is not null and
                  :new.INIZIO_VALIDITA is not null then
                  open  cpk_riferimenti_oggetto(:new.OGGETTO,
                                                :new.INIZIO_VALIDITA);
                  fetch cpk_riferimenti_oggetto into dummy;
                  found := cpk_riferimenti_oggetto%FOUND;
                  close cpk_riferimenti_oggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||' '||
                               :new.INIZIO_VALIDITA||
                               '" gia'' presente in Riferimenti Oggetto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RIFERIMENTI_OGGETTO_TIU */
/

-- Procedure RIFERIMENTI_OGGETTO_BK_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RIFERIMENTI_OGGETTO_BK

create or replace procedure RIFERIMENTI_OGGETTO_BK_PU
(old_oggetto IN number,
 old_inizio_validita IN date,
 old_sequenza IN number,
 new_oggetto IN number,
 new_inizio_validita IN date,
 new_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RIFERIMENTI_OGGETTO_BK_PU */
/

-- Trigger RIFERIMENTI_OGGETTO_BK_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RIFERIMENTI_OGGETTO_BK

create or replace trigger RIFERIMENTI_OGGETTO_BK_TIU
before INSERT
    or UPDATE
on RIFERIMENTI_OGGETTO_BK
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
      RIFERIMENTI_OGGETTO_BK_NR(:new.oggetto, :new.inizio_validita, :new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RIFERIMENTI_OGGETTO_BK_PU(:OLD.OGGETTO,
                                   :OLD.INIZIO_VALIDITA,
                                   :OLD.SEQUENZA,
                         :NEW.OGGETTO,
                         :NEW.INIZIO_VALIDITA,
                         :NEW.SEQUENZA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RIFERIMENTI_OGGETTO_BK"
            cursor cpk_riferimenti_oggetto_bk(var_OGGETTO number,
                                              var_INIZIO_VALIDITA date,
                                              var_SEQUENZA number) is
               select 1
                 from   RIFERIMENTI_OGGETTO_BK
                where  OGGETTO = var_OGGETTO and
                       INIZIO_VALIDITA = var_INIZIO_VALIDITA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RIFERIMENTI_OGGETTO_BK"
               if :new.OGGETTO is not null and
                  :new.INIZIO_VALIDITA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_riferimenti_oggetto_bk(:new.OGGETTO,
                                                   :new.INIZIO_VALIDITA,
                                                   :new.SEQUENZA);
                  fetch cpk_riferimenti_oggetto_bk into dummy;
                  found := cpk_riferimenti_oggetto_bk%FOUND;
                  close cpk_riferimenti_oggetto_bk;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||' '||
                               :new.INIZIO_VALIDITA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in RIFERIMENTI_OGGETTO_BK. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RIFERIMENTI_OGGETTO_BK_TIU */
/

-- Procedure RIVALUTAZIONI_RENDITA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RIVALUTAZIONI_RENDITA

create or replace procedure RIVALUTAZIONI_RENDITA_PI
(new_tipo_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_OGGETTO"
   cursor cpk1_rivalutazioni_rendita(var_tipo_oggetto number) is
      select 1
      from   TIPI_OGGETTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_OGGETTO" deve esistere quando si inserisce su "RIVALUTAZIONI_RENDITA"
         if NEW_TIPO_OGGETTO is not null then
            open  cpk1_rivalutazioni_rendita(NEW_TIPO_OGGETTO);
            fetch cpk1_rivalutazioni_rendita into dummy;
            found := cpk1_rivalutazioni_rendita%FOUND;
            close cpk1_rivalutazioni_rendita;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Oggetto. La registrazione Rivalutazioni Rendita non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RIVALUTAZIONI_RENDITA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RIVALUTAZIONI_RENDITA
/* End Trigger: RIVALUTAZIONI_RENDITA_TC */

-- Procedure RIVALUTAZIONI_RENDITA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RIVALUTAZIONI_RENDITA

create or replace procedure RIVALUTAZIONI_RENDITA_PU
(old_anno IN number,
 old_tipo_oggetto IN number,
 new_anno IN number,
 new_tipo_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_OGGETTO"
   cursor cpk1_rivalutazioni_rendita(var_tipo_oggetto number) is
      select 1
      from   TIPI_OGGETTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_OGGETTO" deve esistere quando si modifica "RIVALUTAZIONI_RENDITA"
         if  NEW_TIPO_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_OGGETTO != OLD_TIPO_OGGETTO or OLD_TIPO_OGGETTO is null) ) then
            open  cpk1_rivalutazioni_rendita(NEW_TIPO_OGGETTO);
            fetch cpk1_rivalutazioni_rendita into dummy;
            found := cpk1_rivalutazioni_rendita%FOUND;
            close cpk1_rivalutazioni_rendita;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Oggetto. La registrazione Rivalutazioni Rendita non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RIVALUTAZIONI_RENDITA_PU */
/

-- Trigger RIVALUTAZIONI_RENDITA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RIVALUTAZIONI_RENDITA

create or replace trigger RIVALUTAZIONI_RENDITA_TIU
before INSERT
    or UPDATE
on RIVALUTAZIONI_RENDITA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RIVALUTAZIONI_RENDITA_PU(:OLD.ANNO,
                                  :OLD.TIPO_OGGETTO,
                         :NEW.ANNO,
                         :NEW.TIPO_OGGETTO);
         null;
      end if;
      if INSERTING then
         RIVALUTAZIONI_RENDITA_PI(:NEW.TIPO_OGGETTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RIVALUTAZIONI_RENDITA"
            cursor cpk_rivalutazioni_rendita(var_ANNO number,
                                             var_TIPO_OGGETTO number) is
               select 1
                 from   RIVALUTAZIONI_RENDITA
                where  ANNO = var_ANNO and
                       TIPO_OGGETTO = var_TIPO_OGGETTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RIVALUTAZIONI_RENDITA"
               if :new.ANNO is not null and
                  :new.TIPO_OGGETTO is not null then
                  open  cpk_rivalutazioni_rendita(:new.ANNO,
                                                  :new.TIPO_OGGETTO);
                  fetch cpk_rivalutazioni_rendita into dummy;
                  found := cpk_rivalutazioni_rendita%FOUND;
                  close cpk_rivalutazioni_rendita;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANNO||' '||
                               :new.TIPO_OGGETTO||
                               '" gia'' presente in Rivalutazioni Rendita. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RIVALUTAZIONI_RENDITA_TIU */
/

-- Procedure RUOLI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RUOLI

create or replace procedure RUOLI_PI
(new_tipo_tributo IN varchar,
 new_ruolo_rif IN number,
 new_ruolo_master IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_ruoli(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk2_ruoli(var_ruolo_rif number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo_rif
       and   var_ruolo_rif is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk3_ruoli(var_ruolo_master number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo_master
       and   var_ruolo_master is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "RUOLI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_ruoli(NEW_TIPO_TRIBUTO);
            fetch cpk1_ruoli into dummy;
            found := cpk1_ruoli%FOUND;
            close cpk1_ruoli;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Ruoli non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "RUOLI"
         if NEW_RUOLO_RIF is not null then
            open  cpk2_ruoli(NEW_RUOLO_RIF);
            fetch cpk2_ruoli into dummy;
            found := cpk2_ruoli%FOUND;
            close cpk2_ruoli;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "RUOLI"
         if NEW_RUOLO_MASTER is not null then
            open  cpk3_ruoli(NEW_RUOLO_MASTER);
            fetch cpk3_ruoli into dummy;
            found := cpk3_ruoli%FOUND;
            close cpk3_ruoli;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RUOLI

create or replace trigger RUOLI_TB
before INSERT
    or UPDATE
    or DELETE
on RUOLI
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: RUOLI_TB */
/

create or replace trigger RUOLI_TC
after INSERT
   or UPDATE
   or DELETE
on RUOLI
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: RUOLI_TC */
/

-- Procedure RUOLI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RUOLI

create or replace procedure RUOLI_PU
(old_ruolo IN number,
 old_tipo_tributo IN varchar,
 old_ruolo_rif IN number,
 old_ruolo_master IN number,
 new_ruolo IN number,
 new_tipo_tributo IN varchar,
 new_ruolo_rif IN number,
 new_ruolo_master IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_ruoli(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk2_ruoli(var_ruolo_rif number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo_rif
       and   var_ruolo_rif is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk3_ruoli(var_ruolo_master number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo_master
       and   var_ruolo_master is not null;

   --  Declaration of UpdateParentRestrict constraint for "RUOLI_CONTRIBUENTE"
   cursor cfk1_ruoli(var_ruolo number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_IMPOSTA"
   cursor cfk2_ruoli(var_ruolo number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "SANZIONI_PRATICA"
   cursor cfk3_ruoli(var_ruolo number) is
      select 1
      from   SANZIONI_PRATICA
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "WRK_TRASMISSIONE_RUOLO"
   cursor cfk4_ruoli(var_ruolo number) is
      select 1
      from   WRK_TRASMISSIONE_RUOLO
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "VERSAMENTI"
   cursor cfk5_ruoli(var_ruolo number) is
      select 1
      from   VERSAMENTI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "COMPENSAZIONI_RUOLO"
   cursor cfk6_ruoli(var_ruolo number) is
      select 1
      from   COMPENSAZIONI_RUOLO
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "DOCUMENTI_CONTRIBUENTE"
   cursor cfk7_ruoli(var_ruolo number) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "ELABORAZIONI_MASSIVE"
   cursor cfk8_ruoli(var_ruolo number) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "RUOLI_AUTOMATICI"
   cursor cfk9_ruoli(var_ruolo number) is
      select 1
      from   RUOLI_AUTOMATICI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of UpdateParentRestrict constraint for "RUOLI_ECCEDENZE"
   cursor cfk10_ruoli(var_ruolo number) is
      select 1
      from   RUOLI_ECCEDENZE
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "RUOLI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_ruoli(NEW_TIPO_TRIBUTO);
            fetch cpk1_ruoli into dummy;
            found := cpk1_ruoli%FOUND;
            close cpk1_ruoli;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Ruoli non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "RUOLI"
         if  NEW_RUOLO_RIF is not null and ( seq = 0 )
         and (   (NEW_RUOLO_RIF != OLD_RUOLO_RIF or OLD_RUOLO_RIF is null) ) then
            open  cpk2_ruoli(NEW_RUOLO_RIF);
            fetch cpk2_ruoli into dummy;
            found := cpk2_ruoli%FOUND;
            close cpk2_ruoli;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "RUOLI"
         if  NEW_RUOLO_MASTER is not null and ( seq = 0 )
         and (   (NEW_RUOLO_MASTER != OLD_RUOLO_MASTER or OLD_RUOLO_MASTER is null) ) then
            open  cpk3_ruoli(NEW_RUOLO_MASTER);
            fetch cpk3_ruoli into dummy;
            found := cpk3_ruoli%FOUND;
            close cpk3_ruoli;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "RUOLI_CONTRIBUENTE"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk1_ruoli(OLD_RUOLO);
         fetch cfk1_ruoli into dummy;
         found := cfk1_ruoli%FOUND;
         close cfk1_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Ruoli Contribuente. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "OGGETTI_IMPOSTA"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk2_ruoli(OLD_RUOLO);
         fetch cfk2_ruoli into dummy;
         found := cfk2_ruoli%FOUND;
         close cfk2_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Imposta. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "SANZIONI_PRATICA"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk3_ruoli(OLD_RUOLO);
         fetch cfk3_ruoli into dummy;
         found := cfk3_ruoli%FOUND;
         close cfk3_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sanzioni Pratica. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "WRK_TRASMISSIONE_RUOLO"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk4_ruoli(OLD_RUOLO);
         fetch cfk4_ruoli into dummy;
         found := cfk4_ruoli%FOUND;
         close cfk4_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Wrk Trasmissione Ruolo. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "VERSAMENTI"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk5_ruoli(OLD_RUOLO);
         fetch cfk5_ruoli into dummy;
         found := cfk5_ruoli%FOUND;
         close cfk5_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "COMPENSAZIONI_RUOLO"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk6_ruoli(OLD_RUOLO);
         fetch cfk6_ruoli into dummy;
         found := cfk6_ruoli%FOUND;
         close cfk6_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Compensazioni Ruolo. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "DOCUMENTI_CONTRIBUENTE"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk7_ruoli(OLD_RUOLO);
         fetch cfk7_ruoli into dummy;
         found := cfk7_ruoli%FOUND;
         close cfk7_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Documenti Contribuente. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "ELABORAZIONI_MASSIVE"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk8_ruoli(OLD_RUOLO);
         fetch cfk8_ruoli into dummy;
         found := cfk8_ruoli%FOUND;
         close cfk8_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Elaborazioni Massive. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "RUOLI_AUTOMATICI"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk9_ruoli(OLD_RUOLO);
         fetch cfk9_ruoli into dummy;
         found := cfk9_ruoli%FOUND;
         close cfk9_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Ruoli Automatici. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "RUOLI" non modificabile se esistono referenze su "RUOLI_ECCEDENZE"
      if (OLD_RUOLO != NEW_RUOLO) then
         open  cfk10_ruoli(OLD_RUOLO);
         fetch cfk10_ruoli into dummy;
         found := cfk10_ruoli%FOUND;
         close cfk10_ruoli;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Ruoli Eccedenze. La registrazione di Ruoli non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_PU */
/

-- Trigger RUOLI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RUOLI

create or replace trigger RUOLI_TIU
before INSERT
    or UPDATE
on RUOLI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      RUOLI_DI (:new.data_emissione,:new.data_denuncia,
                :new.scadenza_prima_rata,:new.invio_consorzio);
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.ruolo is null then
       RUOLI_NR (:new.ruolo);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RUOLI_PU(:OLD.RUOLO,
                  :OLD.TIPO_TRIBUTO,
                  :OLD.RUOLO_RIF,
                  :OLD.RUOLO_MASTER,
                         :NEW.RUOLO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.RUOLO_RIF,
                         :NEW.RUOLO_MASTER);
         null;
      end if;
      if INSERTING then
         RUOLI_PI(:NEW.TIPO_TRIBUTO,
                  :NEW.RUOLO_RIF,
                  :NEW.RUOLO_MASTER);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RUOLI"
            cursor cpk_ruoli(var_RUOLO number) is
               select 1
                 from   RUOLI
                where  RUOLO = var_RUOLO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RUOLI"
               if :new.RUOLO is not null then
                  open  cpk_ruoli(:new.RUOLO);
                  fetch cpk_ruoli into dummy;
                  found := cpk_ruoli%FOUND;
                  close cpk_ruoli;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RUOLO||
                               '" gia'' presente in Ruoli. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin -- Set PostEvent Check REFERENTIAL Integrity at Level 0
      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
      IF IntegrityPackage.GetNestLevel = 0 THEN
         --
         -- Integrità Referenziale di Esistenza FK
         --
         IF INSERTING THEN
            --
            -- Integrità Referenziale di Esistenza su insert FK
            --
            IF :new.ruolo_rif is NOT null THEN
               a_istruzione := 'select 1 from ruoli where ruolo = '
                               || :new.ruolo_rif;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;

            IF :new.ruolo_master is NOT null THEN
               a_istruzione := 'select 1 from ruoli where ruolo = '
                               || :new.ruolo_master;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;

         ELSIF UPDATING THEN
            IF nvl(:new.ruolo_rif,-1) != nvl(:old.ruolo_rif ,-1) THEN
               --
               -- Integrità Referenziale di Esistenza su update FK
               --
               IF :new.ruolo_rif is NOT null THEN
                  a_istruzione := 'select 1 from ruoli where ruolo = '
                                  ||:new.ruolo_rif;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;

            IF nvl(:new.ruolo_master,-1) != nvl(:old.ruolo_master ,-1) THEN
               --
               -- Integrità Referenziale di Esistenza su update FK
               --
               IF :new.ruolo_master is NOT null THEN
                  a_istruzione := 'select 1 from ruoli where ruolo = '
                                  ||:new.ruolo_master;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;

         END IF;
      END IF;
      IF UPDATING THEN
         IF :new.ruolo != :old.ruolo THEN
            --
            -- Integrità Referenziale su update PK
            --

            /* Caso di RESTRICT UPDATE */

               a_istruzione := 'select 0 from ruoli where ruolo_rif = '
                               ||:old.ruolo ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

               a_istruzione := 'select 0 from ruoli where ruolo_master = '
                               ||:old.ruolo ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

            /* Caso di CASCADE UPDATE

               a_istruzione := 'update ruoli set ruolo_rif ='
                               ||:new.ruolo ||' where ruolo_rif = '
                               ||:old.ruolo;
               a_messaggio := '';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            */

         END IF;
      END IF;
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
             RUOLI_FI(:new.ruolo, :old.tipo_emissione, :new.tipo_emissione);
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RUOLI_TIU */
/

-- Procedure RUOLI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table RUOLI

create or replace procedure RUOLI_PD
(old_ruolo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_CONTRIBUENTE"
   cursor cfk1_ruoli(var_ruolo number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_IMPOSTA"
   cursor cfk2_ruoli(var_ruolo number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SANZIONI_PRATICA"
   cursor cfk3_ruoli(var_ruolo number) is
      select 1
      from   SANZIONI_PRATICA
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk4_ruoli(var_ruolo number) is
      select 1
      from   VERSAMENTI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of DeleteParentRestrict constraint for "COMPENSAZIONI_RUOLO"
   cursor cfk5_ruoli(var_ruolo number) is
      select 1
      from   COMPENSAZIONI_RUOLO
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of DeleteParentRestrict constraint for "DOCUMENTI_CONTRIBUENTE"
   cursor cfk6_ruoli(var_ruolo number) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of DeleteParentRestrict constraint for "ELABORAZIONI_MASSIVE"
   cursor cfk7_ruoli(var_ruolo number) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_AUTOMATICI"
   cursor cfk8_ruoli(var_ruolo number) is
      select 1
      from   RUOLI_AUTOMATICI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_ECCEDENZE"
   cursor cfk9_ruoli(var_ruolo number) is
      select 1
      from   RUOLI_ECCEDENZE
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "RUOLI" if children still exist in "RUOLI_CONTRIBUENTE"
      open  cfk1_ruoli(OLD_RUOLO);
      fetch cfk1_ruoli into dummy;
      found := cfk1_ruoli%FOUND;
      close cfk1_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Contribuente. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "RUOLI" if children still exist in "OGGETTI_IMPOSTA"
      open  cfk2_ruoli(OLD_RUOLO);
      fetch cfk2_ruoli into dummy;
      found := cfk2_ruoli%FOUND;
      close cfk2_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Imposta. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "RUOLI" if children still exist in "SANZIONI_PRATICA"
      open  cfk3_ruoli(OLD_RUOLO);
      fetch cfk3_ruoli into dummy;
      found := cfk3_ruoli%FOUND;
      close cfk3_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sanzioni Pratica. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "RUOLI" if children still exist in "VERSAMENTI"
      open  cfk4_ruoli(OLD_RUOLO);
      fetch cfk4_ruoli into dummy;
      found := cfk4_ruoli%FOUND;
      close cfk4_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "RUOLI" if children still exist in "COMPENSAZIONI_RUOLO"
      open  cfk5_ruoli(OLD_RUOLO);
      fetch cfk5_ruoli into dummy;
      found := cfk5_ruoli%FOUND;
      close cfk5_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Compensazioni Ruolo. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "RUOLI" if children still exist in "DOCUMENTI_CONTRIBUENTE"
      open  cfk6_ruoli(OLD_RUOLO);
      fetch cfk6_ruoli into dummy;
      found := cfk6_ruoli%FOUND;
      close cfk6_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Documenti Contribuente. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "RUOLI" if children still exist in "ELABORAZIONI_MASSIVE"
      open  cfk7_ruoli(OLD_RUOLO);
      fetch cfk7_ruoli into dummy;
      found := cfk7_ruoli%FOUND;
      close cfk7_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Elaborazioni Massive. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "RUOLI" if children still exist in "RUOLI_AUTOMATICI"
      open  cfk8_ruoli(OLD_RUOLO);
      fetch cfk8_ruoli into dummy;
      found := cfk8_ruoli%FOUND;
      close cfk8_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Automatici. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "RUOLI" if children still exist in "RUOLI_ECCEDENZE"
      open  cfk9_ruoli(OLD_RUOLO);
      fetch cfk9_ruoli into dummy;
      found := cfk9_ruoli%FOUND;
      close cfk9_ruoli;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Eccedenze. La registrazione di Ruoli non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_PD */
/

-- Tigger RUOLI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table RUOLI

create or replace trigger RUOLI_TD
before DELETE
on RUOLI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: RUOLI_CONTRIBUENTE

      -- Child Restrict Table: OGGETTI_IMPOSTA

      -- Child Restrict Table: SANZIONI_PRATICA

      -- Child Restrict Table: VERSAMENTI

      -- Child Restrict Table: COMPENSAZIONI_RUOLO

      -- Child Restrict Table: DOCUMENTI_CONTRIBUENTE

      -- Child Restrict Table: ELABORAZIONI_MASSIVE

      -- Child Restrict Table: RUOLI_AUTOMATICI

      -- Child Restrict Table: RUOLI_ECCEDENZE

      RUOLI_PD(:OLD.RUOLO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "WRK_TRASMISSIONE_RUOLO"
      delete WRK_TRASMISSIONE_RUOLO
      where  RUOLO = :OLD.RUOLO;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
            DECLARE a_istruzione  varchar2(2000);
                    a_messaggio   varchar2(2000);
            BEGIN
	     BEGIN
               a_messaggio := 'Esistono riferimenti su Ruoli. La registrazione di Ruoli non e'' eliminabile.';
               a_istruzione := 'select 0 from ruoli where ruolo_rif = '
                               ||:old.ruolo;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
             EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
             END;

	     BEGIN
               a_messaggio := 'Esistono riferimenti su Ruoli(Master). La registrazione di Ruoli non e'' eliminabile.';
               a_istruzione := 'select 0 from ruoli where ruolo_master = '
                               ||:old.ruolo;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
             EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
             END;

	    END;
   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RUOLI_TD */
/

-- Procedure RUOLI_AUTOMATICI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RUOLI_AUTOMATICI

create or replace procedure RUOLI_AUTOMATICI_PI
(new_tipo_tributo IN varchar,
 new_ruolo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk1_ruoli_automatici(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_ruoli_automatici(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "RUOLI_AUTOMATICI"
         if NEW_RUOLO is not null then
            open  cpk1_ruoli_automatici(NEW_RUOLO);
            fetch cpk1_ruoli_automatici into dummy;
            found := cpk1_ruoli_automatici%FOUND;
            close cpk1_ruoli_automatici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli Automatici non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "RUOLI_AUTOMATICI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_ruoli_automatici(NEW_TIPO_TRIBUTO);
            fetch cpk2_ruoli_automatici into dummy;
            found := cpk2_ruoli_automatici%FOUND;
            close cpk2_ruoli_automatici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Ruoli Automatici non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_AUTOMATICI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RUOLI_AUTOMATICI
/* End Trigger: RUOLI_AUTOMATICI_TC */

-- Procedure RUOLI_AUTOMATICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RUOLI_AUTOMATICI

create or replace procedure RUOLI_AUTOMATICI_PU
(old_id IN number,
 old_tipo_tributo IN varchar,
 old_ruolo IN number,
 new_id IN number,
 new_tipo_tributo IN varchar,
 new_ruolo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk1_ruoli_automatici(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_ruoli_automatici(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "RUOLI_AUTOMATICI"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk1_ruoli_automatici(NEW_RUOLO);
            fetch cpk1_ruoli_automatici into dummy;
            found := cpk1_ruoli_automatici%FOUND;
            close cpk1_ruoli_automatici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli Automatici non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "RUOLI_AUTOMATICI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_ruoli_automatici(NEW_TIPO_TRIBUTO);
            fetch cpk2_ruoli_automatici into dummy;
            found := cpk2_ruoli_automatici%FOUND;
            close cpk2_ruoli_automatici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Ruoli Automatici non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_AUTOMATICI_PU */
/

-- Trigger RUOLI_AUTOMATICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RUOLI_AUTOMATICI

create or replace trigger RUOLI_AUTOMATICI_TIU
before INSERT
    or UPDATE
on RUOLI_AUTOMATICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id is null then
      RUOLI_AUTOMATICI_NR (:new.id);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RUOLI_AUTOMATICI_PU(:OLD.ID,
                             :OLD.TIPO_TRIBUTO,
                             :OLD.RUOLO,
                         :NEW.ID,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.RUOLO);
         null;
      end if;
      if INSERTING then
         RUOLI_AUTOMATICI_PI(:NEW.TIPO_TRIBUTO,
                             :NEW.RUOLO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RUOLI_AUTOMATICI"
            cursor cpk_ruoli_automatici(var_ID number) is
               select 1
                 from   RUOLI_AUTOMATICI
                where  ID = var_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RUOLI_AUTOMATICI"
               if :new.ID is not null then
                  open  cpk_ruoli_automatici(:new.ID);
                  fetch cpk_ruoli_automatici into dummy;
                  found := cpk_ruoli_automatici%FOUND;
                  close cpk_ruoli_automatici;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID||
                               '" gia'' presente in Ruoli Automatici. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RUOLI_AUTOMATICI_TIU */
/

-- Procedure RUOLI_CONTRIBUENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RUOLI_CONTRIBUENTE

create or replace procedure RUOLI_CONTRIBUENTE_PI
(new_ruolo IN number,
 new_cod_fiscale IN varchar,
 new_oggetto_imposta IN number,
 new_pratica IN number,
 new_tributo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_ruoli_contribuente(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_TRIBUTO"
   cursor cpk2_ruoli_contribuente(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk3_ruoli_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk4_ruoli_contribuente(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_IMPOSTA"
   cursor cpk5_ruoli_contribuente(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "RUOLI_CONTRIBUENTE"
         if NEW_PRATICA is not null then
            open  cpk1_ruoli_contribuente(NEW_PRATICA);
            fetch cpk1_ruoli_contribuente into dummy;
            found := cpk1_ruoli_contribuente%FOUND;
            close cpk1_ruoli_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Ruoli Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si inserisce su "RUOLI_CONTRIBUENTE"
         if NEW_TRIBUTO is not null then
            open  cpk2_ruoli_contribuente(NEW_TRIBUTO);
            fetch cpk2_ruoli_contribuente into dummy;
            found := cpk2_ruoli_contribuente%FOUND;
            close cpk2_ruoli_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Ruoli Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "RUOLI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null then
            open  cpk3_ruoli_contribuente(NEW_COD_FISCALE);
            fetch cpk3_ruoli_contribuente into dummy;
            found := cpk3_ruoli_contribuente%FOUND;
            close cpk3_ruoli_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Ruoli Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "RUOLI_CONTRIBUENTE"
         if NEW_RUOLO is not null then
            open  cpk4_ruoli_contribuente(NEW_RUOLO);
            fetch cpk4_ruoli_contribuente into dummy;
            found := cpk4_ruoli_contribuente%FOUND;
            close cpk4_ruoli_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si inserisce su "RUOLI_CONTRIBUENTE"
         if NEW_OGGETTO_IMPOSTA is not null then
            open  cpk5_ruoli_contribuente(NEW_OGGETTO_IMPOSTA);
            fetch cpk5_ruoli_contribuente into dummy;
            found := cpk5_ruoli_contribuente%FOUND;
            close cpk5_ruoli_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Ruoli Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_CONTRIBUENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RUOLI_CONTRIBUENTE
/* End Trigger: RUOLI_CONTRIBUENTE_TC */

-- Procedure RUOLI_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RUOLI_CONTRIBUENTE

create or replace procedure RUOLI_CONTRIBUENTE_PU
(old_ruolo IN number,
 old_cod_fiscale IN varchar,
 old_sequenza IN number,
 old_oggetto_imposta IN number,
 old_pratica IN number,
 old_tributo IN number,
 new_ruolo IN number,
 new_cod_fiscale IN varchar,
 new_sequenza IN number,
 new_oggetto_imposta IN number,
 new_pratica IN number,
 new_tributo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_ruoli_contribuente(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_TRIBUTO"
   cursor cpk2_ruoli_contribuente(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk3_ruoli_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk4_ruoli_contribuente(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_IMPOSTA"
   cursor cpk5_ruoli_contribuente(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "RUOLI_CONTRIBUENTE"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_ruoli_contribuente(NEW_PRATICA);
            fetch cpk1_ruoli_contribuente into dummy;
            found := cpk1_ruoli_contribuente%FOUND;
            close cpk1_ruoli_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Ruoli Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si modifica "RUOLI_CONTRIBUENTE"
         if  NEW_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null) ) then
            open  cpk2_ruoli_contribuente(NEW_TRIBUTO);
            fetch cpk2_ruoli_contribuente into dummy;
            found := cpk2_ruoli_contribuente%FOUND;
            close cpk2_ruoli_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Ruoli Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "RUOLI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk3_ruoli_contribuente(NEW_COD_FISCALE);
            fetch cpk3_ruoli_contribuente into dummy;
            found := cpk3_ruoli_contribuente%FOUND;
            close cpk3_ruoli_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Ruoli Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "RUOLI_CONTRIBUENTE"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk4_ruoli_contribuente(NEW_RUOLO);
            fetch cpk4_ruoli_contribuente into dummy;
            found := cpk4_ruoli_contribuente%FOUND;
            close cpk4_ruoli_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si modifica "RUOLI_CONTRIBUENTE"
         if  NEW_OGGETTO_IMPOSTA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_IMPOSTA != OLD_OGGETTO_IMPOSTA or OLD_OGGETTO_IMPOSTA is null) ) then
            open  cpk5_ruoli_contribuente(NEW_OGGETTO_IMPOSTA);
            fetch cpk5_ruoli_contribuente into dummy;
            found := cpk5_ruoli_contribuente%FOUND;
            close cpk5_ruoli_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Ruoli Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_CONTRIBUENTE_PU */
/

-- Trigger RUOLI_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RUOLI_CONTRIBUENTE

create or replace trigger RUOLI_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on RUOLI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      RUOLI_CONTRIBUENTE_DI (:new.data_cartella,:new.decorrenza_interessi);
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
       RUOLI_CONTRIBUENTE_NR (:new.ruolo,:new.cod_fiscale,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RUOLI_CONTRIBUENTE_PU(:OLD.RUOLO,
                               :OLD.COD_FISCALE,
                               :OLD.SEQUENZA,
                               :OLD.OGGETTO_IMPOSTA,
                               :OLD.PRATICA,
                               :OLD.TRIBUTO,
                         :NEW.RUOLO,
                         :NEW.COD_FISCALE,
                         :NEW.SEQUENZA,
                         :NEW.OGGETTO_IMPOSTA,
                         :NEW.PRATICA,
                         :NEW.TRIBUTO);
         null;
      end if;
      if INSERTING then
         RUOLI_CONTRIBUENTE_PI(:NEW.RUOLO,
                               :NEW.COD_FISCALE,
                               :NEW.OGGETTO_IMPOSTA,
                               :NEW.PRATICA,
                               :NEW.TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RUOLI_CONTRIBUENTE"
            cursor cpk_ruoli_contribuente(var_RUOLO number,
                                          var_COD_FISCALE varchar,
                                          var_SEQUENZA number) is
               select 1
                 from   RUOLI_CONTRIBUENTE
                where  RUOLO = var_RUOLO and
                       COD_FISCALE = var_COD_FISCALE and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RUOLI_CONTRIBUENTE"
               if :new.RUOLO is not null and
                  :new.COD_FISCALE is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_ruoli_contribuente(:new.RUOLO,
                                               :new.COD_FISCALE,
                                               :new.SEQUENZA);
                  fetch cpk_ruoli_contribuente into dummy;
                  found := cpk_ruoli_contribuente%FOUND;
                  close cpk_ruoli_contribuente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RUOLO||' '||
                               :new.COD_FISCALE||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Ruoli Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "RUOLI_CONTRIBUENTE" for all children in "SGRAVI"
         if (:OLD.RUOLO != :NEW.RUOLO) or
            (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.SEQUENZA != :NEW.SEQUENZA) then
            update SGRAVI
             set   RUOLO = :NEW.RUOLO,
                   COD_FISCALE = :NEW.COD_FISCALE,
                   SEQUENZA = :NEW.SEQUENZA
            where  RUOLO = :OLD.RUOLO
             and   COD_FISCALE = :OLD.COD_FISCALE
             and   SEQUENZA = :OLD.SEQUENZA;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RUOLI_CONTRIBUENTE_TIU */
/

-- Procedure RUOLI_CONTRIBUENTE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table RUOLI_CONTRIBUENTE

create or replace procedure RUOLI_CONTRIBUENTE_PD
(old_ruolo IN number,
 old_cod_fiscale IN varchar,
 old_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SGRAVI"
   cursor cfk1_ruoli_contribuente(var_ruolo number,
                                  var_cod_fiscale varchar,
                                  var_sequenza number) is
      select 1
      from   SGRAVI
      where  RUOLO = var_ruolo
       and   COD_FISCALE = var_cod_fiscale
       and   SEQUENZA = var_sequenza
       and   var_ruolo is not null
       and   var_cod_fiscale is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "RUOLI_CONTRIBUENTE" if children still exist in "SGRAVI"
      open  cfk1_ruoli_contribuente(OLD_RUOLO,
                                    OLD_COD_FISCALE,
                                    OLD_SEQUENZA);
      fetch cfk1_ruoli_contribuente into dummy;
      found := cfk1_ruoli_contribuente%FOUND;
      close cfk1_ruoli_contribuente;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sgravi. La registrazione di Ruoli Contribuente non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_CONTRIBUENTE_PD */
/

-- Tigger RUOLI_CONTRIBUENTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table RUOLI_CONTRIBUENTE

create or replace trigger RUOLI_CONTRIBUENTE_TD
before DELETE
on RUOLI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SGRAVI

      RUOLI_CONTRIBUENTE_PD(:OLD.RUOLO,
                            :OLD.COD_FISCALE,
                            :OLD.SEQUENZA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RUOLI_CONTRIBUENTE_TD */
/

-- Procedure RUOLI_ECCEDENZE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table RUOLI_ECCEDENZE

create or replace procedure RUOLI_ECCEDENZE_PI
(new_ruolo IN number,
 new_cod_fiscale IN varchar,
 new_tributo IN number,
 new_categoria IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk1_ruoli_eccedenze(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk2_ruoli_eccedenze(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE"
   cursor cpk3_ruoli_eccedenze(var_tributo number,
                               var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "RUOLI_ECCEDENZE"
         if NEW_RUOLO is not null then
            open  cpk1_ruoli_eccedenze(NEW_RUOLO);
            fetch cpk1_ruoli_eccedenze into dummy;
            found := cpk1_ruoli_eccedenze%FOUND;
            close cpk1_ruoli_eccedenze;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli Eccedenze non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "RUOLI_ECCEDENZE"
         if NEW_COD_FISCALE is not null then
            open  cpk2_ruoli_eccedenze(NEW_COD_FISCALE);
            fetch cpk2_ruoli_eccedenze into dummy;
            found := cpk2_ruoli_eccedenze%FOUND;
            close cpk2_ruoli_eccedenze;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Ruoli Eccedenze non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE" deve esistere quando si inserisce su "RUOLI_ECCEDENZE"
         if NEW_TRIBUTO is not null and
            NEW_CATEGORIA is not null then
            open  cpk3_ruoli_eccedenze(NEW_TRIBUTO,
                                       NEW_CATEGORIA);
            fetch cpk3_ruoli_eccedenze into dummy;
            found := cpk3_ruoli_eccedenze%FOUND;
            close cpk3_ruoli_eccedenze;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Ruoli Eccedenze non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_ECCEDENZE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table RUOLI_ECCEDENZE
/* End Trigger: RUOLI_ECCEDENZE_TC */

-- Procedure RUOLI_ECCEDENZE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table RUOLI_ECCEDENZE

create or replace procedure RUOLI_ECCEDENZE_PU
(old_id_eccedenza IN number,
 old_ruolo IN number,
 old_cod_fiscale IN varchar,
 old_tributo IN number,
 old_categoria IN number,
 new_id_eccedenza IN number,
 new_ruolo IN number,
 new_cod_fiscale IN varchar,
 new_tributo IN number,
 new_categoria IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk1_ruoli_eccedenze(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk2_ruoli_eccedenze(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE"
   cursor cpk3_ruoli_eccedenze(var_tributo number,
                               var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "RUOLI_ECCEDENZE"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk1_ruoli_eccedenze(NEW_RUOLO);
            fetch cpk1_ruoli_eccedenze into dummy;
            found := cpk1_ruoli_eccedenze%FOUND;
            close cpk1_ruoli_eccedenze;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Ruoli Eccedenze non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "RUOLI_ECCEDENZE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk2_ruoli_eccedenze(NEW_COD_FISCALE);
            fetch cpk2_ruoli_eccedenze into dummy;
            found := cpk2_ruoli_eccedenze%FOUND;
            close cpk2_ruoli_eccedenze;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Ruoli Eccedenze non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CATEGORIE" deve esistere quando si modifica "RUOLI_ECCEDENZE"
         if  NEW_TRIBUTO is not null and
             NEW_CATEGORIA is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null)
              or (NEW_CATEGORIA != OLD_CATEGORIA or OLD_CATEGORIA is null) ) then
            open  cpk3_ruoli_eccedenze(NEW_TRIBUTO,
                                       NEW_CATEGORIA);
            fetch cpk3_ruoli_eccedenze into dummy;
            found := cpk3_ruoli_eccedenze%FOUND;
            close cpk3_ruoli_eccedenze;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Ruoli Eccedenze non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: RUOLI_ECCEDENZE_PU */
/

-- Trigger RUOLI_ECCEDENZE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table RUOLI_ECCEDENZE

create or replace trigger RUOLI_ECCEDENZE_TIU
before INSERT
    or UPDATE
on RUOLI_ECCEDENZE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id_eccedenza is null then
      RUOLI_ECCEDENZE_NR(:new.id_eccedenza);
      RUOLI_ECCEDENZE_SEQ_NR(:new.ruolo,:new.cod_fiscale,:new.tributo,:new.categoria,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         RUOLI_ECCEDENZE_PU(:OLD.ID_ECCEDENZA,
                            :OLD.RUOLO,
                            :OLD.COD_FISCALE,
                            :OLD.TRIBUTO,
                            :OLD.CATEGORIA,
                         :NEW.ID_ECCEDENZA,
                         :NEW.RUOLO,
                         :NEW.COD_FISCALE,
                         :NEW.TRIBUTO,
                         :NEW.CATEGORIA);
         null;
      end if;
      if INSERTING then
         RUOLI_ECCEDENZE_PI(:NEW.RUOLO,
                            :NEW.COD_FISCALE,
                            :NEW.TRIBUTO,
                            :NEW.CATEGORIA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "RUOLI_ECCEDENZE"
            cursor cpk_ruoli_eccedenze(var_ID_ECCEDENZA number) is
               select 1
                 from   RUOLI_ECCEDENZE
                where  ID_ECCEDENZA = var_ID_ECCEDENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "RUOLI_ECCEDENZE"
               if :new.ID_ECCEDENZA is not null then
                  open  cpk_ruoli_eccedenze(:new.ID_ECCEDENZA);
                  fetch cpk_ruoli_eccedenze into dummy;
                  found := cpk_ruoli_eccedenze%FOUND;
                  close cpk_ruoli_eccedenze;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_ECCEDENZA||
                               '" gia'' presente in Ruoli Eccedenze. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: RUOLI_ECCEDENZE_TIU */
/

-- Procedure SAM_CODICI_CARICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_CODICI_CARICA

create or replace procedure SAM_CODICI_CARICA_PU
(old_cod_carica IN varchar,
 new_cod_carica IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk1_sam_codici_carica(var_cod_carica varchar) is
      select 1
      from   SAM_RISPOSTE
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_DITTA"
   cursor cfk2_sam_codici_carica(var_cod_carica varchar) is
      select 1
      from   SAM_RISPOSTE_DITTA
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_RAP"
   cursor cfk3_sam_codici_carica(var_cod_carica varchar) is
      select 1
      from   SAM_RISPOSTE_RAP
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "SAM_CODICI_CARICA" non modificabile se esistono referenze su "SAM_RISPOSTE"
      if (OLD_COD_CARICA != NEW_COD_CARICA) then
         open  cfk1_sam_codici_carica(OLD_COD_CARICA);
         fetch cfk1_sam_codici_carica into dummy;
         found := cfk1_sam_codici_carica%FOUND;
         close cfk1_sam_codici_carica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_CODICI_CARICA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SAM_CODICI_CARICA" non modificabile se esistono referenze su "SAM_RISPOSTE_DITTA"
      if (OLD_COD_CARICA != NEW_COD_CARICA) then
         open  cfk2_sam_codici_carica(OLD_COD_CARICA);
         fetch cfk2_sam_codici_carica into dummy;
         found := cfk2_sam_codici_carica%FOUND;
         close cfk2_sam_codici_carica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_DITTA. La registrazione di SAM_CODICI_CARICA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SAM_CODICI_CARICA" non modificabile se esistono referenze su "SAM_RISPOSTE_RAP"
      if (OLD_COD_CARICA != NEW_COD_CARICA) then
         open  cfk3_sam_codici_carica(OLD_COD_CARICA);
         fetch cfk3_sam_codici_carica into dummy;
         found := cfk3_sam_codici_carica%FOUND;
         close cfk3_sam_codici_carica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_RAP. La registrazione di SAM_CODICI_CARICA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_CODICI_CARICA_PU */
/

-- Trigger SAM_CODICI_CARICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_CODICI_CARICA

create or replace trigger SAM_CODICI_CARICA_TIU
before INSERT
    or UPDATE
on SAM_CODICI_CARICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_CODICI_CARICA_PU(:OLD.COD_CARICA,
                         :NEW.COD_CARICA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_CODICI_CARICA"
            cursor cpk_sam_codici_carica(var_COD_CARICA varchar) is
               select 1
                 from   SAM_CODICI_CARICA
                where  COD_CARICA = var_COD_CARICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_CODICI_CARICA"
               if :new.COD_CARICA is not null then
                  open  cpk_sam_codici_carica(:new.COD_CARICA);
                  fetch cpk_sam_codici_carica into dummy;
                  found := cpk_sam_codici_carica%FOUND;
                  close cpk_sam_codici_carica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_CARICA||
                               '" gia'' presente in SAM_CODICI_CARICA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_CODICI_CARICA_TIU */
/

-- Procedure SAM_CODICI_CARICA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SAM_CODICI_CARICA

create or replace procedure SAM_CODICI_CARICA_PD
(old_cod_carica IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk1_sam_codici_carica(var_cod_carica varchar) is
      select 1
      from   SAM_RISPOSTE
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_DITTA"
   cursor cfk2_sam_codici_carica(var_cod_carica varchar) is
      select 1
      from   SAM_RISPOSTE_DITTA
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_RAP"
   cursor cfk3_sam_codici_carica(var_cod_carica varchar) is
      select 1
      from   SAM_RISPOSTE_RAP
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SAM_CODICI_CARICA" if children still exist in "SAM_RISPOSTE"
      open  cfk1_sam_codici_carica(OLD_COD_CARICA);
      fetch cfk1_sam_codici_carica into dummy;
      found := cfk1_sam_codici_carica%FOUND;
      close cfk1_sam_codici_carica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_CODICI_CARICA non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SAM_CODICI_CARICA" if children still exist in "SAM_RISPOSTE_DITTA"
      open  cfk2_sam_codici_carica(OLD_COD_CARICA);
      fetch cfk2_sam_codici_carica into dummy;
      found := cfk2_sam_codici_carica%FOUND;
      close cfk2_sam_codici_carica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_DITTA. La registrazione di SAM_CODICI_CARICA non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SAM_CODICI_CARICA" if children still exist in "SAM_RISPOSTE_RAP"
      open  cfk3_sam_codici_carica(OLD_COD_CARICA);
      fetch cfk3_sam_codici_carica into dummy;
      found := cfk3_sam_codici_carica%FOUND;
      close cfk3_sam_codici_carica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_RAP. La registrazione di SAM_CODICI_CARICA non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_CODICI_CARICA_PD */
/

-- Tigger SAM_CODICI_CARICA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SAM_CODICI_CARICA

create or replace trigger SAM_CODICI_CARICA_TD
before DELETE
on SAM_CODICI_CARICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SAM_RISPOSTE

      -- Child Restrict Table: SAM_RISPOSTE_DITTA

      -- Child Restrict Table: SAM_RISPOSTE_RAP

      SAM_CODICI_CARICA_PD(:OLD.COD_CARICA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_CODICI_CARICA_TD */
/

-- Procedure SAM_CODICI_RITORNO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_CODICI_RITORNO

create or replace procedure SAM_CODICI_RITORNO_PU
(old_cod_ritorno IN varchar,
 new_cod_ritorno IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_PARTITA_IVA"
   cursor cfk1_sam_codici_ritorno(var_cod_ritorno varchar) is
      select 1
      from   SAM_RISPOSTE_PARTITA_IVA
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk2_sam_codici_ritorno(var_cod_ritorno varchar) is
      select 1
      from   SAM_RISPOSTE
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_DITTA"
   cursor cfk3_sam_codici_ritorno(var_cod_ritorno varchar) is
      select 1
      from   SAM_RISPOSTE_DITTA
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_RAP"
   cursor cfk4_sam_codici_ritorno(var_cod_ritorno varchar) is
      select 1
      from   SAM_RISPOSTE_RAP
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "SAM_CODICI_RITORNO" non modificabile se esistono referenze su "SAM_RISPOSTE_PARTITA_IVA"
      if (OLD_COD_RITORNO != NEW_COD_RITORNO) then
         open  cfk1_sam_codici_ritorno(OLD_COD_RITORNO);
         fetch cfk1_sam_codici_ritorno into dummy;
         found := cfk1_sam_codici_ritorno%FOUND;
         close cfk1_sam_codici_ritorno;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_PARTITA_IVA. La registrazione di SAM_CODICI_RITORNO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SAM_CODICI_RITORNO" non modificabile se esistono referenze su "SAM_RISPOSTE"
      if (OLD_COD_RITORNO != NEW_COD_RITORNO) then
         open  cfk2_sam_codici_ritorno(OLD_COD_RITORNO);
         fetch cfk2_sam_codici_ritorno into dummy;
         found := cfk2_sam_codici_ritorno%FOUND;
         close cfk2_sam_codici_ritorno;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_CODICI_RITORNO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SAM_CODICI_RITORNO" non modificabile se esistono referenze su "SAM_RISPOSTE_DITTA"
      if (OLD_COD_RITORNO != NEW_COD_RITORNO) then
         open  cfk3_sam_codici_ritorno(OLD_COD_RITORNO);
         fetch cfk3_sam_codici_ritorno into dummy;
         found := cfk3_sam_codici_ritorno%FOUND;
         close cfk3_sam_codici_ritorno;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_DITTA. La registrazione di SAM_CODICI_RITORNO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SAM_CODICI_RITORNO" non modificabile se esistono referenze su "SAM_RISPOSTE_RAP"
      if (OLD_COD_RITORNO != NEW_COD_RITORNO) then
         open  cfk4_sam_codici_ritorno(OLD_COD_RITORNO);
         fetch cfk4_sam_codici_ritorno into dummy;
         found := cfk4_sam_codici_ritorno%FOUND;
         close cfk4_sam_codici_ritorno;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_RAP. La registrazione di SAM_CODICI_RITORNO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_CODICI_RITORNO_PU */
/

-- Trigger SAM_CODICI_RITORNO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_CODICI_RITORNO

create or replace trigger SAM_CODICI_RITORNO_TIU
before INSERT
    or UPDATE
on SAM_CODICI_RITORNO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_CODICI_RITORNO_PU(:OLD.COD_RITORNO,
                         :NEW.COD_RITORNO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_CODICI_RITORNO"
            cursor cpk_sam_codici_ritorno(var_COD_RITORNO varchar) is
               select 1
                 from   SAM_CODICI_RITORNO
                where  COD_RITORNO = var_COD_RITORNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_CODICI_RITORNO"
               if :new.COD_RITORNO is not null then
                  open  cpk_sam_codici_ritorno(:new.COD_RITORNO);
                  fetch cpk_sam_codici_ritorno into dummy;
                  found := cpk_sam_codici_ritorno%FOUND;
                  close cpk_sam_codici_ritorno;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_RITORNO||
                               '" gia'' presente in SAM_CODICI_RITORNO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_CODICI_RITORNO_TIU */
/

-- Procedure SAM_CODICI_RITORNO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SAM_CODICI_RITORNO

create or replace procedure SAM_CODICI_RITORNO_PD
(old_cod_ritorno IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_PARTITA_IVA"
   cursor cfk1_sam_codici_ritorno(var_cod_ritorno varchar) is
      select 1
      from   SAM_RISPOSTE_PARTITA_IVA
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk2_sam_codici_ritorno(var_cod_ritorno varchar) is
      select 1
      from   SAM_RISPOSTE
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_DITTA"
   cursor cfk3_sam_codici_ritorno(var_cod_ritorno varchar) is
      select 1
      from   SAM_RISPOSTE_DITTA
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_RAP"
   cursor cfk4_sam_codici_ritorno(var_cod_ritorno varchar) is
      select 1
      from   SAM_RISPOSTE_RAP
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SAM_CODICI_RITORNO" if children still exist in "SAM_RISPOSTE_PARTITA_IVA"
      open  cfk1_sam_codici_ritorno(OLD_COD_RITORNO);
      fetch cfk1_sam_codici_ritorno into dummy;
      found := cfk1_sam_codici_ritorno%FOUND;
      close cfk1_sam_codici_ritorno;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_PARTITA_IVA. La registrazione di SAM_CODICI_RITORNO non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SAM_CODICI_RITORNO" if children still exist in "SAM_RISPOSTE"
      open  cfk2_sam_codici_ritorno(OLD_COD_RITORNO);
      fetch cfk2_sam_codici_ritorno into dummy;
      found := cfk2_sam_codici_ritorno%FOUND;
      close cfk2_sam_codici_ritorno;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_CODICI_RITORNO non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SAM_CODICI_RITORNO" if children still exist in "SAM_RISPOSTE_DITTA"
      open  cfk3_sam_codici_ritorno(OLD_COD_RITORNO);
      fetch cfk3_sam_codici_ritorno into dummy;
      found := cfk3_sam_codici_ritorno%FOUND;
      close cfk3_sam_codici_ritorno;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_DITTA. La registrazione di SAM_CODICI_RITORNO non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SAM_CODICI_RITORNO" if children still exist in "SAM_RISPOSTE_RAP"
      open  cfk4_sam_codici_ritorno(OLD_COD_RITORNO);
      fetch cfk4_sam_codici_ritorno into dummy;
      found := cfk4_sam_codici_ritorno%FOUND;
      close cfk4_sam_codici_ritorno;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_RAP. La registrazione di SAM_CODICI_RITORNO non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_CODICI_RITORNO_PD */
/

-- Tigger SAM_CODICI_RITORNO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SAM_CODICI_RITORNO

create or replace trigger SAM_CODICI_RITORNO_TD
before DELETE
on SAM_CODICI_RITORNO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SAM_RISPOSTE_PARTITA_IVA

      -- Child Restrict Table: SAM_RISPOSTE

      -- Child Restrict Table: SAM_RISPOSTE_DITTA

      -- Child Restrict Table: SAM_RISPOSTE_RAP

      SAM_CODICI_RITORNO_PD(:OLD.COD_RITORNO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_CODICI_RITORNO_TD */
/

-- Procedure SAM_FONTI_DECESSO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_FONTI_DECESSO

create or replace procedure SAM_FONTI_DECESSO_PU
(old_fonte_decesso IN varchar,
 new_fonte_decesso IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk1_sam_fonti_decesso(var_fonte_decesso varchar) is
      select 1
      from   SAM_RISPOSTE
      where  FONTE_DECESSO = var_fonte_decesso
       and   var_fonte_decesso is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "SAM_FONTI_DECESSO" non modificabile se esistono referenze su "SAM_RISPOSTE"
      if (OLD_FONTE_DECESSO != NEW_FONTE_DECESSO) then
         open  cfk1_sam_fonti_decesso(OLD_FONTE_DECESSO);
         fetch cfk1_sam_fonti_decesso into dummy;
         found := cfk1_sam_fonti_decesso%FOUND;
         close cfk1_sam_fonti_decesso;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_FONTI_DECESSO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_FONTI_DECESSO_PU */
/

-- Trigger SAM_FONTI_DECESSO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_FONTI_DECESSO

create or replace trigger SAM_FONTI_DECESSO_TIU
before INSERT
    or UPDATE
on SAM_FONTI_DECESSO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_FONTI_DECESSO_PU(:OLD.FONTE_DECESSO,
                         :NEW.FONTE_DECESSO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_FONTI_DECESSO"
            cursor cpk_sam_fonti_decesso(var_FONTE_DECESSO varchar) is
               select 1
                 from   SAM_FONTI_DECESSO
                where  FONTE_DECESSO = var_FONTE_DECESSO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_FONTI_DECESSO"
               if :new.FONTE_DECESSO is not null then
                  open  cpk_sam_fonti_decesso(:new.FONTE_DECESSO);
                  fetch cpk_sam_fonti_decesso into dummy;
                  found := cpk_sam_fonti_decesso%FOUND;
                  close cpk_sam_fonti_decesso;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.FONTE_DECESSO||
                               '" gia'' presente in SAM_FONTI_DECESSO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_FONTI_DECESSO_TIU */
/

-- Procedure SAM_FONTI_DECESSO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SAM_FONTI_DECESSO

create or replace procedure SAM_FONTI_DECESSO_PD
(old_fonte_decesso IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk1_sam_fonti_decesso(var_fonte_decesso varchar) is
      select 1
      from   SAM_RISPOSTE
      where  FONTE_DECESSO = var_fonte_decesso
       and   var_fonte_decesso is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SAM_FONTI_DECESSO" if children still exist in "SAM_RISPOSTE"
      open  cfk1_sam_fonti_decesso(OLD_FONTE_DECESSO);
      fetch cfk1_sam_fonti_decesso into dummy;
      found := cfk1_sam_fonti_decesso%FOUND;
      close cfk1_sam_fonti_decesso;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_FONTI_DECESSO non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_FONTI_DECESSO_PD */
/

-- Tigger SAM_FONTI_DECESSO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SAM_FONTI_DECESSO

create or replace trigger SAM_FONTI_DECESSO_TD
before DELETE
on SAM_FONTI_DECESSO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SAM_RISPOSTE

      SAM_FONTI_DECESSO_PD(:OLD.FONTE_DECESSO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_FONTI_DECESSO_TD */
/

-- Procedure SAM_FONTI_DOM_SEDE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_FONTI_DOM_SEDE

create or replace procedure SAM_FONTI_DOM_SEDE_PU
(old_fonte IN varchar,
 new_fonte IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk1_sam_fonti_dom_sede(var_fonte varchar) is
      select 1
      from   SAM_RISPOSTE
      where  FONTE_DOMICILIO = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk2_sam_fonti_dom_sede(var_fonte varchar) is
      select 1
      from   SAM_RISPOSTE
      where  FONTE_SEDE_LEGALE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "SAM_FONTI_DOM_SEDE" non modificabile se esistono referenze su "SAM_RISPOSTE"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk1_sam_fonti_dom_sede(OLD_FONTE);
         fetch cfk1_sam_fonti_dom_sede into dummy;
         found := cfk1_sam_fonti_dom_sede%FOUND;
         close cfk1_sam_fonti_dom_sede;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_FONTI_DOM_SEDE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SAM_FONTI_DOM_SEDE" non modificabile se esistono referenze su "SAM_RISPOSTE"
      if (OLD_FONTE != NEW_FONTE) then
         open  cfk2_sam_fonti_dom_sede(OLD_FONTE);
         fetch cfk2_sam_fonti_dom_sede into dummy;
         found := cfk2_sam_fonti_dom_sede%FOUND;
         close cfk2_sam_fonti_dom_sede;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_FONTI_DOM_SEDE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_FONTI_DOM_SEDE_PU */
/

-- Trigger SAM_FONTI_DOM_SEDE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_FONTI_DOM_SEDE

create or replace trigger SAM_FONTI_DOM_SEDE_TIU
before INSERT
    or UPDATE
on SAM_FONTI_DOM_SEDE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_FONTI_DOM_SEDE_PU(:OLD.FONTE,
                         :NEW.FONTE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_FONTI_DOM_SEDE"
            cursor cpk_sam_fonti_dom_sede(var_FONTE varchar) is
               select 1
                 from   SAM_FONTI_DOM_SEDE
                where  FONTE = var_FONTE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_FONTI_DOM_SEDE"
               if :new.FONTE is not null then
                  open  cpk_sam_fonti_dom_sede(:new.FONTE);
                  fetch cpk_sam_fonti_dom_sede into dummy;
                  found := cpk_sam_fonti_dom_sede%FOUND;
                  close cpk_sam_fonti_dom_sede;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.FONTE||
                               '" gia'' presente in SAM_FONTI_DOM_SEDE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_FONTI_DOM_SEDE_TIU */
/

-- Procedure SAM_FONTI_DOM_SEDE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SAM_FONTI_DOM_SEDE

create or replace procedure SAM_FONTI_DOM_SEDE_PD
(old_fonte IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk1_sam_fonti_dom_sede(var_fonte varchar) is
      select 1
      from   SAM_RISPOSTE
      where  FONTE_DOMICILIO = var_fonte
       and   var_fonte is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk2_sam_fonti_dom_sede(var_fonte varchar) is
      select 1
      from   SAM_RISPOSTE
      where  FONTE_SEDE_LEGALE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SAM_FONTI_DOM_SEDE" if children still exist in "SAM_RISPOSTE"
      open  cfk1_sam_fonti_dom_sede(OLD_FONTE);
      fetch cfk1_sam_fonti_dom_sede into dummy;
      found := cfk1_sam_fonti_dom_sede%FOUND;
      close cfk1_sam_fonti_dom_sede;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_FONTI_DOM_SEDE non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SAM_FONTI_DOM_SEDE" if children still exist in "SAM_RISPOSTE"
      open  cfk2_sam_fonti_dom_sede(OLD_FONTE);
      fetch cfk2_sam_fonti_dom_sede into dummy;
      found := cfk2_sam_fonti_dom_sede%FOUND;
      close cfk2_sam_fonti_dom_sede;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_FONTI_DOM_SEDE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_FONTI_DOM_SEDE_PD */
/

-- Tigger SAM_FONTI_DOM_SEDE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SAM_FONTI_DOM_SEDE

create or replace trigger SAM_FONTI_DOM_SEDE_TD
before DELETE
on SAM_FONTI_DOM_SEDE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SAM_RISPOSTE

      -- Child Restrict Table: SAM_RISPOSTE

      SAM_FONTI_DOM_SEDE_PD(:OLD.FONTE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_FONTI_DOM_SEDE_TD */
/

-- Procedure SAM_INTERROGAZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SAM_INTERROGAZIONI

create or replace procedure SAM_INTERROGAZIONI_PI
(new_cod_fiscale IN varchar,
 new_tipo IN varchar,
 new_elaborazione_id IN number,
 new_attivita_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_sam_interrogazioni(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_TIPI"
   cursor cpk2_sam_interrogazioni(var_tipo varchar) is
      select 1
      from   SAM_TIPI
      where  TIPO = var_tipo
       and   var_tipo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ELABORAZIONI_MASSIVE"
   cursor cpk3_sam_interrogazioni(var_elaborazione_id number) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ATTIVITA_ELABORAZIONE"
   cursor cpk4_sam_interrogazioni(var_attivita_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_attivita_id
       and   var_attivita_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "SAM_INTERROGAZIONI"
         if NEW_COD_FISCALE is not null then
            open  cpk1_sam_interrogazioni(NEW_COD_FISCALE);
            fetch cpk1_sam_interrogazioni into dummy;
            found := cpk1_sam_interrogazioni%FOUND;
            close cpk1_sam_interrogazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione SAM_INTERROGAZIONI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_TIPI" deve esistere quando si inserisce su "SAM_INTERROGAZIONI"
         if NEW_TIPO is not null then
            open  cpk2_sam_interrogazioni(NEW_TIPO);
            fetch cpk2_sam_interrogazioni into dummy;
            found := cpk2_sam_interrogazioni%FOUND;
            close cpk2_sam_interrogazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_TIPI. La registrazione SAM_INTERROGAZIONI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ELABORAZIONI_MASSIVE" deve esistere quando si inserisce su "SAM_INTERROGAZIONI"
         if NEW_ELABORAZIONE_ID is not null then
            open  cpk3_sam_interrogazioni(NEW_ELABORAZIONE_ID);
            fetch cpk3_sam_interrogazioni into dummy;
            found := cpk3_sam_interrogazioni%FOUND;
            close cpk3_sam_interrogazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Elaborazioni Massive. La registrazione SAM_INTERROGAZIONI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si inserisce su "SAM_INTERROGAZIONI"
         if NEW_ATTIVITA_ID is not null then
            open  cpk4_sam_interrogazioni(NEW_ATTIVITA_ID);
            fetch cpk4_sam_interrogazioni into dummy;
            found := cpk4_sam_interrogazioni%FOUND;
            close cpk4_sam_interrogazioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione SAM_INTERROGAZIONI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_INTERROGAZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SAM_INTERROGAZIONI
/* End Trigger: SAM_INTERROGAZIONI_TC */

-- Procedure SAM_INTERROGAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_INTERROGAZIONI

create or replace procedure SAM_INTERROGAZIONI_PU
(old_interrogazione IN number,
 old_cod_fiscale IN varchar,
 old_tipo IN varchar,
 old_elaborazione_id IN number,
 old_attivita_id IN number,
 new_interrogazione IN number,
 new_cod_fiscale IN varchar,
 new_tipo IN varchar,
 new_elaborazione_id IN number,
 new_attivita_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_sam_interrogazioni(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_TIPI"
   cursor cpk2_sam_interrogazioni(var_tipo varchar) is
      select 1
      from   SAM_TIPI
      where  TIPO = var_tipo
       and   var_tipo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ELABORAZIONI_MASSIVE"
   cursor cpk3_sam_interrogazioni(var_elaborazione_id number) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  ELABORAZIONE_ID = var_elaborazione_id
       and   var_elaborazione_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ATTIVITA_ELABORAZIONE"
   cursor cpk4_sam_interrogazioni(var_attivita_id number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  ATTIVITA_ID = var_attivita_id
       and   var_attivita_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk1_sam_interrogazioni(var_interrogazione number) is
      select 1
      from   SAM_RISPOSTE
      where  INTERROGAZIONE = var_interrogazione
       and   var_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "SAM_INTERROGAZIONI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_sam_interrogazioni(NEW_COD_FISCALE);
            fetch cpk1_sam_interrogazioni into dummy;
            found := cpk1_sam_interrogazioni%FOUND;
            close cpk1_sam_interrogazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione SAM_INTERROGAZIONI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_TIPI" deve esistere quando si modifica "SAM_INTERROGAZIONI"
         if  NEW_TIPO is not null and ( seq = 0 )
         and (   (NEW_TIPO != OLD_TIPO or OLD_TIPO is null) ) then
            open  cpk2_sam_interrogazioni(NEW_TIPO);
            fetch cpk2_sam_interrogazioni into dummy;
            found := cpk2_sam_interrogazioni%FOUND;
            close cpk2_sam_interrogazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_TIPI. La registrazione SAM_INTERROGAZIONI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ELABORAZIONI_MASSIVE" deve esistere quando si modifica "SAM_INTERROGAZIONI"
         if  NEW_ELABORAZIONE_ID is not null and ( seq = 0 )
         and (   (NEW_ELABORAZIONE_ID != OLD_ELABORAZIONE_ID or OLD_ELABORAZIONE_ID is null) ) then
            open  cpk3_sam_interrogazioni(NEW_ELABORAZIONE_ID);
            fetch cpk3_sam_interrogazioni into dummy;
            found := cpk3_sam_interrogazioni%FOUND;
            close cpk3_sam_interrogazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Elaborazioni Massive. La registrazione SAM_INTERROGAZIONI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ATTIVITA_ELABORAZIONE" deve esistere quando si modifica "SAM_INTERROGAZIONI"
         if  NEW_ATTIVITA_ID is not null and ( seq = 0 )
         and (   (NEW_ATTIVITA_ID != OLD_ATTIVITA_ID or OLD_ATTIVITA_ID is null) ) then
            open  cpk4_sam_interrogazioni(NEW_ATTIVITA_ID);
            fetch cpk4_sam_interrogazioni into dummy;
            found := cpk4_sam_interrogazioni%FOUND;
            close cpk4_sam_interrogazioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Attivita Elaborazione. La registrazione SAM_INTERROGAZIONI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SAM_INTERROGAZIONI" non modificabile se esistono referenze su "SAM_RISPOSTE"
      if (OLD_INTERROGAZIONE != NEW_INTERROGAZIONE) then
         open  cfk1_sam_interrogazioni(OLD_INTERROGAZIONE);
         fetch cfk1_sam_interrogazioni into dummy;
         found := cfk1_sam_interrogazioni%FOUND;
         close cfk1_sam_interrogazioni;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_INTERROGAZIONI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_INTERROGAZIONI_PU */
/

-- Trigger SAM_INTERROGAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_INTERROGAZIONI

create or replace trigger SAM_INTERROGAZIONI_TIU
before INSERT
    or UPDATE
on SAM_INTERROGAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.interrogazione is null then
      SAM_INTERROGAZIONI_NR (:new.interrogazione);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_INTERROGAZIONI_PU(:OLD.INTERROGAZIONE,
                               :OLD.COD_FISCALE,
                               :OLD.TIPO,
                               :OLD.ELABORAZIONE_ID,
                               :OLD.ATTIVITA_ID,
                         :NEW.INTERROGAZIONE,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO,
                         :NEW.ELABORAZIONE_ID,
                         :NEW.ATTIVITA_ID);
         null;
      end if;
      if INSERTING then
         SAM_INTERROGAZIONI_PI(:NEW.COD_FISCALE,
                               :NEW.TIPO,
                               :NEW.ELABORAZIONE_ID,
                               :NEW.ATTIVITA_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_INTERROGAZIONI"
            cursor cpk_sam_interrogazioni(var_INTERROGAZIONE number) is
               select 1
                 from   SAM_INTERROGAZIONI
                where  INTERROGAZIONE = var_INTERROGAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_INTERROGAZIONI"
               if :new.INTERROGAZIONE is not null then
                  open  cpk_sam_interrogazioni(:new.INTERROGAZIONE);
                  fetch cpk_sam_interrogazioni into dummy;
                  found := cpk_sam_interrogazioni%FOUND;
                  close cpk_sam_interrogazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.INTERROGAZIONE||
                               '" gia'' presente in SAM_INTERROGAZIONI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_INTERROGAZIONI_TIU */
/

-- Procedure SAM_INTERROGAZIONI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SAM_INTERROGAZIONI

create or replace procedure SAM_INTERROGAZIONI_PD
(old_interrogazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE"
   cursor cfk1_sam_interrogazioni(var_interrogazione number) is
      select 1
      from   SAM_RISPOSTE
      where  INTERROGAZIONE = var_interrogazione
       and   var_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SAM_INTERROGAZIONI" if children still exist in "SAM_RISPOSTE"
      open  cfk1_sam_interrogazioni(OLD_INTERROGAZIONE);
      fetch cfk1_sam_interrogazioni into dummy;
      found := cfk1_sam_interrogazioni%FOUND;
      close cfk1_sam_interrogazioni;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE. La registrazione di SAM_INTERROGAZIONI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_INTERROGAZIONI_PD */
/

-- Tigger SAM_INTERROGAZIONI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SAM_INTERROGAZIONI

create or replace trigger SAM_INTERROGAZIONI_TD
before DELETE
on SAM_INTERROGAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SAM_RISPOSTE

      SAM_INTERROGAZIONI_PD(:OLD.INTERROGAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_INTERROGAZIONI_TD */
/

-- Procedure SAM_RISPOSTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SAM_RISPOSTE

create or replace procedure SAM_RISPOSTE_PI
(new_interrogazione IN number,
 new_cod_ritorno IN varchar,
 new_fonte_domicilio IN varchar,
 new_fonte_decesso IN varchar,
 new_fonte_sede_legale IN varchar,
 new_cod_carica IN varchar,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_INTERROGAZIONI"
   cursor cpk1_sam_risposte(var_interrogazione number) is
      select 1
      from   SAM_INTERROGAZIONI
      where  INTERROGAZIONE = var_interrogazione
       and   var_interrogazione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_CODICI_RITORNO"
   cursor cpk2_sam_risposte(var_cod_ritorno varchar) is
      select 1
      from   SAM_CODICI_RITORNO
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_FONTI_DOM_SEDE"
   cursor cpk3_sam_risposte(var_fonte_domicilio varchar) is
      select 1
      from   SAM_FONTI_DOM_SEDE
      where  FONTE = var_fonte_domicilio
       and   var_fonte_domicilio is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_FONTI_DECESSO"
   cursor cpk4_sam_risposte(var_fonte_decesso varchar) is
      select 1
      from   SAM_FONTI_DECESSO
      where  FONTE_DECESSO = var_fonte_decesso
       and   var_fonte_decesso is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_FONTI_DOM_SEDE"
   cursor cpk5_sam_risposte(var_fonte_sede_legale varchar) is
      select 1
      from   SAM_FONTI_DOM_SEDE
      where  FONTE = var_fonte_sede_legale
       and   var_fonte_sede_legale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_CODICI_CARICA"
   cursor cpk6_sam_risposte(var_cod_carica varchar) is
      select 1
      from   SAM_CODICI_CARICA
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk7_sam_risposte(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SAM_INTERROGAZIONI" deve esistere quando si inserisce su "SAM_RISPOSTE"
         if NEW_INTERROGAZIONE is not null then
            open  cpk1_sam_risposte(NEW_INTERROGAZIONE);
            fetch cpk1_sam_risposte into dummy;
            found := cpk1_sam_risposte%FOUND;
            close cpk1_sam_risposte;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_INTERROGAZIONI. La registrazione SAM_RISPOSTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_CODICI_RITORNO" deve esistere quando si inserisce su "SAM_RISPOSTE"
         if NEW_COD_RITORNO is not null then
            open  cpk2_sam_risposte(NEW_COD_RITORNO);
            fetch cpk2_sam_risposte into dummy;
            found := cpk2_sam_risposte%FOUND;
            close cpk2_sam_risposte;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_CODICI_RITORNO. La registrazione SAM_RISPOSTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_FONTI_DOM_SEDE" deve esistere quando si inserisce su "SAM_RISPOSTE"
         if NEW_FONTE_DOMICILIO is not null then
            open  cpk3_sam_risposte(NEW_FONTE_DOMICILIO);
            fetch cpk3_sam_risposte into dummy;
            found := cpk3_sam_risposte%FOUND;
            close cpk3_sam_risposte;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_FONTI_DOM_SEDE. La registrazione SAM_RISPOSTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_FONTI_DECESSO" deve esistere quando si inserisce su "SAM_RISPOSTE"
         if NEW_FONTE_DECESSO is not null then
            open  cpk4_sam_risposte(NEW_FONTE_DECESSO);
            fetch cpk4_sam_risposte into dummy;
            found := cpk4_sam_risposte%FOUND;
            close cpk4_sam_risposte;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_FONTI_DECESSO. La registrazione SAM_RISPOSTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_FONTI_DOM_SEDE" deve esistere quando si inserisce su "SAM_RISPOSTE"
         if NEW_FONTE_SEDE_LEGALE is not null then
            open  cpk5_sam_risposte(NEW_FONTE_SEDE_LEGALE);
            fetch cpk5_sam_risposte into dummy;
            found := cpk5_sam_risposte%FOUND;
            close cpk5_sam_risposte;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_FONTI_DOM_SEDE. La registrazione SAM_RISPOSTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_CODICI_CARICA" deve esistere quando si inserisce su "SAM_RISPOSTE"
         if NEW_COD_CARICA is not null then
            open  cpk6_sam_risposte(NEW_COD_CARICA);
            fetch cpk6_sam_risposte into dummy;
            found := cpk6_sam_risposte%FOUND;
            close cpk6_sam_risposte;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_CODICI_CARICA. La registrazione SAM_RISPOSTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "SAM_RISPOSTE"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk7_sam_risposte(NEW_DOCUMENTO_ID);
            fetch cpk7_sam_risposte into dummy;
            found := cpk7_sam_risposte%FOUND;
            close cpk7_sam_risposte;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione SAM_RISPOSTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SAM_RISPOSTE
/* End Trigger: SAM_RISPOSTE_TC */

-- Procedure SAM_RISPOSTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_RISPOSTE

create or replace procedure SAM_RISPOSTE_PU
(old_risposta_interrogazione IN number,
 old_interrogazione IN number,
 old_cod_ritorno IN varchar,
 old_fonte_domicilio IN varchar,
 old_fonte_decesso IN varchar,
 old_fonte_sede_legale IN varchar,
 old_cod_carica IN varchar,
 old_documento_id IN number,
 new_risposta_interrogazione IN number,
 new_interrogazione IN number,
 new_cod_ritorno IN varchar,
 new_fonte_domicilio IN varchar,
 new_fonte_decesso IN varchar,
 new_fonte_sede_legale IN varchar,
 new_cod_carica IN varchar,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_INTERROGAZIONI"
   cursor cpk1_sam_risposte(var_interrogazione number) is
      select 1
      from   SAM_INTERROGAZIONI
      where  INTERROGAZIONE = var_interrogazione
       and   var_interrogazione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_CODICI_RITORNO"
   cursor cpk2_sam_risposte(var_cod_ritorno varchar) is
      select 1
      from   SAM_CODICI_RITORNO
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_FONTI_DOM_SEDE"
   cursor cpk3_sam_risposte(var_fonte_domicilio varchar) is
      select 1
      from   SAM_FONTI_DOM_SEDE
      where  FONTE = var_fonte_domicilio
       and   var_fonte_domicilio is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_FONTI_DECESSO"
   cursor cpk4_sam_risposte(var_fonte_decesso varchar) is
      select 1
      from   SAM_FONTI_DECESSO
      where  FONTE_DECESSO = var_fonte_decesso
       and   var_fonte_decesso is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_FONTI_DOM_SEDE"
   cursor cpk5_sam_risposte(var_fonte_sede_legale varchar) is
      select 1
      from   SAM_FONTI_DOM_SEDE
      where  FONTE = var_fonte_sede_legale
       and   var_fonte_sede_legale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_CODICI_CARICA"
   cursor cpk6_sam_risposte(var_cod_carica varchar) is
      select 1
      from   SAM_CODICI_CARICA
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk7_sam_risposte(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_DITTA"
   cursor cfk1_sam_risposte(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE_DITTA
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_RAP"
   cursor cfk2_sam_risposte(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE_RAP
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_PARTITA_IVA"
   cursor cfk3_sam_risposte(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE_PARTITA_IVA
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SAM_INTERROGAZIONI" deve esistere quando si modifica "SAM_RISPOSTE"
         if  NEW_INTERROGAZIONE is not null and ( seq = 0 )
         and (   (NEW_INTERROGAZIONE != OLD_INTERROGAZIONE or OLD_INTERROGAZIONE is null) ) then
            open  cpk1_sam_risposte(NEW_INTERROGAZIONE);
            fetch cpk1_sam_risposte into dummy;
            found := cpk1_sam_risposte%FOUND;
            close cpk1_sam_risposte;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_INTERROGAZIONI. La registrazione SAM_RISPOSTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_CODICI_RITORNO" deve esistere quando si modifica "SAM_RISPOSTE"
         if  NEW_COD_RITORNO is not null and ( seq = 0 )
         and (   (NEW_COD_RITORNO != OLD_COD_RITORNO or OLD_COD_RITORNO is null) ) then
            open  cpk2_sam_risposte(NEW_COD_RITORNO);
            fetch cpk2_sam_risposte into dummy;
            found := cpk2_sam_risposte%FOUND;
            close cpk2_sam_risposte;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_CODICI_RITORNO. La registrazione SAM_RISPOSTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_FONTI_DOM_SEDE" deve esistere quando si modifica "SAM_RISPOSTE"
         if  NEW_FONTE_DOMICILIO is not null and ( seq = 0 )
         and (   (NEW_FONTE_DOMICILIO != OLD_FONTE_DOMICILIO or OLD_FONTE_DOMICILIO is null) ) then
            open  cpk3_sam_risposte(NEW_FONTE_DOMICILIO);
            fetch cpk3_sam_risposte into dummy;
            found := cpk3_sam_risposte%FOUND;
            close cpk3_sam_risposte;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_FONTI_DOM_SEDE. La registrazione SAM_RISPOSTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_FONTI_DECESSO" deve esistere quando si modifica "SAM_RISPOSTE"
         if  NEW_FONTE_DECESSO is not null and ( seq = 0 )
         and (   (NEW_FONTE_DECESSO != OLD_FONTE_DECESSO or OLD_FONTE_DECESSO is null) ) then
            open  cpk4_sam_risposte(NEW_FONTE_DECESSO);
            fetch cpk4_sam_risposte into dummy;
            found := cpk4_sam_risposte%FOUND;
            close cpk4_sam_risposte;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_FONTI_DECESSO. La registrazione SAM_RISPOSTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_FONTI_DOM_SEDE" deve esistere quando si modifica "SAM_RISPOSTE"
         if  NEW_FONTE_SEDE_LEGALE is not null and ( seq = 0 )
         and (   (NEW_FONTE_SEDE_LEGALE != OLD_FONTE_SEDE_LEGALE or OLD_FONTE_SEDE_LEGALE is null) ) then
            open  cpk5_sam_risposte(NEW_FONTE_SEDE_LEGALE);
            fetch cpk5_sam_risposte into dummy;
            found := cpk5_sam_risposte%FOUND;
            close cpk5_sam_risposte;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_FONTI_DOM_SEDE. La registrazione SAM_RISPOSTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_CODICI_CARICA" deve esistere quando si modifica "SAM_RISPOSTE"
         if  NEW_COD_CARICA is not null and ( seq = 0 )
         and (   (NEW_COD_CARICA != OLD_COD_CARICA or OLD_COD_CARICA is null) ) then
            open  cpk6_sam_risposte(NEW_COD_CARICA);
            fetch cpk6_sam_risposte into dummy;
            found := cpk6_sam_risposte%FOUND;
            close cpk6_sam_risposte;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_CODICI_CARICA. La registrazione SAM_RISPOSTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "SAM_RISPOSTE"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk7_sam_risposte(NEW_DOCUMENTO_ID);
            fetch cpk7_sam_risposte into dummy;
            found := cpk7_sam_risposte%FOUND;
            close cpk7_sam_risposte;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione SAM_RISPOSTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SAM_RISPOSTE" non modificabile se esistono referenze su "SAM_RISPOSTE_DITTA"
      if (OLD_RISPOSTA_INTERROGAZIONE != NEW_RISPOSTA_INTERROGAZIONE) then
         open  cfk1_sam_risposte(OLD_RISPOSTA_INTERROGAZIONE);
         fetch cfk1_sam_risposte into dummy;
         found := cfk1_sam_risposte%FOUND;
         close cfk1_sam_risposte;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_DITTA. La registrazione di SAM_RISPOSTE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SAM_RISPOSTE" non modificabile se esistono referenze su "SAM_RISPOSTE_RAP"
      if (OLD_RISPOSTA_INTERROGAZIONE != NEW_RISPOSTA_INTERROGAZIONE) then
         open  cfk2_sam_risposte(OLD_RISPOSTA_INTERROGAZIONE);
         fetch cfk2_sam_risposte into dummy;
         found := cfk2_sam_risposte%FOUND;
         close cfk2_sam_risposte;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_RAP. La registrazione di SAM_RISPOSTE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SAM_RISPOSTE" non modificabile se esistono referenze su "SAM_RISPOSTE_PARTITA_IVA"
      if (OLD_RISPOSTA_INTERROGAZIONE != NEW_RISPOSTA_INTERROGAZIONE) then
         open  cfk3_sam_risposte(OLD_RISPOSTA_INTERROGAZIONE);
         fetch cfk3_sam_risposte into dummy;
         found := cfk3_sam_risposte%FOUND;
         close cfk3_sam_risposte;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_PARTITA_IVA. La registrazione di SAM_RISPOSTE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_PU */
/

-- Trigger SAM_RISPOSTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_RISPOSTE

create or replace trigger SAM_RISPOSTE_TIU
before INSERT
    or UPDATE
on SAM_RISPOSTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
         :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.risposta_interrogazione is null then
      SAM_RISPOSTE_NR (:new.risposta_interrogazione);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_RISPOSTE_PU(:OLD.RISPOSTA_INTERROGAZIONE,
                         :OLD.INTERROGAZIONE,
                         :OLD.COD_RITORNO,
                         :OLD.FONTE_DOMICILIO,
                         :OLD.FONTE_DECESSO,
                         :OLD.FONTE_SEDE_LEGALE,
                         :OLD.COD_CARICA,
                         :OLD.DOCUMENTO_ID,
                         :NEW.RISPOSTA_INTERROGAZIONE,
                         :NEW.INTERROGAZIONE,
                         :NEW.COD_RITORNO,
                         :NEW.FONTE_DOMICILIO,
                         :NEW.FONTE_DECESSO,
                         :NEW.FONTE_SEDE_LEGALE,
                         :NEW.COD_CARICA,
                         :NEW.DOCUMENTO_ID);
         null;
      end if;
      if INSERTING then
         SAM_RISPOSTE_PI(:NEW.INTERROGAZIONE,
                         :NEW.COD_RITORNO,
                         :NEW.FONTE_DOMICILIO,
                         :NEW.FONTE_DECESSO,
                         :NEW.FONTE_SEDE_LEGALE,
                         :NEW.COD_CARICA,
                         :NEW.DOCUMENTO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_RISPOSTE"
            cursor cpk_sam_risposte(var_RISPOSTA_INTERROGAZIONE number) is
               select 1
                 from   SAM_RISPOSTE
                where  RISPOSTA_INTERROGAZIONE = var_RISPOSTA_INTERROGAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_RISPOSTE"
               if :new.RISPOSTA_INTERROGAZIONE is not null then
                  open  cpk_sam_risposte(:new.RISPOSTA_INTERROGAZIONE);
                  fetch cpk_sam_risposte into dummy;
                  found := cpk_sam_risposte%FOUND;
                  close cpk_sam_risposte;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RISPOSTA_INTERROGAZIONE||
                               '" gia'' presente in SAM_RISPOSTE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_RISPOSTE_TIU */
/

-- Procedure SAM_RISPOSTE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SAM_RISPOSTE

create or replace procedure SAM_RISPOSTE_PD
(old_risposta_interrogazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_DITTA"
   cursor cfk1_sam_risposte(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE_DITTA
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_RAP"
   cursor cfk2_sam_risposte(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE_RAP
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_PARTITA_IVA"
   cursor cfk3_sam_risposte(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE_PARTITA_IVA
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SAM_RISPOSTE" if children still exist in "SAM_RISPOSTE_DITTA"
      open  cfk1_sam_risposte(OLD_RISPOSTA_INTERROGAZIONE);
      fetch cfk1_sam_risposte into dummy;
      found := cfk1_sam_risposte%FOUND;
      close cfk1_sam_risposte;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_DITTA. La registrazione di SAM_RISPOSTE non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SAM_RISPOSTE" if children still exist in "SAM_RISPOSTE_RAP"
      open  cfk2_sam_risposte(OLD_RISPOSTA_INTERROGAZIONE);
      fetch cfk2_sam_risposte into dummy;
      found := cfk2_sam_risposte%FOUND;
      close cfk2_sam_risposte;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_RAP. La registrazione di SAM_RISPOSTE non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SAM_RISPOSTE" if children still exist in "SAM_RISPOSTE_PARTITA_IVA"
      open  cfk3_sam_risposte(OLD_RISPOSTA_INTERROGAZIONE);
      fetch cfk3_sam_risposte into dummy;
      found := cfk3_sam_risposte%FOUND;
      close cfk3_sam_risposte;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_PARTITA_IVA. La registrazione di SAM_RISPOSTE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_PD */
/

-- Tigger SAM_RISPOSTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SAM_RISPOSTE

create or replace trigger SAM_RISPOSTE_TD
before DELETE
on SAM_RISPOSTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SAM_RISPOSTE_DITTA

      -- Child Restrict Table: SAM_RISPOSTE_RAP

      -- Child Restrict Table: SAM_RISPOSTE_PARTITA_IVA

      SAM_RISPOSTE_PD(:OLD.RISPOSTA_INTERROGAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_RISPOSTE_TD */
/

-- Procedure SAM_RISPOSTE_DITTA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SAM_RISPOSTE_DITTA

create or replace procedure SAM_RISPOSTE_DITTA_PI
(new_risposta_interrogazione IN number,
 new_cod_ritorno IN varchar,
 new_cod_carica IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_CODICI_RITORNO"
   cursor cpk1_sam_risposte_ditta(var_cod_ritorno varchar) is
      select 1
      from   SAM_CODICI_RITORNO
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_CODICI_CARICA"
   cursor cpk2_sam_risposte_ditta(var_cod_carica varchar) is
      select 1
      from   SAM_CODICI_CARICA
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_RISPOSTE"
   cursor cpk3_sam_risposte_ditta(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SAM_CODICI_RITORNO" deve esistere quando si inserisce su "SAM_RISPOSTE_DITTA"
         if NEW_COD_RITORNO is not null then
            open  cpk1_sam_risposte_ditta(NEW_COD_RITORNO);
            fetch cpk1_sam_risposte_ditta into dummy;
            found := cpk1_sam_risposte_ditta%FOUND;
            close cpk1_sam_risposte_ditta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_CODICI_RITORNO. La registrazione SAM_RISPOSTE_DITTA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_CODICI_CARICA" deve esistere quando si inserisce su "SAM_RISPOSTE_DITTA"
         if NEW_COD_CARICA is not null then
            open  cpk2_sam_risposte_ditta(NEW_COD_CARICA);
            fetch cpk2_sam_risposte_ditta into dummy;
            found := cpk2_sam_risposte_ditta%FOUND;
            close cpk2_sam_risposte_ditta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_CODICI_CARICA. La registrazione SAM_RISPOSTE_DITTA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_RISPOSTE" deve esistere quando si inserisce su "SAM_RISPOSTE_DITTA"
         if NEW_RISPOSTA_INTERROGAZIONE is not null then
            open  cpk3_sam_risposte_ditta(NEW_RISPOSTA_INTERROGAZIONE);
            fetch cpk3_sam_risposte_ditta into dummy;
            found := cpk3_sam_risposte_ditta%FOUND;
            close cpk3_sam_risposte_ditta;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_RISPOSTE. La registrazione SAM_RISPOSTE_DITTA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_DITTA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SAM_RISPOSTE_DITTA
/* End Trigger: SAM_RISPOSTE_DITTA_TC */

-- Procedure SAM_RISPOSTE_DITTA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_RISPOSTE_DITTA

create or replace procedure SAM_RISPOSTE_DITTA_PU
(old_risposta_ditta IN number,
 old_risposta_interrogazione IN number,
 old_cod_ritorno IN varchar,
 old_cod_carica IN varchar,
 new_risposta_ditta IN number,
 new_risposta_interrogazione IN number,
 new_cod_ritorno IN varchar,
 new_cod_carica IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_CODICI_RITORNO"
   cursor cpk1_sam_risposte_ditta(var_cod_ritorno varchar) is
      select 1
      from   SAM_CODICI_RITORNO
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_CODICI_CARICA"
   cursor cpk2_sam_risposte_ditta(var_cod_carica varchar) is
      select 1
      from   SAM_CODICI_CARICA
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_RISPOSTE"
   cursor cpk3_sam_risposte_ditta(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SAM_CODICI_RITORNO" deve esistere quando si modifica "SAM_RISPOSTE_DITTA"
         if  NEW_COD_RITORNO is not null and ( seq = 0 )
         and (   (NEW_COD_RITORNO != OLD_COD_RITORNO or OLD_COD_RITORNO is null) ) then
            open  cpk1_sam_risposte_ditta(NEW_COD_RITORNO);
            fetch cpk1_sam_risposte_ditta into dummy;
            found := cpk1_sam_risposte_ditta%FOUND;
            close cpk1_sam_risposte_ditta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_CODICI_RITORNO. La registrazione SAM_RISPOSTE_DITTA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_CODICI_CARICA" deve esistere quando si modifica "SAM_RISPOSTE_DITTA"
         if  NEW_COD_CARICA is not null and ( seq = 0 )
         and (   (NEW_COD_CARICA != OLD_COD_CARICA or OLD_COD_CARICA is null) ) then
            open  cpk2_sam_risposte_ditta(NEW_COD_CARICA);
            fetch cpk2_sam_risposte_ditta into dummy;
            found := cpk2_sam_risposte_ditta%FOUND;
            close cpk2_sam_risposte_ditta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_CODICI_CARICA. La registrazione SAM_RISPOSTE_DITTA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_RISPOSTE" deve esistere quando si modifica "SAM_RISPOSTE_DITTA"
         if  NEW_RISPOSTA_INTERROGAZIONE is not null and ( seq = 0 )
         and (   (NEW_RISPOSTA_INTERROGAZIONE != OLD_RISPOSTA_INTERROGAZIONE or OLD_RISPOSTA_INTERROGAZIONE is null) ) then
            open  cpk3_sam_risposte_ditta(NEW_RISPOSTA_INTERROGAZIONE);
            fetch cpk3_sam_risposte_ditta into dummy;
            found := cpk3_sam_risposte_ditta%FOUND;
            close cpk3_sam_risposte_ditta;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_RISPOSTE. La registrazione SAM_RISPOSTE_DITTA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_DITTA_PU */
/

-- Trigger SAM_RISPOSTE_DITTA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_RISPOSTE_DITTA

create or replace trigger SAM_RISPOSTE_DITTA_TIU
before INSERT
    or UPDATE
on SAM_RISPOSTE_DITTA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.risposta_ditta is null then
      SAM_RISPOSTE_DITTA_NR (:new.risposta_ditta);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_RISPOSTE_DITTA_PU(:OLD.RISPOSTA_DITTA,
                               :OLD.RISPOSTA_INTERROGAZIONE,
                               :OLD.COD_RITORNO,
                               :OLD.COD_CARICA,
                         :NEW.RISPOSTA_DITTA,
                         :NEW.RISPOSTA_INTERROGAZIONE,
                         :NEW.COD_RITORNO,
                         :NEW.COD_CARICA);
         null;
      end if;
      if INSERTING then
         SAM_RISPOSTE_DITTA_PI(:NEW.RISPOSTA_INTERROGAZIONE,
                               :NEW.COD_RITORNO,
                               :NEW.COD_CARICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_RISPOSTE_DITTA"
            cursor cpk_sam_risposte_ditta(var_RISPOSTA_DITTA number) is
               select 1
                 from   SAM_RISPOSTE_DITTA
                where  RISPOSTA_DITTA = var_RISPOSTA_DITTA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_RISPOSTE_DITTA"
               if :new.RISPOSTA_DITTA is not null then
                  open  cpk_sam_risposte_ditta(:new.RISPOSTA_DITTA);
                  fetch cpk_sam_risposte_ditta into dummy;
                  found := cpk_sam_risposte_ditta%FOUND;
                  close cpk_sam_risposte_ditta;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RISPOSTA_DITTA||
                               '" gia'' presente in SAM_RISPOSTE_DITTA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_RISPOSTE_DITTA_TIU */
/

-- Procedure SAM_RISPOSTE_PARTITA_IVA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SAM_RISPOSTE_PARTITA_IVA

create or replace procedure SAM_RISPOSTE_PARTITA_IVA_PI
(new_risposta_interrogazione IN number,
 new_cod_ritorno IN varchar,
 new_tipo_cessazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_CODICI_RITORNO"
   cursor cpk1_sam_risposte_partita_iva(var_cod_ritorno varchar) is
      select 1
      from   SAM_CODICI_RITORNO
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_TIPI_CESSAZIONE"
   cursor cpk2_sam_risposte_partita_iva(var_tipo_cessazione varchar) is
      select 1
      from   SAM_TIPI_CESSAZIONE
      where  TIPO_CESSAZIONE = var_tipo_cessazione
       and   var_tipo_cessazione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_RISPOSTE"
   cursor cpk3_sam_risposte_partita_iva(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SAM_CODICI_RITORNO" deve esistere quando si inserisce su "SAM_RISPOSTE_PARTITA_IVA"
         if NEW_COD_RITORNO is not null then
            open  cpk1_sam_risposte_partita_iva(NEW_COD_RITORNO);
            fetch cpk1_sam_risposte_partita_iva into dummy;
            found := cpk1_sam_risposte_partita_iva%FOUND;
            close cpk1_sam_risposte_partita_iva;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_CODICI_RITORNO. La registrazione SAM_RISPOSTE_PARTITA_IVA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_TIPI_CESSAZIONE" deve esistere quando si inserisce su "SAM_RISPOSTE_PARTITA_IVA"
         if NEW_TIPO_CESSAZIONE is not null then
            open  cpk2_sam_risposte_partita_iva(NEW_TIPO_CESSAZIONE);
            fetch cpk2_sam_risposte_partita_iva into dummy;
            found := cpk2_sam_risposte_partita_iva%FOUND;
            close cpk2_sam_risposte_partita_iva;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_TIPI_CESSAZIONE. La registrazione SAM_RISPOSTE_PARTITA_IVA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_RISPOSTE" deve esistere quando si inserisce su "SAM_RISPOSTE_PARTITA_IVA"
         if NEW_RISPOSTA_INTERROGAZIONE is not null then
            open  cpk3_sam_risposte_partita_iva(NEW_RISPOSTA_INTERROGAZIONE);
            fetch cpk3_sam_risposte_partita_iva into dummy;
            found := cpk3_sam_risposte_partita_iva%FOUND;
            close cpk3_sam_risposte_partita_iva;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_RISPOSTE. La registrazione SAM_RISPOSTE_PARTITA_IVA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_PARTITA_IVA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SAM_RISPOSTE_PARTITA_IVA
/* End Trigger: SAM_RISPOSTE_PARTITA_IVA_TC */

-- Procedure SAM_RISPOSTE_PARTITA_IVA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_RISPOSTE_PARTITA_IVA

create or replace procedure SAM_RISPOSTE_PARTITA_IVA_PU
(old_risposta_partita_iva IN number,
 old_risposta_interrogazione IN number,
 old_cod_ritorno IN varchar,
 old_tipo_cessazione IN varchar,
 new_risposta_partita_iva IN number,
 new_risposta_interrogazione IN number,
 new_cod_ritorno IN varchar,
 new_tipo_cessazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_CODICI_RITORNO"
   cursor cpk1_sam_risposte_partita_iva(var_cod_ritorno varchar) is
      select 1
      from   SAM_CODICI_RITORNO
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_TIPI_CESSAZIONE"
   cursor cpk2_sam_risposte_partita_iva(var_tipo_cessazione varchar) is
      select 1
      from   SAM_TIPI_CESSAZIONE
      where  TIPO_CESSAZIONE = var_tipo_cessazione
       and   var_tipo_cessazione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_RISPOSTE"
   cursor cpk3_sam_risposte_partita_iva(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SAM_CODICI_RITORNO" deve esistere quando si modifica "SAM_RISPOSTE_PARTITA_IVA"
         if  NEW_COD_RITORNO is not null and ( seq = 0 )
         and (   (NEW_COD_RITORNO != OLD_COD_RITORNO or OLD_COD_RITORNO is null) ) then
            open  cpk1_sam_risposte_partita_iva(NEW_COD_RITORNO);
            fetch cpk1_sam_risposte_partita_iva into dummy;
            found := cpk1_sam_risposte_partita_iva%FOUND;
            close cpk1_sam_risposte_partita_iva;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_CODICI_RITORNO. La registrazione SAM_RISPOSTE_PARTITA_IVA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_TIPI_CESSAZIONE" deve esistere quando si modifica "SAM_RISPOSTE_PARTITA_IVA"
         if  NEW_TIPO_CESSAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_CESSAZIONE != OLD_TIPO_CESSAZIONE or OLD_TIPO_CESSAZIONE is null) ) then
            open  cpk2_sam_risposte_partita_iva(NEW_TIPO_CESSAZIONE);
            fetch cpk2_sam_risposte_partita_iva into dummy;
            found := cpk2_sam_risposte_partita_iva%FOUND;
            close cpk2_sam_risposte_partita_iva;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_TIPI_CESSAZIONE. La registrazione SAM_RISPOSTE_PARTITA_IVA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_RISPOSTE" deve esistere quando si modifica "SAM_RISPOSTE_PARTITA_IVA"
         if  NEW_RISPOSTA_INTERROGAZIONE is not null and ( seq = 0 )
         and (   (NEW_RISPOSTA_INTERROGAZIONE != OLD_RISPOSTA_INTERROGAZIONE or OLD_RISPOSTA_INTERROGAZIONE is null) ) then
            open  cpk3_sam_risposte_partita_iva(NEW_RISPOSTA_INTERROGAZIONE);
            fetch cpk3_sam_risposte_partita_iva into dummy;
            found := cpk3_sam_risposte_partita_iva%FOUND;
            close cpk3_sam_risposte_partita_iva;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_RISPOSTE. La registrazione SAM_RISPOSTE_PARTITA_IVA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_PARTITA_IVA_PU */
/

-- Trigger SAM_RISPOSTE_PARTITA_IVA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_RISPOSTE_PARTITA_IVA

create or replace trigger SAM_RISPOSTE_PARTITA_IVA_TIU
before INSERT
    or UPDATE
on SAM_RISPOSTE_PARTITA_IVA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.risposta_partita_iva is null then
      SAM_RISPOSTE_PARTITA_IVA_NR (:new.risposta_partita_iva);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_RISPOSTE_PARTITA_IVA_PU(:OLD.RISPOSTA_PARTITA_IVA,
                                     :OLD.RISPOSTA_INTERROGAZIONE,
                                     :OLD.COD_RITORNO,
                                     :OLD.TIPO_CESSAZIONE,
                         :NEW.RISPOSTA_PARTITA_IVA,
                         :NEW.RISPOSTA_INTERROGAZIONE,
                         :NEW.COD_RITORNO,
                         :NEW.TIPO_CESSAZIONE);
         null;
      end if;
      if INSERTING then
         SAM_RISPOSTE_PARTITA_IVA_PI(:NEW.RISPOSTA_INTERROGAZIONE,
                                     :NEW.COD_RITORNO,
                                     :NEW.TIPO_CESSAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_RISPOSTE_PARTITA_IVA"
            cursor cpk_sam_risposte_partita_iva(var_RISPOSTA_PARTITA_IVA number) is
               select 1
                 from   SAM_RISPOSTE_PARTITA_IVA
                where  RISPOSTA_PARTITA_IVA = var_RISPOSTA_PARTITA_IVA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_RISPOSTE_PARTITA_IVA"
               if :new.RISPOSTA_PARTITA_IVA is not null then
                  open  cpk_sam_risposte_partita_iva(:new.RISPOSTA_PARTITA_IVA);
                  fetch cpk_sam_risposte_partita_iva into dummy;
                  found := cpk_sam_risposte_partita_iva%FOUND;
                  close cpk_sam_risposte_partita_iva;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RISPOSTA_PARTITA_IVA||
                               '" gia'' presente in SAM_RISPOSTE_PARTITA_IVA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_RISPOSTE_PARTITA_IVA_TIU */
/

-- Procedure SAM_RISPOSTE_RAP_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SAM_RISPOSTE_RAP

create or replace procedure SAM_RISPOSTE_RAP_PI
(new_risposta_interrogazione IN number,
 new_cod_ritorno IN varchar,
 new_cod_carica IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_CODICI_CARICA"
   cursor cpk1_sam_risposte_rap(var_cod_carica varchar) is
      select 1
      from   SAM_CODICI_CARICA
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_CODICI_RITORNO"
   cursor cpk2_sam_risposte_rap(var_cod_ritorno varchar) is
      select 1
      from   SAM_CODICI_RITORNO
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SAM_RISPOSTE"
   cursor cpk3_sam_risposte_rap(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SAM_CODICI_CARICA" deve esistere quando si inserisce su "SAM_RISPOSTE_RAP"
         if NEW_COD_CARICA is not null then
            open  cpk1_sam_risposte_rap(NEW_COD_CARICA);
            fetch cpk1_sam_risposte_rap into dummy;
            found := cpk1_sam_risposte_rap%FOUND;
            close cpk1_sam_risposte_rap;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_CODICI_CARICA. La registrazione SAM_RISPOSTE_RAP non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_CODICI_RITORNO" deve esistere quando si inserisce su "SAM_RISPOSTE_RAP"
         if NEW_COD_RITORNO is not null then
            open  cpk2_sam_risposte_rap(NEW_COD_RITORNO);
            fetch cpk2_sam_risposte_rap into dummy;
            found := cpk2_sam_risposte_rap%FOUND;
            close cpk2_sam_risposte_rap;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_CODICI_RITORNO. La registrazione SAM_RISPOSTE_RAP non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_RISPOSTE" deve esistere quando si inserisce su "SAM_RISPOSTE_RAP"
         if NEW_RISPOSTA_INTERROGAZIONE is not null then
            open  cpk3_sam_risposte_rap(NEW_RISPOSTA_INTERROGAZIONE);
            fetch cpk3_sam_risposte_rap into dummy;
            found := cpk3_sam_risposte_rap%FOUND;
            close cpk3_sam_risposte_rap;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SAM_RISPOSTE. La registrazione SAM_RISPOSTE_RAP non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_RAP_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SAM_RISPOSTE_RAP
/* End Trigger: SAM_RISPOSTE_RAP_TC */

-- Procedure SAM_RISPOSTE_RAP_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_RISPOSTE_RAP

create or replace procedure SAM_RISPOSTE_RAP_PU
(old_risposta_rap IN number,
 old_risposta_interrogazione IN number,
 old_cod_ritorno IN varchar,
 old_cod_carica IN varchar,
 new_risposta_rap IN number,
 new_risposta_interrogazione IN number,
 new_cod_ritorno IN varchar,
 new_cod_carica IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_CODICI_CARICA"
   cursor cpk1_sam_risposte_rap(var_cod_carica varchar) is
      select 1
      from   SAM_CODICI_CARICA
      where  COD_CARICA = var_cod_carica
       and   var_cod_carica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_CODICI_RITORNO"
   cursor cpk2_sam_risposte_rap(var_cod_ritorno varchar) is
      select 1
      from   SAM_CODICI_RITORNO
      where  COD_RITORNO = var_cod_ritorno
       and   var_cod_ritorno is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SAM_RISPOSTE"
   cursor cpk3_sam_risposte_rap(var_risposta_interrogazione number) is
      select 1
      from   SAM_RISPOSTE
      where  RISPOSTA_INTERROGAZIONE = var_risposta_interrogazione
       and   var_risposta_interrogazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SAM_CODICI_CARICA" deve esistere quando si modifica "SAM_RISPOSTE_RAP"
         if  NEW_COD_CARICA is not null and ( seq = 0 )
         and (   (NEW_COD_CARICA != OLD_COD_CARICA or OLD_COD_CARICA is null) ) then
            open  cpk1_sam_risposte_rap(NEW_COD_CARICA);
            fetch cpk1_sam_risposte_rap into dummy;
            found := cpk1_sam_risposte_rap%FOUND;
            close cpk1_sam_risposte_rap;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_CODICI_CARICA. La registrazione SAM_RISPOSTE_RAP non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_CODICI_RITORNO" deve esistere quando si modifica "SAM_RISPOSTE_RAP"
         if  NEW_COD_RITORNO is not null and ( seq = 0 )
         and (   (NEW_COD_RITORNO != OLD_COD_RITORNO or OLD_COD_RITORNO is null) ) then
            open  cpk2_sam_risposte_rap(NEW_COD_RITORNO);
            fetch cpk2_sam_risposte_rap into dummy;
            found := cpk2_sam_risposte_rap%FOUND;
            close cpk2_sam_risposte_rap;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_CODICI_RITORNO. La registrazione SAM_RISPOSTE_RAP non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SAM_RISPOSTE" deve esistere quando si modifica "SAM_RISPOSTE_RAP"
         if  NEW_RISPOSTA_INTERROGAZIONE is not null and ( seq = 0 )
         and (   (NEW_RISPOSTA_INTERROGAZIONE != OLD_RISPOSTA_INTERROGAZIONE or OLD_RISPOSTA_INTERROGAZIONE is null) ) then
            open  cpk3_sam_risposte_rap(NEW_RISPOSTA_INTERROGAZIONE);
            fetch cpk3_sam_risposte_rap into dummy;
            found := cpk3_sam_risposte_rap%FOUND;
            close cpk3_sam_risposte_rap;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SAM_RISPOSTE. La registrazione SAM_RISPOSTE_RAP non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_RISPOSTE_RAP_PU */
/

-- Trigger SAM_RISPOSTE_RAP_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_RISPOSTE_RAP

create or replace trigger SAM_RISPOSTE_RAP_TIU
before INSERT
    or UPDATE
on SAM_RISPOSTE_RAP
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.risposta_rap is null then
      SAM_RISPOSTE_RAP_NR (:new.risposta_rap);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_RISPOSTE_RAP_PU(:OLD.RISPOSTA_RAP,
                             :OLD.RISPOSTA_INTERROGAZIONE,
                             :OLD.COD_RITORNO,
                             :OLD.COD_CARICA,
                         :NEW.RISPOSTA_RAP,
                         :NEW.RISPOSTA_INTERROGAZIONE,
                         :NEW.COD_RITORNO,
                         :NEW.COD_CARICA);
         null;
      end if;
      if INSERTING then
         SAM_RISPOSTE_RAP_PI(:NEW.RISPOSTA_INTERROGAZIONE,
                             :NEW.COD_RITORNO,
                             :NEW.COD_CARICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_RISPOSTE_RAP"
            cursor cpk_sam_risposte_rap(var_RISPOSTA_RAP number) is
               select 1
                 from   SAM_RISPOSTE_RAP
                where  RISPOSTA_RAP = var_RISPOSTA_RAP;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_RISPOSTE_RAP"
               if :new.RISPOSTA_RAP is not null then
                  open  cpk_sam_risposte_rap(:new.RISPOSTA_RAP);
                  fetch cpk_sam_risposte_rap into dummy;
                  found := cpk_sam_risposte_rap%FOUND;
                  close cpk_sam_risposte_rap;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RISPOSTA_RAP||
                               '" gia'' presente in SAM_RISPOSTE_RAP. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_RISPOSTE_RAP_TIU */
/

-- Procedure SAM_TIPI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_TIPI

create or replace procedure SAM_TIPI_PU
(old_tipo IN varchar,
 new_tipo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SAM_INTERROGAZIONI"
   cursor cfk1_sam_tipi(var_tipo varchar) is
      select 1
      from   SAM_INTERROGAZIONI
      where  TIPO = var_tipo
       and   var_tipo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "SAM_TIPI" non modificabile se esistono referenze su "SAM_INTERROGAZIONI"
      if (OLD_TIPO != NEW_TIPO) then
         open  cfk1_sam_tipi(OLD_TIPO);
         fetch cfk1_sam_tipi into dummy;
         found := cfk1_sam_tipi%FOUND;
         close cfk1_sam_tipi;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_INTERROGAZIONI. La registrazione di SAM_TIPI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_TIPI_PU */
/

-- Trigger SAM_TIPI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_TIPI

create or replace trigger SAM_TIPI_TIU
before INSERT
    or UPDATE
on SAM_TIPI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_TIPI_PU(:OLD.TIPO,
                         :NEW.TIPO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_TIPI"
            cursor cpk_sam_tipi(var_TIPO varchar) is
               select 1
                 from   SAM_TIPI
                where  TIPO = var_TIPO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_TIPI"
               if :new.TIPO is not null then
                  open  cpk_sam_tipi(:new.TIPO);
                  fetch cpk_sam_tipi into dummy;
                  found := cpk_sam_tipi%FOUND;
                  close cpk_sam_tipi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO||
                               '" gia'' presente in SAM_TIPI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_TIPI_TIU */
/

-- Procedure SAM_TIPI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SAM_TIPI

create or replace procedure SAM_TIPI_PD
(old_tipo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SAM_INTERROGAZIONI"
   cursor cfk1_sam_tipi(var_tipo varchar) is
      select 1
      from   SAM_INTERROGAZIONI
      where  TIPO = var_tipo
       and   var_tipo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SAM_TIPI" if children still exist in "SAM_INTERROGAZIONI"
      open  cfk1_sam_tipi(OLD_TIPO);
      fetch cfk1_sam_tipi into dummy;
      found := cfk1_sam_tipi%FOUND;
      close cfk1_sam_tipi;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_INTERROGAZIONI. La registrazione di SAM_TIPI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_TIPI_PD */
/

-- Tigger SAM_TIPI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SAM_TIPI

create or replace trigger SAM_TIPI_TD
before DELETE
on SAM_TIPI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SAM_INTERROGAZIONI

      SAM_TIPI_PD(:OLD.TIPO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_TIPI_TD */
/

-- Procedure SAM_TIPI_CESSAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SAM_TIPI_CESSAZIONE

create or replace procedure SAM_TIPI_CESSAZIONE_PU
(old_tipo_cessazione IN varchar,
 new_tipo_cessazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "SAM_RISPOSTE_PARTITA_IVA"
   cursor cfk1_sam_tipi_cessazione(var_tipo_cessazione varchar) is
      select 1
      from   SAM_RISPOSTE_PARTITA_IVA
      where  TIPO_CESSAZIONE = var_tipo_cessazione
       and   var_tipo_cessazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "SAM_TIPI_CESSAZIONE" non modificabile se esistono referenze su "SAM_RISPOSTE_PARTITA_IVA"
      if (OLD_TIPO_CESSAZIONE != NEW_TIPO_CESSAZIONE) then
         open  cfk1_sam_tipi_cessazione(OLD_TIPO_CESSAZIONE);
         fetch cfk1_sam_tipi_cessazione into dummy;
         found := cfk1_sam_tipi_cessazione%FOUND;
         close cfk1_sam_tipi_cessazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SAM_RISPOSTE_PARTITA_IVA. La registrazione di SAM_TIPI_CESSAZIONE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_TIPI_CESSAZIONE_PU */
/

-- Trigger SAM_TIPI_CESSAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SAM_TIPI_CESSAZIONE

create or replace trigger SAM_TIPI_CESSAZIONE_TIU
before INSERT
    or UPDATE
on SAM_TIPI_CESSAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SAM_TIPI_CESSAZIONE_PU(:OLD.TIPO_CESSAZIONE,
                         :NEW.TIPO_CESSAZIONE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SAM_TIPI_CESSAZIONE"
            cursor cpk_sam_tipi_cessazione(var_TIPO_CESSAZIONE varchar) is
               select 1
                 from   SAM_TIPI_CESSAZIONE
                where  TIPO_CESSAZIONE = var_TIPO_CESSAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SAM_TIPI_CESSAZIONE"
               if :new.TIPO_CESSAZIONE is not null then
                  open  cpk_sam_tipi_cessazione(:new.TIPO_CESSAZIONE);
                  fetch cpk_sam_tipi_cessazione into dummy;
                  found := cpk_sam_tipi_cessazione%FOUND;
                  close cpk_sam_tipi_cessazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_CESSAZIONE||
                               '" gia'' presente in SAM_TIPI_CESSAZIONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_TIPI_CESSAZIONE_TIU */
/

-- Procedure SAM_TIPI_CESSAZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SAM_TIPI_CESSAZIONE

create or replace procedure SAM_TIPI_CESSAZIONE_PD
(old_tipo_cessazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SAM_RISPOSTE_PARTITA_IVA"
   cursor cfk1_sam_tipi_cessazione(var_tipo_cessazione varchar) is
      select 1
      from   SAM_RISPOSTE_PARTITA_IVA
      where  TIPO_CESSAZIONE = var_tipo_cessazione
       and   var_tipo_cessazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SAM_TIPI_CESSAZIONE" if children still exist in "SAM_RISPOSTE_PARTITA_IVA"
      open  cfk1_sam_tipi_cessazione(OLD_TIPO_CESSAZIONE);
      fetch cfk1_sam_tipi_cessazione into dummy;
      found := cfk1_sam_tipi_cessazione%FOUND;
      close cfk1_sam_tipi_cessazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SAM_RISPOSTE_PARTITA_IVA. La registrazione di SAM_TIPI_CESSAZIONE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SAM_TIPI_CESSAZIONE_PD */
/

-- Tigger SAM_TIPI_CESSAZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SAM_TIPI_CESSAZIONE

create or replace trigger SAM_TIPI_CESSAZIONE_TD
before DELETE
on SAM_TIPI_CESSAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SAM_RISPOSTE_PARTITA_IVA

      SAM_TIPI_CESSAZIONE_PD(:OLD.TIPO_CESSAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SAM_TIPI_CESSAZIONE_TD */
/

-- Procedure SANZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SANZIONI

create or replace procedure SANZIONI_PI
(new_tipo_tributo IN varchar,
 new_gruppo_sanzione IN number,
 new_tributo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_TRIBUTO"
   cursor cpk1_sanzioni(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_sanzioni(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "GRUPPI_SANZIONE"
   cursor cpk3_sanzioni(var_gruppo_sanzione number) is
      select 1
      from   GRUPPI_SANZIONE
      where  GRUPPO_SANZIONE = var_gruppo_sanzione
       and   var_gruppo_sanzione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si inserisce su "SANZIONI"
         if NEW_TRIBUTO is not null then
            open  cpk1_sanzioni(NEW_TRIBUTO);
            fetch cpk1_sanzioni into dummy;
            found := cpk1_sanzioni%FOUND;
            close cpk1_sanzioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Sanzioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "SANZIONI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_sanzioni(NEW_TIPO_TRIBUTO);
            fetch cpk2_sanzioni into dummy;
            found := cpk2_sanzioni%FOUND;
            close cpk2_sanzioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Sanzioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_SANZIONE" deve esistere quando si inserisce su "SANZIONI"
         if NEW_GRUPPO_SANZIONE is not null then
            open  cpk3_sanzioni(NEW_GRUPPO_SANZIONE);
            fetch cpk3_sanzioni into dummy;
            found := cpk3_sanzioni%FOUND;
            close cpk3_sanzioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Gruppi Sanzione. La registrazione Sanzioni non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SANZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SANZIONI
/* End Trigger: SANZIONI_TC */

-- Procedure SANZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SANZIONI

create or replace procedure SANZIONI_PU
(old_tipo_tributo IN varchar,
 old_cod_sanzione IN number,
 old_sequenza IN number,
 old_gruppo_sanzione IN number,
 old_tributo IN number,
 new_tipo_tributo IN varchar,
 new_cod_sanzione IN number,
 new_sequenza IN number,
 new_gruppo_sanzione IN number,
 new_tributo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_TRIBUTO"
   cursor cpk1_sanzioni(var_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_tributo
       and   var_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_sanzioni(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "GRUPPI_SANZIONE"
   cursor cpk3_sanzioni(var_gruppo_sanzione number) is
      select 1
      from   GRUPPI_SANZIONE
      where  GRUPPO_SANZIONE = var_gruppo_sanzione
       and   var_gruppo_sanzione is not null;

   --  Declaration of UpdateParentRestrict constraint for "SANZIONI_PRATICA"
   cursor cfk1_sanzioni(var_tipo_tributo varchar,
                        var_cod_sanzione number,
                        var_sequenza number) is
      select 1
      from   SANZIONI_PRATICA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   COD_SANZIONE = var_cod_sanzione
       and   SEQUENZA_SANZ = var_sequenza
       and   var_tipo_tributo is not null
       and   var_cod_sanzione is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si modifica "SANZIONI"
         if  NEW_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null) ) then
            open  cpk1_sanzioni(NEW_TRIBUTO);
            fetch cpk1_sanzioni into dummy;
            found := cpk1_sanzioni%FOUND;
            close cpk1_sanzioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione Sanzioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "SANZIONI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_sanzioni(NEW_TIPO_TRIBUTO);
            fetch cpk2_sanzioni into dummy;
            found := cpk2_sanzioni%FOUND;
            close cpk2_sanzioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Sanzioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_SANZIONE" deve esistere quando si modifica "SANZIONI"
         if  NEW_GRUPPO_SANZIONE is not null and ( seq = 0 )
         and (   (NEW_GRUPPO_SANZIONE != OLD_GRUPPO_SANZIONE or OLD_GRUPPO_SANZIONE is null) ) then
            open  cpk3_sanzioni(NEW_GRUPPO_SANZIONE);
            fetch cpk3_sanzioni into dummy;
            found := cpk3_sanzioni%FOUND;
            close cpk3_sanzioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Gruppi Sanzione. La registrazione Sanzioni non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SANZIONI" non modificabile se esistono referenze su "SANZIONI_PRATICA"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_COD_SANZIONE != NEW_COD_SANZIONE) or
         (OLD_SEQUENZA != NEW_SEQUENZA) then
         open  cfk1_sanzioni(OLD_TIPO_TRIBUTO,
                             OLD_COD_SANZIONE,
                             OLD_SEQUENZA);
         fetch cfk1_sanzioni into dummy;
         found := cfk1_sanzioni%FOUND;
         close cfk1_sanzioni;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Sanzioni Pratica. La registrazione di Sanzioni non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SANZIONI_PU */
/

-- Trigger SANZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SANZIONI

create or replace trigger SANZIONI_TIU
before INSERT
    or UPDATE
on SANZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
          SANZIONI_NR(:new.tipo_tributo,:new.cod_sanzione,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SANZIONI_PU(:OLD.TIPO_TRIBUTO,
                     :OLD.COD_SANZIONE,
                     :OLD.SEQUENZA,
                     :OLD.GRUPPO_SANZIONE,
                     :OLD.TRIBUTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.COD_SANZIONE,
                         :NEW.SEQUENZA,
                         :NEW.GRUPPO_SANZIONE,
                         :NEW.TRIBUTO);
         null;
      end if;
      if INSERTING then
         SANZIONI_PI(:NEW.TIPO_TRIBUTO,
                     :NEW.GRUPPO_SANZIONE,
                     :NEW.TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SANZIONI"
            cursor cpk_sanzioni(var_TIPO_TRIBUTO varchar,
                                var_COD_SANZIONE number,
                                var_SEQUENZA number) is
               select 1
                 from   SANZIONI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       COD_SANZIONE = var_COD_SANZIONE and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SANZIONI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.COD_SANZIONE is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_sanzioni(:new.TIPO_TRIBUTO,
                                     :new.COD_SANZIONE,
                                     :new.SEQUENZA);
                  fetch cpk_sanzioni into dummy;
                  found := cpk_sanzioni%FOUND;
                  close cpk_sanzioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.COD_SANZIONE||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Sanzioni. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SANZIONI_TIU */
/

-- Procedure SANZIONI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SANZIONI

create or replace procedure SANZIONI_PD
(old_tipo_tributo IN varchar,
 old_cod_sanzione IN number,
 old_sequenza IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SANZIONI_PRATICA"
   cursor cfk1_sanzioni(var_tipo_tributo varchar,
                        var_cod_sanzione number,
                        var_sequenza number) is
      select 1
      from   SANZIONI_PRATICA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   COD_SANZIONE = var_cod_sanzione
       and   SEQUENZA_SANZ = var_sequenza
       and   var_tipo_tributo is not null
       and   var_cod_sanzione is not null
       and   var_sequenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SANZIONI" if children still exist in "SANZIONI_PRATICA"
      open  cfk1_sanzioni(OLD_TIPO_TRIBUTO,
                          OLD_COD_SANZIONE,
                          OLD_SEQUENZA);
      fetch cfk1_sanzioni into dummy;
      found := cfk1_sanzioni%FOUND;
      close cfk1_sanzioni;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sanzioni Pratica. La registrazione di Sanzioni non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SANZIONI_PD */
/

-- Tigger SANZIONI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SANZIONI

create or replace trigger SANZIONI_TD
before DELETE
on SANZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SANZIONI_PRATICA

      SANZIONI_PD(:OLD.TIPO_TRIBUTO,
                  :OLD.COD_SANZIONE,
                  :OLD.SEQUENZA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SANZIONI_TD */
/

-- Procedure SANZIONI_PRATICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SANZIONI_PRATICA

create or replace procedure SANZIONI_PRATICA_PI
(new_pratica IN number,
 new_cod_sanzione IN number,
 new_sequenza_sanz IN number,
 new_tipo_tributo IN varchar,
 new_oggetto_pratica IN number,
 new_ruolo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_sanzioni_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk2_sanzioni_pratica(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SANZIONI"
   cursor cpk3_sanzioni_pratica(var_tipo_tributo varchar,
                                var_cod_sanzione number,
                                var_sequenza_sanz number) is
      select 1
      from   SANZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   COD_SANZIONE = var_cod_sanzione
       and   SEQUENZA = var_sequenza_sanz
       and   var_tipo_tributo is not null
       and   var_cod_sanzione is not null
       and   var_sequenza_sanz is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk4_sanzioni_pratica(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk5_sanzioni_pratica(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "SANZIONI_PRATICA"
         if NEW_PRATICA is not null then
            open  cpk1_sanzioni_pratica(NEW_PRATICA);
            fetch cpk1_sanzioni_pratica into dummy;
            found := cpk1_sanzioni_pratica%FOUND;
            close cpk1_sanzioni_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Sanzioni Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "SANZIONI_PRATICA"
         if NEW_RUOLO is not null then
            open  cpk2_sanzioni_pratica(NEW_RUOLO);
            fetch cpk2_sanzioni_pratica into dummy;
            found := cpk2_sanzioni_pratica%FOUND;
            close cpk2_sanzioni_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Sanzioni Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SANZIONI" deve esistere quando si inserisce su "SANZIONI_PRATICA"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_COD_SANZIONE is not null and
            NEW_SEQUENZA_SANZ is not null then
            open  cpk3_sanzioni_pratica(NEW_TIPO_TRIBUTO,
                                        NEW_COD_SANZIONE,
                                        NEW_SEQUENZA_SANZ);
            fetch cpk3_sanzioni_pratica into dummy;
            found := cpk3_sanzioni_pratica%FOUND;
            close cpk3_sanzioni_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Sanzioni. La registrazione Sanzioni Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "SANZIONI_PRATICA"
         if NEW_OGGETTO_PRATICA is not null then
            open  cpk4_sanzioni_pratica(NEW_OGGETTO_PRATICA);
            fetch cpk4_sanzioni_pratica into dummy;
            found := cpk4_sanzioni_pratica%FOUND;
            close cpk4_sanzioni_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Sanzioni Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "SANZIONI_PRATICA"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk5_sanzioni_pratica(NEW_TIPO_TRIBUTO);
            fetch cpk5_sanzioni_pratica into dummy;
            found := cpk5_sanzioni_pratica%FOUND;
            close cpk5_sanzioni_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Sanzioni Pratica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SANZIONI_PRATICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SANZIONI_PRATICA
/* End Trigger: SANZIONI_PRATICA_TC */

-- Procedure SANZIONI_PRATICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SANZIONI_PRATICA

create or replace procedure SANZIONI_PRATICA_PU
(old_pratica IN number,
 old_cod_sanzione IN number,
 old_sequenza_sanz IN number,
 old_sequenza IN number,
 old_tipo_tributo IN varchar,
 old_oggetto_pratica IN number,
 old_ruolo IN number,
 new_pratica IN number,
 new_cod_sanzione IN number,
 new_sequenza_sanz IN number,
 new_sequenza IN number,
 new_tipo_tributo IN varchar,
 new_oggetto_pratica IN number,
 new_ruolo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_sanzioni_pratica(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk2_sanzioni_pratica(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SANZIONI"
   cursor cpk3_sanzioni_pratica(var_tipo_tributo varchar,
                                var_cod_sanzione number,
                                var_sequenza_sanz number) is
      select 1
      from   SANZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   COD_SANZIONE = var_cod_sanzione
       and   SEQUENZA = var_sequenza_sanz
       and   var_tipo_tributo is not null
       and   var_cod_sanzione is not null
       and   var_sequenza_sanz is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk4_sanzioni_pratica(var_oggetto_pratica number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk5_sanzioni_pratica(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "SANZIONI_PRATICA"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_sanzioni_pratica(NEW_PRATICA);
            fetch cpk1_sanzioni_pratica into dummy;
            found := cpk1_sanzioni_pratica%FOUND;
            close cpk1_sanzioni_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Sanzioni Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "SANZIONI_PRATICA"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk2_sanzioni_pratica(NEW_RUOLO);
            fetch cpk2_sanzioni_pratica into dummy;
            found := cpk2_sanzioni_pratica%FOUND;
            close cpk2_sanzioni_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Sanzioni Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SANZIONI" deve esistere quando si modifica "SANZIONI_PRATICA"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_COD_SANZIONE is not null and
             NEW_SEQUENZA_SANZ is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_COD_SANZIONE != OLD_COD_SANZIONE or OLD_COD_SANZIONE is null)
              or (NEW_SEQUENZA_SANZ != OLD_SEQUENZA_SANZ or OLD_SEQUENZA_SANZ is null) ) then
            open  cpk3_sanzioni_pratica(NEW_TIPO_TRIBUTO,
                                        NEW_COD_SANZIONE,
                                        NEW_SEQUENZA_SANZ);
            fetch cpk3_sanzioni_pratica into dummy;
            found := cpk3_sanzioni_pratica%FOUND;
            close cpk3_sanzioni_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Sanzioni. La registrazione Sanzioni Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "SANZIONI_PRATICA"
         if  NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk4_sanzioni_pratica(NEW_OGGETTO_PRATICA);
            fetch cpk4_sanzioni_pratica into dummy;
            found := cpk4_sanzioni_pratica%FOUND;
            close cpk4_sanzioni_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Sanzioni Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "SANZIONI_PRATICA"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk5_sanzioni_pratica(NEW_TIPO_TRIBUTO);
            fetch cpk5_sanzioni_pratica into dummy;
            found := cpk5_sanzioni_pratica%FOUND;
            close cpk5_sanzioni_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Sanzioni Pratica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SANZIONI" non modificabile sul figlio: "SANZIONI_PRATICA"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_COD_SANZIONE != NEW_COD_SANZIONE) or
         (OLD_SEQUENZA_SANZ != NEW_SEQUENZA_SANZ) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Sanzioni non e'' modificabile su Sanzioni Pratica.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SANZIONI_PRATICA_PU */
/

-- Trigger SANZIONI_PRATICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SANZIONI_PRATICA

create or replace trigger SANZIONI_PRATICA_TIU
before INSERT
    or UPDATE
on SANZIONI_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   :new.sequenza_sanz := nvl(:new.sequenza_sanz,1);

   if INSERTING and :new.sequenza is null then
         SANZIONI_PRATICA_NR(:new.pratica,:new.cod_sanzione,:new.sequenza_sanz,:new.sequenza);
   end if;
   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SANZIONI_PRATICA_PU(:OLD.PRATICA,
                             :OLD.COD_SANZIONE,
                             :OLD.SEQUENZA_SANZ,
                             :OLD.SEQUENZA,
                             :OLD.TIPO_TRIBUTO,
                             :OLD.OGGETTO_PRATICA,
                             :OLD.RUOLO,
                         :NEW.PRATICA,
                         :NEW.COD_SANZIONE,
                         :NEW.SEQUENZA_SANZ,
                         :NEW.SEQUENZA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.RUOLO);
         null;
      end if;
      if INSERTING then
         SANZIONI_PRATICA_PI(:NEW.PRATICA,
                             :NEW.COD_SANZIONE,
                             :NEW.SEQUENZA_SANZ,
                             :NEW.TIPO_TRIBUTO,
                             :NEW.OGGETTO_PRATICA,
                             :NEW.RUOLO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SANZIONI_PRATICA"
            cursor cpk_sanzioni_pratica(var_PRATICA number,
                                        var_COD_SANZIONE number,
                                        var_SEQUENZA_SANZ number,
                                        var_SEQUENZA number) is
               select 1
                 from   SANZIONI_PRATICA
                where  PRATICA = var_PRATICA and
                       COD_SANZIONE = var_COD_SANZIONE and
                       SEQUENZA_SANZ = var_SEQUENZA_SANZ and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SANZIONI_PRATICA"
               if :new.PRATICA is not null and
                  :new.COD_SANZIONE is not null and
                  :new.SEQUENZA_SANZ is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_sanzioni_pratica(:new.PRATICA,
                                             :new.COD_SANZIONE,
                                             :new.SEQUENZA_SANZ,
                                             :new.SEQUENZA);
                  fetch cpk_sanzioni_pratica into dummy;
                  found := cpk_sanzioni_pratica%FOUND;
                  close cpk_sanzioni_pratica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||' '||
                               :new.COD_SANZIONE||' '||
                               :new.SEQUENZA_SANZ||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Sanzioni Pratica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            SANZIONI_PRATICA_FI (:old.pratica,:new.pratica,:old.importo,:new.importo,
                                 :old.riduzione,:new.riduzione,:old.riduzione_2,:new.riduzione_2,
				 :new.cod_sanzione,:new.sequenza_sanz);
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SANZIONI_PRATICA_TIU */
/

-- Tigger SANZIONI_PRATICA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SANZIONI_PRATICA

create or replace trigger SANZIONI_PRATICA_TD
before DELETE
on SANZIONI_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            SANZIONI_PRATICA_FI (:old.pratica,:new.pratica,:old.importo,:new.importo,
                                 :old.riduzione,:new.riduzione,:old.riduzione_2,:new.riduzione_2,
				 :old.cod_sanzione,:old.sequenza_sanz);
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      SANZIONI_PRATICA_PD(:OLD.PRATICA,
                          :OLD.COD_SANZIONE,
                          :OLD.SEQUENZA_SANZ,
                          :OLD.SEQUENZA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SANZIONI_PRATICA_TD */
/

-- Procedure SCADENZE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SCADENZE

create or replace procedure SCADENZE_PI
(new_tipo_tributo IN varchar,
 new_gruppo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_scadenze(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "GRUPPI_TRIBUTO"
   cursor cpk2_scadenze(var_tipo_tributo varchar,
                        var_gruppo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "SCADENZE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_scadenze(NEW_TIPO_TRIBUTO);
            fetch cpk1_scadenze into dummy;
            found := cpk1_scadenze%FOUND;
            close cpk1_scadenze;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Scadenze non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_TRIBUTO" deve esistere quando si inserisce su "SCADENZE"
         if NEW_TIPO_TRIBUTO is not null and
            NEW_GRUPPO_TRIBUTO is not null then
            open  cpk2_scadenze(NEW_TIPO_TRIBUTO,
                                NEW_GRUPPO_TRIBUTO);
            fetch cpk2_scadenze into dummy;
            found := cpk2_scadenze%FOUND;
            close cpk2_scadenze;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Gruppi_tributo. La registrazione Scadenze non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SCADENZE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SCADENZE
/* End Trigger: SCADENZE_TC */

-- Procedure SCADENZE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SCADENZE

create or replace procedure SCADENZE_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_sequenza IN number,
 old_gruppo_tributo IN varchar,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_sequenza IN number,
 new_gruppo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_scadenze(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "GRUPPI_TRIBUTO"
   cursor cpk2_scadenze(var_tipo_tributo varchar,
                        var_gruppo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   GRUPPO_TRIBUTO = var_gruppo_tributo
       and   var_tipo_tributo is not null
       and   var_gruppo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "SCADENZE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_scadenze(NEW_TIPO_TRIBUTO);
            fetch cpk1_scadenze into dummy;
            found := cpk1_scadenze%FOUND;
            close cpk1_scadenze;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Scadenze non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "GRUPPI_TRIBUTO" deve esistere quando si modifica "SCADENZE"
         if  NEW_TIPO_TRIBUTO is not null and
             NEW_GRUPPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null)
              or (NEW_GRUPPO_TRIBUTO != OLD_GRUPPO_TRIBUTO or OLD_GRUPPO_TRIBUTO is null) ) then
            open  cpk2_scadenze(NEW_TIPO_TRIBUTO,
                                NEW_GRUPPO_TRIBUTO);
            fetch cpk2_scadenze into dummy;
            found := cpk2_scadenze%FOUND;
            close cpk2_scadenze;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Gruppi_tributo. La registrazione Scadenze non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "GRUPPI_TRIBUTO" non modificabile sul figlio: "SCADENZE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_GRUPPO_TRIBUTO != NEW_GRUPPO_TRIBUTO) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Gruppi_tributo non e'' modificabile su Scadenze.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SCADENZE_PU */
/

-- Trigger SCADENZE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SCADENZE

create or replace trigger SCADENZE_TIU
before INSERT
    or UPDATE
on SCADENZE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      SCADENZE_DI (:new.tipo_scadenza,:new.rata,:new.tipo_versamento);
   end;

   if INSERTING and :new.sequenza is null then
       SCADENZE_NR (:new.tipo_tributo,:new.anno,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SCADENZE_PU(:OLD.TIPO_TRIBUTO,
                     :OLD.ANNO,
                     :OLD.SEQUENZA,
                     :OLD.GRUPPO_TRIBUTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.SEQUENZA,
                         :NEW.GRUPPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         SCADENZE_PI(:NEW.TIPO_TRIBUTO,
                     :NEW.GRUPPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SCADENZE"
            cursor cpk_scadenze(var_TIPO_TRIBUTO varchar,
                                var_ANNO number,
                                var_SEQUENZA number) is
               select 1
                 from   SCADENZE
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SCADENZE"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_scadenze(:new.TIPO_TRIBUTO,
                                     :new.ANNO,
                                     :new.SEQUENZA);
                  fetch cpk_scadenze into dummy;
                  found := cpk_scadenze%FOUND;
                  close cpk_scadenze;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Scadenze. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SCADENZE_TIU */
/

-- Procedure SCAGLIONI_REDDITO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SCAGLIONI_REDDITO

create or replace procedure SCAGLIONI_REDDITO_PU
(old_anno IN number,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "CLASSI_SUPERFICIE"
   cursor cfk1_scaglioni_reddito(var_anno number) is
      select 1
      from   CLASSI_SUPERFICIE
      where  ANNO = var_anno
       and   var_anno is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "SCAGLIONI_REDDITO" non modificabile se esistono referenze su "CLASSI_SUPERFICIE"
      if (OLD_ANNO != NEW_ANNO) then
         open  cfk1_scaglioni_reddito(OLD_ANNO);
         fetch cfk1_scaglioni_reddito into dummy;
         found := cfk1_scaglioni_reddito%FOUND;
         close cfk1_scaglioni_reddito;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su CLASSI_SUPERFICIE. La registrazione di SCAGLIONI_REDDITO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SCAGLIONI_REDDITO_PU */
/

-- Trigger SCAGLIONI_REDDITO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SCAGLIONI_REDDITO

create or replace trigger SCAGLIONI_REDDITO_TIU
before INSERT
    or UPDATE
on SCAGLIONI_REDDITO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SCAGLIONI_REDDITO_PU(:OLD.ANNO,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SCAGLIONI_REDDITO"
            cursor cpk_scaglioni_reddito(var_ANNO number) is
               select 1
                 from   SCAGLIONI_REDDITO
                where  ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SCAGLIONI_REDDITO"
               if :new.ANNO is not null then
                  open  cpk_scaglioni_reddito(:new.ANNO);
                  fetch cpk_scaglioni_reddito into dummy;
                  found := cpk_scaglioni_reddito%FOUND;
                  close cpk_scaglioni_reddito;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ANNO||
                               '" gia'' presente in SCAGLIONI_REDDITO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SCAGLIONI_REDDITO_TIU */
/

-- Procedure SCAGLIONI_REDDITO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SCAGLIONI_REDDITO

create or replace procedure SCAGLIONI_REDDITO_PD
(old_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CLASSI_SUPERFICIE"
   cursor cfk1_scaglioni_reddito(var_anno number) is
      select 1
      from   CLASSI_SUPERFICIE
      where  ANNO = var_anno
       and   var_anno is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SCAGLIONI_REDDITO" if children still exist in "CLASSI_SUPERFICIE"
      open  cfk1_scaglioni_reddito(OLD_ANNO);
      fetch cfk1_scaglioni_reddito into dummy;
      found := cfk1_scaglioni_reddito%FOUND;
      close cfk1_scaglioni_reddito;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su CLASSI_SUPERFICIE. La registrazione di SCAGLIONI_REDDITO non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SCAGLIONI_REDDITO_PD */
/

-- Tigger SCAGLIONI_REDDITO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SCAGLIONI_REDDITO

create or replace trigger SCAGLIONI_REDDITO_TD
before DELETE
on SCAGLIONI_REDDITO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CLASSI_SUPERFICIE

      SCAGLIONI_REDDITO_PD(:OLD.ANNO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SCAGLIONI_REDDITO_TD */
/

-- Procedure SETTORI_ATTIVITA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SETTORI_ATTIVITA

create or replace procedure SETTORI_ATTIVITA_PU
(old_settore IN number,
 new_settore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "CLASSI_SUPERFICIE"
   cursor cfk1_settori_attivita(var_settore number) is
      select 1
      from   CLASSI_SUPERFICIE
      where  SETTORE = var_settore
       and   var_settore is not null;

   --  Declaration of UpdateParentRestrict constraint for "DENUNCE_ICIAP"
   cursor cfk2_settori_attivita(var_settore number) is
      select 1
      from   DENUNCE_ICIAP
      where  SETTORE = var_settore
       and   var_settore is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk3_settori_attivita(var_settore number) is
      select 1
      from   OGGETTI_PRATICA
      where  SETTORE = var_settore
       and   var_settore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "SETTORI_ATTIVITA" non modificabile se esistono referenze su "CLASSI_SUPERFICIE"
      if (OLD_SETTORE != NEW_SETTORE) then
         open  cfk1_settori_attivita(OLD_SETTORE);
         fetch cfk1_settori_attivita into dummy;
         found := cfk1_settori_attivita%FOUND;
         close cfk1_settori_attivita;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su CLASSI_SUPERFICIE. La registrazione di SETTORI_ATTIVITA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SETTORI_ATTIVITA" non modificabile se esistono referenze su "DENUNCE_ICIAP"
      if (OLD_SETTORE != NEW_SETTORE) then
         open  cfk2_settori_attivita(OLD_SETTORE);
         fetch cfk2_settori_attivita into dummy;
         found := cfk2_settori_attivita%FOUND;
         close cfk2_settori_attivita;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Denunce ICIAP. La registrazione di SETTORI_ATTIVITA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SETTORI_ATTIVITA" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_SETTORE != NEW_SETTORE) then
         open  cfk3_settori_attivita(OLD_SETTORE);
         fetch cfk3_settori_attivita into dummy;
         found := cfk3_settori_attivita%FOUND;
         close cfk3_settori_attivita;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di SETTORI_ATTIVITA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SETTORI_ATTIVITA_PU */
/

-- Trigger SETTORI_ATTIVITA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SETTORI_ATTIVITA

create or replace trigger SETTORI_ATTIVITA_TIU
before INSERT
    or UPDATE
on SETTORI_ATTIVITA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SETTORI_ATTIVITA_PU(:OLD.SETTORE,
                         :NEW.SETTORE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SETTORI_ATTIVITA"
            cursor cpk_settori_attivita(var_SETTORE number) is
               select 1
                 from   SETTORI_ATTIVITA
                where  SETTORE = var_SETTORE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SETTORI_ATTIVITA"
               if :new.SETTORE is not null then
                  open  cpk_settori_attivita(:new.SETTORE);
                  fetch cpk_settori_attivita into dummy;
                  found := cpk_settori_attivita%FOUND;
                  close cpk_settori_attivita;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.SETTORE||
                               '" gia'' presente in SETTORI_ATTIVITA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SETTORI_ATTIVITA_TIU */
/

-- Procedure SETTORI_ATTIVITA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SETTORI_ATTIVITA

create or replace procedure SETTORI_ATTIVITA_PD
(old_settore IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CLASSI_SUPERFICIE"
   cursor cfk1_settori_attivita(var_settore number) is
      select 1
      from   CLASSI_SUPERFICIE
      where  SETTORE = var_settore
       and   var_settore is not null;

   --  Declaration of DeleteParentRestrict constraint for "DENUNCE_ICIAP"
   cursor cfk2_settori_attivita(var_settore number) is
      select 1
      from   DENUNCE_ICIAP
      where  SETTORE = var_settore
       and   var_settore is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk3_settori_attivita(var_settore number) is
      select 1
      from   OGGETTI_PRATICA
      where  SETTORE = var_settore
       and   var_settore is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SETTORI_ATTIVITA" if children still exist in "CLASSI_SUPERFICIE"
      open  cfk1_settori_attivita(OLD_SETTORE);
      fetch cfk1_settori_attivita into dummy;
      found := cfk1_settori_attivita%FOUND;
      close cfk1_settori_attivita;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su CLASSI_SUPERFICIE. La registrazione di SETTORI_ATTIVITA non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SETTORI_ATTIVITA" if children still exist in "DENUNCE_ICIAP"
      open  cfk2_settori_attivita(OLD_SETTORE);
      fetch cfk2_settori_attivita into dummy;
      found := cfk2_settori_attivita%FOUND;
      close cfk2_settori_attivita;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Denunce ICIAP. La registrazione di SETTORI_ATTIVITA non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SETTORI_ATTIVITA" if children still exist in "OGGETTI_PRATICA"
      open  cfk3_settori_attivita(OLD_SETTORE);
      fetch cfk3_settori_attivita into dummy;
      found := cfk3_settori_attivita%FOUND;
      close cfk3_settori_attivita;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di SETTORI_ATTIVITA non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SETTORI_ATTIVITA_PD */
/

-- Tigger SETTORI_ATTIVITA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SETTORI_ATTIVITA

create or replace trigger SETTORI_ATTIVITA_TD
before DELETE
on SETTORI_ATTIVITA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CLASSI_SUPERFICIE

      -- Child Restrict Table: DENUNCE_ICIAP

      -- Child Restrict Table: OGGETTI_PRATICA

      SETTORI_ATTIVITA_PD(:OLD.SETTORE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SETTORI_ATTIVITA_TD */
/

-- Procedure SGRAVI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SGRAVI

create or replace procedure SGRAVI_PI
(new_ruolo IN number,
 new_cod_fiscale IN varchar,
 new_sequenza IN number,
 new_motivo_sgravio IN number,
 new_fattura IN number,
 new_ogpr_sgravio IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI_CONTRIBUENTE"
   cursor cpk1_sgravi(var_ruolo number,
                      var_cod_fiscale varchar,
                      var_sequenza number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  RUOLO = var_ruolo
       and   COD_FISCALE = var_cod_fiscale
       and   SEQUENZA = var_sequenza
       and   var_ruolo is not null
       and   var_cod_fiscale is not null
       and   var_sequenza is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "MOTIVI_SGRAVIO"
   cursor cpk2_sgravi(var_motivo_sgravio number) is
      select 1
      from   MOTIVI_SGRAVIO
      where  MOTIVO_SGRAVIO = var_motivo_sgravio
       and   var_motivo_sgravio is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FATTURE"
   cursor cpk3_sgravi(var_fattura number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_PRATICA"
   cursor cpk4_sgravi(var_ogpr_sgravio number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_ogpr_sgravio
       and   var_ogpr_sgravio is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "RUOLI_CONTRIBUENTE" deve esistere quando si inserisce su "SGRAVI"
         if NEW_RUOLO is not null and
            NEW_COD_FISCALE is not null and
            NEW_SEQUENZA is not null then
            open  cpk1_sgravi(NEW_RUOLO,
                              NEW_COD_FISCALE,
                              NEW_SEQUENZA);
            fetch cpk1_sgravi into dummy;
            found := cpk1_sgravi%FOUND;
            close cpk1_sgravi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli Contribuente. La registrazione Sgravi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_SGRAVIO" deve esistere quando si inserisce su "SGRAVI"
         if NEW_MOTIVO_SGRAVIO is not null then
            open  cpk2_sgravi(NEW_MOTIVO_SGRAVIO);
            fetch cpk2_sgravi into dummy;
            found := cpk2_sgravi%FOUND;
            close cpk2_sgravi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Motivi Sgravio. La registrazione Sgravi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FATTURE" deve esistere quando si inserisce su "SGRAVI"
         if NEW_FATTURA is not null then
            open  cpk3_sgravi(NEW_FATTURA);
            fetch cpk3_sgravi into dummy;
            found := cpk3_sgravi%FOUND;
            close cpk3_sgravi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione Sgravi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si inserisce su "SGRAVI"
         if NEW_OGPR_SGRAVIO is not null then
            open  cpk4_sgravi(NEW_OGPR_SGRAVIO);
            fetch cpk4_sgravi into dummy;
            found := cpk4_sgravi%FOUND;
            close cpk4_sgravi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Sgravi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SGRAVI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SGRAVI
/* End Trigger: SGRAVI_TC */

-- Procedure SGRAVI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SGRAVI

create or replace procedure SGRAVI_PU
(old_ruolo IN number,
 old_cod_fiscale IN varchar,
 old_sequenza IN number,
 old_sequenza_sgravio IN number,
 old_motivo_sgravio IN number,
 old_fattura IN number,
 old_ogpr_sgravio IN number,
 new_ruolo IN number,
 new_cod_fiscale IN varchar,
 new_sequenza IN number,
 new_sequenza_sgravio IN number,
 new_motivo_sgravio IN number,
 new_fattura IN number,
 new_ogpr_sgravio IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI_CONTRIBUENTE"
   cursor cpk1_sgravi(var_ruolo number,
                      var_cod_fiscale varchar,
                      var_sequenza number) is
      select 1
      from   RUOLI_CONTRIBUENTE
      where  RUOLO = var_ruolo
       and   COD_FISCALE = var_cod_fiscale
       and   SEQUENZA = var_sequenza
       and   var_ruolo is not null
       and   var_cod_fiscale is not null
       and   var_sequenza is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "MOTIVI_SGRAVIO"
   cursor cpk2_sgravi(var_motivo_sgravio number) is
      select 1
      from   MOTIVI_SGRAVIO
      where  MOTIVO_SGRAVIO = var_motivo_sgravio
       and   var_motivo_sgravio is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FATTURE"
   cursor cpk3_sgravi(var_fattura number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_PRATICA"
   cursor cpk4_sgravi(var_ogpr_sgravio number) is
      select 1
      from   OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_ogpr_sgravio
       and   var_ogpr_sgravio is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "RUOLI_CONTRIBUENTE" deve esistere quando si modifica "SGRAVI"
         if  NEW_RUOLO is not null and
             NEW_COD_FISCALE is not null and
             NEW_SEQUENZA is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null)
              or (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_SEQUENZA != OLD_SEQUENZA or OLD_SEQUENZA is null) ) then
            open  cpk1_sgravi(NEW_RUOLO,
                              NEW_COD_FISCALE,
                              NEW_SEQUENZA);
            fetch cpk1_sgravi into dummy;
            found := cpk1_sgravi%FOUND;
            close cpk1_sgravi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli Contribuente. La registrazione Sgravi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "MOTIVI_SGRAVIO" deve esistere quando si modifica "SGRAVI"
         if  NEW_MOTIVO_SGRAVIO is not null and ( seq = 0 )
         and (   (NEW_MOTIVO_SGRAVIO != OLD_MOTIVO_SGRAVIO or OLD_MOTIVO_SGRAVIO is null) ) then
            open  cpk2_sgravi(NEW_MOTIVO_SGRAVIO);
            fetch cpk2_sgravi into dummy;
            found := cpk2_sgravi%FOUND;
            close cpk2_sgravi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Motivi Sgravio. La registrazione Sgravi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FATTURE" deve esistere quando si modifica "SGRAVI"
         if  NEW_FATTURA is not null and ( seq = 0 )
         and (   (NEW_FATTURA != OLD_FATTURA or OLD_FATTURA is null) ) then
            open  cpk3_sgravi(NEW_FATTURA);
            fetch cpk3_sgravi into dummy;
            found := cpk3_sgravi%FOUND;
            close cpk3_sgravi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione Sgravi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_PRATICA" deve esistere quando si modifica "SGRAVI"
         if  NEW_OGPR_SGRAVIO is not null and ( seq = 0 )
         and (   (NEW_OGPR_SGRAVIO != OLD_OGPR_SGRAVIO or OLD_OGPR_SGRAVIO is null) ) then
            open  cpk4_sgravi(NEW_OGPR_SGRAVIO);
            fetch cpk4_sgravi into dummy;
            found := cpk4_sgravi%FOUND;
            close cpk4_sgravi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Pratica. La registrazione Sgravi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SGRAVI_PU */
/

-- Trigger SGRAVI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SGRAVI

create or replace trigger SGRAVI_TIU
before INSERT
    or UPDATE
on SGRAVI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
       SGRAVI_DI (:new.data_elenco);
   end;

   if INSERTING and :new.sequenza_sgravio is null then
       SGRAVI_NR (:new.ruolo,:new.cod_fiscale,:new.sequenza,:new.sequenza_sgravio);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SGRAVI_PU(:OLD.RUOLO,
                   :OLD.COD_FISCALE,
                   :OLD.SEQUENZA,
                   :OLD.SEQUENZA_SGRAVIO,
                   :OLD.MOTIVO_SGRAVIO,
                   :OLD.FATTURA,
                   :OLD.OGPR_SGRAVIO,
                         :NEW.RUOLO,
                         :NEW.COD_FISCALE,
                         :NEW.SEQUENZA,
                         :NEW.SEQUENZA_SGRAVIO,
                         :NEW.MOTIVO_SGRAVIO,
                         :NEW.FATTURA,
                         :NEW.OGPR_SGRAVIO);
         null;
      end if;
      if INSERTING then
         SGRAVI_PI(:NEW.RUOLO,
                   :NEW.COD_FISCALE,
                   :NEW.SEQUENZA,
                   :NEW.MOTIVO_SGRAVIO,
                   :NEW.FATTURA,
                   :NEW.OGPR_SGRAVIO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SGRAVI"
            cursor cpk_sgravi(var_RUOLO number,
                              var_COD_FISCALE varchar,
                              var_SEQUENZA number,
                              var_SEQUENZA_SGRAVIO number) is
               select 1
                 from   SGRAVI
                where  RUOLO = var_RUOLO and
                       COD_FISCALE = var_COD_FISCALE and
                       SEQUENZA = var_SEQUENZA and
                       SEQUENZA_SGRAVIO = var_SEQUENZA_SGRAVIO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SGRAVI"
               if :new.RUOLO is not null and
                  :new.COD_FISCALE is not null and
                  :new.SEQUENZA is not null and
                  :new.SEQUENZA_SGRAVIO is not null then
                  open  cpk_sgravi(:new.RUOLO,
                                   :new.COD_FISCALE,
                                   :new.SEQUENZA,
                                   :new.SEQUENZA_SGRAVIO);
                  fetch cpk_sgravi into dummy;
                  found := cpk_sgravi%FOUND;
                  close cpk_sgravi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RUOLO||' '||
                               :new.COD_FISCALE||' '||
                               :new.SEQUENZA||' '||
                               :new.SEQUENZA_SGRAVIO||
                               '" gia'' presente in Sgravi. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "SGRAVI" for all children in "FAMILIARI_SGRA"
         if (:OLD.RUOLO != :NEW.RUOLO) or
            (:OLD.COD_FISCALE != :NEW.COD_FISCALE) or
            (:OLD.SEQUENZA != :NEW.SEQUENZA) or
            (:OLD.SEQUENZA_SGRAVIO != :NEW.SEQUENZA_SGRAVIO) then
            update FAMILIARI_SGRA
             set   RUOLO = :NEW.RUOLO,
                   COD_FISCALE = :NEW.COD_FISCALE,
                   SEQUENZA = :NEW.SEQUENZA,
                   SEQUENZA_SGRAVIO = :NEW.SEQUENZA_SGRAVIO
            where  RUOLO = :OLD.RUOLO
             and   COD_FISCALE = :OLD.COD_FISCALE
             and   SEQUENZA = :OLD.SEQUENZA
             and   SEQUENZA_SGRAVIO = :OLD.SEQUENZA_SGRAVIO;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SGRAVI_TIU */
/

-- Procedure SGRAVI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SGRAVI

create or replace procedure SGRAVI_PD
(old_ruolo IN number,
 old_cod_fiscale IN varchar,
 old_sequenza IN number,
 old_sequenza_sgravio IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SGRAVI_PD */
/

-- Tigger SGRAVI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SGRAVI

create or replace trigger SGRAVI_TD
before DELETE
on SGRAVI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      SGRAVI_PD(:OLD.RUOLO,
                :OLD.COD_FISCALE,
                :OLD.SEQUENZA,
                :OLD.SEQUENZA_SGRAVIO);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "FAMILIARI_SGRA"
      delete FAMILIARI_SGRA
      where  RUOLO = :OLD.RUOLO
       and   COD_FISCALE = :OLD.COD_FISCALE
       and   SEQUENZA = :OLD.SEQUENZA
       and   SEQUENZA_SGRAVIO = :OLD.SEQUENZA_SGRAVIO;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SGRAVI_TD */
/

-- Procedure SOGEI_DIC_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SOGEI_DIC

create or replace procedure SOGEI_DIC_PU
(old_progressivo IN number,
 new_progressivo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SOGEI_DIC_PU */
/

-- Trigger SOGEI_DIC_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SOGEI_DIC

create or replace trigger SOGEI_DIC_TIU
before INSERT
    or UPDATE
on SOGEI_DIC
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.progressivo is null then
	SOGEI_DIC_NR(:new.progressivo);
   end if;

   begin  -- Check REFERENTIAL Integrity at Level 0
      if UPDATING then
         SOGEI_DIC_PU(:OLD.PROGRESSIVO,
                         :NEW.PROGRESSIVO);
         null;
      end if;
	if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SOGEI_DIC"
            cursor cpk_sogei_dic(var_PROGRESSIVO number) is
               select 1
                 from   SOGEI_DIC
                where  PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SOGEI_DIC"
               if :new.PROGRESSIVO is not null then
                  open  cpk_sogei_dic(:new.PROGRESSIVO);
                  fetch cpk_sogei_dic into dummy;
                  found := cpk_sogei_dic%FOUND;
                  close cpk_sogei_dic;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PROGRESSIVO||
                               '" gia'' presente in Sogei Dic. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SOGEI_DIC_TIU */
/

-- Procedure SOGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SOGGETTI

create or replace procedure SOGGETTI_PI
(new_cod_via IN number,
 new_tipo_carica IN number,
 new_ni_presso IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_CARICA"
   cursor cpk1_soggetti(var_tipo_carica number) is
      select 1
      from   TIPI_CARICA
      where  TIPO_CARICA = var_tipo_carica
       and   var_tipo_carica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE"
   cursor cpk2_soggetti(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk3_soggetti(var_ni_presso number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni_presso
       and   var_ni_presso is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FONTI"
   cursor cpk4_soggetti(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_CARICA" deve esistere quando si inserisce su "SOGGETTI"
         if NEW_TIPO_CARICA is not null then
            open  cpk1_soggetti(NEW_TIPO_CARICA);
            fetch cpk1_soggetti into dummy;
            found := cpk1_soggetti%FOUND;
            close cpk1_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Carica. La registrazione Soggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si inserisce su "SOGGETTI"
         if NEW_COD_VIA is not null then
            open  cpk2_soggetti(NEW_COD_VIA);
            fetch cpk2_soggetti into dummy;
            found := cpk2_soggetti%FOUND;
            close cpk2_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Soggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "SOGGETTI"
         if NEW_NI_PRESSO is not null then
            open  cpk3_soggetti(NEW_NI_PRESSO);
            fetch cpk3_soggetti into dummy;
            found := cpk3_soggetti%FOUND;
            close cpk3_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Soggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si inserisce su "SOGGETTI"
         if NEW_FONTE is not null then
            open  cpk4_soggetti(NEW_FONTE);
            fetch cpk4_soggetti into dummy;
            found := cpk4_soggetti%FOUND;
            close cpk4_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Soggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SOGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SOGGETTI

create or replace trigger SOGGETTI_TB
before INSERT
    or UPDATE
    or DELETE
on SOGGETTI
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: SOGGETTI_TB */
/

create or replace trigger SOGGETTI_TC
after INSERT
   or UPDATE
   or DELETE
on SOGGETTI
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: SOGGETTI_TC */
/

-- Procedure SOGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SOGGETTI

create or replace procedure SOGGETTI_PU
(old_ni IN number,
 old_cod_via IN number,
 old_tipo_carica IN number,
 old_ni_presso IN number,
 old_fonte IN number,
 new_ni IN number,
 new_cod_via IN number,
 new_tipo_carica IN number,
 new_ni_presso IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_CARICA"
   cursor cpk1_soggetti(var_tipo_carica number) is
      select 1
      from   TIPI_CARICA
      where  TIPO_CARICA = var_tipo_carica
       and   var_tipo_carica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE"
   cursor cpk2_soggetti(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk3_soggetti(var_ni_presso number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni_presso
       and   var_ni_presso is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FONTI"
   cursor cpk4_soggetti(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Declaration of UpdateParentRestrict constraint for "CONTRIBUENTI"
   cursor cfk1_soggetti(var_ni number) is
      select 1
      from   CONTRIBUENTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of UpdateParentRestrict constraint for "STORICO_SOGGETTI"
   cursor cfk2_soggetti(var_ni number) is
      select 1
      from   STORICO_SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of UpdateParentRestrict constraint for "EDIFICI"
   cursor cfk3_soggetti(var_ni number) is
      select 1
      from   EDIFICI
      where  AMMINISTRATORE = var_ni
       and   var_ni is not null;

   --  Declaration of UpdateParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk4_soggetti(var_ni number) is
      select 1
      from   UTILIZZI_OGGETTO
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of UpdateParentRestrict constraint for "FAMILIARI_PRATICA"
   cursor cfk5_soggetti(var_ni number) is
      select 1
      from   FAMILIARI_PRATICA
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of UpdateParentRestrict constraint for "FAMILIARI_SOGGETTO"
   cursor cfk6_soggetti(var_ni number) is
      select 1
      from   FAMILIARI_SOGGETTO
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of UpdateParentRestrict constraint for "EREDI_SOGGETTO"
   cursor cfk7_soggetti(var_ni number) is
      select 1
      from   EREDI_SOGGETTO
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of UpdateParentRestrict constraint for "EREDI_SOGGETTO"
   cursor cfk8_soggetti(var_ni number) is
      select 1
      from   EREDI_SOGGETTO
      where  NI_EREDE = var_ni
       and   var_ni is not null;

   --  Declaration of UpdateParentRestrict constraint for "RECAPITI_SOGGETTO"
   cursor cfk9_soggetti(var_ni number) is
      select 1
      from   RECAPITI_SOGGETTO
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_CARICA" deve esistere quando si modifica "SOGGETTI"
         if  NEW_TIPO_CARICA is not null and ( seq = 0 )
         and (   (NEW_TIPO_CARICA != OLD_TIPO_CARICA or OLD_TIPO_CARICA is null) ) then
            open  cpk1_soggetti(NEW_TIPO_CARICA);
            fetch cpk1_soggetti into dummy;
            found := cpk1_soggetti%FOUND;
            close cpk1_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Carica. La registrazione Soggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si modifica "SOGGETTI"
         if  NEW_COD_VIA is not null and ( seq = 0 )
         and (   (NEW_COD_VIA != OLD_COD_VIA or OLD_COD_VIA is null) ) then
            open  cpk2_soggetti(NEW_COD_VIA);
            fetch cpk2_soggetti into dummy;
            found := cpk2_soggetti%FOUND;
            close cpk2_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione Soggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "SOGGETTI"
         if  NEW_NI_PRESSO is not null and ( seq = 0 )
         and (   (NEW_NI_PRESSO != OLD_NI_PRESSO or OLD_NI_PRESSO is null) ) then
            open  cpk3_soggetti(NEW_NI_PRESSO);
            fetch cpk3_soggetti into dummy;
            found := cpk3_soggetti%FOUND;
            close cpk3_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Soggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si modifica "SOGGETTI"
         if  NEW_FONTE is not null and ( seq = 0 )
         and (   (NEW_FONTE != OLD_FONTE or OLD_FONTE is null) ) then
            open  cpk4_soggetti(NEW_FONTE);
            fetch cpk4_soggetti into dummy;
            found := cpk4_soggetti%FOUND;
            close cpk4_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Soggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "CONTRIBUENTI"
      if (OLD_NI != NEW_NI) then
         open  cfk1_soggetti(OLD_NI);
         fetch cfk1_soggetti into dummy;
         found := cfk1_soggetti%FOUND;
         close cfk1_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Contribuenti. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "STORICO_SOGGETTI"
      if (OLD_NI != NEW_NI) then
         open  cfk2_soggetti(OLD_NI);
         fetch cfk2_soggetti into dummy;
         found := cfk2_soggetti%FOUND;
         close cfk2_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Storico Soggetti. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "EDIFICI"
      if (OLD_NI != NEW_NI) then
         open  cfk3_soggetti(OLD_NI);
         fetch cfk3_soggetti into dummy;
         found := cfk3_soggetti%FOUND;
         close cfk3_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Edifici. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "UTILIZZI_OGGETTO"
      if (OLD_NI != NEW_NI) then
         open  cfk4_soggetti(OLD_NI);
         fetch cfk4_soggetti into dummy;
         found := cfk4_soggetti%FOUND;
         close cfk4_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "FAMILIARI_PRATICA"
      if (OLD_NI != NEW_NI) then
         open  cfk5_soggetti(OLD_NI);
         fetch cfk5_soggetti into dummy;
         found := cfk5_soggetti%FOUND;
         close cfk5_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Familiari_pratica. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "FAMILIARI_SOGGETTO"
      if (OLD_NI != NEW_NI) then
         open  cfk6_soggetti(OLD_NI);
         fetch cfk6_soggetti into dummy;
         found := cfk6_soggetti%FOUND;
         close cfk6_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Familiari Soggetto. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "EREDI_SOGGETTO"
      if (OLD_NI != NEW_NI) then
         open  cfk7_soggetti(OLD_NI);
         fetch cfk7_soggetti into dummy;
         found := cfk7_soggetti%FOUND;
         close cfk7_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Eredi Soggetto. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "EREDI_SOGGETTO"
      if (OLD_NI != NEW_NI) then
         open  cfk8_soggetti(OLD_NI);
         fetch cfk8_soggetti into dummy;
         found := cfk8_soggetti%FOUND;
         close cfk8_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Eredi Soggetto. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SOGGETTI" non modificabile se esistono referenze su "RECAPITI_SOGGETTO"
      if (OLD_NI != NEW_NI) then
         open  cfk9_soggetti(OLD_NI);
         fetch cfk9_soggetti into dummy;
         found := cfk9_soggetti%FOUND;
         close cfk9_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su RECAPITI_SOGGETTO. La registrazione di Soggetti non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SOGGETTI_PU */
/

-- Trigger SOGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SOGGETTI

create or replace trigger SOGGETTI_TIU
before INSERT
    or UPDATE
on SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      SOGGETTI_DI (:new.cod_fiscale,:new.data_nas);

--      IF :new.data_variazione is null THEN  -- Disabilitata in data 17/12/2004
         :new.data_variazione := trunc(sysdate);
--      END IF;

      IF nvl(:old.cognome_nome,' ') != :new.cognome_nome THEN
         IF instr(:new.cognome_nome,'/') > 0 THEN
            :new.cognome := substr(:new.cognome_nome,1,instr(:new.cognome_nome,'/')-1);
            :new.nome    := substr(:new.cognome_nome,instr(:new.cognome_nome,'/')+1,36);
         ELSE
            :new.cognome := :new.cognome_nome;
            :new.nome    := '';
         END IF;
      ELSIF nvl(:old.cognome,' ') 	!= nvl(:new.cognome,' ') or
            nvl(:old.nome,' ')		!= nvl(:new.nome,' ') THEN
            :new.cognome_nome := :new.cognome;
         IF :new.nome is not null THEN
            :new.cognome_nome := :new.cognome||'/'||:new.nome;
         END IF;
      END IF;
      :new.cognome_nome_ric := upper(:new.cognome_nome);
      :new.cognome_ric      := upper(:new.cognome);
      :new.nome_ric         := upper(:new.nome);

   end;

   if INSERTING and :new.ni is null then
      SOGGETTI_NR(:new.ni);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SOGGETTI_PU(:OLD.NI,
                     :OLD.COD_VIA,
                     :OLD.TIPO_CARICA,
                     :OLD.NI_PRESSO,
                     :OLD.FONTE,
                         :NEW.NI,
                         :NEW.COD_VIA,
                         :NEW.TIPO_CARICA,
                         :NEW.NI_PRESSO,
                         :NEW.FONTE);
         null;
      end if;
      if INSERTING then
         SOGGETTI_PI(:NEW.COD_VIA,
                     :NEW.TIPO_CARICA,
                     :NEW.NI_PRESSO,
                     :NEW.FONTE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SOGGETTI"
            cursor cpk_soggetti(var_NI number) is
               select 1
                 from   SOGGETTI
                where  NI = var_NI;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SOGGETTI"
               if :new.NI is not null then
                  open  cpk_soggetti(:new.NI);
                  fetch cpk_soggetti into dummy;
                  found := cpk_soggetti%FOUND;
                  close cpk_soggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.NI||
                               '" gia'' presente in Soggetti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin -- Set PostEvent Check REFERENTIAL Integrity at Level 0
      DECLARE a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
      IF IntegrityPackage.GetNestLevel = 0 THEN
         --
         -- Integrit… Referenziale di Esistenza FK
         --
         IF INSERTING THEN
            --
            -- Integrit… Referenziale di Esistenza su insert FK
            --
            IF :new.ni_presso is NOT null THEN
               a_istruzione := 'select 1 from soggetti where ni = '
                               || :new.ni_presso;
               a_messaggio := 'Impossibile inserire, non esiste il padre';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            END IF;
         ELSIF UPDATING THEN
            IF nvl(:new.ni_presso,-1) != nvl(:old.ni_presso ,-1) THEN
               --
               -- Integrit… Referenziale di Esistenza su update FK
               --
               IF :new.ni_presso is NOT null THEN
                  a_istruzione := 'select 1 from soggetti where ni = '
                                  ||:new.ni_presso;
                  a_messaggio := 'Impossibile aggiornare, non esiste il padre';
                  IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
               END IF;
            END IF;
         END IF;
      END IF;
      IF UPDATING THEN
         IF :new.ni != :old.ni THEN
            --
            -- Integrit… Referenziale su update PK
            --

            /* Caso di RESTRICT UPDATE */

               a_istruzione := 'select 0 from soggetti where ni_presso = '
                               ||:old.ni ;
               a_messaggio := 'Impossibile aggiornare, ci sono figli';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);

            /* Caso di CASCADE UPDATE

               a_istruzione := 'update soggetti set ni_presso ='
                               ||:new.ni ||' where ni_presso = '
                               ||:old.ni;
               a_messaggio := '';
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            */

         END IF;
      END IF;
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            SOGGETTI_FI (:new.tipo_residente);
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SOGGETTI_TIU */
/

-- Procedure SOGGETTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SOGGETTI

create or replace procedure SOGGETTI_PD
(old_ni IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CONTRIBUENTI"
   cursor cfk1_soggetti(var_ni number) is
      select 1
      from   CONTRIBUENTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of DeleteParentRestrict constraint for "STORICO_SOGGETTI"
   cursor cfk2_soggetti(var_ni number) is
      select 1
      from   STORICO_SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of DeleteParentRestrict constraint for "EDIFICI"
   cursor cfk3_soggetti(var_ni number) is
      select 1
      from   EDIFICI
      where  AMMINISTRATORE = var_ni
       and   var_ni is not null;

   --  Declaration of DeleteParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk4_soggetti(var_ni number) is
      select 1
      from   UTILIZZI_OGGETTO
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of DeleteParentRestrict constraint for "FAMILIARI_PRATICA"
   cursor cfk5_soggetti(var_ni number) is
      select 1
      from   FAMILIARI_PRATICA
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of DeleteParentRestrict constraint for "FAMILIARI_SOGGETTO"
   cursor cfk6_soggetti(var_ni number) is
      select 1
      from   FAMILIARI_SOGGETTO
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of DeleteParentRestrict constraint for "EREDI_SOGGETTO"
   cursor cfk7_soggetti(var_ni number) is
      select 1
      from   EREDI_SOGGETTO
      where  NI = var_ni
       and   var_ni is not null;

   --  Declaration of DeleteParentRestrict constraint for "EREDI_SOGGETTO"
   cursor cfk8_soggetti(var_ni number) is
      select 1
      from   EREDI_SOGGETTO
      where  NI_EREDE = var_ni
       and   var_ni is not null;

   --  Declaration of DeleteParentRestrict constraint for "RECAPITI_SOGGETTO"
   cursor cfk9_soggetti(var_ni number) is
      select 1
      from   RECAPITI_SOGGETTO
      where  NI = var_ni
       and   var_ni is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SOGGETTI" if children still exist in "CONTRIBUENTI"
      open  cfk1_soggetti(OLD_NI);
      fetch cfk1_soggetti into dummy;
      found := cfk1_soggetti%FOUND;
      close cfk1_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Contribuenti. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SOGGETTI" if children still exist in "STORICO_SOGGETTI"
      open  cfk2_soggetti(OLD_NI);
      fetch cfk2_soggetti into dummy;
      found := cfk2_soggetti%FOUND;
      close cfk2_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Storico Soggetti. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SOGGETTI" if children still exist in "EDIFICI"
      open  cfk3_soggetti(OLD_NI);
      fetch cfk3_soggetti into dummy;
      found := cfk3_soggetti%FOUND;
      close cfk3_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Edifici. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SOGGETTI" if children still exist in "UTILIZZI_OGGETTO"
      open  cfk4_soggetti(OLD_NI);
      fetch cfk4_soggetti into dummy;
      found := cfk4_soggetti%FOUND;
      close cfk4_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SOGGETTI" if children still exist in "FAMILIARI_PRATICA"
      open  cfk5_soggetti(OLD_NI);
      fetch cfk5_soggetti into dummy;
      found := cfk5_soggetti%FOUND;
      close cfk5_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Familiari_pratica. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SOGGETTI" if children still exist in "FAMILIARI_SOGGETTO"
      open  cfk6_soggetti(OLD_NI);
      fetch cfk6_soggetti into dummy;
      found := cfk6_soggetti%FOUND;
      close cfk6_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Familiari Soggetto. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SOGGETTI" if children still exist in "EREDI_SOGGETTO"
      open  cfk7_soggetti(OLD_NI);
      fetch cfk7_soggetti into dummy;
      found := cfk7_soggetti%FOUND;
      close cfk7_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Eredi Soggetto. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SOGGETTI" if children still exist in "EREDI_SOGGETTO"
      open  cfk8_soggetti(OLD_NI);
      fetch cfk8_soggetti into dummy;
      found := cfk8_soggetti%FOUND;
      close cfk8_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Eredi Soggetto. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SOGGETTI" if children still exist in "RECAPITI_SOGGETTO"
      open  cfk9_soggetti(OLD_NI);
      fetch cfk9_soggetti into dummy;
      found := cfk9_soggetti%FOUND;
      close cfk9_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su RECAPITI_SOGGETTO. La registrazione di Soggetti non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SOGGETTI_PD */
/

-- Tigger SOGGETTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SOGGETTI

create or replace trigger SOGGETTI_TD
before DELETE
on SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            SOGGETTI_FI (:old.tipo_residente);
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CONTRIBUENTI

      -- Child Restrict Table: STORICO_SOGGETTI

      -- Child Restrict Table: EDIFICI

      -- Child Restrict Table: UTILIZZI_OGGETTO

      -- Child Restrict Table: FAMILIARI_PRATICA

      -- Child Restrict Table: FAMILIARI_SOGGETTO

      -- Child Restrict Table: EREDI_SOGGETTO

      -- Child Restrict Table: EREDI_SOGGETTO

      -- Child Restrict Table: RECAPITI_SOGGETTO

      SOGGETTI_PD(:OLD.NI);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
            DECLARE a_istruzione  varchar2(2000);
                    a_messaggio   varchar2(2000);
            BEGIN
               a_messaggio := 'Esistono riferimenti su Soggetti (NI Presso). La registrazione di Soggetti non e'' eliminabile.';
               a_istruzione := 'select 0 from soggetti where ni_presso = '
                               ||:old.ni;
               IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
            EXCEPTION
               WHEN OTHERS THEN
                    IntegrityPackage.InitNestLevel;
                    raise;
            END;
   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SOGGETTI_TD */
/

-- Procedure SOTTOCLASSI_CER_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SOTTOCLASSI_CER

create or replace procedure SOTTOCLASSI_CER_PI
(new_classe_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CLASSI_CER"
   cursor cpk1_sottoclassi_cer(var_classe_cer varchar) is
      select 1
      from   CLASSI_CER
      where  CLASSE_CER = var_classe_cer
       and   var_classe_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CLASSI_CER" deve esistere quando si inserisce su "SOTTOCLASSI_CER"
         if NEW_CLASSE_CER is not null then
            open  cpk1_sottoclassi_cer(NEW_CLASSE_CER);
            fetch cpk1_sottoclassi_cer into dummy;
            found := cpk1_sottoclassi_cer%FOUND;
            close cpk1_sottoclassi_cer;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Classi CER. La registrazione Sottoclassi CER non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SOTTOCLASSI_CER_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SOTTOCLASSI_CER
/* End Trigger: SOTTOCLASSI_CER_TC */

-- Procedure SOTTOCLASSI_CER_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SOTTOCLASSI_CER

create or replace procedure SOTTOCLASSI_CER_PU
(old_classe_cer IN varchar,
 old_sottoclasse_cer IN varchar,
 new_classe_cer IN varchar,
 new_sottoclasse_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CLASSI_CER"
   cursor cpk1_sottoclassi_cer(var_classe_cer varchar) is
      select 1
      from   CLASSI_CER
      where  CLASSE_CER = var_classe_cer
       and   var_classe_cer is not null;

   --  Declaration of UpdateParentRestrict constraint for "CATEGORIE_CER"
   cursor cfk1_sottoclassi_cer(var_classe_cer varchar,
                               var_sottoclasse_cer varchar) is
      select 1
      from   CATEGORIE_CER
      where  CLASSE_CER = var_classe_cer
       and   SOTTOCLASSE_CER = var_sottoclasse_cer
       and   var_classe_cer is not null
       and   var_sottoclasse_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CLASSI_CER" deve esistere quando si modifica "SOTTOCLASSI_CER"
         if  NEW_CLASSE_CER is not null and ( seq = 0 )
         and (   (NEW_CLASSE_CER != OLD_CLASSE_CER or OLD_CLASSE_CER is null) ) then
            open  cpk1_sottoclassi_cer(NEW_CLASSE_CER);
            fetch cpk1_sottoclassi_cer into dummy;
            found := cpk1_sottoclassi_cer%FOUND;
            close cpk1_sottoclassi_cer;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Classi CER. La registrazione Sottoclassi CER non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SOTTOCLASSI_CER" non modificabile se esistono referenze su "CATEGORIE_CER"
      if (OLD_CLASSE_CER != NEW_CLASSE_CER) or
         (OLD_SOTTOCLASSE_CER != NEW_SOTTOCLASSE_CER) then
         open  cfk1_sottoclassi_cer(OLD_CLASSE_CER,
                                    OLD_SOTTOCLASSE_CER);
         fetch cfk1_sottoclassi_cer into dummy;
         found := cfk1_sottoclassi_cer%FOUND;
         close cfk1_sottoclassi_cer;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Categorie CER. La registrazione di Sottoclassi CER non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SOTTOCLASSI_CER_PU */
/

-- Trigger SOTTOCLASSI_CER_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SOTTOCLASSI_CER

create or replace trigger SOTTOCLASSI_CER_TIU
before INSERT
    or UPDATE
on SOTTOCLASSI_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SOTTOCLASSI_CER_PU(:OLD.CLASSE_CER,
                            :OLD.SOTTOCLASSE_CER,
                         :NEW.CLASSE_CER,
                         :NEW.SOTTOCLASSE_CER);
         null;
      end if;
      if INSERTING then
         SOTTOCLASSI_CER_PI(:NEW.CLASSE_CER);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SOTTOCLASSI_CER"
            cursor cpk_sottoclassi_cer(var_CLASSE_CER varchar,
                                       var_SOTTOCLASSE_CER varchar) is
               select 1
                 from   SOTTOCLASSI_CER
                where  CLASSE_CER = var_CLASSE_CER and
                       SOTTOCLASSE_CER = var_SOTTOCLASSE_CER;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SOTTOCLASSI_CER"
               if :new.CLASSE_CER is not null and
                  :new.SOTTOCLASSE_CER is not null then
                  open  cpk_sottoclassi_cer(:new.CLASSE_CER,
                                            :new.SOTTOCLASSE_CER);
                  fetch cpk_sottoclassi_cer into dummy;
                  found := cpk_sottoclassi_cer%FOUND;
                  close cpk_sottoclassi_cer;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.CLASSE_CER||' '||
                               :new.SOTTOCLASSE_CER||
                               '" gia'' presente in Sottoclassi CER. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SOTTOCLASSI_CER_TIU */
/

-- Procedure SOTTOCLASSI_CER_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SOTTOCLASSI_CER

create or replace procedure SOTTOCLASSI_CER_PD
(old_classe_cer IN varchar,
 old_sottoclasse_cer IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CATEGORIE_CER"
   cursor cfk1_sottoclassi_cer(var_classe_cer varchar,
                               var_sottoclasse_cer varchar) is
      select 1
      from   CATEGORIE_CER
      where  CLASSE_CER = var_classe_cer
       and   SOTTOCLASSE_CER = var_sottoclasse_cer
       and   var_classe_cer is not null
       and   var_sottoclasse_cer is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SOTTOCLASSI_CER" if children still exist in "CATEGORIE_CER"
      open  cfk1_sottoclassi_cer(OLD_CLASSE_CER,
                                 OLD_SOTTOCLASSE_CER);
      fetch cfk1_sottoclassi_cer into dummy;
      found := cfk1_sottoclassi_cer%FOUND;
      close cfk1_sottoclassi_cer;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Categorie CER. La registrazione di Sottoclassi CER non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SOTTOCLASSI_CER_PD */
/

-- Tigger SOTTOCLASSI_CER_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SOTTOCLASSI_CER

create or replace trigger SOTTOCLASSI_CER_TD
before DELETE
on SOTTOCLASSI_CER
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CATEGORIE_CER

      SOTTOCLASSI_CER_PD(:OLD.CLASSE_CER,
                         :OLD.SOTTOCLASSE_CER);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SOTTOCLASSI_CER_TD */
/

-- Procedure SPESE_ISTRUTTORIA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SPESE_ISTRUTTORIA

create or replace procedure SPESE_ISTRUTTORIA_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_spese_istruttoria(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "SPESE_ISTRUTTORIA"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_spese_istruttoria(NEW_TIPO_TRIBUTO);
            fetch cpk1_spese_istruttoria into dummy;
            found := cpk1_spese_istruttoria%FOUND;
            close cpk1_spese_istruttoria;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Spese Istruttoria non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SPESE_ISTRUTTORIA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SPESE_ISTRUTTORIA
/* End Trigger: SPESE_ISTRUTTORIA_TC */

-- Procedure SPESE_ISTRUTTORIA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SPESE_ISTRUTTORIA

create or replace procedure SPESE_ISTRUTTORIA_PU
(old_tipo_tributo IN varchar,
 old_anno IN number,
 old_da_importo IN number,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_da_importo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_spese_istruttoria(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "SPESE_ISTRUTTORIA"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_spese_istruttoria(NEW_TIPO_TRIBUTO);
            fetch cpk1_spese_istruttoria into dummy;
            found := cpk1_spese_istruttoria%FOUND;
            close cpk1_spese_istruttoria;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Spese Istruttoria non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SPESE_ISTRUTTORIA_PU */
/

-- Trigger SPESE_ISTRUTTORIA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SPESE_ISTRUTTORIA

create or replace trigger SPESE_ISTRUTTORIA_TIU
before INSERT
    or UPDATE
on SPESE_ISTRUTTORIA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      SPESE_ISTRUTTORIA_DI(:new.spese, :new.perc_insolvenza);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SPESE_ISTRUTTORIA_PU(:OLD.TIPO_TRIBUTO,
                              :OLD.ANNO,
                              :OLD.DA_IMPORTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.DA_IMPORTO);
         null;
      end if;
      if INSERTING then
         SPESE_ISTRUTTORIA_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SPESE_ISTRUTTORIA"
            cursor cpk_spese_istruttoria(var_TIPO_TRIBUTO varchar,
                                         var_ANNO number,
                                         var_DA_IMPORTO number) is
               select 1
                 from   SPESE_ISTRUTTORIA
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       DA_IMPORTO = var_DA_IMPORTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SPESE_ISTRUTTORIA"
               if :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.DA_IMPORTO is not null then
                  open  cpk_spese_istruttoria(:new.TIPO_TRIBUTO,
                                              :new.ANNO,
                                              :new.DA_IMPORTO);
                  fetch cpk_spese_istruttoria into dummy;
                  found := cpk_spese_istruttoria%FOUND;
                  close cpk_spese_istruttoria;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.DA_IMPORTO||
                               '" gia'' presente in Spese Istruttoria. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SPESE_ISTRUTTORIA_TIU */
/

-- Procedure SPESE_NOTIFICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SPESE_NOTIFICA

create or replace procedure SPESE_NOTIFICA_PI
(new_tipo_tributo IN varchar,
 new_tipo_notifica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_spese_notifica(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_NOTIFICA"
   cursor cpk2_spese_notifica(var_tipo_notifica number) is
      select 1
      from   TIPI_NOTIFICA
      where  TIPO_NOTIFICA = var_tipo_notifica
       and   var_tipo_notifica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "SPESE_NOTIFICA"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_spese_notifica(NEW_TIPO_TRIBUTO);
            fetch cpk1_spese_notifica into dummy;
            found := cpk1_spese_notifica%FOUND;
            close cpk1_spese_notifica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Spese Notifica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_NOTIFICA" deve esistere quando si inserisce su "SPESE_NOTIFICA"
         if NEW_TIPO_NOTIFICA is not null then
            open  cpk2_spese_notifica(NEW_TIPO_NOTIFICA);
            fetch cpk2_spese_notifica into dummy;
            found := cpk2_spese_notifica%FOUND;
            close cpk2_spese_notifica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Notifica. La registrazione Spese Notifica non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SPESE_NOTIFICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SPESE_NOTIFICA
/* End Trigger: SPESE_NOTIFICA_TC */

-- Procedure SPESE_NOTIFICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SPESE_NOTIFICA

create or replace procedure SPESE_NOTIFICA_PU
(old_tipo_tributo IN varchar,
 old_sequenza IN number,
 old_tipo_notifica IN number,
 new_tipo_tributo IN varchar,
 new_sequenza IN number,
 new_tipo_notifica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_spese_notifica(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_NOTIFICA"
   cursor cpk2_spese_notifica(var_tipo_notifica number) is
      select 1
      from   TIPI_NOTIFICA
      where  TIPO_NOTIFICA = var_tipo_notifica
       and   var_tipo_notifica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "SPESE_NOTIFICA"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_spese_notifica(NEW_TIPO_TRIBUTO);
            fetch cpk1_spese_notifica into dummy;
            found := cpk1_spese_notifica%FOUND;
            close cpk1_spese_notifica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Spese Notifica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_NOTIFICA" deve esistere quando si modifica "SPESE_NOTIFICA"
         if  NEW_TIPO_NOTIFICA is not null and ( seq = 0 )
         and (   (NEW_TIPO_NOTIFICA != OLD_TIPO_NOTIFICA or OLD_TIPO_NOTIFICA is null) ) then
            open  cpk2_spese_notifica(NEW_TIPO_NOTIFICA);
            fetch cpk2_spese_notifica into dummy;
            found := cpk2_spese_notifica%FOUND;
            close cpk2_spese_notifica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Notifica. La registrazione Spese Notifica non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SPESE_NOTIFICA_PU */
/

-- Trigger SPESE_NOTIFICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SPESE_NOTIFICA

create or replace trigger SPESE_NOTIFICA_TIU
before INSERT
    or UPDATE
on SPESE_NOTIFICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.sequenza is null then
       SPESE_NOTIFICA_NR(:new.tipo_tributo,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SPESE_NOTIFICA_PU(:OLD.TIPO_TRIBUTO,
                           :OLD.SEQUENZA,
                           :OLD.TIPO_NOTIFICA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.SEQUENZA,
                         :NEW.TIPO_NOTIFICA);
         null;
      end if;
      if INSERTING then
         SPESE_NOTIFICA_PI(:NEW.TIPO_TRIBUTO,
                           :NEW.TIPO_NOTIFICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SPESE_NOTIFICA"
            cursor cpk_spese_notifica(var_TIPO_TRIBUTO varchar,
                                      var_SEQUENZA number) is
               select 1
                 from   SPESE_NOTIFICA
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SPESE_NOTIFICA"
               if :new.TIPO_TRIBUTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_spese_notifica(:new.TIPO_TRIBUTO,
                                           :new.SEQUENZA);
                  fetch cpk_spese_notifica into dummy;
                  found := cpk_spese_notifica%FOUND;
                  close cpk_spese_notifica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Spese Notifica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SPESE_NOTIFICA_TIU */
/

-- Procedure STATI_ATTIVITA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STATI_ATTIVITA

create or replace procedure STATI_ATTIVITA_PU
(old_stato_attivita IN number,
 new_stato_attivita IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STATI_ATTIVITA_PU */
/

-- Trigger STATI_ATTIVITA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STATI_ATTIVITA

create or replace trigger STATI_ATTIVITA_TIU
before INSERT
    or UPDATE
on STATI_ATTIVITA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STATI_ATTIVITA_PU(:OLD.STATO_ATTIVITA,
                         :NEW.STATO_ATTIVITA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STATI_ATTIVITA"
            cursor cpk_stati_attivita(var_STATO_ATTIVITA number) is
               select 1
                 from   STATI_ATTIVITA
                where  STATO_ATTIVITA = var_STATO_ATTIVITA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STATI_ATTIVITA"
               if :new.STATO_ATTIVITA is not null then
                  open  cpk_stati_attivita(:new.STATO_ATTIVITA);
                  fetch cpk_stati_attivita into dummy;
                  found := cpk_stati_attivita%FOUND;
                  close cpk_stati_attivita;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.STATO_ATTIVITA||
                               '" gia'' presente in Stati Attivita. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "STATI_ATTIVITA" for all children in "ATTIVITA_ELABORAZIONE"
         if (:OLD.STATO_ATTIVITA != :NEW.STATO_ATTIVITA) then
            update ATTIVITA_ELABORAZIONE
             set   STATO_ATTIVITA = :NEW.STATO_ATTIVITA
            where  STATO_ATTIVITA = :OLD.STATO_ATTIVITA;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STATI_ATTIVITA_TIU */
/

-- Procedure STATI_ATTIVITA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table STATI_ATTIVITA

create or replace procedure STATI_ATTIVITA_PD
(old_stato_attivita IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ATTIVITA_ELABORAZIONE"
   cursor cfk1_stati_attivita(var_stato_attivita number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  STATO_ATTIVITA = var_stato_attivita
       and   var_stato_attivita is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "STATI_ATTIVITA" if children still exist in "ATTIVITA_ELABORAZIONE"
      open  cfk1_stati_attivita(OLD_STATO_ATTIVITA);
      fetch cfk1_stati_attivita into dummy;
      found := cfk1_stati_attivita%FOUND;
      close cfk1_stati_attivita;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Attivita Elaborazione. La registrazione di Stati Attivita non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STATI_ATTIVITA_PD */
/

-- Tigger STATI_ATTIVITA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table STATI_ATTIVITA

create or replace trigger STATI_ATTIVITA_TD
before DELETE
on STATI_ATTIVITA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ATTIVITA_ELABORAZIONE

      STATI_ATTIVITA_PD(:OLD.STATO_ATTIVITA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STATI_ATTIVITA_TD */
/

-- Procedure STATI_CONTRIBUENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STATI_CONTRIBUENTE

create or replace procedure STATI_CONTRIBUENTE_PI
(new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_tipo_stato_contribuente IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_stati_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_stati_contribuente(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_STATO_CONTRIBUENTE"
   cursor cpk3_stati_contribuente(var_tipo_stato_contribuente number) is
      select 1
      from   TIPI_STATO_CONTRIBUENTE
      where  TIPO_STATO_CONTRIBUENTE = var_tipo_stato_contribuente
       and   var_tipo_stato_contribuente is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "STATI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null then
            open  cpk1_stati_contribuente(NEW_COD_FISCALE);
            fetch cpk1_stati_contribuente into dummy;
            found := cpk1_stati_contribuente%FOUND;
            close cpk1_stati_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Stati Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "STATI_CONTRIBUENTE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_stati_contribuente(NEW_TIPO_TRIBUTO);
            fetch cpk2_stati_contribuente into dummy;
            found := cpk2_stati_contribuente%FOUND;
            close cpk2_stati_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Stati Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO_CONTRIBUENTE" deve esistere quando si inserisce su "STATI_CONTRIBUENTE"
         if NEW_TIPO_STATO_CONTRIBUENTE is not null then
            open  cpk3_stati_contribuente(NEW_TIPO_STATO_CONTRIBUENTE);
            fetch cpk3_stati_contribuente into dummy;
            found := cpk3_stati_contribuente%FOUND;
            close cpk3_stati_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Stato Contribuente. La registrazione Stati Contribuente non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STATI_CONTRIBUENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STATI_CONTRIBUENTE

create or replace trigger STATI_CONTRIBUENTE_tb
before INSERT
    or UPDATE
    or DELETE
on STATI_CONTRIBUENTE
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: STATI_CONTRIBUENTE_TB */
/

create or replace trigger STATI_CONTRIBUENTE_tc
after INSERT
   or UPDATE
   or DELETE
on STATI_CONTRIBUENTE
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: STATI_CONTRIBUENTE_TC */
/

-- Procedure STATI_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STATI_CONTRIBUENTE

create or replace procedure STATI_CONTRIBUENTE_PU
(old_id IN number,
 old_cod_fiscale IN varchar,
 old_tipo_tributo IN varchar,
 old_tipo_stato_contribuente IN number,
 new_id IN number,
 new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_tipo_stato_contribuente IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_stati_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_stati_contribuente(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_STATO_CONTRIBUENTE"
   cursor cpk3_stati_contribuente(var_tipo_stato_contribuente number) is
      select 1
      from   TIPI_STATO_CONTRIBUENTE
      where  TIPO_STATO_CONTRIBUENTE = var_tipo_stato_contribuente
       and   var_tipo_stato_contribuente is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "STATI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_stati_contribuente(NEW_COD_FISCALE);
            fetch cpk1_stati_contribuente into dummy;
            found := cpk1_stati_contribuente%FOUND;
            close cpk1_stati_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Stati Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "STATI_CONTRIBUENTE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_stati_contribuente(NEW_TIPO_TRIBUTO);
            fetch cpk2_stati_contribuente into dummy;
            found := cpk2_stati_contribuente%FOUND;
            close cpk2_stati_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Stati Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO_CONTRIBUENTE" deve esistere quando si modifica "STATI_CONTRIBUENTE"
         if  NEW_TIPO_STATO_CONTRIBUENTE is not null and ( seq = 0 )
         and (   (NEW_TIPO_STATO_CONTRIBUENTE != OLD_TIPO_STATO_CONTRIBUENTE or OLD_TIPO_STATO_CONTRIBUENTE is null) ) then
            open  cpk3_stati_contribuente(NEW_TIPO_STATO_CONTRIBUENTE);
            fetch cpk3_stati_contribuente into dummy;
            found := cpk3_stati_contribuente%FOUND;
            close cpk3_stati_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Stato Contribuente. La registrazione Stati Contribuente non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STATI_CONTRIBUENTE_PU */
/

-- Trigger STATI_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STATI_CONTRIBUENTE

create or replace trigger STATI_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on STATI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.id is null then
      STATI_CONTRIBUENTE_NR(:new.id);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STATI_CONTRIBUENTE_PU(:OLD.ID,
                               :OLD.COD_FISCALE,
                               :OLD.TIPO_TRIBUTO,
                               :OLD.TIPO_STATO_CONTRIBUENTE,
                         :NEW.ID,
                         :NEW.COD_FISCALE,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_STATO_CONTRIBUENTE);
         null;
      end if;
      if INSERTING then
         STATI_CONTRIBUENTE_PI(:NEW.COD_FISCALE,
                               :NEW.TIPO_TRIBUTO,
                               :NEW.TIPO_STATO_CONTRIBUENTE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STATI_CONTRIBUENTE"
            cursor cpk_stati_contribuente(var_ID number) is
               select 1
                 from   STATI_CONTRIBUENTE
                where  ID = var_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STATI_CONTRIBUENTE"
               if :new.ID is not null then
                  open  cpk_stati_contribuente(:new.ID);
                  fetch cpk_stati_contribuente into dummy;
                  found := cpk_stati_contribuente%FOUND;
                  close cpk_stati_contribuente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID||
                               '" gia'' presente in Stati Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STATI_CONTRIBUENTE_TIU */
/

-- Tigger STATI_CONTRIBUENTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table STATI_CONTRIBUENTE

create or replace trigger STATI_CONTRIBUENTE_TD
before DELETE
on STATI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      STATI_CONTRIBUENTE_PD(:OLD.ID);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
      DECLARE
	a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
            a_istruzione := 'BEGIN CONTRIBUENTI_CHK_DEL('''||:old.cod_fiscale||''','''''||'); end;';
            a_messaggio := '';
            IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;
   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STATI_CONTRIBUENTE_TD */
/

-- Procedure STO_CIVICI_OGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STO_CIVICI_OGGETTO

create or replace procedure STO_CIVICI_OGGETTO_PI
(new_oggetto IN number,
 new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "STO_OGGETTI"
   cursor cpk1_sto_civici_oggetto(var_oggetto number) is
      select 1
      from   STO_OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE"
   cursor cpk2_sto_civici_oggetto(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "STO_OGGETTI" deve esistere quando si inserisce su "STO_CIVICI_OGGETTO"
         if NEW_OGGETTO is not null then
            open  cpk1_sto_civici_oggetto(NEW_OGGETTO);
            fetch cpk1_sto_civici_oggetto into dummy;
            found := cpk1_sto_civici_oggetto%FOUND;
            close cpk1_sto_civici_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su STO_OGGETTI. La registrazione STO_CIVICI_OGGETTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si inserisce su "STO_CIVICI_OGGETTO"
         if NEW_COD_VIA is not null then
            open  cpk2_sto_civici_oggetto(NEW_COD_VIA);
            fetch cpk2_sto_civici_oggetto into dummy;
            found := cpk2_sto_civici_oggetto%FOUND;
            close cpk2_sto_civici_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione STO_CIVICI_OGGETTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_CIVICI_OGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STO_CIVICI_OGGETTO
/* End Trigger: STO_CIVICI_OGGETTO_TC */

-- Procedure STO_CIVICI_OGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STO_CIVICI_OGGETTO

create or replace procedure STO_CIVICI_OGGETTO_PU
(old_oggetto IN number,
 old_sequenza IN number,
 old_cod_via IN number,
 new_oggetto IN number,
 new_sequenza IN number,
 new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "STO_OGGETTI"
   cursor cpk1_sto_civici_oggetto(var_oggetto number) is
      select 1
      from   STO_OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE"
   cursor cpk2_sto_civici_oggetto(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "STO_OGGETTI" deve esistere quando si modifica "STO_CIVICI_OGGETTO"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk1_sto_civici_oggetto(NEW_OGGETTO);
            fetch cpk1_sto_civici_oggetto into dummy;
            found := cpk1_sto_civici_oggetto%FOUND;
            close cpk1_sto_civici_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su STO_OGGETTI. La registrazione STO_CIVICI_OGGETTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si modifica "STO_CIVICI_OGGETTO"
         if  NEW_COD_VIA is not null and ( seq = 0 )
         and (   (NEW_COD_VIA != OLD_COD_VIA or OLD_COD_VIA is null) ) then
            open  cpk2_sto_civici_oggetto(NEW_COD_VIA);
            fetch cpk2_sto_civici_oggetto into dummy;
            found := cpk2_sto_civici_oggetto%FOUND;
            close cpk2_sto_civici_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione STO_CIVICI_OGGETTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_CIVICI_OGGETTO_PU */
/

-- Trigger STO_CIVICI_OGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STO_CIVICI_OGGETTO

create or replace trigger STO_CIVICI_OGGETTO_TIU
before INSERT
    or UPDATE
on STO_CIVICI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STO_CIVICI_OGGETTO_PU(:OLD.OGGETTO,
                               :OLD.SEQUENZA,
                               :OLD.COD_VIA,
                         :NEW.OGGETTO,
                         :NEW.SEQUENZA,
                         :NEW.COD_VIA);
         null;
      end if;
      if INSERTING then
         STO_CIVICI_OGGETTO_PI(:NEW.OGGETTO,
                               :NEW.COD_VIA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STO_CIVICI_OGGETTO"
            cursor cpk_sto_civici_oggetto(var_OGGETTO number,
                                          var_SEQUENZA number) is
               select 1
                 from   STO_CIVICI_OGGETTO
                where  OGGETTO = var_OGGETTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STO_CIVICI_OGGETTO"
               if :new.OGGETTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_sto_civici_oggetto(:new.OGGETTO,
                                               :new.SEQUENZA);
                  fetch cpk_sto_civici_oggetto into dummy;
                  found := cpk_sto_civici_oggetto%FOUND;
                  close cpk_sto_civici_oggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in STO_CIVICI_OGGETTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_CIVICI_OGGETTO_TIU */
/

-- Procedure STO_DENUNCE_ICI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STO_DENUNCE_ICI

create or replace procedure STO_DENUNCE_ICI_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "STO_PRATICHE_TRIBUTO"
   cursor cpk1_sto_denunce_ici(var_pratica number) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "STO_PRATICHE_TRIBUTO" deve esistere quando si inserisce su "STO_DENUNCE_ICI"
         if NEW_PRATICA is not null then
            open  cpk1_sto_denunce_ici(NEW_PRATICA);
            fetch cpk1_sto_denunce_ici into dummy;
            found := cpk1_sto_denunce_ici%FOUND;
            close cpk1_sto_denunce_ici;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su STO_PRATICHE_TRIBUTO. La registrazione STO_DENUNCE_ICI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_DENUNCE_ICI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STO_DENUNCE_ICI
/* End Trigger: STO_DENUNCE_ICI_TC */

-- Procedure STO_DENUNCE_ICI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STO_DENUNCE_ICI

create or replace procedure STO_DENUNCE_ICI_PU
(old_pratica IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "STO_PRATICHE_TRIBUTO"
   cursor cpk1_sto_denunce_ici(var_pratica number) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "STO_PRATICHE_TRIBUTO" deve esistere quando si modifica "STO_DENUNCE_ICI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_sto_denunce_ici(NEW_PRATICA);
            fetch cpk1_sto_denunce_ici into dummy;
            found := cpk1_sto_denunce_ici%FOUND;
            close cpk1_sto_denunce_ici;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su STO_PRATICHE_TRIBUTO. La registrazione STO_DENUNCE_ICI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_DENUNCE_ICI_PU */
/

-- Trigger STO_DENUNCE_ICI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STO_DENUNCE_ICI

create or replace trigger STO_DENUNCE_ICI_TIU
before INSERT
    or UPDATE
on STO_DENUNCE_ICI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STO_DENUNCE_ICI_PU(:OLD.PRATICA,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         STO_DENUNCE_ICI_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STO_DENUNCE_ICI"
            cursor cpk_sto_denunce_ici(var_PRATICA number) is
               select 1
                 from   STO_DENUNCE_ICI
                where  PRATICA = var_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STO_DENUNCE_ICI"
               if :new.PRATICA is not null then
                  open  cpk_sto_denunce_ici(:new.PRATICA);
                  fetch cpk_sto_denunce_ici into dummy;
                  found := cpk_sto_denunce_ici%FOUND;
                  close cpk_sto_denunce_ici;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||
                               '" gia'' presente in STO_DENUNCE_ICI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_DENUNCE_ICI_TIU */
/

-- Procedure STO_DENUNCE_TASI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STO_DENUNCE_TASI

create or replace procedure STO_DENUNCE_TASI_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "STO_PRATICHE_TRIBUTO"
   cursor cpk1_sto_denunce_tasi(var_pratica number) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "STO_PRATICHE_TRIBUTO" deve esistere quando si inserisce su "STO_DENUNCE_TASI"
         if NEW_PRATICA is not null then
            open  cpk1_sto_denunce_tasi(NEW_PRATICA);
            fetch cpk1_sto_denunce_tasi into dummy;
            found := cpk1_sto_denunce_tasi%FOUND;
            close cpk1_sto_denunce_tasi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su STO_PRATICHE_TRIBUTO. La registrazione STO_DENUNCE_TASI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_DENUNCE_TASI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STO_DENUNCE_TASI
/* End Trigger: STO_DENUNCE_TASI_TC */

-- Procedure STO_DENUNCE_TASI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STO_DENUNCE_TASI

create or replace procedure STO_DENUNCE_TASI_PU
(old_pratica IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "STO_PRATICHE_TRIBUTO"
   cursor cpk1_sto_denunce_tasi(var_pratica number) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "STO_PRATICHE_TRIBUTO" deve esistere quando si modifica "STO_DENUNCE_TASI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_sto_denunce_tasi(NEW_PRATICA);
            fetch cpk1_sto_denunce_tasi into dummy;
            found := cpk1_sto_denunce_tasi%FOUND;
            close cpk1_sto_denunce_tasi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su STO_PRATICHE_TRIBUTO. La registrazione STO_DENUNCE_TASI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_DENUNCE_TASI_PU */
/

-- Trigger STO_DENUNCE_TASI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STO_DENUNCE_TASI

create or replace trigger STO_DENUNCE_TASI_TIU
before INSERT
    or UPDATE
on STO_DENUNCE_TASI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STO_DENUNCE_TASI_PU(:OLD.PRATICA,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         STO_DENUNCE_TASI_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STO_DENUNCE_TASI"
            cursor cpk_sto_denunce_tasi(var_PRATICA number) is
               select 1
                 from   STO_DENUNCE_TASI
                where  PRATICA = var_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STO_DENUNCE_TASI"
               if :new.PRATICA is not null then
                  open  cpk_sto_denunce_tasi(:new.PRATICA);
                  fetch cpk_sto_denunce_tasi into dummy;
                  found := cpk_sto_denunce_tasi%FOUND;
                  close cpk_sto_denunce_tasi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||
                               '" gia'' presente in STO_DENUNCE_TASI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_DENUNCE_TASI_TIU */
/

-- Procedure STO_OGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STO_OGGETTI

create or replace procedure STO_OGGETTI_PI
(new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "ARCHIVIO_VIE"
   cursor cpk1_sto_oggetti(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si inserisce su "STO_OGGETTI"
         if NEW_COD_VIA is not null then
            open  cpk1_sto_oggetti(NEW_COD_VIA);
            fetch cpk1_sto_oggetti into dummy;
            found := cpk1_sto_oggetti%FOUND;
            close cpk1_sto_oggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione STO_OGGETTI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_OGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STO_OGGETTI
/* End Trigger: STO_OGGETTI_TC */

-- Procedure STO_OGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STO_OGGETTI

create or replace procedure STO_OGGETTI_PU
(old_oggetto IN number,
 old_cod_via IN number,
 new_oggetto IN number,
 new_cod_via IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "ARCHIVIO_VIE"
   cursor cpk1_sto_oggetti(var_cod_via number) is
      select 1
      from   ARCHIVIO_VIE
      where  COD_VIA = var_cod_via
       and   var_cod_via is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_CIVICI_OGGETTO"
   cursor cfk1_sto_oggetti(var_oggetto number) is
      select 1
      from   STO_CIVICI_OGGETTO
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_OGGETTI_PRATICA"
   cursor cfk2_sto_oggetti(var_oggetto number) is
      select 1
      from   STO_OGGETTI_PRATICA
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "ARCHIVIO_VIE" deve esistere quando si modifica "STO_OGGETTI"
         if  NEW_COD_VIA is not null and ( seq = 0 )
         and (   (NEW_COD_VIA != OLD_COD_VIA or OLD_COD_VIA is null) ) then
            open  cpk1_sto_oggetti(NEW_COD_VIA);
            fetch cpk1_sto_oggetti into dummy;
            found := cpk1_sto_oggetti%FOUND;
            close cpk1_sto_oggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Archivio Vie. La registrazione STO_OGGETTI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "STO_OGGETTI" non modificabile se esistono referenze su "STO_CIVICI_OGGETTO"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk1_sto_oggetti(OLD_OGGETTO);
         fetch cfk1_sto_oggetti into dummy;
         found := cfk1_sto_oggetti%FOUND;
         close cfk1_sto_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_CIVICI_OGGETTO. La registrazione di STO_OGGETTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "STO_OGGETTI" non modificabile se esistono referenze su "STO_OGGETTI_PRATICA"
      if (OLD_OGGETTO != NEW_OGGETTO) then
         open  cfk2_sto_oggetti(OLD_OGGETTO);
         fetch cfk2_sto_oggetti into dummy;
         found := cfk2_sto_oggetti%FOUND;
         close cfk2_sto_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_OGGETTI_PRATICA. La registrazione di STO_OGGETTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_OGGETTI_PU */
/

-- Trigger STO_OGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STO_OGGETTI

create or replace trigger STO_OGGETTI_TIU
before INSERT
    or UPDATE
on STO_OGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STO_OGGETTI_PU(:OLD.OGGETTO,
                        :OLD.COD_VIA,
                         :NEW.OGGETTO,
                         :NEW.COD_VIA);
         null;
      end if;
      if INSERTING then
         STO_OGGETTI_PI(:NEW.COD_VIA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STO_OGGETTI"
            cursor cpk_sto_oggetti(var_OGGETTO number) is
               select 1
                 from   STO_OGGETTI
                where  OGGETTO = var_OGGETTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STO_OGGETTI"
               if :new.OGGETTO is not null then
                  open  cpk_sto_oggetti(:new.OGGETTO);
                  fetch cpk_sto_oggetti into dummy;
                  found := cpk_sto_oggetti%FOUND;
                  close cpk_sto_oggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||
                               '" gia'' presente in STO_OGGETTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_OGGETTI_TIU */
/

-- Procedure STO_OGGETTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table STO_OGGETTI

create or replace procedure STO_OGGETTI_PD
(old_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_OGGETTI_PD */
/

-- Tigger STO_OGGETTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table STO_OGGETTI

create or replace trigger STO_OGGETTI_TD
before DELETE
on STO_OGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      STO_OGGETTI_PD(:OLD.OGGETTO);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "STO_CIVICI_OGGETTO"
      delete STO_CIVICI_OGGETTO
      where  OGGETTO = :OLD.OGGETTO;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_OGGETTI_TD */
/

-- Procedure STO_OGGETTI_CONTRIBUENTE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STO_OGGETTI_CONTRIBUENTE

create or replace procedure STO_OGGETTI_CONTRIBUENTE_PI
(new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "STO_OGGETTI_PRATICA"
   cursor cpk1_sto_oggetti_contribuente(var_oggetto_pratica number) is
      select 1
      from   STO_OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk2_sto_oggetti_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "STO_OGGETTI_PRATICA" deve esistere quando si inserisce su "STO_OGGETTI_CONTRIBUENTE"
         if NEW_OGGETTO_PRATICA is not null then
            open  cpk1_sto_oggetti_contribuente(NEW_OGGETTO_PRATICA);
            fetch cpk1_sto_oggetti_contribuente into dummy;
            found := cpk1_sto_oggetti_contribuente%FOUND;
            close cpk1_sto_oggetti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su STO_OGGETTI_PRATICA. La registrazione STO_OGGETTI_CONTRIBUENTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "STO_OGGETTI_CONTRIBUENTE"
         if NEW_COD_FISCALE is not null then
            open  cpk2_sto_oggetti_contribuente(NEW_COD_FISCALE);
            fetch cpk2_sto_oggetti_contribuente into dummy;
            found := cpk2_sto_oggetti_contribuente%FOUND;
            close cpk2_sto_oggetti_contribuente;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione STO_OGGETTI_CONTRIBUENTE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_OGGETTI_CONTRIBUENTE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STO_OGGETTI_CONTRIBUENTE
/* End Trigger: STO_OGGETTI_CONTRIBUENTE_TC */

-- Procedure STO_OGGETTI_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STO_OGGETTI_CONTRIBUENTE

create or replace procedure STO_OGGETTI_CONTRIBUENTE_PU
(old_cod_fiscale IN varchar,
 old_oggetto_pratica IN number,
 new_cod_fiscale IN varchar,
 new_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "STO_OGGETTI_PRATICA"
   cursor cpk1_sto_oggetti_contribuente(var_oggetto_pratica number) is
      select 1
      from   STO_OGGETTI_PRATICA
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk2_sto_oggetti_contribuente(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "STO_OGGETTI_PRATICA" deve esistere quando si modifica "STO_OGGETTI_CONTRIBUENTE"
         if  NEW_OGGETTO_PRATICA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_PRATICA != OLD_OGGETTO_PRATICA or OLD_OGGETTO_PRATICA is null) ) then
            open  cpk1_sto_oggetti_contribuente(NEW_OGGETTO_PRATICA);
            fetch cpk1_sto_oggetti_contribuente into dummy;
            found := cpk1_sto_oggetti_contribuente%FOUND;
            close cpk1_sto_oggetti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su STO_OGGETTI_PRATICA. La registrazione STO_OGGETTI_CONTRIBUENTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "STO_OGGETTI_CONTRIBUENTE"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk2_sto_oggetti_contribuente(NEW_COD_FISCALE);
            fetch cpk2_sto_oggetti_contribuente into dummy;
            found := cpk2_sto_oggetti_contribuente%FOUND;
            close cpk2_sto_oggetti_contribuente;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione STO_OGGETTI_CONTRIBUENTE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_OGGETTI_CONTRIBUENTE_PU */
/

-- Trigger STO_OGGETTI_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STO_OGGETTI_CONTRIBUENTE

create or replace trigger STO_OGGETTI_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on STO_OGGETTI_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STO_OGGETTI_CONTRIBUENTE_PU(:OLD.COD_FISCALE,
                                     :OLD.OGGETTO_PRATICA,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO_PRATICA);
         null;
      end if;
      if INSERTING then
         STO_OGGETTI_CONTRIBUENTE_PI(:NEW.COD_FISCALE,
                                     :NEW.OGGETTO_PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STO_OGGETTI_CONTRIBUENTE"
            cursor cpk_sto_oggetti_contribuente(var_COD_FISCALE varchar,
                                                var_OGGETTO_PRATICA number) is
               select 1
                 from   STO_OGGETTI_CONTRIBUENTE
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO_PRATICA = var_OGGETTO_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STO_OGGETTI_CONTRIBUENTE"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO_PRATICA is not null then
                  open  cpk_sto_oggetti_contribuente(:new.COD_FISCALE,
                                                     :new.OGGETTO_PRATICA);
                  fetch cpk_sto_oggetti_contribuente into dummy;
                  found := cpk_sto_oggetti_contribuente%FOUND;
                  close cpk_sto_oggetti_contribuente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO_PRATICA||
                               '" gia'' presente in STO_OGGETTI_CONTRIBUENTE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_OGGETTI_CONTRIBUENTE_TIU */
/

-- Procedure STO_OGGETTI_PRATICA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STO_OGGETTI_PRATICA

create or replace procedure STO_OGGETTI_PRATICA_PI
(new_oggetto IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "STO_PRATICHE_TRIBUTO"
   cursor cpk1_sto_oggetti_pratica(var_pratica number) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "STO_OGGETTI"
   cursor cpk2_sto_oggetti_pratica(var_oggetto number) is
      select 1
      from   STO_OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "STO_PRATICHE_TRIBUTO" deve esistere quando si inserisce su "STO_OGGETTI_PRATICA"
         if NEW_PRATICA is not null then
            open  cpk1_sto_oggetti_pratica(NEW_PRATICA);
            fetch cpk1_sto_oggetti_pratica into dummy;
            found := cpk1_sto_oggetti_pratica%FOUND;
            close cpk1_sto_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su STO_PRATICHE_TRIBUTO. La registrazione STO_OGGETTI_PRATICA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "STO_OGGETTI" deve esistere quando si inserisce su "STO_OGGETTI_PRATICA"
         if NEW_OGGETTO is not null then
            open  cpk2_sto_oggetti_pratica(NEW_OGGETTO);
            fetch cpk2_sto_oggetti_pratica into dummy;
            found := cpk2_sto_oggetti_pratica%FOUND;
            close cpk2_sto_oggetti_pratica;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su STO_OGGETTI. La registrazione STO_OGGETTI_PRATICA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_OGGETTI_PRATICA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STO_OGGETTI_PRATICA
/* End Trigger: STO_OGGETTI_PRATICA_TC */

-- Procedure STO_OGGETTI_PRATICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STO_OGGETTI_PRATICA

create or replace procedure STO_OGGETTI_PRATICA_PU
(old_oggetto_pratica IN number,
 old_oggetto IN number,
 old_pratica IN number,
 new_oggetto_pratica IN number,
 new_oggetto IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "STO_PRATICHE_TRIBUTO"
   cursor cpk1_sto_oggetti_pratica(var_pratica number) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "STO_OGGETTI"
   cursor cpk2_sto_oggetti_pratica(var_oggetto number) is
      select 1
      from   STO_OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_OGGETTI_CONTRIBUENTE"
   cursor cfk1_sto_oggetti_pratica(var_oggetto_pratica number) is
      select 1
      from   STO_OGGETTI_CONTRIBUENTE
      where  OGGETTO_PRATICA = var_oggetto_pratica
       and   var_oggetto_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "STO_PRATICHE_TRIBUTO" deve esistere quando si modifica "STO_OGGETTI_PRATICA"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_sto_oggetti_pratica(NEW_PRATICA);
            fetch cpk1_sto_oggetti_pratica into dummy;
            found := cpk1_sto_oggetti_pratica%FOUND;
            close cpk1_sto_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su STO_PRATICHE_TRIBUTO. La registrazione STO_OGGETTI_PRATICA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "STO_OGGETTI" deve esistere quando si modifica "STO_OGGETTI_PRATICA"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk2_sto_oggetti_pratica(NEW_OGGETTO);
            fetch cpk2_sto_oggetti_pratica into dummy;
            found := cpk2_sto_oggetti_pratica%FOUND;
            close cpk2_sto_oggetti_pratica;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su STO_OGGETTI. La registrazione STO_OGGETTI_PRATICA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "STO_OGGETTI_PRATICA" non modificabile se esistono referenze su "STO_OGGETTI_CONTRIBUENTE"
      if (OLD_OGGETTO_PRATICA != NEW_OGGETTO_PRATICA) then
         open  cfk1_sto_oggetti_pratica(OLD_OGGETTO_PRATICA);
         fetch cfk1_sto_oggetti_pratica into dummy;
         found := cfk1_sto_oggetti_pratica%FOUND;
         close cfk1_sto_oggetti_pratica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_OGGETTI_CONTRIBUENTE. La registrazione di STO_OGGETTI_PRATICA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_OGGETTI_PRATICA_PU */
/

-- Trigger STO_OGGETTI_PRATICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STO_OGGETTI_PRATICA

create or replace trigger STO_OGGETTI_PRATICA_TIU
before INSERT
    or UPDATE
on STO_OGGETTI_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STO_OGGETTI_PRATICA_PU(:OLD.OGGETTO_PRATICA,
                                :OLD.OGGETTO,
                                :OLD.PRATICA,
                         :NEW.OGGETTO_PRATICA,
                         :NEW.OGGETTO,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         STO_OGGETTI_PRATICA_PI(:NEW.OGGETTO,
                                :NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STO_OGGETTI_PRATICA"
            cursor cpk_sto_oggetti_pratica(var_OGGETTO_PRATICA number) is
               select 1
                 from   STO_OGGETTI_PRATICA
                where  OGGETTO_PRATICA = var_OGGETTO_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STO_OGGETTI_PRATICA"
               if :new.OGGETTO_PRATICA is not null then
                  open  cpk_sto_oggetti_pratica(:new.OGGETTO_PRATICA);
                  fetch cpk_sto_oggetti_pratica into dummy;
                  found := cpk_sto_oggetti_pratica%FOUND;
                  close cpk_sto_oggetti_pratica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO_PRATICA||
                               '" gia'' presente in STO_OGGETTI_PRATICA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_OGGETTI_PRATICA_TIU */
/

-- Procedure STO_OGGETTI_PRATICA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table STO_OGGETTI_PRATICA

create or replace procedure STO_OGGETTI_PRATICA_PD
(old_oggetto_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_OGGETTI_PRATICA_PD */
/

-- Tigger STO_OGGETTI_PRATICA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table STO_OGGETTI_PRATICA

create or replace trigger STO_OGGETTI_PRATICA_TD
before DELETE
on STO_OGGETTI_PRATICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      STO_OGGETTI_PRATICA_PD(:OLD.OGGETTO_PRATICA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "STO_OGGETTI_CONTRIBUENTE"
      delete STO_OGGETTI_CONTRIBUENTE
      where  OGGETTO_PRATICA = :OLD.OGGETTO_PRATICA;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_OGGETTI_PRATICA_TD */
/

-- Procedure STO_PRATICHE_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STO_PRATICHE_TRIBUTO

create or replace procedure STO_PRATICHE_TRIBUTO_PI
(new_pratica IN number,
 new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_sto_pratiche_tributo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk2_sto_pratiche_tributo(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "STO_PRATICHE_TRIBUTO"
         if NEW_COD_FISCALE is not null then
            open  cpk1_sto_pratiche_tributo(NEW_COD_FISCALE);
            fetch cpk1_sto_pratiche_tributo into dummy;
            found := cpk1_sto_pratiche_tributo%FOUND;
            close cpk1_sto_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione STO_PRATICHE_TRIBUTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "STO_PRATICHE_TRIBUTO"
         if NEW_PRATICA is not null then
            open  cpk2_sto_pratiche_tributo(NEW_PRATICA);
            fetch cpk2_sto_pratiche_tributo into dummy;
            found := cpk2_sto_pratiche_tributo%FOUND;
            close cpk2_sto_pratiche_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione STO_PRATICHE_TRIBUTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_PRATICHE_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STO_PRATICHE_TRIBUTO
/* End Trigger: STO_PRATICHE_TRIBUTO_TC */

-- Procedure STO_PRATICHE_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STO_PRATICHE_TRIBUTO

create or replace procedure STO_PRATICHE_TRIBUTO_PU
(old_pratica IN number,
 old_cod_fiscale IN varchar,
 new_pratica IN number,
 new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_sto_pratiche_tributo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk2_sto_pratiche_tributo(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_RAPPORTI_TRIBUTO"
   cursor cfk1_sto_pratiche_tributo(var_pratica number) is
      select 1
      from   STO_RAPPORTI_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_OGGETTI_PRATICA"
   cursor cfk2_sto_pratiche_tributo(var_pratica number) is
      select 1
      from   STO_OGGETTI_PRATICA
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_DENUNCE_ICI"
   cursor cfk3_sto_pratiche_tributo(var_pratica number) is
      select 1
      from   STO_DENUNCE_ICI
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "STO_DENUNCE_TASI"
   cursor cfk4_sto_pratiche_tributo(var_pratica number) is
      select 1
      from   STO_DENUNCE_TASI
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "STO_PRATICHE_TRIBUTO"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_sto_pratiche_tributo(NEW_COD_FISCALE);
            fetch cpk1_sto_pratiche_tributo into dummy;
            found := cpk1_sto_pratiche_tributo%FOUND;
            close cpk1_sto_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione STO_PRATICHE_TRIBUTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "STO_PRATICHE_TRIBUTO"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk2_sto_pratiche_tributo(NEW_PRATICA);
            fetch cpk2_sto_pratiche_tributo into dummy;
            found := cpk2_sto_pratiche_tributo%FOUND;
            close cpk2_sto_pratiche_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione STO_PRATICHE_TRIBUTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "STO_PRATICHE_TRIBUTO" non modificabile se esistono referenze su "STO_RAPPORTI_TRIBUTO"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk1_sto_pratiche_tributo(OLD_PRATICA);
         fetch cfk1_sto_pratiche_tributo into dummy;
         found := cfk1_sto_pratiche_tributo%FOUND;
         close cfk1_sto_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_RAPPORTI_TRIBUTO. La registrazione di STO_PRATICHE_TRIBUTO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "STO_PRATICHE_TRIBUTO" non modificabile se esistono referenze su "STO_OGGETTI_PRATICA"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk2_sto_pratiche_tributo(OLD_PRATICA);
         fetch cfk2_sto_pratiche_tributo into dummy;
         found := cfk2_sto_pratiche_tributo%FOUND;
         close cfk2_sto_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_OGGETTI_PRATICA. La registrazione di STO_PRATICHE_TRIBUTO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "STO_PRATICHE_TRIBUTO" non modificabile se esistono referenze su "STO_DENUNCE_ICI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk3_sto_pratiche_tributo(OLD_PRATICA);
         fetch cfk3_sto_pratiche_tributo into dummy;
         found := cfk3_sto_pratiche_tributo%FOUND;
         close cfk3_sto_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_DENUNCE_ICI. La registrazione di STO_PRATICHE_TRIBUTO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "STO_PRATICHE_TRIBUTO" non modificabile se esistono referenze su "STO_DENUNCE_TASI"
      if (OLD_PRATICA != NEW_PRATICA) then
         open  cfk4_sto_pratiche_tributo(OLD_PRATICA);
         fetch cfk4_sto_pratiche_tributo into dummy;
         found := cfk4_sto_pratiche_tributo%FOUND;
         close cfk4_sto_pratiche_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su STO_DENUNCE_TASI. La registrazione di STO_PRATICHE_TRIBUTO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_PRATICHE_TRIBUTO_PU */
/

-- Trigger STO_PRATICHE_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STO_PRATICHE_TRIBUTO

create or replace trigger STO_PRATICHE_TRIBUTO_TIU
before INSERT
    or UPDATE
on STO_PRATICHE_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_sto := sysdate;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STO_PRATICHE_TRIBUTO_PU(:OLD.PRATICA,
                                 :OLD.COD_FISCALE,
                         :NEW.PRATICA,
                         :NEW.COD_FISCALE);
         null;
      end if;
      if INSERTING then
         STO_PRATICHE_TRIBUTO_PI(:NEW.PRATICA,
                                 :NEW.COD_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STO_PRATICHE_TRIBUTO"
            cursor cpk_sto_pratiche_tributo(var_PRATICA number) is
               select 1
                 from   STO_PRATICHE_TRIBUTO
                where  PRATICA = var_PRATICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STO_PRATICHE_TRIBUTO"
               if :new.PRATICA is not null then
                  open  cpk_sto_pratiche_tributo(:new.PRATICA);
                  fetch cpk_sto_pratiche_tributo into dummy;
                  found := cpk_sto_pratiche_tributo%FOUND;
                  close cpk_sto_pratiche_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||
                               '" gia'' presente in STO_PRATICHE_TRIBUTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_PRATICHE_TRIBUTO_TIU */
/

-- Procedure STO_PRATICHE_TRIBUTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table STO_PRATICHE_TRIBUTO

create or replace procedure STO_PRATICHE_TRIBUTO_PD
(old_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_PRATICHE_TRIBUTO_PD */
/

-- Tigger STO_PRATICHE_TRIBUTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table STO_PRATICHE_TRIBUTO

create or replace trigger STO_PRATICHE_TRIBUTO_TD
before DELETE
on STO_PRATICHE_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      STO_PRATICHE_TRIBUTO_PD(:OLD.PRATICA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "STO_OGGETTI_PRATICA"
      delete STO_OGGETTI_PRATICA
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "STO_DENUNCE_ICI"
      delete STO_DENUNCE_ICI
      where  PRATICA = :OLD.PRATICA;

      --  Delete all children in "STO_DENUNCE_TASI"
      delete STO_DENUNCE_TASI
      where  PRATICA = :OLD.PRATICA;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_PRATICHE_TRIBUTO_TD */
/

-- Procedure STO_RAPPORTI_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STO_RAPPORTI_TRIBUTO

create or replace procedure STO_RAPPORTI_TRIBUTO_PI
(new_pratica IN number,
 new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "STO_PRATICHE_TRIBUTO"
   cursor cpk1_sto_rapporti_tributo(var_pratica number) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk2_sto_rapporti_tributo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "STO_PRATICHE_TRIBUTO" deve esistere quando si inserisce su "STO_RAPPORTI_TRIBUTO"
         if NEW_PRATICA is not null then
            open  cpk1_sto_rapporti_tributo(NEW_PRATICA);
            fetch cpk1_sto_rapporti_tributo into dummy;
            found := cpk1_sto_rapporti_tributo%FOUND;
            close cpk1_sto_rapporti_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su STO_PRATICHE_TRIBUTO. La registrazione STO_RAPPORTI_TRIBUTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "STO_RAPPORTI_TRIBUTO"
         if NEW_COD_FISCALE is not null then
            open  cpk2_sto_rapporti_tributo(NEW_COD_FISCALE);
            fetch cpk2_sto_rapporti_tributo into dummy;
            found := cpk2_sto_rapporti_tributo%FOUND;
            close cpk2_sto_rapporti_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione STO_RAPPORTI_TRIBUTO non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_RAPPORTI_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STO_RAPPORTI_TRIBUTO
/* End Trigger: STO_RAPPORTI_TRIBUTO_TC */

-- Procedure STO_RAPPORTI_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STO_RAPPORTI_TRIBUTO

create or replace procedure STO_RAPPORTI_TRIBUTO_PU
(old_pratica IN number,
 old_sequenza IN number,
 old_cod_fiscale IN varchar,
 new_pratica IN number,
 new_sequenza IN number,
 new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "STO_PRATICHE_TRIBUTO"
   cursor cpk1_sto_rapporti_tributo(var_pratica number) is
      select 1
      from   STO_PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk2_sto_rapporti_tributo(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "STO_PRATICHE_TRIBUTO" deve esistere quando si modifica "STO_RAPPORTI_TRIBUTO"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_sto_rapporti_tributo(NEW_PRATICA);
            fetch cpk1_sto_rapporti_tributo into dummy;
            found := cpk1_sto_rapporti_tributo%FOUND;
            close cpk1_sto_rapporti_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su STO_PRATICHE_TRIBUTO. La registrazione STO_RAPPORTI_TRIBUTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "STO_RAPPORTI_TRIBUTO"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk2_sto_rapporti_tributo(NEW_COD_FISCALE);
            fetch cpk2_sto_rapporti_tributo into dummy;
            found := cpk2_sto_rapporti_tributo%FOUND;
            close cpk2_sto_rapporti_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione STO_RAPPORTI_TRIBUTO non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STO_RAPPORTI_TRIBUTO_PU */
/

-- Trigger STO_RAPPORTI_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STO_RAPPORTI_TRIBUTO

create or replace trigger STO_RAPPORTI_TRIBUTO_TIU
before INSERT
    or UPDATE
on STO_RAPPORTI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STO_RAPPORTI_TRIBUTO_PU(:OLD.PRATICA,
                                 :OLD.SEQUENZA,
                                 :OLD.COD_FISCALE,
                         :NEW.PRATICA,
                         :NEW.SEQUENZA,
                         :NEW.COD_FISCALE);
         null;
      end if;
      if INSERTING then
         STO_RAPPORTI_TRIBUTO_PI(:NEW.PRATICA,
                                 :NEW.COD_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STO_RAPPORTI_TRIBUTO"
            cursor cpk_sto_rapporti_tributo(var_PRATICA number,
                                            var_SEQUENZA number) is
               select 1
                 from   STO_RAPPORTI_TRIBUTO
                where  PRATICA = var_PRATICA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STO_RAPPORTI_TRIBUTO"
               if :new.PRATICA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_sto_rapporti_tributo(:new.PRATICA,
                                                 :new.SEQUENZA);
                  fetch cpk_sto_rapporti_tributo into dummy;
                  found := cpk_sto_rapporti_tributo%FOUND;
                  close cpk_sto_rapporti_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PRATICA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in STO_RAPPORTI_TRIBUTO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STO_RAPPORTI_TRIBUTO_TIU */
/

-- Procedure STORICO_SOGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table STORICO_SOGGETTI

create or replace procedure STORICO_SOGGETTI_PI
(new_ni IN number,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk1_storico_soggetti(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FONTI"
   cursor cpk2_storico_soggetti(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "STORICO_SOGGETTI"
         if NEW_NI is not null then
            open  cpk1_storico_soggetti(NEW_NI);
            fetch cpk1_storico_soggetti into dummy;
            found := cpk1_storico_soggetti%FOUND;
            close cpk1_storico_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Storico Soggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si inserisce su "STORICO_SOGGETTI"
         if NEW_FONTE is not null then
            open  cpk2_storico_soggetti(NEW_FONTE);
            fetch cpk2_storico_soggetti into dummy;
            found := cpk2_storico_soggetti%FOUND;
            close cpk2_storico_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Storico Soggetti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STORICO_SOGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table STORICO_SOGGETTI
/* End Trigger: STORICO_SOGGETTI_TC */

-- Procedure STORICO_SOGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table STORICO_SOGGETTI

create or replace procedure STORICO_SOGGETTI_PU
(old_ni IN number,
 old_dal IN date,
 old_fonte IN number,
 new_ni IN number,
 new_dal IN date,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk1_storico_soggetti(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FONTI"
   cursor cpk2_storico_soggetti(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "STORICO_SOGGETTI"
         if  NEW_NI is not null and ( seq = 0 )
         and (   (NEW_NI != OLD_NI or OLD_NI is null) ) then
            open  cpk1_storico_soggetti(NEW_NI);
            fetch cpk1_storico_soggetti into dummy;
            found := cpk1_storico_soggetti%FOUND;
            close cpk1_storico_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Storico Soggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si modifica "STORICO_SOGGETTI"
         if  NEW_FONTE is not null and ( seq = 0 )
         and (   (NEW_FONTE != OLD_FONTE or OLD_FONTE is null) ) then
            open  cpk2_storico_soggetti(NEW_FONTE);
            fetch cpk2_storico_soggetti into dummy;
            found := cpk2_storico_soggetti%FOUND;
            close cpk2_storico_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Storico Soggetti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SOGGETTI" non modificabile sul figlio: "STORICO_SOGGETTI"
      if (OLD_NI != NEW_NI) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Soggetti non e'' modificabile su Storico Soggetti.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: STORICO_SOGGETTI_PU */
/

-- Trigger STORICO_SOGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table STORICO_SOGGETTI

create or replace trigger STORICO_SOGGETTI_TIU
before INSERT
    or UPDATE
on STORICO_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
--      IF :new.data_variazione is null THEN  -- Disabilitata in data 17/12/2004
         :new.data_variazione := trunc(sysdate);
--      END IF;

      IF nvl(:old.cognome_nome,' ') != :new.cognome_nome THEN
         IF instr(:new.cognome_nome,'/') > 0 THEN
            :new.cognome := substr(:new.cognome_nome,1,instr(:new.cognome_nome,'/')-1);
            :new.nome    := substr(:new.cognome_nome,instr(:new.cognome_nome,'/')+1,36);
         ELSE
            :new.cognome := :new.cognome_nome;
            :new.nome    := '';
         END IF;
      ELSIF nvl(:old.cognome,' ') 	!= nvl(:new.cognome,' ') or
            nvl(:old.nome,' ')		!= nvl(:new.nome,' ') THEN
         :new.cognome_nome := :new.cognome;
         IF :new.nome is not null THEN
            :new.cognome_nome := :new.cognome||'/'||:new.nome;
         END IF;
      END IF;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         STORICO_SOGGETTI_PU(:OLD.NI,
                             :OLD.DAL,
                             :OLD.FONTE,
                         :NEW.NI,
                         :NEW.DAL,
                         :NEW.FONTE);
         null;
      end if;
      if INSERTING then
         STORICO_SOGGETTI_PI(:NEW.NI,
                             :NEW.FONTE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "STORICO_SOGGETTI"
            cursor cpk_storico_soggetti(var_NI number,
                                        var_DAL date) is
               select 1
                 from   STORICO_SOGGETTI
                where  NI = var_NI and
                       DAL = var_DAL;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "STORICO_SOGGETTI"
               if :new.NI is not null and
                  :new.DAL is not null then
                  open  cpk_storico_soggetti(:new.NI,
                                             :new.DAL);
                  fetch cpk_storico_soggetti into dummy;
                  found := cpk_storico_soggetti%FOUND;
                  close cpk_storico_soggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.NI||' '||
                               :new.DAL||
                               '" gia'' presente in Storico Soggetti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STORICO_SOGGETTI_TIU */
/

-- Tigger STORICO_SOGGETTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table STORICO_SOGGETTI

create or replace trigger STORICO_SOGGETTI_TD
before DELETE
on STORICO_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      STORICO_SOGGETTI_PD(:OLD.NI,
                          :OLD.DAL);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: STORICO_SOGGETTI_TD */
/

-- Procedure SUCCESSIONI_DEFUNTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SUCCESSIONI_DEFUNTI

create or replace procedure SUCCESSIONI_DEFUNTI_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_successioni_defunti(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "SUCCESSIONI_DEFUNTI"
         if NEW_PRATICA is not null then
            open  cpk1_successioni_defunti(NEW_PRATICA);
            fetch cpk1_successioni_defunti into dummy;
            found := cpk1_successioni_defunti%FOUND;
            close cpk1_successioni_defunti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione SUCCESSIONI_DEFUNTI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_DEFUNTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SUCCESSIONI_DEFUNTI
/* End Trigger: SUCCESSIONI_DEFUNTI_TC */

-- Procedure SUCCESSIONI_DEFUNTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SUCCESSIONI_DEFUNTI

create or replace procedure SUCCESSIONI_DEFUNTI_PU
(old_successione IN number,
 old_pratica IN number,
 new_successione IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_successioni_defunti(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_IMMOBILI"
   cursor cfk1_successioni_defunti(var_successione number) is
      select 1
      from   SUCCESSIONI_IMMOBILI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_DEVOLUZIONI"
   cursor cfk2_successioni_defunti(var_successione number) is
      select 1
      from   SUCCESSIONI_DEVOLUZIONI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_EREDI"
   cursor cfk3_successioni_defunti(var_successione number) is
      select 1
      from   SUCCESSIONI_EREDI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_TRIBUTO_DEFUNTI"
   cursor cfk4_successioni_defunti(var_successione number) is
      select 1
      from   SUCCESSIONI_TRIBUTO_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "SUCCESSIONI_DEFUNTI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_successioni_defunti(NEW_PRATICA);
            fetch cpk1_successioni_defunti into dummy;
            found := cpk1_successioni_defunti%FOUND;
            close cpk1_successioni_defunti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione SUCCESSIONI_DEFUNTI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SUCCESSIONI_DEFUNTI" non modificabile se esistono referenze su "SUCCESSIONI_IMMOBILI"
      if (OLD_SUCCESSIONE != NEW_SUCCESSIONE) then
         open  cfk1_successioni_defunti(OLD_SUCCESSIONE);
         fetch cfk1_successioni_defunti into dummy;
         found := cfk1_successioni_defunti%FOUND;
         close cfk1_successioni_defunti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUCCESSIONI_IMMOBILI. La registrazione di SUCCESSIONI_DEFUNTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SUCCESSIONI_DEFUNTI" non modificabile se esistono referenze su "SUCCESSIONI_DEVOLUZIONI"
      if (OLD_SUCCESSIONE != NEW_SUCCESSIONE) then
         open  cfk2_successioni_defunti(OLD_SUCCESSIONE);
         fetch cfk2_successioni_defunti into dummy;
         found := cfk2_successioni_defunti%FOUND;
         close cfk2_successioni_defunti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUCCESSIONI_DEVOLUZIONI. La registrazione di SUCCESSIONI_DEFUNTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SUCCESSIONI_DEFUNTI" non modificabile se esistono referenze su "SUCCESSIONI_EREDI"
      if (OLD_SUCCESSIONE != NEW_SUCCESSIONE) then
         open  cfk3_successioni_defunti(OLD_SUCCESSIONE);
         fetch cfk3_successioni_defunti into dummy;
         found := cfk3_successioni_defunti%FOUND;
         close cfk3_successioni_defunti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUCCESSIONI_EREDI. La registrazione di SUCCESSIONI_DEFUNTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "SUCCESSIONI_DEFUNTI" non modificabile se esistono referenze su "SUCCESSIONI_TRIBUTO_DEFUNTI"
      if (OLD_SUCCESSIONE != NEW_SUCCESSIONE) then
         open  cfk4_successioni_defunti(OLD_SUCCESSIONE);
         fetch cfk4_successioni_defunti into dummy;
         found := cfk4_successioni_defunti%FOUND;
         close cfk4_successioni_defunti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Successioni Tributo Defunti. La registrazione di SUCCESSIONI_DEFUNTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_DEFUNTI_PU */
/

-- Trigger SUCCESSIONI_DEFUNTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SUCCESSIONI_DEFUNTI

create or replace trigger SUCCESSIONI_DEFUNTO_TIU
before INSERT
    or UPDATE
on SUCCESSIONI_DEFUNTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
         :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SUCCESSIONI_DEFUNTI_PU(:OLD.SUCCESSIONE,
                                :OLD.PRATICA,
                         :NEW.SUCCESSIONE,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         SUCCESSIONI_DEFUNTI_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SUCCESSIONI_DEFUNTI"
            cursor cpk_successioni_defunti(var_SUCCESSIONE number) is
               select 1
                 from   SUCCESSIONI_DEFUNTI
                where  SUCCESSIONE = var_SUCCESSIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SUCCESSIONI_DEFUNTI"
               if :new.SUCCESSIONE is not null then
                  open  cpk_successioni_defunti(:new.SUCCESSIONE);
                  fetch cpk_successioni_defunti into dummy;
                  found := cpk_successioni_defunti%FOUND;
                  close cpk_successioni_defunti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.SUCCESSIONE||
                               '" gia'' presente in SUCCESSIONI_DEFUNTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUCCESSIONI_DEFUNTO_TIU */
/

-- Procedure SUCCESSIONI_DEFUNTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SUCCESSIONI_DEFUNTI

create or replace procedure SUCCESSIONI_DEFUNTI_PD
(old_successione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "SUCCESSIONI_IMMOBILI"
   cursor cfk1_successioni_defunti(var_successione number) is
      select 1
      from   SUCCESSIONI_IMMOBILI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUCCESSIONI_DEVOLUZIONI"
   cursor cfk2_successioni_defunti(var_successione number) is
      select 1
      from   SUCCESSIONI_DEVOLUZIONI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUCCESSIONI_EREDI"
   cursor cfk3_successioni_defunti(var_successione number) is
      select 1
      from   SUCCESSIONI_EREDI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "SUCCESSIONI_DEFUNTI" if children still exist in "SUCCESSIONI_IMMOBILI"
      open  cfk1_successioni_defunti(OLD_SUCCESSIONE);
      fetch cfk1_successioni_defunti into dummy;
      found := cfk1_successioni_defunti%FOUND;
      close cfk1_successioni_defunti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SUCCESSIONI_IMMOBILI. La registrazione di SUCCESSIONI_DEFUNTI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SUCCESSIONI_DEFUNTI" if children still exist in "SUCCESSIONI_DEVOLUZIONI"
      open  cfk2_successioni_defunti(OLD_SUCCESSIONE);
      fetch cfk2_successioni_defunti into dummy;
      found := cfk2_successioni_defunti%FOUND;
      close cfk2_successioni_defunti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SUCCESSIONI_DEVOLUZIONI. La registrazione di SUCCESSIONI_DEFUNTI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "SUCCESSIONI_DEFUNTI" if children still exist in "SUCCESSIONI_EREDI"
      open  cfk3_successioni_defunti(OLD_SUCCESSIONE);
      fetch cfk3_successioni_defunti into dummy;
      found := cfk3_successioni_defunti%FOUND;
      close cfk3_successioni_defunti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SUCCESSIONI_EREDI. La registrazione di SUCCESSIONI_DEFUNTI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_DEFUNTI_PD */
/

-- Tigger SUCCESSIONI_DEFUNTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SUCCESSIONI_DEFUNTI

create or replace trigger SUCCESSIONI_DEFUNTI_TD
before DELETE
on SUCCESSIONI_DEFUNTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: SUCCESSIONI_IMMOBILI

      -- Child Restrict Table: SUCCESSIONI_DEVOLUZIONI

      -- Child Restrict Table: SUCCESSIONI_EREDI

      SUCCESSIONI_DEFUNTI_PD(:OLD.SUCCESSIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "SUCCESSIONI_TRIBUTO_DEFUNTI"
      delete SUCCESSIONI_TRIBUTO_DEFUNTI
      where  SUCCESSIONE = :OLD.SUCCESSIONE;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUCCESSIONI_DEFUNTI_TD */
/

-- Procedure SUCCESSIONI_DEVOLUZIONI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SUCCESSIONI_DEVOLUZIONI

create or replace procedure SUCCESSIONI_DEVOLUZIONI_PI
(new_successione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SUCCESSIONI_DEFUNTI"
   cursor cpk1_successioni_devoluzioni(var_successione number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SUCCESSIONI_DEFUNTI" deve esistere quando si inserisce su "SUCCESSIONI_DEVOLUZIONI"
         if NEW_SUCCESSIONE is not null then
            open  cpk1_successioni_devoluzioni(NEW_SUCCESSIONE);
            fetch cpk1_successioni_devoluzioni into dummy;
            found := cpk1_successioni_devoluzioni%FOUND;
            close cpk1_successioni_devoluzioni;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_DEFUNTI. La registrazione SUCCESSIONI_DEVOLUZIONI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_DEVOLUZIONI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SUCCESSIONI_DEVOLUZIONI
/* End Trigger: SUCCESSIONI_DEVOLUZIONI_TC */

-- Procedure SUCCESSIONI_DEVOLUZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SUCCESSIONI_DEVOLUZIONI

create or replace procedure SUCCESSIONI_DEVOLUZIONI_PU
(old_successione IN number,
 old_progressivo IN number,
 new_successione IN number,
 new_progressivo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SUCCESSIONI_DEFUNTI"
   cursor cpk1_successioni_devoluzioni(var_successione number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SUCCESSIONI_DEFUNTI" deve esistere quando si modifica "SUCCESSIONI_DEVOLUZIONI"
         if  NEW_SUCCESSIONE is not null and ( seq = 0 )
         and (   (NEW_SUCCESSIONE != OLD_SUCCESSIONE or OLD_SUCCESSIONE is null) ) then
            open  cpk1_successioni_devoluzioni(NEW_SUCCESSIONE);
            fetch cpk1_successioni_devoluzioni into dummy;
            found := cpk1_successioni_devoluzioni%FOUND;
            close cpk1_successioni_devoluzioni;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_DEFUNTI. La registrazione SUCCESSIONI_DEVOLUZIONI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_DEVOLUZIONI_PU */
/

-- Trigger SUCCESSIONI_DEVOLUZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SUCCESSIONI_DEVOLUZIONI

create or replace trigger SUCCESSIONI_DEVOLUZIONI_TIU
before INSERT
    or UPDATE
on SUCCESSIONI_DEVOLUZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SUCCESSIONI_DEVOLUZIONI_PU(:OLD.SUCCESSIONE,
                                    :OLD.PROGRESSIVO,
                         :NEW.SUCCESSIONE,
                         :NEW.PROGRESSIVO);
         null;
      end if;
      if INSERTING then
         SUCCESSIONI_DEVOLUZIONI_PI(:NEW.SUCCESSIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SUCCESSIONI_DEVOLUZIONI"
            cursor cpk_successioni_devoluzioni(var_SUCCESSIONE number,
                                               var_PROGRESSIVO number) is
               select 1
                 from   SUCCESSIONI_DEVOLUZIONI
                where  SUCCESSIONE = var_SUCCESSIONE and
                       PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SUCCESSIONI_DEVOLUZIONI"
               if :new.SUCCESSIONE is not null and
                  :new.PROGRESSIVO is not null then
                  open  cpk_successioni_devoluzioni(:new.SUCCESSIONE,
                                                    :new.PROGRESSIVO);
                  fetch cpk_successioni_devoluzioni into dummy;
                  found := cpk_successioni_devoluzioni%FOUND;
                  close cpk_successioni_devoluzioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.SUCCESSIONE||' '||
                               :new.PROGRESSIVO||
                               '" gia'' presente in SUCCESSIONI_DEVOLUZIONI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUCCESSIONI_DEVOLUZIONI_TIU */
/

-- Procedure SUCCESSIONI_EREDI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SUCCESSIONI_EREDI

create or replace procedure SUCCESSIONI_EREDI_PI
(new_successione IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SUCCESSIONI_DEFUNTI"
   cursor cpk1_successioni_eredi(var_successione number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk2_successioni_eredi(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SUCCESSIONI_DEFUNTI" deve esistere quando si inserisce su "SUCCESSIONI_EREDI"
         if NEW_SUCCESSIONE is not null then
            open  cpk1_successioni_eredi(NEW_SUCCESSIONE);
            fetch cpk1_successioni_eredi into dummy;
            found := cpk1_successioni_eredi%FOUND;
            close cpk1_successioni_eredi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_DEFUNTI. La registrazione SUCCESSIONI_EREDI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "SUCCESSIONI_EREDI"
         if NEW_PRATICA is not null then
            open  cpk2_successioni_eredi(NEW_PRATICA);
            fetch cpk2_successioni_eredi into dummy;
            found := cpk2_successioni_eredi%FOUND;
            close cpk2_successioni_eredi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione SUCCESSIONI_EREDI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_EREDI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SUCCESSIONI_EREDI
/* End Trigger: SUCCESSIONI_EREDI_TC */

-- Procedure SUCCESSIONI_EREDI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SUCCESSIONI_EREDI

create or replace procedure SUCCESSIONI_EREDI_PU
(old_successione IN number,
 old_progressivo IN number,
 old_pratica IN number,
 new_successione IN number,
 new_progressivo IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SUCCESSIONI_DEFUNTI"
   cursor cpk1_successioni_eredi(var_successione number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk2_successioni_eredi(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_TRIBUTO_EREDI"
   cursor cfk1_successioni_eredi(var_successione number,
                                 var_progressivo number) is
      select 1
      from   SUCCESSIONI_TRIBUTO_EREDI
      where  SUCCESSIONE = var_successione
       and   PROGRESSIVO = var_progressivo
       and   var_successione is not null
       and   var_progressivo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SUCCESSIONI_DEFUNTI" deve esistere quando si modifica "SUCCESSIONI_EREDI"
         if  NEW_SUCCESSIONE is not null and ( seq = 0 )
         and (   (NEW_SUCCESSIONE != OLD_SUCCESSIONE or OLD_SUCCESSIONE is null) ) then
            open  cpk1_successioni_eredi(NEW_SUCCESSIONE);
            fetch cpk1_successioni_eredi into dummy;
            found := cpk1_successioni_eredi%FOUND;
            close cpk1_successioni_eredi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_DEFUNTI. La registrazione SUCCESSIONI_EREDI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "SUCCESSIONI_EREDI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk2_successioni_eredi(NEW_PRATICA);
            fetch cpk2_successioni_eredi into dummy;
            found := cpk2_successioni_eredi%FOUND;
            close cpk2_successioni_eredi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione SUCCESSIONI_EREDI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "SUCCESSIONI_EREDI" non modificabile se esistono referenze su "SUCCESSIONI_TRIBUTO_EREDI"
      if (OLD_SUCCESSIONE != NEW_SUCCESSIONE) or
         (OLD_PROGRESSIVO != NEW_PROGRESSIVO) then
         open  cfk1_successioni_eredi(OLD_SUCCESSIONE,
                                      OLD_PROGRESSIVO);
         fetch cfk1_successioni_eredi into dummy;
         found := cfk1_successioni_eredi%FOUND;
         close cfk1_successioni_eredi;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Successioni Tributo Eredi. La registrazione di SUCCESSIONI_EREDI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_EREDI_PU */
/

-- Trigger SUCCESSIONI_EREDI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SUCCESSIONI_EREDI

create or replace trigger SUCCESSIONI_EREDI_TIU
before INSERT
    or UPDATE
on SUCCESSIONI_EREDI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SUCCESSIONI_EREDI_PU(:OLD.SUCCESSIONE,
                              :OLD.PROGRESSIVO,
                              :OLD.PRATICA,
                         :NEW.SUCCESSIONE,
                         :NEW.PROGRESSIVO,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         SUCCESSIONI_EREDI_PI(:NEW.SUCCESSIONE,
                              :NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SUCCESSIONI_EREDI"
            cursor cpk_successioni_eredi(var_SUCCESSIONE number,
                                         var_PROGRESSIVO number) is
               select 1
                 from   SUCCESSIONI_EREDI
                where  SUCCESSIONE = var_SUCCESSIONE and
                       PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SUCCESSIONI_EREDI"
               if :new.SUCCESSIONE is not null and
                  :new.PROGRESSIVO is not null then
                  open  cpk_successioni_eredi(:new.SUCCESSIONE,
                                              :new.PROGRESSIVO);
                  fetch cpk_successioni_eredi into dummy;
                  found := cpk_successioni_eredi%FOUND;
                  close cpk_successioni_eredi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.SUCCESSIONE||' '||
                               :new.PROGRESSIVO||
                               '" gia'' presente in SUCCESSIONI_EREDI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUCCESSIONI_EREDI_TIU */
/

-- Procedure SUCCESSIONI_EREDI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table SUCCESSIONI_EREDI

create or replace procedure SUCCESSIONI_EREDI_PD
(old_successione IN number,
 old_progressivo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_EREDI_PD */
/

-- Tigger SUCCESSIONI_EREDI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table SUCCESSIONI_EREDI

create or replace trigger SUCCESSIONI_EREDI_TD
before DELETE
on SUCCESSIONI_EREDI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      SUCCESSIONI_EREDI_PD(:OLD.SUCCESSIONE,
                           :OLD.PROGRESSIVO);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "SUCCESSIONI_TRIBUTO_EREDI"
      delete SUCCESSIONI_TRIBUTO_EREDI
      where  SUCCESSIONE = :OLD.SUCCESSIONE
       and   PROGRESSIVO = :OLD.PROGRESSIVO;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUCCESSIONI_EREDI_TD */
/

-- Procedure SUCCESSIONI_IMMOBILI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SUCCESSIONI_IMMOBILI

create or replace procedure SUCCESSIONI_IMMOBILI_PI
(new_successione IN number,
 new_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SUCCESSIONI_DEFUNTI"
   cursor cpk1_successioni_immobili(var_successione number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk2_successioni_immobili(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SUCCESSIONI_DEFUNTI" deve esistere quando si inserisce su "SUCCESSIONI_IMMOBILI"
         if NEW_SUCCESSIONE is not null then
            open  cpk1_successioni_immobili(NEW_SUCCESSIONE);
            fetch cpk1_successioni_immobili into dummy;
            found := cpk1_successioni_immobili%FOUND;
            close cpk1_successioni_immobili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_DEFUNTI. La registrazione SUCCESSIONI_IMMOBILI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "SUCCESSIONI_IMMOBILI"
         if NEW_OGGETTO is not null then
            open  cpk2_successioni_immobili(NEW_OGGETTO);
            fetch cpk2_successioni_immobili into dummy;
            found := cpk2_successioni_immobili%FOUND;
            close cpk2_successioni_immobili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione SUCCESSIONI_IMMOBILI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_IMMOBILI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SUCCESSIONI_IMMOBILI
/* End Trigger: SUCCESSIONI_IMMOBILI_TC */

-- Procedure SUCCESSIONI_IMMOBILI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SUCCESSIONI_IMMOBILI

create or replace procedure SUCCESSIONI_IMMOBILI_PU
(old_successione IN number,
 old_progressivo IN number,
 old_oggetto IN number,
 new_successione IN number,
 new_progressivo IN number,
 new_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SUCCESSIONI_DEFUNTI"
   cursor cpk1_successioni_immobili(var_successione number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk2_successioni_immobili(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SUCCESSIONI_DEFUNTI" deve esistere quando si modifica "SUCCESSIONI_IMMOBILI"
         if  NEW_SUCCESSIONE is not null and ( seq = 0 )
         and (   (NEW_SUCCESSIONE != OLD_SUCCESSIONE or OLD_SUCCESSIONE is null) ) then
            open  cpk1_successioni_immobili(NEW_SUCCESSIONE);
            fetch cpk1_successioni_immobili into dummy;
            found := cpk1_successioni_immobili%FOUND;
            close cpk1_successioni_immobili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_DEFUNTI. La registrazione SUCCESSIONI_IMMOBILI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "SUCCESSIONI_IMMOBILI"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk2_successioni_immobili(NEW_OGGETTO);
            fetch cpk2_successioni_immobili into dummy;
            found := cpk2_successioni_immobili%FOUND;
            close cpk2_successioni_immobili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione SUCCESSIONI_IMMOBILI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_IMMOBILI_PU */
/

-- Trigger SUCCESSIONI_IMMOBILI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SUCCESSIONI_IMMOBILI

create or replace trigger SUCCESSIONI_IMMOBILI_TIU
before INSERT
    or UPDATE
on SUCCESSIONI_IMMOBILI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SUCCESSIONI_IMMOBILI_PU(:OLD.SUCCESSIONE,
                                 :OLD.PROGRESSIVO,
                                 :OLD.OGGETTO,
                         :NEW.SUCCESSIONE,
                         :NEW.PROGRESSIVO,
                         :NEW.OGGETTO);
         null;
      end if;
      if INSERTING then
         SUCCESSIONI_IMMOBILI_PI(:NEW.SUCCESSIONE,
                                 :NEW.OGGETTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SUCCESSIONI_IMMOBILI"
            cursor cpk_successioni_immobili(var_SUCCESSIONE number,
                                            var_PROGRESSIVO number) is
               select 1
                 from   SUCCESSIONI_IMMOBILI
                where  SUCCESSIONE = var_SUCCESSIONE and
                       PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SUCCESSIONI_IMMOBILI"
               if :new.SUCCESSIONE is not null and
                  :new.PROGRESSIVO is not null then
                  open  cpk_successioni_immobili(:new.SUCCESSIONE,
                                                 :new.PROGRESSIVO);
                  fetch cpk_successioni_immobili into dummy;
                  found := cpk_successioni_immobili%FOUND;
                  close cpk_successioni_immobili;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.SUCCESSIONE||' '||
                               :new.PROGRESSIVO||
                               '" gia'' presente in SUCCESSIONI_IMMOBILI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUCCESSIONI_IMMOBILI_TIU */
/

-- Procedure SUCCESSIONI_TRIBUTO_DEFUNTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SUCCESSIONI_TRIBUTO_DEFUNTI

create or replace procedure SUCCESSIONI_TRIBUTO_DEFUNTI_PI
(new_tipo_tributo IN varchar,
 new_successione IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_successioni_tributo_defun(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk2_successioni_tributo_defun(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SUCCESSIONI_DEFUNTI"
   cursor cpk3_successioni_tributo_defun(var_successione number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "SUCCESSIONI_TRIBUTO_DEFUNTI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_successioni_tributo_defun(NEW_TIPO_TRIBUTO);
            fetch cpk1_successioni_tributo_defun into dummy;
            found := cpk1_successioni_tributo_defun%FOUND;
            close cpk1_successioni_tributo_defun;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Successioni Tributo Defunti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "SUCCESSIONI_TRIBUTO_DEFUNTI"
         if NEW_PRATICA is not null then
            open  cpk2_successioni_tributo_defun(NEW_PRATICA);
            fetch cpk2_successioni_tributo_defun into dummy;
            found := cpk2_successioni_tributo_defun%FOUND;
            close cpk2_successioni_tributo_defun;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Successioni Tributo Defunti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SUCCESSIONI_DEFUNTI" deve esistere quando si inserisce su "SUCCESSIONI_TRIBUTO_DEFUNTI"
         if NEW_SUCCESSIONE is not null then
            open  cpk3_successioni_tributo_defun(NEW_SUCCESSIONE);
            fetch cpk3_successioni_tributo_defun into dummy;
            found := cpk3_successioni_tributo_defun%FOUND;
            close cpk3_successioni_tributo_defun;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_DEFUNTI. La registrazione Successioni Tributo Defunti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_TRIBUTO_DEFUNTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SUCCESSIONI_TRIBUTO_DEFUNTI
/* End Trigger: SUCCESSIONI_TRIBUTO_DEFUNTI_TC */

-- Procedure SUCCESSIONI_TRIBUTO_DEFUNTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SUCCESSIONI_TRIBUTO_DEFUNTI

create or replace procedure SUCCESSIONI_TRIBUTO_DEFUNTI_PU
(old_tipo_tributo IN varchar,
 old_successione IN number,
 old_pratica IN number,
 new_tipo_tributo IN varchar,
 new_successione IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_successioni_tributo_defun(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk2_successioni_tributo_defun(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SUCCESSIONI_DEFUNTI"
   cursor cpk3_successioni_tributo_defun(var_successione number) is
      select 1
      from   SUCCESSIONI_DEFUNTI
      where  SUCCESSIONE = var_successione
       and   var_successione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "SUCCESSIONI_TRIBUTO_DEFUNTI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_successioni_tributo_defun(NEW_TIPO_TRIBUTO);
            fetch cpk1_successioni_tributo_defun into dummy;
            found := cpk1_successioni_tributo_defun%FOUND;
            close cpk1_successioni_tributo_defun;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Successioni Tributo Defunti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "SUCCESSIONI_TRIBUTO_DEFUNTI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk2_successioni_tributo_defun(NEW_PRATICA);
            fetch cpk2_successioni_tributo_defun into dummy;
            found := cpk2_successioni_tributo_defun%FOUND;
            close cpk2_successioni_tributo_defun;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Successioni Tributo Defunti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SUCCESSIONI_DEFUNTI" deve esistere quando si modifica "SUCCESSIONI_TRIBUTO_DEFUNTI"
         if  NEW_SUCCESSIONE is not null and ( seq = 0 )
         and (   (NEW_SUCCESSIONE != OLD_SUCCESSIONE or OLD_SUCCESSIONE is null) ) then
            open  cpk3_successioni_tributo_defun(NEW_SUCCESSIONE);
            fetch cpk3_successioni_tributo_defun into dummy;
            found := cpk3_successioni_tributo_defun%FOUND;
            close cpk3_successioni_tributo_defun;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_DEFUNTI. La registrazione Successioni Tributo Defunti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_TRIBUTO_DEFUNTI_PU */
/

-- Trigger SUCCESSIONI_TRIBUTO_DEFUNT_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SUCCESSIONI_TRIBUTO_DEFUNTI

create or replace trigger SUCCESSIONI_TRIBUTO_DEFUNT_TIU
before INSERT
    or UPDATE
on SUCCESSIONI_TRIBUTO_DEFUNTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SUCCESSIONI_TRIBUTO_DEFUNTI_PU(:OLD.TIPO_TRIBUTO,
                                        :OLD.SUCCESSIONE,
                                        :OLD.PRATICA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.SUCCESSIONE,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         SUCCESSIONI_TRIBUTO_DEFUNTI_PI(:NEW.TIPO_TRIBUTO,
                                        :NEW.SUCCESSIONE,
                                        :NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SUCCESSIONI_TRIBUTO_DEFUNTI"
            cursor cpk_successioni_tributo_defun(var_TIPO_TRIBUTO varchar,
                                                 var_SUCCESSIONE number) is
               select 1
                 from   SUCCESSIONI_TRIBUTO_DEFUNTI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       SUCCESSIONE = var_SUCCESSIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SUCCESSIONI_TRIBUTO_DEFUNTI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.SUCCESSIONE is not null then
                  open  cpk_successioni_tributo_defun(:new.TIPO_TRIBUTO,
                                                      :new.SUCCESSIONE);
                  fetch cpk_successioni_tributo_defun into dummy;
                  found := cpk_successioni_tributo_defun%FOUND;
                  close cpk_successioni_tributo_defun;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.SUCCESSIONE||
                               '" gia'' presente in Successioni Tributo Defunti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUCCESSIONI_TRIBUTO_DEFUNT_TIU */
/

-- Procedure SUCCESSIONI_TRIBUTO_EREDI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SUCCESSIONI_TRIBUTO_EREDI

create or replace procedure SUCCESSIONI_TRIBUTO_EREDI_PI
(new_tipo_tributo IN varchar,
 new_successione IN number,
 new_progressivo IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SUCCESSIONI_EREDI"
   cursor cpk1_successioni_tributo_eredi(var_successione number,
                                         var_progressivo number) is
      select 1
      from   SUCCESSIONI_EREDI
      where  SUCCESSIONE = var_successione
       and   PROGRESSIVO = var_progressivo
       and   var_successione is not null
       and   var_progressivo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk2_successioni_tributo_eredi(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk3_successioni_tributo_eredi(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "SUCCESSIONI_EREDI" deve esistere quando si inserisce su "SUCCESSIONI_TRIBUTO_EREDI"
         if NEW_SUCCESSIONE is not null and
            NEW_PROGRESSIVO is not null then
            open  cpk1_successioni_tributo_eredi(NEW_SUCCESSIONE,
                                                 NEW_PROGRESSIVO);
            fetch cpk1_successioni_tributo_eredi into dummy;
            found := cpk1_successioni_tributo_eredi%FOUND;
            close cpk1_successioni_tributo_eredi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_EREDI. La registrazione Successioni Tributo Eredi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "SUCCESSIONI_TRIBUTO_EREDI"
         if NEW_PRATICA is not null then
            open  cpk2_successioni_tributo_eredi(NEW_PRATICA);
            fetch cpk2_successioni_tributo_eredi into dummy;
            found := cpk2_successioni_tributo_eredi%FOUND;
            close cpk2_successioni_tributo_eredi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Successioni Tributo Eredi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "SUCCESSIONI_TRIBUTO_EREDI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk3_successioni_tributo_eredi(NEW_TIPO_TRIBUTO);
            fetch cpk3_successioni_tributo_eredi into dummy;
            found := cpk3_successioni_tributo_eredi%FOUND;
            close cpk3_successioni_tributo_eredi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Successioni Tributo Eredi non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_TRIBUTO_EREDI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SUCCESSIONI_TRIBUTO_EREDI
/* End Trigger: SUCCESSIONI_TRIBUTO_EREDI_TC */

-- Procedure SUCCESSIONI_TRIBUTO_EREDI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SUCCESSIONI_TRIBUTO_EREDI

create or replace procedure SUCCESSIONI_TRIBUTO_EREDI_PU
(old_tipo_tributo IN varchar,
 old_successione IN number,
 old_progressivo IN number,
 old_pratica IN number,
 new_tipo_tributo IN varchar,
 new_successione IN number,
 new_progressivo IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SUCCESSIONI_EREDI"
   cursor cpk1_successioni_tributo_eredi(var_successione number,
                                         var_progressivo number) is
      select 1
      from   SUCCESSIONI_EREDI
      where  SUCCESSIONE = var_successione
       and   PROGRESSIVO = var_progressivo
       and   var_successione is not null
       and   var_progressivo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk2_successioni_tributo_eredi(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk3_successioni_tributo_eredi(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "SUCCESSIONI_EREDI" deve esistere quando si modifica "SUCCESSIONI_TRIBUTO_EREDI"
         if  NEW_SUCCESSIONE is not null and
             NEW_PROGRESSIVO is not null and ( seq = 0 )
         and (   (NEW_SUCCESSIONE != OLD_SUCCESSIONE or OLD_SUCCESSIONE is null)
              or (NEW_PROGRESSIVO != OLD_PROGRESSIVO or OLD_PROGRESSIVO is null) ) then
            open  cpk1_successioni_tributo_eredi(NEW_SUCCESSIONE,
                                                 NEW_PROGRESSIVO);
            fetch cpk1_successioni_tributo_eredi into dummy;
            found := cpk1_successioni_tributo_eredi%FOUND;
            close cpk1_successioni_tributo_eredi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su SUCCESSIONI_EREDI. La registrazione Successioni Tributo Eredi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "SUCCESSIONI_TRIBUTO_EREDI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk2_successioni_tributo_eredi(NEW_PRATICA);
            fetch cpk2_successioni_tributo_eredi into dummy;
            found := cpk2_successioni_tributo_eredi%FOUND;
            close cpk2_successioni_tributo_eredi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Successioni Tributo Eredi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "SUCCESSIONI_TRIBUTO_EREDI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk3_successioni_tributo_eredi(NEW_TIPO_TRIBUTO);
            fetch cpk3_successioni_tributo_eredi into dummy;
            found := cpk3_successioni_tributo_eredi%FOUND;
            close cpk3_successioni_tributo_eredi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Successioni Tributo Eredi non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUCCESSIONI_TRIBUTO_EREDI_PU */
/

-- Trigger SUCCESSIONI_TRIBUTO_EREDI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SUCCESSIONI_TRIBUTO_EREDI

create or replace trigger SUCCESSIONI_TRIBUTO_EREDI_TIU
before INSERT
    or UPDATE
on SUCCESSIONI_TRIBUTO_EREDI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SUCCESSIONI_TRIBUTO_EREDI_PU(:OLD.TIPO_TRIBUTO,
                                      :OLD.SUCCESSIONE,
                                      :OLD.PROGRESSIVO,
                                      :OLD.PRATICA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.SUCCESSIONE,
                         :NEW.PROGRESSIVO,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         SUCCESSIONI_TRIBUTO_EREDI_PI(:NEW.TIPO_TRIBUTO,
                                      :NEW.SUCCESSIONE,
                                      :NEW.PROGRESSIVO,
                                      :NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SUCCESSIONI_TRIBUTO_EREDI"
            cursor cpk_successioni_tributo_eredi(var_TIPO_TRIBUTO varchar,
                                                 var_SUCCESSIONE number,
                                                 var_PROGRESSIVO number) is
               select 1
                 from   SUCCESSIONI_TRIBUTO_EREDI
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       SUCCESSIONE = var_SUCCESSIONE and
                       PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SUCCESSIONI_TRIBUTO_EREDI"
               if :new.TIPO_TRIBUTO is not null and
                  :new.SUCCESSIONE is not null and
                  :new.PROGRESSIVO is not null then
                  open  cpk_successioni_tributo_eredi(:new.TIPO_TRIBUTO,
                                                      :new.SUCCESSIONE,
                                                      :new.PROGRESSIVO);
                  fetch cpk_successioni_tributo_eredi into dummy;
                  found := cpk_successioni_tributo_eredi%FOUND;
                  close cpk_successioni_tributo_eredi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.SUCCESSIONE||' '||
                               :new.PROGRESSIVO||
                               '" gia'' presente in Successioni Tributo Eredi. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUCCESSIONI_TRIBUTO_EREDI_TIU */
/

-- Procedure SUPPORTO_SERVIZI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SUPPORTO_SERVIZI

create or replace procedure SUPPORTO_SERVIZI_PI
(new_tipo_tributo IN varchar,
 new_stato IN varchar,
 new_tipo_atto IN number,
 new_liq2_stato IN varchar,
 new_liq2_tipo_atto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_supporto_servizi(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ATTO"
   cursor cpk2_supporto_servizi(var_tipo_atto number) is
      select 1
      from   TIPI_ATTO
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ATTO"
   cursor cpk3_supporto_servizi(var_liq2_tipo_atto number) is
      select 1
      from   TIPI_ATTO
      where  TIPO_ATTO = var_liq2_tipo_atto
       and   var_liq2_tipo_atto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_STATO"
   cursor cpk4_supporto_servizi(var_stato varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_stato
       and   var_stato is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_STATO"
   cursor cpk5_supporto_servizi(var_liq2_stato varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_liq2_stato
       and   var_liq2_stato is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "SUPPORTO_SERVIZI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_supporto_servizi(NEW_TIPO_TRIBUTO);
            fetch cpk1_supporto_servizi into dummy;
            found := cpk1_supporto_servizi%FOUND;
            close cpk1_supporto_servizi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione SUPPORTO_SERVIZI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTO" deve esistere quando si inserisce su "SUPPORTO_SERVIZI"
         if NEW_TIPO_ATTO is not null then
            open  cpk2_supporto_servizi(NEW_TIPO_ATTO);
            fetch cpk2_supporto_servizi into dummy;
            found := cpk2_supporto_servizi%FOUND;
            close cpk2_supporto_servizi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Atto. La registrazione SUPPORTO_SERVIZI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTO" deve esistere quando si inserisce su "SUPPORTO_SERVIZI"
         if NEW_LIQ2_TIPO_ATTO is not null then
            open  cpk3_supporto_servizi(NEW_LIQ2_TIPO_ATTO);
            fetch cpk3_supporto_servizi into dummy;
            found := cpk3_supporto_servizi%FOUND;
            close cpk3_supporto_servizi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Atto. La registrazione SUPPORTO_SERVIZI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si inserisce su "SUPPORTO_SERVIZI"
         if NEW_STATO is not null then
            open  cpk4_supporto_servizi(NEW_STATO);
            fetch cpk4_supporto_servizi into dummy;
            found := cpk4_supporto_servizi%FOUND;
            close cpk4_supporto_servizi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione SUPPORTO_SERVIZI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si inserisce su "SUPPORTO_SERVIZI"
         if NEW_LIQ2_STATO is not null then
            open  cpk5_supporto_servizi(NEW_LIQ2_STATO);
            fetch cpk5_supporto_servizi into dummy;
            found := cpk5_supporto_servizi%FOUND;
            close cpk5_supporto_servizi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione SUPPORTO_SERVIZI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUPPORTO_SERVIZI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SUPPORTO_SERVIZI
/* End Trigger: SUPPORTO_SERVIZI_TC */

-- Procedure SUPPORTO_SERVIZI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SUPPORTO_SERVIZI

create or replace procedure SUPPORTO_SERVIZI_PU
(old_id IN number,
 old_tipo_tributo IN varchar,
 old_stato IN varchar,
 old_tipo_atto IN number,
 old_liq2_stato IN varchar,
 old_liq2_tipo_atto IN number,
 new_id IN number,
 new_tipo_tributo IN varchar,
 new_stato IN varchar,
 new_tipo_atto IN number,
 new_liq2_stato IN varchar,
 new_liq2_tipo_atto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_supporto_servizi(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ATTO"
   cursor cpk2_supporto_servizi(var_tipo_atto number) is
      select 1
      from   TIPI_ATTO
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ATTO"
   cursor cpk3_supporto_servizi(var_liq2_tipo_atto number) is
      select 1
      from   TIPI_ATTO
      where  TIPO_ATTO = var_liq2_tipo_atto
       and   var_liq2_tipo_atto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_STATO"
   cursor cpk4_supporto_servizi(var_stato varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_stato
       and   var_stato is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_STATO"
   cursor cpk5_supporto_servizi(var_liq2_stato varchar) is
      select 1
      from   TIPI_STATO
      where  TIPO_STATO = var_liq2_stato
       and   var_liq2_stato is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "SUPPORTO_SERVIZI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_supporto_servizi(NEW_TIPO_TRIBUTO);
            fetch cpk1_supporto_servizi into dummy;
            found := cpk1_supporto_servizi%FOUND;
            close cpk1_supporto_servizi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione SUPPORTO_SERVIZI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTO" deve esistere quando si modifica "SUPPORTO_SERVIZI"
         if  NEW_TIPO_ATTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_ATTO != OLD_TIPO_ATTO or OLD_TIPO_ATTO is null) ) then
            open  cpk2_supporto_servizi(NEW_TIPO_ATTO);
            fetch cpk2_supporto_servizi into dummy;
            found := cpk2_supporto_servizi%FOUND;
            close cpk2_supporto_servizi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Atto. La registrazione SUPPORTO_SERVIZI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ATTO" deve esistere quando si modifica "SUPPORTO_SERVIZI"
         if  NEW_LIQ2_TIPO_ATTO is not null and ( seq = 0 )
         and (   (NEW_LIQ2_TIPO_ATTO != OLD_LIQ2_TIPO_ATTO or OLD_LIQ2_TIPO_ATTO is null) ) then
            open  cpk3_supporto_servizi(NEW_LIQ2_TIPO_ATTO);
            fetch cpk3_supporto_servizi into dummy;
            found := cpk3_supporto_servizi%FOUND;
            close cpk3_supporto_servizi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Atto. La registrazione SUPPORTO_SERVIZI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si modifica "SUPPORTO_SERVIZI"
         if  NEW_STATO is not null and ( seq = 0 )
         and (   (NEW_STATO != OLD_STATO or OLD_STATO is null) ) then
            open  cpk4_supporto_servizi(NEW_STATO);
            fetch cpk4_supporto_servizi into dummy;
            found := cpk4_supporto_servizi%FOUND;
            close cpk4_supporto_servizi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione SUPPORTO_SERVIZI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_STATO" deve esistere quando si modifica "SUPPORTO_SERVIZI"
         if  NEW_LIQ2_STATO is not null and ( seq = 0 )
         and (   (NEW_LIQ2_STATO != OLD_LIQ2_STATO or OLD_LIQ2_STATO is null) ) then
            open  cpk5_supporto_servizi(NEW_LIQ2_STATO);
            fetch cpk5_supporto_servizi into dummy;
            found := cpk5_supporto_servizi%FOUND;
            close cpk5_supporto_servizi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Stato. La registrazione SUPPORTO_SERVIZI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SUPPORTO_SERVIZI_PU */
/

-- Trigger SUPPORTO_SERVIZI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SUPPORTO_SERVIZI

create or replace trigger SUPPORTO_SERVIZI_TIU
before INSERT
    or UPDATE
on SUPPORTO_SERVIZI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
         :new.data_variazione := trunc(sysdate);
   end;

   begin
      IF nvl(:old.cognome_nome,' ') != :new.cognome_nome THEN
         IF instr(:new.cognome_nome,'/') > 0 THEN
            :new.cognome := substr(:new.cognome_nome,1,instr(:new.cognome_nome,'/')-1);
            :new.nome    := substr(:new.cognome_nome,instr(:new.cognome_nome,'/')+1,36);
         ELSE
            :new.cognome := :new.cognome_nome;
            :new.nome    := '';
         END IF;
      ELSIF nvl(:old.cognome,' ') 	!= nvl(:new.cognome,' ') or
            nvl(:old.nome,' ')		!= nvl(:new.nome,' ') THEN
            :new.cognome_nome := :new.cognome;
         IF :new.nome is not null THEN
            :new.cognome_nome := :new.cognome||'/'||:new.nome;
         END IF;
      END IF;
      :new.cognome_nome_ric := upper(:new.cognome_nome);
      :new.cognome_ric      := upper(:new.cognome);
      :new.nome_ric         := upper(:new.nome);

   end;

   if INSERTING and :new.id is null then
      SUPPORTO_SERVIZI_NR(:new.id);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SUPPORTO_SERVIZI_PU(:OLD.ID,
                             :OLD.TIPO_TRIBUTO,
                             :OLD.STATO,
                             :OLD.TIPO_ATTO,
                             :OLD.LIQ2_STATO,
                             :OLD.LIQ2_TIPO_ATTO,
                         :NEW.ID,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.STATO,
                         :NEW.TIPO_ATTO,
                         :NEW.LIQ2_STATO,
                         :NEW.LIQ2_TIPO_ATTO);
         null;
      end if;
      if INSERTING then
         SUPPORTO_SERVIZI_PI(:NEW.TIPO_TRIBUTO,
                             :NEW.STATO,
                             :NEW.TIPO_ATTO,
                             :NEW.LIQ2_STATO,
                             :NEW.LIQ2_TIPO_ATTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SUPPORTO_SERVIZI"
            cursor cpk_supporto_servizi(var_ID number) is
               select 1
                 from   SUPPORTO_SERVIZI
                where  ID = var_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SUPPORTO_SERVIZI"
               if :new.ID is not null then
                  open  cpk_supporto_servizi(:new.ID);
                  fetch cpk_supporto_servizi into dummy;
                  found := cpk_supporto_servizi%FOUND;
                  close cpk_supporto_servizi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID||
                               '" gia'' presente in SUPPORTO_SERVIZI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SUPPORTO_SERVIZI_TIU */
/

-- Procedure SVUOTAMENTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table SVUOTAMENTI

create or replace procedure SVUOTAMENTI_PI
(new_cod_fiscale IN varchar,
 new_oggetto IN number,
 new_cod_rfid IN varchar,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_RFID"
   cursor cpk1_svuotamenti(var_cod_fiscale varchar,
                           var_oggetto number,
                           var_cod_rfid varchar) is
      select 1
      from   CODICI_RFID
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO = var_oggetto
       and   COD_RFID = var_cod_rfid
       and   var_cod_fiscale is not null
       and   var_oggetto is not null
       and   var_cod_rfid is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk2_svuotamenti(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CODICI_RFID" deve esistere quando si inserisce su "SVUOTAMENTI"
         if NEW_COD_FISCALE is not null and
            NEW_OGGETTO is not null and
            NEW_COD_RFID is not null then
            open  cpk1_svuotamenti(NEW_COD_FISCALE,
                                   NEW_OGGETTO,
                                   NEW_COD_RFID);
            fetch cpk1_svuotamenti into dummy;
            found := cpk1_svuotamenti%FOUND;
            close cpk1_svuotamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici RFID. La registrazione Svuotamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "SVUOTAMENTI"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk2_svuotamenti(NEW_DOCUMENTO_ID);
            fetch cpk2_svuotamenti into dummy;
            found := cpk2_svuotamenti%FOUND;
            close cpk2_svuotamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione Svuotamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SVUOTAMENTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table SVUOTAMENTI
/* End Trigger: SVUOTAMENTI_TC */

-- Procedure SVUOTAMENTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table SVUOTAMENTI

create or replace procedure SVUOTAMENTI_PU
(old_cod_fiscale IN varchar,
 old_oggetto IN number,
 old_cod_rfid IN varchar,
 old_sequenza IN number,
 old_documento_id IN number,
 new_cod_fiscale IN varchar,
 new_oggetto IN number,
 new_cod_rfid IN varchar,
 new_sequenza IN number,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_RFID"
   cursor cpk1_svuotamenti(var_cod_fiscale varchar,
                           var_oggetto number,
                           var_cod_rfid varchar) is
      select 1
      from   CODICI_RFID
      where  COD_FISCALE = var_cod_fiscale
       and   OGGETTO = var_oggetto
       and   COD_RFID = var_cod_rfid
       and   var_cod_fiscale is not null
       and   var_oggetto is not null
       and   var_cod_rfid is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk2_svuotamenti(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CODICI_RFID" deve esistere quando si modifica "SVUOTAMENTI"
         if  NEW_COD_FISCALE is not null and
             NEW_OGGETTO is not null and
             NEW_COD_RFID is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null)
              or (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null)
              or (NEW_COD_RFID != OLD_COD_RFID or OLD_COD_RFID is null) ) then
            open  cpk1_svuotamenti(NEW_COD_FISCALE,
                                   NEW_OGGETTO,
                                   NEW_COD_RFID);
            fetch cpk1_svuotamenti into dummy;
            found := cpk1_svuotamenti%FOUND;
            close cpk1_svuotamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici RFID. La registrazione Svuotamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "SVUOTAMENTI"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk2_svuotamenti(NEW_DOCUMENTO_ID);
            fetch cpk2_svuotamenti into dummy;
            found := cpk2_svuotamenti%FOUND;
            close cpk2_svuotamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione Svuotamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: SVUOTAMENTI_PU */
/

-- Trigger SVUOTAMENTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table SVUOTAMENTI

create or replace trigger SVUOTAMENTI_TIU
before INSERT
    or UPDATE
on SVUOTAMENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
      SVUOTAMENTI_NR(:new.cod_fiscale,:new.oggetto,:new.cod_rfid,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         SVUOTAMENTI_PU(:OLD.COD_FISCALE,
                        :OLD.OGGETTO,
                        :OLD.COD_RFID,
                        :OLD.SEQUENZA,
                        :OLD.DOCUMENTO_ID,
                         :NEW.COD_FISCALE,
                         :NEW.OGGETTO,
                         :NEW.COD_RFID,
                         :NEW.SEQUENZA,
                         :NEW.DOCUMENTO_ID);
         null;
      end if;
      if INSERTING then
         SVUOTAMENTI_PI(:NEW.COD_FISCALE,
                        :NEW.OGGETTO,
                        :NEW.COD_RFID,
                        :NEW.DOCUMENTO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "SVUOTAMENTI"
            cursor cpk_svuotamenti(var_COD_FISCALE varchar,
                                   var_OGGETTO number,
                                   var_COD_RFID varchar,
                                   var_SEQUENZA number) is
               select 1
                 from   SVUOTAMENTI
                where  COD_FISCALE = var_COD_FISCALE and
                       OGGETTO = var_OGGETTO and
                       COD_RFID = var_COD_RFID and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "SVUOTAMENTI"
               if :new.COD_FISCALE is not null and
                  :new.OGGETTO is not null and
                  :new.COD_RFID is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_svuotamenti(:new.COD_FISCALE,
                                        :new.OGGETTO,
                                        :new.COD_RFID,
                                        :new.SEQUENZA);
                  fetch cpk_svuotamenti into dummy;
                  found := cpk_svuotamenti%FOUND;
                  close cpk_svuotamenti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.OGGETTO||' '||
                               :new.COD_RFID||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Svuotamenti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: SVUOTAMENTI_TIU */
/

-- Procedure TARIFFE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TARIFFE

create or replace procedure TARIFFE_PI
(new_tributo IN number,
 new_categoria IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE"
   cursor cpk1_tariffe(var_tributo number,
                       var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CATEGORIE" deve esistere quando si inserisce su "TARIFFE"
         if NEW_TRIBUTO is not null and
            NEW_CATEGORIA is not null then
            open  cpk1_tariffe(NEW_TRIBUTO,
                               NEW_CATEGORIA);
            fetch cpk1_tariffe into dummy;
            found := cpk1_tariffe%FOUND;
            close cpk1_tariffe;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Tariffe non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TARIFFE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TARIFFE
/* End Trigger: TARIFFE_TC */

-- Procedure TARIFFE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TARIFFE

create or replace procedure TARIFFE_PU
(old_tributo IN number,
 old_categoria IN number,
 old_anno IN number,
 old_tipo_tariffa IN number,
 new_tributo IN number,
 new_categoria IN number,
 new_anno IN number,
 new_tipo_tariffa IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE"
   cursor cpk1_tariffe(var_tributo number,
                       var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_tariffe(var_tributo number,
                       var_categoria number,
                       var_anno number,
                       var_tipo_tariffa number) is
      select 1
      from   OGGETTI_PRATICA
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   ANNO = var_anno
       and   TIPO_TARIFFA = var_tipo_tariffa
       and   var_tributo is not null
       and   var_categoria is not null
       and   var_anno is not null
       and   var_tipo_tariffa is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CATEGORIE" deve esistere quando si modifica "TARIFFE"
         if  NEW_TRIBUTO is not null and
             NEW_CATEGORIA is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null)
              or (NEW_CATEGORIA != OLD_CATEGORIA or OLD_CATEGORIA is null) ) then
            open  cpk1_tariffe(NEW_TRIBUTO,
                               NEW_CATEGORIA);
            fetch cpk1_tariffe into dummy;
            found := cpk1_tariffe%FOUND;
            close cpk1_tariffe;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Tariffe non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "TARIFFE" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_TRIBUTO != NEW_TRIBUTO) or
         (OLD_CATEGORIA != NEW_CATEGORIA) or
         (OLD_ANNO != NEW_ANNO) or
         (OLD_TIPO_TARIFFA != NEW_TIPO_TARIFFA) then
         open  cfk1_tariffe(OLD_TRIBUTO,
                            OLD_CATEGORIA,
                            OLD_ANNO,
                            OLD_TIPO_TARIFFA);
         fetch cfk1_tariffe into dummy;
         found := cfk1_tariffe%FOUND;
         close cfk1_tariffe;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Tariffe non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TARIFFE_PU */
/

-- Trigger TARIFFE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TARIFFE

create or replace trigger TARIFFE_TIU
before INSERT
    or UPDATE
on TARIFFE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.id_tariffa   := to_number(lpad(:new.ANNO, 4, '0') || lpad(:new.TRIBUTO, 4, '0') || lpad(:new.CATEGORIA, 4, '0') || lpad(:new.TIPO_TARIFFA, 2, '0'));
      :new.id_categoria := lpad(:new.TRIBUTO, 4, '0') || lpad(:new.CATEGORIA, 4, '0');
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TARIFFE_PU(:OLD.TRIBUTO,
                    :OLD.CATEGORIA,
                    :OLD.ANNO,
                    :OLD.TIPO_TARIFFA,
                         :NEW.TRIBUTO,
                         :NEW.CATEGORIA,
                         :NEW.ANNO,
                         :NEW.TIPO_TARIFFA);
         null;
      end if;
      if INSERTING then
         TARIFFE_PI(:NEW.TRIBUTO,
                    :NEW.CATEGORIA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TARIFFE"
            cursor cpk_tariffe(var_TRIBUTO number,
                               var_CATEGORIA number,
                               var_ANNO number,
                               var_TIPO_TARIFFA number) is
               select 1
                 from   TARIFFE
                where  TRIBUTO = var_TRIBUTO and
                       CATEGORIA = var_CATEGORIA and
                       ANNO = var_ANNO and
                       TIPO_TARIFFA = var_TIPO_TARIFFA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TARIFFE"
               if :new.TRIBUTO is not null and
                  :new.CATEGORIA is not null and
                  :new.ANNO is not null and
                  :new.TIPO_TARIFFA is not null then
                  open  cpk_tariffe(:new.TRIBUTO,
                                    :new.CATEGORIA,
                                    :new.ANNO,
                                    :new.TIPO_TARIFFA);
                  fetch cpk_tariffe into dummy;
                  found := cpk_tariffe%FOUND;
                  close cpk_tariffe;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TRIBUTO||' '||
                               :new.CATEGORIA||' '||
                               :new.ANNO||' '||
                               :new.TIPO_TARIFFA||
                               '" gia'' presente in Tariffe. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TARIFFE_TIU */
/

-- Procedure TARIFFE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TARIFFE

create or replace procedure TARIFFE_PD
(old_tributo IN number,
 old_categoria IN number,
 old_anno IN number,
 old_tipo_tariffa IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_tariffe(var_tributo number,
                       var_categoria number,
                       var_anno number,
                       var_tipo_tariffa number) is
      select 1
      from   OGGETTI_PRATICA
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   ANNO = var_anno
       and   TIPO_TARIFFA = var_tipo_tariffa
       and   var_tributo is not null
       and   var_categoria is not null
       and   var_anno is not null
       and   var_tipo_tariffa is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TARIFFE" if children still exist in "OGGETTI_PRATICA"
      open  cfk1_tariffe(OLD_TRIBUTO,
                         OLD_CATEGORIA,
                         OLD_ANNO,
                         OLD_TIPO_TARIFFA);
      fetch cfk1_tariffe into dummy;
      found := cfk1_tariffe%FOUND;
      close cfk1_tariffe;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Tariffe non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TARIFFE_PD */
/

-- Tigger TARIFFE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TARIFFE

create or replace trigger TARIFFE_TD
before DELETE
on TARIFFE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI_PRATICA

      TARIFFE_PD(:OLD.TRIBUTO,
                 :OLD.CATEGORIA,
                 :OLD.ANNO,
                 :OLD.TIPO_TARIFFA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TARIFFE_TD */
/

-- Procedure TARIFFE_CONVERSIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TARIFFE_CONVERSIONE

create or replace procedure TARIFFE_CONVERSIONE_PI
(new_tributo IN number,
 new_categoria IN number,
 new_converti_tributo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE"
   cursor cpk1_tariffe_conversione(var_tributo number,
                                   var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CODICI_TRIBUTO"
   cursor cpk2_tariffe_conversione(var_converti_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_converti_tributo
       and   var_converti_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CATEGORIE" deve esistere quando si inserisce su "TARIFFE_CONVERSIONE"
         if NEW_TRIBUTO is not null and
            NEW_CATEGORIA is not null then
            open  cpk1_tariffe_conversione(NEW_TRIBUTO,
                                           NEW_CATEGORIA);
            fetch cpk1_tariffe_conversione into dummy;
            found := cpk1_tariffe_conversione%FOUND;
            close cpk1_tariffe_conversione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione TARIFFE_CONVERSIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si inserisce su "TARIFFE_CONVERSIONE"
         if NEW_CONVERTI_TRIBUTO is not null then
            open  cpk2_tariffe_conversione(NEW_CONVERTI_TRIBUTO);
            fetch cpk2_tariffe_conversione into dummy;
            found := cpk2_tariffe_conversione%FOUND;
            close cpk2_tariffe_conversione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione TARIFFE_CONVERSIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TARIFFE_CONVERSIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TARIFFE_CONVERSIONE
/* End Trigger: TARIFFE_CONVERSIONE_TC */

-- Procedure TARIFFE_CONVERSIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TARIFFE_CONVERSIONE

create or replace procedure TARIFFE_CONVERSIONE_PU
(old_tributo IN number,
 old_categoria IN number,
 old_tipo_tariffa IN number,
 old_sequenza IN number,
 old_converti_tributo IN number,
 new_tributo IN number,
 new_categoria IN number,
 new_tipo_tariffa IN number,
 new_sequenza IN number,
 new_converti_tributo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE"
   cursor cpk1_tariffe_conversione(var_tributo number,
                                   var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CODICI_TRIBUTO"
   cursor cpk2_tariffe_conversione(var_converti_tributo number) is
      select 1
      from   CODICI_TRIBUTO
      where  TRIBUTO = var_converti_tributo
       and   var_converti_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CATEGORIE" deve esistere quando si modifica "TARIFFE_CONVERSIONE"
         if  NEW_TRIBUTO is not null and
             NEW_CATEGORIA is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null)
              or (NEW_CATEGORIA != OLD_CATEGORIA or OLD_CATEGORIA is null) ) then
            open  cpk1_tariffe_conversione(NEW_TRIBUTO,
                                           NEW_CATEGORIA);
            fetch cpk1_tariffe_conversione into dummy;
            found := cpk1_tariffe_conversione%FOUND;
            close cpk1_tariffe_conversione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione TARIFFE_CONVERSIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "CODICI_TRIBUTO" deve esistere quando si modifica "TARIFFE_CONVERSIONE"
         if  NEW_CONVERTI_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_CONVERTI_TRIBUTO != OLD_CONVERTI_TRIBUTO or OLD_CONVERTI_TRIBUTO is null) ) then
            open  cpk2_tariffe_conversione(NEW_CONVERTI_TRIBUTO);
            fetch cpk2_tariffe_conversione into dummy;
            found := cpk2_tariffe_conversione%FOUND;
            close cpk2_tariffe_conversione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Codici Tributo. La registrazione TARIFFE_CONVERSIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TARIFFE_CONVERSIONE_PU */
/

-- Trigger TARIFFE_CONVERSIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TARIFFE_CONVERSIONE

create or replace trigger TARIFFE_CONVERSIONE_TIU
before INSERT
    or UPDATE
on TARIFFE_CONVERSIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TARIFFE_CONVERSIONE_PU(:OLD.TRIBUTO,
                                :OLD.CATEGORIA,
                                :OLD.TIPO_TARIFFA,
                                :OLD.SEQUENZA,
                                :OLD.CONVERTI_TRIBUTO,
                         :NEW.TRIBUTO,
                         :NEW.CATEGORIA,
                         :NEW.TIPO_TARIFFA,
                         :NEW.SEQUENZA,
                         :NEW.CONVERTI_TRIBUTO);
         null;
      end if;
      if INSERTING then
         TARIFFE_CONVERSIONE_PI(:NEW.TRIBUTO,
                                :NEW.CATEGORIA,
                                :NEW.CONVERTI_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TARIFFE_CONVERSIONE"
            cursor cpk_tariffe_conversione(var_TRIBUTO number,
                                           var_CATEGORIA number,
                                           var_TIPO_TARIFFA number,
                                           var_SEQUENZA number) is
               select 1
                 from   TARIFFE_CONVERSIONE
                where  TRIBUTO = var_TRIBUTO and
                       CATEGORIA = var_CATEGORIA and
                       TIPO_TARIFFA = var_TIPO_TARIFFA and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TARIFFE_CONVERSIONE"
               if :new.TRIBUTO is not null and
                  :new.CATEGORIA is not null and
                  :new.TIPO_TARIFFA is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_tariffe_conversione(:new.TRIBUTO,
                                                :new.CATEGORIA,
                                                :new.TIPO_TARIFFA,
                                                :new.SEQUENZA);
                  fetch cpk_tariffe_conversione into dummy;
                  found := cpk_tariffe_conversione%FOUND;
                  close cpk_tariffe_conversione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TRIBUTO||' '||
                               :new.CATEGORIA||' '||
                               :new.TIPO_TARIFFA||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in TARIFFE_CONVERSIONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TARIFFE_CONVERSIONE_TIU */
/

-- Procedure TARIFFE_NON_DOMESTICHE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TARIFFE_NON_DOMESTICHE

create or replace procedure TARIFFE_NON_DOMESTICHE_PI
(new_tributo IN number,
 new_categoria IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CATEGORIE"
   cursor cpk1_tariffe_non_domestiche(var_tributo number,
                                      var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CATEGORIE" deve esistere quando si inserisce su "TARIFFE_NON_DOMESTICHE"
         if NEW_TRIBUTO is not null and
            NEW_CATEGORIA is not null then
            open  cpk1_tariffe_non_domestiche(NEW_TRIBUTO,
                                              NEW_CATEGORIA);
            fetch cpk1_tariffe_non_domestiche into dummy;
            found := cpk1_tariffe_non_domestiche%FOUND;
            close cpk1_tariffe_non_domestiche;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Tariffe non Domestiche non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TARIFFE_NON_DOMESTICHE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TARIFFE_NON_DOMESTICHE
/* End Trigger: TARIFFE_NON_DOMESTICHE_TC */

-- Procedure TARIFFE_NON_DOMESTICHE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TARIFFE_NON_DOMESTICHE

create or replace procedure TARIFFE_NON_DOMESTICHE_PU
(old_tributo IN number,
 old_categoria IN number,
 old_anno IN number,
 new_tributo IN number,
 new_categoria IN number,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CATEGORIE"
   cursor cpk1_tariffe_non_domestiche(var_tributo number,
                                      var_categoria number) is
      select 1
      from   CATEGORIE
      where  TRIBUTO = var_tributo
       and   CATEGORIA = var_categoria
       and   var_tributo is not null
       and   var_categoria is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CATEGORIE" deve esistere quando si modifica "TARIFFE_NON_DOMESTICHE"
         if  NEW_TRIBUTO is not null and
             NEW_CATEGORIA is not null and ( seq = 0 )
         and (   (NEW_TRIBUTO != OLD_TRIBUTO or OLD_TRIBUTO is null)
              or (NEW_CATEGORIA != OLD_CATEGORIA or OLD_CATEGORIA is null) ) then
            open  cpk1_tariffe_non_domestiche(NEW_TRIBUTO,
                                              NEW_CATEGORIA);
            fetch cpk1_tariffe_non_domestiche into dummy;
            found := cpk1_tariffe_non_domestiche%FOUND;
            close cpk1_tariffe_non_domestiche;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Categorie. La registrazione Tariffe non Domestiche non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TARIFFE_NON_DOMESTICHE_PU */
/

-- Trigger TARIFFE_NON_DOMESTICHE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TARIFFE_NON_DOMESTICHE

create or replace trigger TARIFFE_NON_DOMESTICHE_TIU
before INSERT
    or UPDATE
on TARIFFE_NON_DOMESTICHE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TARIFFE_NON_DOMESTICHE_PU(:OLD.TRIBUTO,
                                   :OLD.CATEGORIA,
                                   :OLD.ANNO,
                         :NEW.TRIBUTO,
                         :NEW.CATEGORIA,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         TARIFFE_NON_DOMESTICHE_PI(:NEW.TRIBUTO,
                                   :NEW.CATEGORIA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TARIFFE_NON_DOMESTICHE"
            cursor cpk_tariffe_non_domestiche(var_TRIBUTO number,
                                              var_CATEGORIA number,
                                              var_ANNO number) is
               select 1
                 from   TARIFFE_NON_DOMESTICHE
                where  TRIBUTO = var_TRIBUTO and
                       CATEGORIA = var_CATEGORIA and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TARIFFE_NON_DOMESTICHE"
               if :new.TRIBUTO is not null and
                  :new.CATEGORIA is not null and
                  :new.ANNO is not null then
                  open  cpk_tariffe_non_domestiche(:new.TRIBUTO,
                                                   :new.CATEGORIA,
                                                   :new.ANNO);
                  fetch cpk_tariffe_non_domestiche into dummy;
                  found := cpk_tariffe_non_domestiche%FOUND;
                  close cpk_tariffe_non_domestiche;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TRIBUTO||' '||
                               :new.CATEGORIA||' '||
                               :new.ANNO||
                               '" gia'' presente in Tariffe non Domestiche. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TARIFFE_NON_DOMESTICHE_TIU */
/

-- Procedure TERRENI_RIDOTTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TERRENI_RIDOTTI

create or replace procedure TERRENI_RIDOTTI_PI
(new_cod_fiscale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_terreni_ridotti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "TERRENI_RIDOTTI"
         if NEW_COD_FISCALE is not null then
            open  cpk1_terreni_ridotti(NEW_COD_FISCALE);
            fetch cpk1_terreni_ridotti into dummy;
            found := cpk1_terreni_ridotti%FOUND;
            close cpk1_terreni_ridotti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Terreni Ridotti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TERRENI_RIDOTTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TERRENI_RIDOTTI
/* End Trigger: TERRENI_RIDOTTI_TC */

-- Procedure TERRENI_RIDOTTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TERRENI_RIDOTTI

create or replace procedure TERRENI_RIDOTTI_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 new_cod_fiscale IN varchar,
 new_anno IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_terreni_ridotti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "TERRENI_RIDOTTI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_terreni_ridotti(NEW_COD_FISCALE);
            fetch cpk1_terreni_ridotti into dummy;
            found := cpk1_terreni_ridotti%FOUND;
            close cpk1_terreni_ridotti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Terreni Ridotti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TERRENI_RIDOTTI_PU */
/

-- Trigger TERRENI_RIDOTTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TERRENI_RIDOTTI

create or replace trigger TERRENI_RIDOTTI_TIU
before INSERT
    or UPDATE
on TERRENI_RIDOTTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TERRENI_RIDOTTI_PU(:OLD.COD_FISCALE,
                            :OLD.ANNO,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO);
         null;
      end if;
      if INSERTING then
         TERRENI_RIDOTTI_PI(:NEW.COD_FISCALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TERRENI_RIDOTTI"
            cursor cpk_terreni_ridotti(var_COD_FISCALE varchar,
                                       var_ANNO number) is
               select 1
                 from   TERRENI_RIDOTTI
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TERRENI_RIDOTTI"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null then
                  open  cpk_terreni_ridotti(:new.COD_FISCALE,
                                            :new.ANNO);
                  fetch cpk_terreni_ridotti into dummy;
                  found := cpk_terreni_ridotti%FOUND;
                  close cpk_terreni_ridotti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||
                               '" gia'' presente in Terreni Ridotti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TERRENI_RIDOTTI_TIU */
/

-- Procedure TIPI_ALIQUOTA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TIPI_ALIQUOTA

create or replace procedure TIPI_ALIQUOTA_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_tipi_aliquota(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "TIPI_ALIQUOTA"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_tipi_aliquota(NEW_TIPO_TRIBUTO);
            fetch cpk1_tipi_aliquota into dummy;
            found := cpk1_tipi_aliquota%FOUND;
            close cpk1_tipi_aliquota;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Tipi Aliquota non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ALIQUOTA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TIPI_ALIQUOTA
/* End Trigger: TIPI_ALIQUOTA_TC */

-- Procedure TIPI_ALIQUOTA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_ALIQUOTA

create or replace procedure TIPI_ALIQUOTA_PU
(old_tipo_tributo IN varchar,
 old_tipo_aliquota IN number,
 new_tipo_tributo IN varchar,
 new_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_tipi_aliquota(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "ALIQUOTE"
   cursor cfk1_tipi_aliquota(var_tipo_tributo varchar,
                             var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_IMPOSTA"
   cursor cfk2_tipi_aliquota(var_tipo_tributo varchar,
                             var_tipo_aliquota number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Declaration of UpdateParentRestrict constraint for "ALIQUOTE_OGCO"
   cursor cfk3_tipi_aliquota(var_tipo_tributo varchar,
                             var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE_OGCO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "TIPI_ALIQUOTA"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_tipi_aliquota(NEW_TIPO_TRIBUTO);
            fetch cpk1_tipi_aliquota into dummy;
            found := cpk1_tipi_aliquota%FOUND;
            close cpk1_tipi_aliquota;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Tipi Aliquota non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "TIPI_ALIQUOTA" non modificabile se esistono referenze su "ALIQUOTE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_TIPO_ALIQUOTA != NEW_TIPO_ALIQUOTA) then
         open  cfk1_tipi_aliquota(OLD_TIPO_TRIBUTO,
                                  OLD_TIPO_ALIQUOTA);
         fetch cfk1_tipi_aliquota into dummy;
         found := cfk1_tipi_aliquota%FOUND;
         close cfk1_tipi_aliquota;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Aliquote. La registrazione di Tipi Aliquota non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ALIQUOTA" non modificabile se esistono referenze su "OGGETTI_IMPOSTA"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_TIPO_ALIQUOTA != NEW_TIPO_ALIQUOTA) then
         open  cfk2_tipi_aliquota(OLD_TIPO_TRIBUTO,
                                  OLD_TIPO_ALIQUOTA);
         fetch cfk2_tipi_aliquota into dummy;
         found := cfk2_tipi_aliquota%FOUND;
         close cfk2_tipi_aliquota;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Imposta. La registrazione di Tipi Aliquota non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ALIQUOTA" non modificabile se esistono referenze su "ALIQUOTE_OGCO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) or
         (OLD_TIPO_ALIQUOTA != NEW_TIPO_ALIQUOTA) then
         open  cfk3_tipi_aliquota(OLD_TIPO_TRIBUTO,
                                  OLD_TIPO_ALIQUOTA);
         fetch cfk3_tipi_aliquota into dummy;
         found := cfk3_tipi_aliquota%FOUND;
         close cfk3_tipi_aliquota;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Aliquote Oggetto Contribuente. La registrazione di Tipi Aliquota non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ALIQUOTA_PU */
/

-- Trigger TIPI_ALIQUOTA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_ALIQUOTA

create or replace trigger TIPI_ALIQUOTA_TIU
before INSERT
    or UPDATE
on TIPI_ALIQUOTA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_ALIQUOTA_PU(:OLD.TIPO_TRIBUTO,
                          :OLD.TIPO_ALIQUOTA,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_ALIQUOTA);
         null;
      end if;
      if INSERTING then
         TIPI_ALIQUOTA_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_ALIQUOTA"
            cursor cpk_tipi_aliquota(var_TIPO_TRIBUTO varchar,
                                     var_TIPO_ALIQUOTA number) is
               select 1
                 from   TIPI_ALIQUOTA
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       TIPO_ALIQUOTA = var_TIPO_ALIQUOTA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_ALIQUOTA"
               if :new.TIPO_TRIBUTO is not null and
                  :new.TIPO_ALIQUOTA is not null then
                  open  cpk_tipi_aliquota(:new.TIPO_TRIBUTO,
                                          :new.TIPO_ALIQUOTA);
                  fetch cpk_tipi_aliquota into dummy;
                  found := cpk_tipi_aliquota%FOUND;
                  close cpk_tipi_aliquota;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.TIPO_ALIQUOTA||
                               '" gia'' presente in Tipi Aliquota. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ALIQUOTA_TIU */
/

-- Procedure TIPI_ALIQUOTA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ALIQUOTA

create or replace procedure TIPI_ALIQUOTA_PD
(old_tipo_tributo IN varchar,
 old_tipo_aliquota IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ALIQUOTE"
   cursor cfk1_tipi_aliquota(var_tipo_tributo varchar,
                             var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_IMPOSTA"
   cursor cfk2_tipi_aliquota(var_tipo_tributo varchar,
                             var_tipo_aliquota number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;

   --  Declaration of DeleteParentRestrict constraint for "ALIQUOTE_OGCO"
   cursor cfk3_tipi_aliquota(var_tipo_tributo varchar,
                             var_tipo_aliquota number) is
      select 1
      from   ALIQUOTE_OGCO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   TIPO_ALIQUOTA = var_tipo_aliquota
       and   var_tipo_tributo is not null
       and   var_tipo_aliquota is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_ALIQUOTA" if children still exist in "ALIQUOTE"
      open  cfk1_tipi_aliquota(OLD_TIPO_TRIBUTO,
                               OLD_TIPO_ALIQUOTA);
      fetch cfk1_tipi_aliquota into dummy;
      found := cfk1_tipi_aliquota%FOUND;
      close cfk1_tipi_aliquota;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Aliquote. La registrazione di Tipi Aliquota non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ALIQUOTA" if children still exist in "OGGETTI_IMPOSTA"
      open  cfk2_tipi_aliquota(OLD_TIPO_TRIBUTO,
                               OLD_TIPO_ALIQUOTA);
      fetch cfk2_tipi_aliquota into dummy;
      found := cfk2_tipi_aliquota%FOUND;
      close cfk2_tipi_aliquota;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Imposta. La registrazione di Tipi Aliquota non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ALIQUOTA" if children still exist in "ALIQUOTE_OGCO"
      open  cfk3_tipi_aliquota(OLD_TIPO_TRIBUTO,
                               OLD_TIPO_ALIQUOTA);
      fetch cfk3_tipi_aliquota into dummy;
      found := cfk3_tipi_aliquota%FOUND;
      close cfk3_tipi_aliquota;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Aliquote Oggetto Contribuente. La registrazione di Tipi Aliquota non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ALIQUOTA_PD */
/

-- Tigger TIPI_ALIQUOTA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ALIQUOTA

create or replace trigger TIPI_ALIQUOTA_TD
before DELETE
on TIPI_ALIQUOTA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ALIQUOTE

      -- Child Restrict Table: OGGETTI_IMPOSTA

      -- Child Restrict Table: ALIQUOTE_OGCO

      TIPI_ALIQUOTA_PD(:OLD.TIPO_TRIBUTO,
                       :OLD.TIPO_ALIQUOTA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ALIQUOTA_TD */
/

-- Procedure TIPI_ANOMALIA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_ANOMALIA

create or replace procedure TIPI_ANOMALIA_PU
(old_tipo_anomalia IN number,
 new_tipo_anomalia IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE_ICI"
   cursor cfk1_tipi_anomalia(var_tipo_anomalia number) is
      select 1
      from   ANOMALIE_ICI
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE_ANNO"
   cursor cfk2_tipi_anomalia(var_tipo_anomalia number) is
      select 1
      from   ANOMALIE_ANNO
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANCI_VER"
   cursor cfk3_tipi_anomalia(var_tipo_anomalia number) is
      select 1
      from   ANCI_VER
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE_PARAMETRI"
   cursor cfk4_tipi_anomalia(var_tipo_anomalia number) is
      select 1
      from   ANOMALIE_PARAMETRI
      where  ID_TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_ANOMALIA" non modificabile se esistono referenze su "ANOMALIE_ICI"
      if (OLD_TIPO_ANOMALIA != NEW_TIPO_ANOMALIA) then
         open  cfk1_tipi_anomalia(OLD_TIPO_ANOMALIA);
         fetch cfk1_tipi_anomalia into dummy;
         found := cfk1_tipi_anomalia%FOUND;
         close cfk1_tipi_anomalia;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Anomalie ICI. La registrazione di Tipi Anomalia non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ANOMALIA" non modificabile se esistono referenze su "ANOMALIE_ANNO"
      if (OLD_TIPO_ANOMALIA != NEW_TIPO_ANOMALIA) then
         open  cfk2_tipi_anomalia(OLD_TIPO_ANOMALIA);
         fetch cfk2_tipi_anomalia into dummy;
         found := cfk2_tipi_anomalia%FOUND;
         close cfk2_tipi_anomalia;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Anomalie_anno. La registrazione di Tipi Anomalia non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ANOMALIA" non modificabile se esistono referenze su "ANCI_VER"
      if (OLD_TIPO_ANOMALIA != NEW_TIPO_ANOMALIA) then
         open  cfk3_tipi_anomalia(OLD_TIPO_ANOMALIA);
         fetch cfk3_tipi_anomalia into dummy;
         found := cfk3_tipi_anomalia%FOUND;
         close cfk3_tipi_anomalia;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Anci Ver. La registrazione di Tipi Anomalia non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ANOMALIA" non modificabile se esistono referenze su "ANOMALIE_PARAMETRI"
      if (OLD_TIPO_ANOMALIA != NEW_TIPO_ANOMALIA) then
         open  cfk4_tipi_anomalia(OLD_TIPO_ANOMALIA);
         fetch cfk4_tipi_anomalia into dummy;
         found := cfk4_tipi_anomalia%FOUND;
         close cfk4_tipi_anomalia;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ANOMALIE_PARAMETRI. La registrazione di Tipi Anomalia non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ANOMALIA_PU */
/

-- Trigger TIPI_ANOMALIA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_ANOMALIA

create or replace trigger TIPI_ANOMALIA_TIU
before INSERT
    or UPDATE
on TIPI_ANOMALIA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_ANOMALIA_PU(:OLD.TIPO_ANOMALIA,
                         :NEW.TIPO_ANOMALIA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_ANOMALIA"
            cursor cpk_tipi_anomalia(var_TIPO_ANOMALIA number) is
               select 1
                 from   TIPI_ANOMALIA
                where  TIPO_ANOMALIA = var_TIPO_ANOMALIA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_ANOMALIA"
               if :new.TIPO_ANOMALIA is not null then
                  open  cpk_tipi_anomalia(:new.TIPO_ANOMALIA);
                  fetch cpk_tipi_anomalia into dummy;
                  found := cpk_tipi_anomalia%FOUND;
                  close cpk_tipi_anomalia;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_ANOMALIA||
                               '" gia'' presente in Tipi Anomalia. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ANOMALIA_TIU */
/

-- Procedure TIPI_ANOMALIA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ANOMALIA

create or replace procedure TIPI_ANOMALIA_PD
(old_tipo_anomalia IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ANOMALIE_ICI"
   cursor cfk1_tipi_anomalia(var_tipo_anomalia number) is
      select 1
      from   ANOMALIE_ICI
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;

   --  Declaration of DeleteParentRestrict constraint for "ANOMALIE_ANNO"
   cursor cfk2_tipi_anomalia(var_tipo_anomalia number) is
      select 1
      from   ANOMALIE_ANNO
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;

   --  Declaration of DeleteParentRestrict constraint for "ANCI_VER"
   cursor cfk3_tipi_anomalia(var_tipo_anomalia number) is
      select 1
      from   ANCI_VER
      where  TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;

   --  Declaration of DeleteParentRestrict constraint for "ANOMALIE_PARAMETRI"
   cursor cfk4_tipi_anomalia(var_tipo_anomalia number) is
      select 1
      from   ANOMALIE_PARAMETRI
      where  ID_TIPO_ANOMALIA = var_tipo_anomalia
       and   var_tipo_anomalia is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_ANOMALIA" if children still exist in "ANOMALIE_ICI"
      open  cfk1_tipi_anomalia(OLD_TIPO_ANOMALIA);
      fetch cfk1_tipi_anomalia into dummy;
      found := cfk1_tipi_anomalia%FOUND;
      close cfk1_tipi_anomalia;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Anomalie ICI. La registrazione di Tipi Anomalia non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ANOMALIA" if children still exist in "ANOMALIE_ANNO"
      open  cfk2_tipi_anomalia(OLD_TIPO_ANOMALIA);
      fetch cfk2_tipi_anomalia into dummy;
      found := cfk2_tipi_anomalia%FOUND;
      close cfk2_tipi_anomalia;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Anomalie_anno. La registrazione di Tipi Anomalia non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ANOMALIA" if children still exist in "ANCI_VER"
      open  cfk3_tipi_anomalia(OLD_TIPO_ANOMALIA);
      fetch cfk3_tipi_anomalia into dummy;
      found := cfk3_tipi_anomalia%FOUND;
      close cfk3_tipi_anomalia;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Anci Ver. La registrazione di Tipi Anomalia non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ANOMALIA" if children still exist in "ANOMALIE_PARAMETRI"
      open  cfk4_tipi_anomalia(OLD_TIPO_ANOMALIA);
      fetch cfk4_tipi_anomalia into dummy;
      found := cfk4_tipi_anomalia%FOUND;
      close cfk4_tipi_anomalia;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ANOMALIE_PARAMETRI. La registrazione di Tipi Anomalia non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ANOMALIA_PD */
/

-- Tigger TIPI_ANOMALIA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ANOMALIA

create or replace trigger TIPI_ANOMALIA_TD
before DELETE
on TIPI_ANOMALIA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ANOMALIE_ICI

      -- Child Restrict Table: ANOMALIE_ANNO

      -- Child Restrict Table: ANCI_VER

      -- Child Restrict Table: ANOMALIE_PARAMETRI

      TIPI_ANOMALIA_PD(:OLD.TIPO_ANOMALIA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ANOMALIA_TD */
/

-- Procedure TIPI_AREA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_AREA

create or replace procedure TIPI_AREA_PU
(old_tipo_area IN number,
 new_tipo_area IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "PARTIZIONI_OGGETTO"
   cursor cfk1_tipi_area(var_tipo_area number) is
      select 1
      from   PARTIZIONI_OGGETTO
      where  TIPO_AREA = var_tipo_area
       and   var_tipo_area is not null;

   --  Declaration of UpdateParentRestrict constraint for "PARTIZIONI_OGGETTO_PRATICA"
   cursor cfk2_tipi_area(var_tipo_area number) is
      select 1
      from   PARTIZIONI_OGGETTO_PRATICA
      where  TIPO_AREA = var_tipo_area
       and   var_tipo_area is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_AREA" non modificabile se esistono referenze su "PARTIZIONI_OGGETTO"
      if (OLD_TIPO_AREA != NEW_TIPO_AREA) then
         open  cfk1_tipi_area(OLD_TIPO_AREA);
         fetch cfk1_tipi_area into dummy;
         found := cfk1_tipi_area%FOUND;
         close cfk1_tipi_area;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Partizioni Oggetto. La registrazione di Tipi Area non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_AREA" non modificabile se esistono referenze su "PARTIZIONI_OGGETTO_PRATICA"
      if (OLD_TIPO_AREA != NEW_TIPO_AREA) then
         open  cfk2_tipi_area(OLD_TIPO_AREA);
         fetch cfk2_tipi_area into dummy;
         found := cfk2_tipi_area%FOUND;
         close cfk2_tipi_area;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Partizioni Oggetto Pratica. La registrazione di Tipi Area non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_AREA_PU */
/

-- Trigger TIPI_AREA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_AREA

create or replace trigger TIPI_AREA_TIU
before INSERT
    or UPDATE
on TIPI_AREA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_AREA_PU(:OLD.TIPO_AREA,
                         :NEW.TIPO_AREA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_AREA"
            cursor cpk_tipi_area(var_TIPO_AREA number) is
               select 1
                 from   TIPI_AREA
                where  TIPO_AREA = var_TIPO_AREA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_AREA"
               if :new.TIPO_AREA is not null then
                  open  cpk_tipi_area(:new.TIPO_AREA);
                  fetch cpk_tipi_area into dummy;
                  found := cpk_tipi_area%FOUND;
                  close cpk_tipi_area;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_AREA||
                               '" gia'' presente in Tipi Area. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_AREA_TIU */
/

-- Procedure TIPI_AREA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_AREA

create or replace procedure TIPI_AREA_PD
(old_tipo_area IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "PARTIZIONI_OGGETTO"
   cursor cfk1_tipi_area(var_tipo_area number) is
      select 1
      from   PARTIZIONI_OGGETTO
      where  TIPO_AREA = var_tipo_area
       and   var_tipo_area is not null;

   --  Declaration of DeleteParentRestrict constraint for "PARTIZIONI_OGGETTO_PRATICA"
   cursor cfk2_tipi_area(var_tipo_area number) is
      select 1
      from   PARTIZIONI_OGGETTO_PRATICA
      where  TIPO_AREA = var_tipo_area
       and   var_tipo_area is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_AREA" if children still exist in "PARTIZIONI_OGGETTO"
      open  cfk1_tipi_area(OLD_TIPO_AREA);
      fetch cfk1_tipi_area into dummy;
      found := cfk1_tipi_area%FOUND;
      close cfk1_tipi_area;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Partizioni Oggetto. La registrazione di Tipi Area non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_AREA" if children still exist in "PARTIZIONI_OGGETTO_PRATICA"
      open  cfk2_tipi_area(OLD_TIPO_AREA);
      fetch cfk2_tipi_area into dummy;
      found := cfk2_tipi_area%FOUND;
      close cfk2_tipi_area;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Partizioni Oggetto Pratica. La registrazione di Tipi Area non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_AREA_PD */
/

-- Tigger TIPI_AREA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_AREA

create or replace trigger TIPI_AREA_TD
before DELETE
on TIPI_AREA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: PARTIZIONI_OGGETTO

      -- Child Restrict Table: PARTIZIONI_OGGETTO_PRATICA

      TIPI_AREA_PD(:OLD.TIPO_AREA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_AREA_TD */
/

-- Procedure TIPI_ATTIVITA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_ATTIVITA

create or replace procedure TIPI_ATTIVITA_PU
(old_tipo_attivita IN number,
 new_tipo_attivita IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "TIPI_ATTIVITA_ELABORAZIONE"
   cursor cfk1_tipi_attivita(var_tipo_attivita number) is
      select 1
      from   TIPI_ATTIVITA_ELABORAZIONE
      where  TIPO_ATTIVITA = var_tipo_attivita
       and   var_tipo_attivita is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_ATTIVITA" non modificabile se esistono referenze su "TIPI_ATTIVITA_ELABORAZIONE"
      if (OLD_TIPO_ATTIVITA != NEW_TIPO_ATTIVITA) then
         open  cfk1_tipi_attivita(OLD_TIPO_ATTIVITA);
         fetch cfk1_tipi_attivita into dummy;
         found := cfk1_tipi_attivita%FOUND;
         close cfk1_tipi_attivita;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Tipi_Attivita_Elaborazione. La registrazione di Tipi Attivita non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ATTIVITA_PU */
/

-- Trigger TIPI_ATTIVITA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_ATTIVITA

create or replace trigger TIPI_ATTIVITA_TIU
before INSERT
    or UPDATE
on TIPI_ATTIVITA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_ATTIVITA_PU(:OLD.TIPO_ATTIVITA,
                         :NEW.TIPO_ATTIVITA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_ATTIVITA"
            cursor cpk_tipi_attivita(var_TIPO_ATTIVITA number) is
               select 1
                 from   TIPI_ATTIVITA
                where  TIPO_ATTIVITA = var_TIPO_ATTIVITA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_ATTIVITA"
               if :new.TIPO_ATTIVITA is not null then
                  open  cpk_tipi_attivita(:new.TIPO_ATTIVITA);
                  fetch cpk_tipi_attivita into dummy;
                  found := cpk_tipi_attivita%FOUND;
                  close cpk_tipi_attivita;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_ATTIVITA||
                               '" gia'' presente in Tipi Attivita. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "TIPI_ATTIVITA" for all children in "ATTIVITA_ELABORAZIONE"
         if (:OLD.TIPO_ATTIVITA != :NEW.TIPO_ATTIVITA) then
            update ATTIVITA_ELABORAZIONE
             set   TIPO_ATTIVITA = :NEW.TIPO_ATTIVITA
            where  TIPO_ATTIVITA = :OLD.TIPO_ATTIVITA;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ATTIVITA_TIU */
/

-- Procedure TIPI_ATTIVITA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ATTIVITA

create or replace procedure TIPI_ATTIVITA_PD
(old_tipo_attivita IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ATTIVITA_ELABORAZIONE"
   cursor cfk1_tipi_attivita(var_tipo_attivita number) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  TIPO_ATTIVITA = var_tipo_attivita
       and   var_tipo_attivita is not null;

   --  Declaration of DeleteParentRestrict constraint for "TIPI_ATTIVITA_ELABORAZIONE"
   cursor cfk2_tipi_attivita(var_tipo_attivita number) is
      select 1
      from   TIPI_ATTIVITA_ELABORAZIONE
      where  TIPO_ATTIVITA = var_tipo_attivita
       and   var_tipo_attivita is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_ATTIVITA" if children still exist in "ATTIVITA_ELABORAZIONE"
      open  cfk1_tipi_attivita(OLD_TIPO_ATTIVITA);
      fetch cfk1_tipi_attivita into dummy;
      found := cfk1_tipi_attivita%FOUND;
      close cfk1_tipi_attivita;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Attivita Elaborazione. La registrazione di Tipi Attivita non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ATTIVITA" if children still exist in "TIPI_ATTIVITA_ELABORAZIONE"
      open  cfk2_tipi_attivita(OLD_TIPO_ATTIVITA);
      fetch cfk2_tipi_attivita into dummy;
      found := cfk2_tipi_attivita%FOUND;
      close cfk2_tipi_attivita;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Tipi_Attivita_Elaborazione. La registrazione di Tipi Attivita non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ATTIVITA_PD */
/

-- Tigger TIPI_ATTIVITA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ATTIVITA

create or replace trigger TIPI_ATTIVITA_TD
before DELETE
on TIPI_ATTIVITA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ATTIVITA_ELABORAZIONE

      -- Child Restrict Table: TIPI_ATTIVITA_ELABORAZIONE

      TIPI_ATTIVITA_PD(:OLD.TIPO_ATTIVITA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ATTIVITA_TD */
/

-- Procedure TIPI_ATTIVITA_ELABORAZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TIPI_ATTIVITA_ELABORAZIONE

create or replace procedure TIPI_ATTIVITA_ELABORAZIONE_PI
(new_tipo_elaborazione IN varchar,
 new_tipo_attivita IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ATTIVITA"
   cursor cpk1_tipi_attivita_elaborazion(var_tipo_attivita number) is
      select 1
      from   TIPI_ATTIVITA
      where  TIPO_ATTIVITA = var_tipo_attivita
       and   var_tipo_attivita is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_ELABORAZIONE"
   cursor cpk2_tipi_attivita_elaborazion(var_tipo_elaborazione varchar) is
      select 1
      from   TIPI_ELABORAZIONE
      where  TIPO_ELABORAZIONE = var_tipo_elaborazione
       and   var_tipo_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_ATTIVITA" deve esistere quando si inserisce su "TIPI_ATTIVITA_ELABORAZIONE"
         if NEW_TIPO_ATTIVITA is not null then
            open  cpk1_tipi_attivita_elaborazion(NEW_TIPO_ATTIVITA);
            fetch cpk1_tipi_attivita_elaborazion into dummy;
            found := cpk1_tipi_attivita_elaborazion%FOUND;
            close cpk1_tipi_attivita_elaborazion;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Attivita. La registrazione Tipi_Attivita_Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ELABORAZIONE" deve esistere quando si inserisce su "TIPI_ATTIVITA_ELABORAZIONE"
         if NEW_TIPO_ELABORAZIONE is not null then
            open  cpk2_tipi_attivita_elaborazion(NEW_TIPO_ELABORAZIONE);
            fetch cpk2_tipi_attivita_elaborazion into dummy;
            found := cpk2_tipi_attivita_elaborazion%FOUND;
            close cpk2_tipi_attivita_elaborazion;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi_Elaborazione. La registrazione Tipi_Attivita_Elaborazione non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ATTIVITA_ELABORAZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TIPI_ATTIVITA_ELABORAZIONE
/* End Trigger: TIPI_ATTIVITA_ELABORAZIONE_TC */

-- Procedure TIPI_ATTIVITA_ELABORAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_ATTIVITA_ELABORAZIONE

create or replace procedure TIPI_ATTIVITA_ELABORAZIONE_PU
(old_tipo_elaborazione IN varchar,
 old_tipo_attivita IN number,
 new_tipo_elaborazione IN varchar,
 new_tipo_attivita IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ATTIVITA"
   cursor cpk1_tipi_attivita_elaborazion(var_tipo_attivita number) is
      select 1
      from   TIPI_ATTIVITA
      where  TIPO_ATTIVITA = var_tipo_attivita
       and   var_tipo_attivita is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_ELABORAZIONE"
   cursor cpk2_tipi_attivita_elaborazion(var_tipo_elaborazione varchar) is
      select 1
      from   TIPI_ELABORAZIONE
      where  TIPO_ELABORAZIONE = var_tipo_elaborazione
       and   var_tipo_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_ATTIVITA" deve esistere quando si modifica "TIPI_ATTIVITA_ELABORAZIONE"
         if  NEW_TIPO_ATTIVITA is not null and ( seq = 0 )
         and (   (NEW_TIPO_ATTIVITA != OLD_TIPO_ATTIVITA or OLD_TIPO_ATTIVITA is null) ) then
            open  cpk1_tipi_attivita_elaborazion(NEW_TIPO_ATTIVITA);
            fetch cpk1_tipi_attivita_elaborazion into dummy;
            found := cpk1_tipi_attivita_elaborazion%FOUND;
            close cpk1_tipi_attivita_elaborazion;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Attivita. La registrazione Tipi_Attivita_Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_ELABORAZIONE" deve esistere quando si modifica "TIPI_ATTIVITA_ELABORAZIONE"
         if  NEW_TIPO_ELABORAZIONE is not null and ( seq = 0 )
         and (   (NEW_TIPO_ELABORAZIONE != OLD_TIPO_ELABORAZIONE or OLD_TIPO_ELABORAZIONE is null) ) then
            open  cpk2_tipi_attivita_elaborazion(NEW_TIPO_ELABORAZIONE);
            fetch cpk2_tipi_attivita_elaborazion into dummy;
            found := cpk2_tipi_attivita_elaborazion%FOUND;
            close cpk2_tipi_attivita_elaborazion;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi_Elaborazione. La registrazione Tipi_Attivita_Elaborazione non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ATTIVITA_ELABORAZIONE_PU */
/

-- Trigger TIPI_ATTIVITA_ELABORAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_ATTIVITA_ELABORAZIONE

create or replace trigger TIPI_ATTIVITA_ELABORAZIONE_TIU
before INSERT
    or UPDATE
on TIPI_ATTIVITA_ELABORAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_ATTIVITA_ELABORAZIONE_PU(:OLD.TIPO_ELABORAZIONE,
                                       :OLD.TIPO_ATTIVITA,
                         :NEW.TIPO_ELABORAZIONE,
                         :NEW.TIPO_ATTIVITA);
         null;
      end if;
      if INSERTING then
         TIPI_ATTIVITA_ELABORAZIONE_PI(:NEW.TIPO_ELABORAZIONE,
                                       :NEW.TIPO_ATTIVITA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_ATTIVITA_ELABORAZIONE"
            cursor cpk_tipi_attivita_elaborazion(var_TIPO_ELABORAZIONE varchar,
                                                 var_TIPO_ATTIVITA number) is
               select 1
                 from   TIPI_ATTIVITA_ELABORAZIONE
                where  TIPO_ELABORAZIONE = var_TIPO_ELABORAZIONE and
                       TIPO_ATTIVITA = var_TIPO_ATTIVITA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_ATTIVITA_ELABORAZIONE"
               if :new.TIPO_ELABORAZIONE is not null and
                  :new.TIPO_ATTIVITA is not null then
                  open  cpk_tipi_attivita_elaborazion(:new.TIPO_ELABORAZIONE,
                                                      :new.TIPO_ATTIVITA);
                  fetch cpk_tipi_attivita_elaborazion into dummy;
                  found := cpk_tipi_attivita_elaborazion%FOUND;
                  close cpk_tipi_attivita_elaborazion;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_ELABORAZIONE||' '||
                               :new.TIPO_ATTIVITA||
                               '" gia'' presente in Tipi_Attivita_Elaborazione. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ATTIVITA_ELABORAZIONE_TIU */
/

-- Procedure TIPI_ATTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_ATTO

create or replace procedure TIPI_ATTO_PU
(old_tipo_atto IN number,
 new_tipo_atto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_atto(var_tipo_atto number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Declaration of UpdateParentRestrict constraint for "ITER_PRATICA"
   cursor cfk2_tipi_atto(var_tipo_atto number) is
      select 1
      from   ITER_PRATICA
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk3_tipi_atto(var_tipo_atto number) is
      select 1
      from   SUPPORTO_SERVIZI
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk4_tipi_atto(var_tipo_atto number) is
      select 1
      from   SUPPORTO_SERVIZI
      where  LIQ2_TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_ATTO" non modificabile se esistono referenze su "PRATICHE_TRIBUTO"
      if (OLD_TIPO_ATTO != NEW_TIPO_ATTO) then
         open  cfk1_tipi_atto(OLD_TIPO_ATTO);
         fetch cfk1_tipi_atto into dummy;
         found := cfk1_tipi_atto%FOUND;
         close cfk1_tipi_atto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Atto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ATTO" non modificabile se esistono referenze su "ITER_PRATICA"
      if (OLD_TIPO_ATTO != NEW_TIPO_ATTO) then
         open  cfk2_tipi_atto(OLD_TIPO_ATTO);
         fetch cfk2_tipi_atto into dummy;
         found := cfk2_tipi_atto%FOUND;
         close cfk2_tipi_atto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Iter Pratica. La registrazione di Tipi Atto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ATTO" non modificabile se esistono referenze su "SUPPORTO_SERVIZI"
      if (OLD_TIPO_ATTO != NEW_TIPO_ATTO) then
         open  cfk3_tipi_atto(OLD_TIPO_ATTO);
         fetch cfk3_tipi_atto into dummy;
         found := cfk3_tipi_atto%FOUND;
         close cfk3_tipi_atto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Atto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ATTO" non modificabile se esistono referenze su "SUPPORTO_SERVIZI"
      if (OLD_TIPO_ATTO != NEW_TIPO_ATTO) then
         open  cfk4_tipi_atto(OLD_TIPO_ATTO);
         fetch cfk4_tipi_atto into dummy;
         found := cfk4_tipi_atto%FOUND;
         close cfk4_tipi_atto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Atto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ATTO_PU */
/

-- Trigger TIPI_ATTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_ATTO

create or replace trigger TIPI_ATTO_TIU
before INSERT
    or UPDATE
on TIPI_ATTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_ATTO_PU(:OLD.TIPO_ATTO,
                         :NEW.TIPO_ATTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_ATTO"
            cursor cpk_tipi_atto(var_TIPO_ATTO number) is
               select 1
                 from   TIPI_ATTO
                where  TIPO_ATTO = var_TIPO_ATTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_ATTO"
               if :new.TIPO_ATTO is not null then
                  open  cpk_tipi_atto(:new.TIPO_ATTO);
                  fetch cpk_tipi_atto into dummy;
                  found := cpk_tipi_atto%FOUND;
                  close cpk_tipi_atto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_ATTO||
                               '" gia'' presente in Tipi Atto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ATTO_TIU */
/

-- Procedure TIPI_ATTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ATTO

create or replace procedure TIPI_ATTO_PD
(old_tipo_atto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_atto(var_tipo_atto number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Declaration of DeleteParentRestrict constraint for "ITER_PRATICA"
   cursor cfk2_tipi_atto(var_tipo_atto number) is
      select 1
      from   ITER_PRATICA
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk3_tipi_atto(var_tipo_atto number) is
      select 1
      from   SUPPORTO_SERVIZI
      where  TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk4_tipi_atto(var_tipo_atto number) is
      select 1
      from   SUPPORTO_SERVIZI
      where  LIQ2_TIPO_ATTO = var_tipo_atto
       and   var_tipo_atto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_ATTO" if children still exist in "PRATICHE_TRIBUTO"
      open  cfk1_tipi_atto(OLD_TIPO_ATTO);
      fetch cfk1_tipi_atto into dummy;
      found := cfk1_tipi_atto%FOUND;
      close cfk1_tipi_atto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Atto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ATTO" if children still exist in "ITER_PRATICA"
      open  cfk2_tipi_atto(OLD_TIPO_ATTO);
      fetch cfk2_tipi_atto into dummy;
      found := cfk2_tipi_atto%FOUND;
      close cfk2_tipi_atto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Iter Pratica. La registrazione di Tipi Atto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ATTO" if children still exist in "SUPPORTO_SERVIZI"
      open  cfk3_tipi_atto(OLD_TIPO_ATTO);
      fetch cfk3_tipi_atto into dummy;
      found := cfk3_tipi_atto%FOUND;
      close cfk3_tipi_atto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Atto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ATTO" if children still exist in "SUPPORTO_SERVIZI"
      open  cfk4_tipi_atto(OLD_TIPO_ATTO);
      fetch cfk4_tipi_atto into dummy;
      found := cfk4_tipi_atto%FOUND;
      close cfk4_tipi_atto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Atto non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ATTO_PD */
/

-- Tigger TIPI_ATTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ATTO

create or replace trigger TIPI_ATTO_TD
before DELETE
on TIPI_ATTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: PRATICHE_TRIBUTO

      -- Child Restrict Table: ITER_PRATICA

      -- Child Restrict Table: SUPPORTO_SERVIZI

      -- Child Restrict Table: SUPPORTO_SERVIZI

      TIPI_ATTO_PD(:OLD.TIPO_ATTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ATTO_TD */
/

-- Procedure TIPI_CANALE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_CANALE

create or replace procedure TIPI_CANALE_PU
(old_tipo_canale IN number,
 new_tipo_canale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "COMUNICAZIONE_TESTI"
   cursor cfk1_tipi_canale(var_tipo_canale number) is
      select 1
      from   COMUNICAZIONE_TESTI
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;

   --  Declaration of UpdateParentRestrict constraint for "DOCUMENTI_CONTRIBUENTE"
   cursor cfk2_tipi_canale(var_tipo_canale number) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;

   --  Declaration of UpdateParentRestrict constraint for "DETTAGLI_COMUNICAZIONE"
   cursor cfk3_tipi_canale(var_tipo_canale number) is
      select 1
      from   DETTAGLI_COMUNICAZIONE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_CANALE" non modificabile se esistono referenze su "COMUNICAZIONE_TESTI"
      if (OLD_TIPO_CANALE != NEW_TIPO_CANALE) then
         open  cfk1_tipi_canale(OLD_TIPO_CANALE);
         fetch cfk1_tipi_canale into dummy;
         found := cfk1_tipi_canale%FOUND;
         close cfk1_tipi_canale;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Comunicazione Testi. La registrazione di Tipi Canale non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_CANALE" non modificabile se esistono referenze su "DOCUMENTI_CONTRIBUENTE"
      if (OLD_TIPO_CANALE != NEW_TIPO_CANALE) then
         open  cfk2_tipi_canale(OLD_TIPO_CANALE);
         fetch cfk2_tipi_canale into dummy;
         found := cfk2_tipi_canale%FOUND;
         close cfk2_tipi_canale;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Documenti Contribuente. La registrazione di Tipi Canale non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_CANALE" non modificabile se esistono referenze su "DETTAGLI_COMUNICAZIONE"
      if (OLD_TIPO_CANALE != NEW_TIPO_CANALE) then
         open  cfk3_tipi_canale(OLD_TIPO_CANALE);
         fetch cfk3_tipi_canale into dummy;
         found := cfk3_tipi_canale%FOUND;
         close cfk3_tipi_canale;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DETTAGLI COMUNICAZIONE. La registrazione di Tipi Canale non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_CANALE_PU */
/

-- Trigger TIPI_CANALE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_CANALE

create or replace trigger TIPI_CANALE_TIU
before INSERT
    or UPDATE
on TIPI_CANALE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_CANALE_PU(:OLD.TIPO_CANALE,
                         :NEW.TIPO_CANALE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_CANALE"
            cursor cpk_tipi_canale(var_TIPO_CANALE number) is
               select 1
                 from   TIPI_CANALE
                where  TIPO_CANALE = var_TIPO_CANALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_CANALE"
               if :new.TIPO_CANALE is not null then
                  open  cpk_tipi_canale(:new.TIPO_CANALE);
                  fetch cpk_tipi_canale into dummy;
                  found := cpk_tipi_canale%FOUND;
                  close cpk_tipi_canale;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_CANALE||
                               '" gia'' presente in Tipi Canale. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_CANALE_TIU */
/

-- Procedure TIPI_CANALE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_CANALE

create or replace procedure TIPI_CANALE_PD
(old_tipo_canale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "COMUNICAZIONE_TESTI"
   cursor cfk1_tipi_canale(var_tipo_canale number) is
      select 1
      from   COMUNICAZIONE_TESTI
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;

   --  Declaration of DeleteParentRestrict constraint for "DOCUMENTI_CONTRIBUENTE"
   cursor cfk2_tipi_canale(var_tipo_canale number) is
      select 1
      from   DOCUMENTI_CONTRIBUENTE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETTAGLI_COMUNICAZIONE"
   cursor cfk3_tipi_canale(var_tipo_canale number) is
      select 1
      from   DETTAGLI_COMUNICAZIONE
      where  TIPO_CANALE = var_tipo_canale
       and   var_tipo_canale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_CANALE" if children still exist in "COMUNICAZIONE_TESTI"
      open  cfk1_tipi_canale(OLD_TIPO_CANALE);
      fetch cfk1_tipi_canale into dummy;
      found := cfk1_tipi_canale%FOUND;
      close cfk1_tipi_canale;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Comunicazione Testi. La registrazione di Tipi Canale non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_CANALE" if children still exist in "DOCUMENTI_CONTRIBUENTE"
      open  cfk2_tipi_canale(OLD_TIPO_CANALE);
      fetch cfk2_tipi_canale into dummy;
      found := cfk2_tipi_canale%FOUND;
      close cfk2_tipi_canale;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Documenti Contribuente. La registrazione di Tipi Canale non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_CANALE" if children still exist in "DETTAGLI_COMUNICAZIONE"
      open  cfk3_tipi_canale(OLD_TIPO_CANALE);
      fetch cfk3_tipi_canale into dummy;
      found := cfk3_tipi_canale%FOUND;
      close cfk3_tipi_canale;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DETTAGLI COMUNICAZIONE. La registrazione di Tipi Canale non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_CANALE_PD */
/

-- Tigger TIPI_CANALE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_CANALE

create or replace trigger TIPI_CANALE_TD
before DELETE
on TIPI_CANALE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: COMUNICAZIONE_TESTI

      -- Child Restrict Table: DOCUMENTI_CONTRIBUENTE

      -- Child Restrict Table: DETTAGLI_COMUNICAZIONE

      TIPI_CANALE_PD(:OLD.TIPO_CANALE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_CANALE_TD */
/

-- Procedure TIPI_CARICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_CARICA

create or replace procedure TIPI_CARICA_PU
(old_tipo_carica IN number,
 new_tipo_carica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_carica(var_tipo_carica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  TIPO_CARICA = var_tipo_carica
       and   var_tipo_carica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SOGGETTI"
   cursor cfk2_tipi_carica(var_tipo_carica number) is
      select 1
      from   SOGGETTI
      where  TIPO_CARICA = var_tipo_carica
       and   var_tipo_carica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_CARICA" non modificabile se esistono referenze su "PRATICHE_TRIBUTO"
      if (OLD_TIPO_CARICA != NEW_TIPO_CARICA) then
         open  cfk1_tipi_carica(OLD_TIPO_CARICA);
         fetch cfk1_tipi_carica into dummy;
         found := cfk1_tipi_carica%FOUND;
         close cfk1_tipi_carica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Carica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_CARICA" non modificabile se esistono referenze su "SOGGETTI"
      if (OLD_TIPO_CARICA != NEW_TIPO_CARICA) then
         open  cfk2_tipi_carica(OLD_TIPO_CARICA);
         fetch cfk2_tipi_carica into dummy;
         found := cfk2_tipi_carica%FOUND;
         close cfk2_tipi_carica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Soggetti. La registrazione di Tipi Carica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_CARICA_PU */
/

-- Trigger TIPI_CARICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_CARICA

create or replace trigger TIPI_CARICA_TIU
before INSERT
    or UPDATE
on TIPI_CARICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_CARICA_PU(:OLD.TIPO_CARICA,
                         :NEW.TIPO_CARICA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_CARICA"
            cursor cpk_tipi_carica(var_TIPO_CARICA number) is
               select 1
                 from   TIPI_CARICA
                where  TIPO_CARICA = var_TIPO_CARICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_CARICA"
               if :new.TIPO_CARICA is not null then
                  open  cpk_tipi_carica(:new.TIPO_CARICA);
                  fetch cpk_tipi_carica into dummy;
                  found := cpk_tipi_carica%FOUND;
                  close cpk_tipi_carica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_CARICA||
                               '" gia'' presente in Tipi Carica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_CARICA_TIU */
/

-- Procedure TIPI_CARICA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_CARICA

create or replace procedure TIPI_CARICA_PD
(old_tipo_carica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_carica(var_tipo_carica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  TIPO_CARICA = var_tipo_carica
       and   var_tipo_carica is not null;

   --  Declaration of DeleteParentRestrict constraint for "SOGGETTI"
   cursor cfk2_tipi_carica(var_tipo_carica number) is
      select 1
      from   SOGGETTI
      where  TIPO_CARICA = var_tipo_carica
       and   var_tipo_carica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_CARICA" if children still exist in "PRATICHE_TRIBUTO"
      open  cfk1_tipi_carica(OLD_TIPO_CARICA);
      fetch cfk1_tipi_carica into dummy;
      found := cfk1_tipi_carica%FOUND;
      close cfk1_tipi_carica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Carica non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_CARICA" if children still exist in "SOGGETTI"
      open  cfk2_tipi_carica(OLD_TIPO_CARICA);
      fetch cfk2_tipi_carica into dummy;
      found := cfk2_tipi_carica%FOUND;
      close cfk2_tipi_carica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Soggetti. La registrazione di Tipi Carica non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_CARICA_PD */
/

-- Tigger TIPI_CARICA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_CARICA

create or replace trigger TIPI_CARICA_TD
before DELETE
on TIPI_CARICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: PRATICHE_TRIBUTO

      -- Child Restrict Table: SOGGETTI

      TIPI_CARICA_PD(:OLD.TIPO_CARICA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_CARICA_TD */
/

-- Procedure TIPI_CONTATTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_CONTATTO

create or replace procedure TIPI_CONTATTO_PU
(old_tipo_contatto IN number,
 new_tipo_contatto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "CONTATTI_CONTRIBUENTE"
   cursor cfk1_tipi_contatto(var_tipo_contatto number) is
      select 1
      from   CONTATTI_CONTRIBUENTE
      where  TIPO_CONTATTO = var_tipo_contatto
       and   var_tipo_contatto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_CONTATTO" non modificabile se esistono referenze su "CONTATTI_CONTRIBUENTE"
      if (OLD_TIPO_CONTATTO != NEW_TIPO_CONTATTO) then
         open  cfk1_tipi_contatto(OLD_TIPO_CONTATTO);
         fetch cfk1_tipi_contatto into dummy;
         found := cfk1_tipi_contatto%FOUND;
         close cfk1_tipi_contatto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Contatti Contribuente. La registrazione di Tipi Contatto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_CONTATTO_PU */
/

-- Trigger TIPI_CONTATTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_CONTATTO

create or replace trigger TIPI_CONTATTO_TIU
before INSERT
    or UPDATE
on TIPI_CONTATTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_CONTATTO_PU(:OLD.TIPO_CONTATTO,
                         :NEW.TIPO_CONTATTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_CONTATTO"
            cursor cpk_tipi_contatto(var_TIPO_CONTATTO number) is
               select 1
                 from   TIPI_CONTATTO
                where  TIPO_CONTATTO = var_TIPO_CONTATTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_CONTATTO"
               if :new.TIPO_CONTATTO is not null then
                  open  cpk_tipi_contatto(:new.TIPO_CONTATTO);
                  fetch cpk_tipi_contatto into dummy;
                  found := cpk_tipi_contatto%FOUND;
                  close cpk_tipi_contatto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_CONTATTO||
                               '" gia'' presente in Tipi Contatto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_CONTATTO_TIU */
/

-- Procedure TIPI_CONTATTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_CONTATTO

create or replace procedure TIPI_CONTATTO_PD
(old_tipo_contatto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CONTATTI_CONTRIBUENTE"
   cursor cfk1_tipi_contatto(var_tipo_contatto number) is
      select 1
      from   CONTATTI_CONTRIBUENTE
      where  TIPO_CONTATTO = var_tipo_contatto
       and   var_tipo_contatto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_CONTATTO" if children still exist in "CONTATTI_CONTRIBUENTE"
      open  cfk1_tipi_contatto(OLD_TIPO_CONTATTO);
      fetch cfk1_tipi_contatto into dummy;
      found := cfk1_tipi_contatto%FOUND;
      close cfk1_tipi_contatto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Contatti Contribuente. La registrazione di Tipi Contatto non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_CONTATTO_PD */
/

-- Tigger TIPI_CONTATTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_CONTATTO

create or replace trigger TIPI_CONTATTO_TD
before DELETE
on TIPI_CONTATTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CONTATTI_CONTRIBUENTE

      TIPI_CONTATTO_PD(:OLD.TIPO_CONTATTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_CONTATTO_TD */
/

-- Procedure TIPI_COSTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_COSTO

create or replace procedure TIPI_COSTO_PU
(old_tipo_costo IN varchar,
 new_tipo_costo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "COSTI_TARSU"
   cursor cfk1_tipi_costo(var_tipo_costo varchar) is
      select 1
      from   COSTI_TARSU
      where  TIPO_COSTO = var_tipo_costo
       and   var_tipo_costo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_COSTO" non modificabile se esistono referenze su "COSTI_TARSU"
      if (OLD_TIPO_COSTO != NEW_TIPO_COSTO) then
         open  cfk1_tipi_costo(OLD_TIPO_COSTO);
         fetch cfk1_tipi_costo into dummy;
         found := cfk1_tipi_costo%FOUND;
         close cfk1_tipi_costo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Costi TARSU. La registrazione di Tipi Costo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_COSTO_PU */
/

-- Trigger TIPI_COSTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_COSTO

create or replace trigger TIPI_COSTO_TIU
before INSERT
    or UPDATE
on TIPI_COSTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_COSTO_PU(:OLD.TIPO_COSTO,
                         :NEW.TIPO_COSTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_COSTO"
            cursor cpk_tipi_costo(var_TIPO_COSTO varchar) is
               select 1
                 from   TIPI_COSTO
                where  TIPO_COSTO = var_TIPO_COSTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_COSTO"
               if :new.TIPO_COSTO is not null then
                  open  cpk_tipi_costo(:new.TIPO_COSTO);
                  fetch cpk_tipi_costo into dummy;
                  found := cpk_tipi_costo%FOUND;
                  close cpk_tipi_costo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_COSTO||
                               '" gia'' presente in Tipi Costo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_COSTO_TIU */
/

-- Procedure TIPI_COSTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_COSTO

create or replace procedure TIPI_COSTO_PD
(old_tipo_costo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "COSTI_TARSU"
   cursor cfk1_tipi_costo(var_tipo_costo varchar) is
      select 1
      from   COSTI_TARSU
      where  TIPO_COSTO = var_tipo_costo
       and   var_tipo_costo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_COSTO" if children still exist in "COSTI_TARSU"
      open  cfk1_tipi_costo(OLD_TIPO_COSTO);
      fetch cfk1_tipi_costo into dummy;
      found := cfk1_tipi_costo%FOUND;
      close cfk1_tipi_costo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Costi TARSU. La registrazione di Tipi Costo non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_COSTO_PD */
/

-- Tigger TIPI_COSTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_COSTO

create or replace trigger TIPI_COSTO_TD
before DELETE
on TIPI_COSTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: COSTI_TARSU

      TIPI_COSTO_PD(:OLD.TIPO_COSTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_COSTO_TD */
/

-- Procedure TIPI_ELABORAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_ELABORAZIONE

create or replace procedure TIPI_ELABORAZIONE_PU
(old_tipo_elaborazione IN varchar,
 new_tipo_elaborazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "TIPI_ATTIVITA_ELABORAZIONE"
   cursor cfk1_tipi_elaborazione(var_tipo_elaborazione varchar) is
      select 1
      from   TIPI_ATTIVITA_ELABORAZIONE
      where  TIPO_ELABORAZIONE = var_tipo_elaborazione
       and   var_tipo_elaborazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "ELABORAZIONI_MASSIVE"
   cursor cfk2_tipi_elaborazione(var_tipo_elaborazione varchar) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  TIPO_ELABORAZIONE = var_tipo_elaborazione
       and   var_tipo_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_ELABORAZIONE" non modificabile se esistono referenze su "TIPI_ATTIVITA_ELABORAZIONE"
      if (OLD_TIPO_ELABORAZIONE != NEW_TIPO_ELABORAZIONE) then
         open  cfk1_tipi_elaborazione(OLD_TIPO_ELABORAZIONE);
         fetch cfk1_tipi_elaborazione into dummy;
         found := cfk1_tipi_elaborazione%FOUND;
         close cfk1_tipi_elaborazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Tipi_Attivita_Elaborazione. La registrazione di Tipi_Elaborazione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_ELABORAZIONE" non modificabile se esistono referenze su "ELABORAZIONI_MASSIVE"
      if (OLD_TIPO_ELABORAZIONE != NEW_TIPO_ELABORAZIONE) then
         open  cfk2_tipi_elaborazione(OLD_TIPO_ELABORAZIONE);
         fetch cfk2_tipi_elaborazione into dummy;
         found := cfk2_tipi_elaborazione%FOUND;
         close cfk2_tipi_elaborazione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Elaborazioni Massive. La registrazione di Tipi_Elaborazione non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ELABORAZIONE_PU */
/

-- Trigger TIPI_ELABORAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_ELABORAZIONE

create or replace trigger TIPI_ELABORAZIONE_TIU
before INSERT
    or UPDATE
on TIPI_ELABORAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_ELABORAZIONE_PU(:OLD.TIPO_ELABORAZIONE,
                         :NEW.TIPO_ELABORAZIONE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_ELABORAZIONE"
            cursor cpk_tipi_elaborazione(var_TIPO_ELABORAZIONE varchar) is
               select 1
                 from   TIPI_ELABORAZIONE
                where  TIPO_ELABORAZIONE = var_TIPO_ELABORAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_ELABORAZIONE"
               if :new.TIPO_ELABORAZIONE is not null then
                  open  cpk_tipi_elaborazione(:new.TIPO_ELABORAZIONE);
                  fetch cpk_tipi_elaborazione into dummy;
                  found := cpk_tipi_elaborazione%FOUND;
                  close cpk_tipi_elaborazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_ELABORAZIONE||
                               '" gia'' presente in Tipi_Elaborazione. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ELABORAZIONE_TIU */
/

-- Procedure TIPI_ELABORAZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ELABORAZIONE

create or replace procedure TIPI_ELABORAZIONE_PD
(old_tipo_elaborazione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "TIPI_ATTIVITA_ELABORAZIONE"
   cursor cfk1_tipi_elaborazione(var_tipo_elaborazione varchar) is
      select 1
      from   TIPI_ATTIVITA_ELABORAZIONE
      where  TIPO_ELABORAZIONE = var_tipo_elaborazione
       and   var_tipo_elaborazione is not null;

   --  Declaration of DeleteParentRestrict constraint for "ELABORAZIONI_MASSIVE"
   cursor cfk2_tipi_elaborazione(var_tipo_elaborazione varchar) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  TIPO_ELABORAZIONE = var_tipo_elaborazione
       and   var_tipo_elaborazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_ELABORAZIONE" if children still exist in "TIPI_ATTIVITA_ELABORAZIONE"
      open  cfk1_tipi_elaborazione(OLD_TIPO_ELABORAZIONE);
      fetch cfk1_tipi_elaborazione into dummy;
      found := cfk1_tipi_elaborazione%FOUND;
      close cfk1_tipi_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Tipi_Attivita_Elaborazione. La registrazione di Tipi_Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_ELABORAZIONE" if children still exist in "ELABORAZIONI_MASSIVE"
      open  cfk2_tipi_elaborazione(OLD_TIPO_ELABORAZIONE);
      fetch cfk2_tipi_elaborazione into dummy;
      found := cfk2_tipi_elaborazione%FOUND;
      close cfk2_tipi_elaborazione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Elaborazioni Massive. La registrazione di Tipi_Elaborazione non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ELABORAZIONE_PD */
/

-- Tigger TIPI_ELABORAZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ELABORAZIONE

create or replace trigger TIPI_ELABORAZIONE_TD
before DELETE
on TIPI_ELABORAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: TIPI_ATTIVITA_ELABORAZIONE

      -- Child Restrict Table: ELABORAZIONI_MASSIVE

      TIPI_ELABORAZIONE_PD(:OLD.TIPO_ELABORAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ELABORAZIONE_TD */
/

-- Procedure TIPI_ESENZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TIPI_ESENZIONE

create or replace procedure TIPI_ESENZIONE_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_tipi_esenzione(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "TIPI_ESENZIONE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_tipi_esenzione(NEW_TIPO_TRIBUTO);
            fetch cpk1_tipi_esenzione into dummy;
            found := cpk1_tipi_esenzione%FOUND;
            close cpk1_tipi_esenzione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione TIPI_ESENZIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ESENZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TIPI_ESENZIONE
/* End Trigger: TIPI_ESENZIONE_TC */

-- Procedure TIPI_ESENZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_ESENZIONE

create or replace procedure TIPI_ESENZIONE_PU
(old_tipo_esenzione IN number,
 old_tipo_tributo IN varchar,
 new_tipo_esenzione IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_tipi_esenzione(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_tipi_esenzione(var_tipo_esenzione number) is
      select 1
      from   OGGETTI_PRATICA
      where  TIP_TIPO_RIDUZIONE = var_tipo_esenzione
       and   var_tipo_esenzione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "TIPI_ESENZIONE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_tipi_esenzione(NEW_TIPO_TRIBUTO);
            fetch cpk1_tipi_esenzione into dummy;
            found := cpk1_tipi_esenzione%FOUND;
            close cpk1_tipi_esenzione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione TIPI_ESENZIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "TIPI_ESENZIONE" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_TIPO_ESENZIONE != NEW_TIPO_ESENZIONE) then
         open  cfk1_tipi_esenzione(OLD_TIPO_ESENZIONE);
         fetch cfk1_tipi_esenzione into dummy;
         found := cfk1_tipi_esenzione%FOUND;
         close cfk1_tipi_esenzione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di TIPI_ESENZIONE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ESENZIONE_PU */
/

-- Trigger TIPI_ESENZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_ESENZIONE

create or replace trigger TIPI_ESENZIONE_TIU
before INSERT
    or UPDATE
on TIPI_ESENZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_ESENZIONE_PU(:OLD.TIPO_ESENZIONE,
                           :OLD.TIPO_TRIBUTO,
                         :NEW.TIPO_ESENZIONE,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         TIPI_ESENZIONE_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_ESENZIONE"
            cursor cpk_tipi_esenzione(var_TIPO_ESENZIONE number) is
               select 1
                 from   TIPI_ESENZIONE
                where  TIPO_ESENZIONE = var_TIPO_ESENZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_ESENZIONE"
               if :new.TIPO_ESENZIONE is not null then
                  open  cpk_tipi_esenzione(:new.TIPO_ESENZIONE);
                  fetch cpk_tipi_esenzione into dummy;
                  found := cpk_tipi_esenzione%FOUND;
                  close cpk_tipi_esenzione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_ESENZIONE||
                               '" gia'' presente in TIPI_ESENZIONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ESENZIONE_TIU */
/

-- Procedure TIPI_ESENZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ESENZIONE

create or replace procedure TIPI_ESENZIONE_PD
(old_tipo_esenzione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_tipi_esenzione(var_tipo_esenzione number) is
      select 1
      from   OGGETTI_PRATICA
      where  TIP_TIPO_RIDUZIONE = var_tipo_esenzione
       and   var_tipo_esenzione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_ESENZIONE" if children still exist in "OGGETTI_PRATICA"
      open  cfk1_tipi_esenzione(OLD_TIPO_ESENZIONE);
      fetch cfk1_tipi_esenzione into dummy;
      found := cfk1_tipi_esenzione%FOUND;
      close cfk1_tipi_esenzione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di TIPI_ESENZIONE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_ESENZIONE_PD */
/

-- Tigger TIPI_ESENZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_ESENZIONE

create or replace trigger TIPI_ESENZIONE_TD
before DELETE
on TIPI_ESENZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI_PRATICA

      TIPI_ESENZIONE_PD(:OLD.TIPO_ESENZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_ESENZIONE_TD */
/

-- Procedure TIPI_EVENTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_EVENTO

create or replace procedure TIPI_EVENTO_PU
(old_tipo_evento IN varchar,
 new_tipo_evento IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "EVENTI"
   cursor cfk1_tipi_evento(var_tipo_evento varchar) is
      select 1
      from   EVENTI
      where  TIPO_EVENTO = var_tipo_evento
       and   var_tipo_evento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_EVENTO" non modificabile se esistono referenze su "EVENTI"
      if (OLD_TIPO_EVENTO != NEW_TIPO_EVENTO) then
         open  cfk1_tipi_evento(OLD_TIPO_EVENTO);
         fetch cfk1_tipi_evento into dummy;
         found := cfk1_tipi_evento%FOUND;
         close cfk1_tipi_evento;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Eventi. La registrazione di Tipi Evento non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_EVENTO_PU */
/

-- Trigger TIPI_EVENTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_EVENTO

create or replace trigger TIPI_EVENTO_TIU
before INSERT
    or UPDATE
on TIPI_EVENTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_EVENTO_PU(:OLD.TIPO_EVENTO,
                         :NEW.TIPO_EVENTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_EVENTO"
            cursor cpk_tipi_evento(var_TIPO_EVENTO varchar) is
               select 1
                 from   TIPI_EVENTO
                where  TIPO_EVENTO = var_TIPO_EVENTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_EVENTO"
               if :new.TIPO_EVENTO is not null then
                  open  cpk_tipi_evento(:new.TIPO_EVENTO);
                  fetch cpk_tipi_evento into dummy;
                  found := cpk_tipi_evento%FOUND;
                  close cpk_tipi_evento;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_EVENTO||
                               '" gia'' presente in Tipi Evento. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_EVENTO_TIU */
/

-- Procedure TIPI_EVENTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_EVENTO

create or replace procedure TIPI_EVENTO_PD
(old_tipo_evento IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "EVENTI"
   cursor cfk1_tipi_evento(var_tipo_evento varchar) is
      select 1
      from   EVENTI
      where  TIPO_EVENTO = var_tipo_evento
       and   var_tipo_evento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_EVENTO" if children still exist in "EVENTI"
      open  cfk1_tipi_evento(OLD_TIPO_EVENTO);
      fetch cfk1_tipi_evento into dummy;
      found := cfk1_tipi_evento%FOUND;
      close cfk1_tipi_evento;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Eventi. La registrazione di Tipi Evento non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_EVENTO_PD */
/

-- Tigger TIPI_EVENTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_EVENTO

create or replace trigger TIPI_EVENTO_TD
before DELETE
on TIPI_EVENTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: EVENTI

      TIPI_EVENTO_PD(:OLD.TIPO_EVENTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_EVENTO_TD */
/

-- Procedure TIPI_EXPORT_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_EXPORT

create or replace procedure TIPI_EXPORT_PU
(old_tipo_export IN number,
 new_tipo_export IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_EXPORT_PU */
/

-- Trigger TIPI_EXPORT_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_EXPORT

create or replace trigger TIPI_EXPORT_TIU
before INSERT
    or UPDATE
on TIPI_EXPORT
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_EXPORT_PU(:OLD.TIPO_EXPORT,
                         :NEW.TIPO_EXPORT);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_EXPORT"
            cursor cpk_tipi_export(var_TIPO_EXPORT number) is
               select 1
                 from   TIPI_EXPORT
                where  TIPO_EXPORT = var_TIPO_EXPORT;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_EXPORT"
               if :new.TIPO_EXPORT is not null then
                  open  cpk_tipi_export(:new.TIPO_EXPORT);
                  fetch cpk_tipi_export into dummy;
                  found := cpk_tipi_export%FOUND;
                  close cpk_tipi_export;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_EXPORT||
                               '" gia'' presente in TIPI_EXPORT. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "TIPI_EXPORT" for all children in "EXPORT_PERSONALIZZATI"
         if (:OLD.TIPO_EXPORT != :NEW.TIPO_EXPORT) then
            update EXPORT_PERSONALIZZATI
             set   TIPO_EXPORT = :NEW.TIPO_EXPORT
            where  TIPO_EXPORT = :OLD.TIPO_EXPORT;
         end if;

         --  Modify parent code of "TIPI_EXPORT" for all children in "PARAMETRI_EXPORT"
         if (:OLD.TIPO_EXPORT != :NEW.TIPO_EXPORT) then
            update PARAMETRI_EXPORT
             set   TIPO_EXPORT = :NEW.TIPO_EXPORT
            where  TIPO_EXPORT = :OLD.TIPO_EXPORT;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_EXPORT_TIU */
/

-- Procedure TIPI_EXPORT_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_EXPORT

create or replace procedure TIPI_EXPORT_PD
(old_tipo_export IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "EXPORT_PERSONALIZZATI"
   cursor cfk1_tipi_export(var_tipo_export number) is
      select 1
      from   EXPORT_PERSONALIZZATI
      where  TIPO_EXPORT = var_tipo_export
       and   var_tipo_export is not null;

   --  Declaration of DeleteParentRestrict constraint for "PARAMETRI_EXPORT"
   cursor cfk2_tipi_export(var_tipo_export number) is
      select 1
      from   PARAMETRI_EXPORT
      where  TIPO_EXPORT = var_tipo_export
       and   var_tipo_export is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_EXPORT" if children still exist in "EXPORT_PERSONALIZZATI"
      open  cfk1_tipi_export(OLD_TIPO_EXPORT);
      fetch cfk1_tipi_export into dummy;
      found := cfk1_tipi_export%FOUND;
      close cfk1_tipi_export;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su EXPORT_PERSONALIZZATI. La registrazione di TIPI_EXPORT non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_EXPORT" if children still exist in "PARAMETRI_EXPORT"
      open  cfk2_tipi_export(OLD_TIPO_EXPORT);
      fetch cfk2_tipi_export into dummy;
      found := cfk2_tipi_export%FOUND;
      close cfk2_tipi_export;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su PARAMETRI_EXPORT. La registrazione di TIPI_EXPORT non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_EXPORT_PD */
/

-- Tigger TIPI_EXPORT_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_EXPORT

create or replace trigger TIPI_EXPORT_TD
before DELETE
on TIPI_EXPORT
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: EXPORT_PERSONALIZZATI

      -- Child Restrict Table: PARAMETRI_EXPORT

      TIPI_EXPORT_PD(:OLD.TIPO_EXPORT);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_EXPORT_TD */
/

-- Procedure TIPI_MODELLO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_MODELLO

create or replace procedure TIPI_MODELLO_PU
(old_tipo_modello IN varchar,
 new_tipo_modello IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "MODELLI"
   cursor cfk1_tipi_modello(var_tipo_modello varchar) is
      select 1
      from   MODELLI
      where  DESCRIZIONE_ORD = var_tipo_modello
       and   var_tipo_modello is not null;

   --  Declaration of UpdateParentRestrict constraint for "TIPI_MODELLO_PARAMETRI"
   cursor cfk2_tipi_modello(var_tipo_modello varchar) is
      select 1
      from   TIPI_MODELLO_PARAMETRI
      where  TIPO_MODELLO = var_tipo_modello
       and   var_tipo_modello is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_MODELLO" non modificabile se esistono referenze su "MODELLI"
      if (OLD_TIPO_MODELLO != NEW_TIPO_MODELLO) then
         open  cfk1_tipi_modello(OLD_TIPO_MODELLO);
         fetch cfk1_tipi_modello into dummy;
         found := cfk1_tipi_modello%FOUND;
         close cfk1_tipi_modello;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Modelli. La registrazione di Tipi Modello non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_MODELLO" non modificabile se esistono referenze su "TIPI_MODELLO_PARAMETRI"
      if (OLD_TIPO_MODELLO != NEW_TIPO_MODELLO) then
         open  cfk2_tipi_modello(OLD_TIPO_MODELLO);
         fetch cfk2_tipi_modello into dummy;
         found := cfk2_tipi_modello%FOUND;
         close cfk2_tipi_modello;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Tipi Modello Parametri. La registrazione di Tipi Modello non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_MODELLO_PU */
/

-- Trigger TIPI_MODELLO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_MODELLO

create or replace trigger TIPI_MODELLO_TIU
before INSERT
    or UPDATE
on TIPI_MODELLO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_MODELLO_PU(:OLD.TIPO_MODELLO,
                         :NEW.TIPO_MODELLO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_MODELLO"
            cursor cpk_tipi_modello(var_TIPO_MODELLO varchar) is
               select 1
                 from   TIPI_MODELLO
                where  TIPO_MODELLO = var_TIPO_MODELLO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_MODELLO"
               if :new.TIPO_MODELLO is not null then
                  open  cpk_tipi_modello(:new.TIPO_MODELLO);
                  fetch cpk_tipi_modello into dummy;
                  found := cpk_tipi_modello%FOUND;
                  close cpk_tipi_modello;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_MODELLO||
                               '" gia'' presente in Tipi Modello. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_MODELLO_TIU */
/

-- Procedure TIPI_MODELLO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_MODELLO

create or replace procedure TIPI_MODELLO_PD
(old_tipo_modello IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "MODELLI"
   cursor cfk1_tipi_modello(var_tipo_modello varchar) is
      select 1
      from   MODELLI
      where  DESCRIZIONE_ORD = var_tipo_modello
       and   var_tipo_modello is not null;

   --  Declaration of DeleteParentRestrict constraint for "TIPI_MODELLO_PARAMETRI"
   cursor cfk2_tipi_modello(var_tipo_modello varchar) is
      select 1
      from   TIPI_MODELLO_PARAMETRI
      where  TIPO_MODELLO = var_tipo_modello
       and   var_tipo_modello is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_MODELLO" if children still exist in "MODELLI"
      open  cfk1_tipi_modello(OLD_TIPO_MODELLO);
      fetch cfk1_tipi_modello into dummy;
      found := cfk1_tipi_modello%FOUND;
      close cfk1_tipi_modello;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Modelli. La registrazione di Tipi Modello non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_MODELLO" if children still exist in "TIPI_MODELLO_PARAMETRI"
      open  cfk2_tipi_modello(OLD_TIPO_MODELLO);
      fetch cfk2_tipi_modello into dummy;
      found := cfk2_tipi_modello%FOUND;
      close cfk2_tipi_modello;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Tipi Modello Parametri. La registrazione di Tipi Modello non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_MODELLO_PD */
/

-- Tigger TIPI_MODELLO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_MODELLO

create or replace trigger TIPI_MODELLO_TD
before DELETE
on TIPI_MODELLO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: MODELLI

      -- Child Restrict Table: TIPI_MODELLO_PARAMETRI

      TIPI_MODELLO_PD(:OLD.TIPO_MODELLO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_MODELLO_TD */
/

-- Procedure TIPI_MODELLO_PARAMETRI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TIPI_MODELLO_PARAMETRI

create or replace procedure TIPI_MODELLO_PARAMETRI_PI
(new_tipo_modello IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_MODELLO"
   cursor cpk1_tipi_modello_parametri(var_tipo_modello varchar) is
      select 1
      from   TIPI_MODELLO
      where  TIPO_MODELLO = var_tipo_modello
       and   var_tipo_modello is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_MODELLO" deve esistere quando si inserisce su "TIPI_MODELLO_PARAMETRI"
         if NEW_TIPO_MODELLO is not null then
            open  cpk1_tipi_modello_parametri(NEW_TIPO_MODELLO);
            fetch cpk1_tipi_modello_parametri into dummy;
            found := cpk1_tipi_modello_parametri%FOUND;
            close cpk1_tipi_modello_parametri;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Modello. La registrazione Tipi Modello Parametri non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_MODELLO_PARAMETRI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TIPI_MODELLO_PARAMETRI
/* End Trigger: TIPI_MODELLO_PARAMETRI_TC */

-- Procedure TIPI_MODELLO_PARAMETRI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_MODELLO_PARAMETRI

create or replace procedure TIPI_MODELLO_PARAMETRI_PU
(old_parametro_id IN number,
 old_tipo_modello IN varchar,
 new_parametro_id IN number,
 new_tipo_modello IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_MODELLO"
   cursor cpk1_tipi_modello_parametri(var_tipo_modello varchar) is
      select 1
      from   TIPI_MODELLO
      where  TIPO_MODELLO = var_tipo_modello
       and   var_tipo_modello is not null;

   --  Declaration of UpdateParentRestrict constraint for "MODELLI_DETTAGLIO"
   cursor cfk1_tipi_modello_parametri(var_parametro_id number) is
      select 1
      from   MODELLI_DETTAGLIO
      where  PARAMETRO_ID = var_parametro_id
       and   var_parametro_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_MODELLO" deve esistere quando si modifica "TIPI_MODELLO_PARAMETRI"
         if  NEW_TIPO_MODELLO is not null and ( seq = 0 )
         and (   (NEW_TIPO_MODELLO != OLD_TIPO_MODELLO or OLD_TIPO_MODELLO is null) ) then
            open  cpk1_tipi_modello_parametri(NEW_TIPO_MODELLO);
            fetch cpk1_tipi_modello_parametri into dummy;
            found := cpk1_tipi_modello_parametri%FOUND;
            close cpk1_tipi_modello_parametri;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Modello. La registrazione Tipi Modello Parametri non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "TIPI_MODELLO_PARAMETRI" non modificabile se esistono referenze su "MODELLI_DETTAGLIO"
      if (OLD_PARAMETRO_ID != NEW_PARAMETRO_ID) then
         open  cfk1_tipi_modello_parametri(OLD_PARAMETRO_ID);
         fetch cfk1_tipi_modello_parametri into dummy;
         found := cfk1_tipi_modello_parametri%FOUND;
         close cfk1_tipi_modello_parametri;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su MODELLI_DETTAGLIO. La registrazione di Tipi Modello Parametri non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_MODELLO_PARAMETRI_PU */
/

-- Trigger TIPI_MODELLO_PARAMETRI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_MODELLO_PARAMETRI

create or replace trigger TIPI_MODELLO_PARAMETRI_TIU
before INSERT
    or UPDATE
on TIPI_MODELLO_PARAMETRI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
       TIPI_MODELLO_PARAMETRI_NR (:new.parametro_id);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_MODELLO_PARAMETRI_PU(:OLD.PARAMETRO_ID,
                                   :OLD.TIPO_MODELLO,
                         :NEW.PARAMETRO_ID,
                         :NEW.TIPO_MODELLO);
         null;
      end if;
      if INSERTING then
         TIPI_MODELLO_PARAMETRI_PI(:NEW.TIPO_MODELLO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_MODELLO_PARAMETRI"
            cursor cpk_tipi_modello_parametri(var_PARAMETRO_ID number) is
               select 1
                 from   TIPI_MODELLO_PARAMETRI
                where  PARAMETRO_ID = var_PARAMETRO_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_MODELLO_PARAMETRI"
               if :new.PARAMETRO_ID is not null then
                  open  cpk_tipi_modello_parametri(:new.PARAMETRO_ID);
                  fetch cpk_tipi_modello_parametri into dummy;
                  found := cpk_tipi_modello_parametri%FOUND;
                  close cpk_tipi_modello_parametri;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PARAMETRO_ID||
                               '" gia'' presente in Tipi Modello Parametri. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_MODELLO_PARAMETRI_TIU */
/

-- Procedure TIPI_MODELLO_PARAMETRI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_MODELLO_PARAMETRI

create or replace procedure TIPI_MODELLO_PARAMETRI_PD
(old_parametro_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "MODELLI_DETTAGLIO"
   cursor cfk1_tipi_modello_parametri(var_parametro_id number) is
      select 1
      from   MODELLI_DETTAGLIO
      where  PARAMETRO_ID = var_parametro_id
       and   var_parametro_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_MODELLO_PARAMETRI" if children still exist in "MODELLI_DETTAGLIO"
      open  cfk1_tipi_modello_parametri(OLD_PARAMETRO_ID);
      fetch cfk1_tipi_modello_parametri into dummy;
      found := cfk1_tipi_modello_parametri%FOUND;
      close cfk1_tipi_modello_parametri;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su MODELLI_DETTAGLIO. La registrazione di Tipi Modello Parametri non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_MODELLO_PARAMETRI_PD */
/

-- Tigger TIPI_MODELLO_PARAMETRI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_MODELLO_PARAMETRI

create or replace trigger TIPI_MODELLO_PARAMETRI_TD
before DELETE
on TIPI_MODELLO_PARAMETRI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: MODELLI_DETTAGLIO

      TIPI_MODELLO_PARAMETRI_PD(:OLD.PARAMETRO_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_MODELLO_PARAMETRI_TD */
/

-- Procedure TIPI_NOTIFICA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_NOTIFICA

create or replace procedure TIPI_NOTIFICA_PU
(old_tipo_notifica IN number,
 new_tipo_notifica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_notifica(var_tipo_notifica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  TIPO_NOTIFICA = var_tipo_notifica
       and   var_tipo_notifica is not null;

   --  Declaration of UpdateParentRestrict constraint for "SPESE_NOTIFICA"
   cursor cfk2_tipi_notifica(var_tipo_notifica number) is
      select 1
      from   SPESE_NOTIFICA
      where  TIPO_NOTIFICA = var_tipo_notifica
       and   var_tipo_notifica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_NOTIFICA" non modificabile se esistono referenze su "PRATICHE_TRIBUTO"
      if (OLD_TIPO_NOTIFICA != NEW_TIPO_NOTIFICA) then
         open  cfk1_tipi_notifica(OLD_TIPO_NOTIFICA);
         fetch cfk1_tipi_notifica into dummy;
         found := cfk1_tipi_notifica%FOUND;
         close cfk1_tipi_notifica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Notifica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_NOTIFICA" non modificabile se esistono referenze su "SPESE_NOTIFICA"
      if (OLD_TIPO_NOTIFICA != NEW_TIPO_NOTIFICA) then
         open  cfk2_tipi_notifica(OLD_TIPO_NOTIFICA);
         fetch cfk2_tipi_notifica into dummy;
         found := cfk2_tipi_notifica%FOUND;
         close cfk2_tipi_notifica;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Spese Notifica. La registrazione di Tipi Notifica non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_NOTIFICA_PU */
/

-- Trigger TIPI_NOTIFICA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_NOTIFICA

create or replace trigger TIPI_NOTIFICA_TIU
before INSERT
    or UPDATE
on TIPI_NOTIFICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_NOTIFICA_PU(:OLD.TIPO_NOTIFICA,
                         :NEW.TIPO_NOTIFICA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_NOTIFICA"
            cursor cpk_tipi_notifica(var_TIPO_NOTIFICA number) is
               select 1
                 from   TIPI_NOTIFICA
                where  TIPO_NOTIFICA = var_TIPO_NOTIFICA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_NOTIFICA"
               if :new.TIPO_NOTIFICA is not null then
                  open  cpk_tipi_notifica(:new.TIPO_NOTIFICA);
                  fetch cpk_tipi_notifica into dummy;
                  found := cpk_tipi_notifica%FOUND;
                  close cpk_tipi_notifica;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_NOTIFICA||
                               '" gia'' presente in Tipi Notifica. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_NOTIFICA_TIU */
/

-- Procedure TIPI_NOTIFICA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_NOTIFICA

create or replace procedure TIPI_NOTIFICA_PD
(old_tipo_notifica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_notifica(var_tipo_notifica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  TIPO_NOTIFICA = var_tipo_notifica
       and   var_tipo_notifica is not null;

   --  Declaration of DeleteParentRestrict constraint for "SPESE_NOTIFICA"
   cursor cfk2_tipi_notifica(var_tipo_notifica number) is
      select 1
      from   SPESE_NOTIFICA
      where  TIPO_NOTIFICA = var_tipo_notifica
       and   var_tipo_notifica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_NOTIFICA" if children still exist in "PRATICHE_TRIBUTO"
      open  cfk1_tipi_notifica(OLD_TIPO_NOTIFICA);
      fetch cfk1_tipi_notifica into dummy;
      found := cfk1_tipi_notifica%FOUND;
      close cfk1_tipi_notifica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Notifica non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_NOTIFICA" if children still exist in "SPESE_NOTIFICA"
      open  cfk2_tipi_notifica(OLD_TIPO_NOTIFICA);
      fetch cfk2_tipi_notifica into dummy;
      found := cfk2_tipi_notifica%FOUND;
      close cfk2_tipi_notifica;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Spese Notifica. La registrazione di Tipi Notifica non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_NOTIFICA_PD */
/

-- Tigger TIPI_NOTIFICA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_NOTIFICA

create or replace trigger TIPI_NOTIFICA_TD
before DELETE
on TIPI_NOTIFICA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: PRATICHE_TRIBUTO

      -- Child Restrict Table: SPESE_NOTIFICA

      TIPI_NOTIFICA_PD(:OLD.TIPO_NOTIFICA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_NOTIFICA_TD */
/

-- Procedure TIPI_OGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_OGGETTO

create or replace procedure TIPI_OGGETTO_PU
(old_tipo_oggetto IN number,
 new_tipo_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI"
   cursor cfk1_tipi_oggetto(var_tipo_oggetto number) is
      select 1
      from   OGGETTI
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "RIVALUTAZIONI_RENDITA"
   cursor cfk2_tipi_oggetto(var_tipo_oggetto number) is
      select 1
      from   RIVALUTAZIONI_RENDITA
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_TRIBUTO"
   cursor cfk3_tipi_oggetto(var_tipo_oggetto number) is
      select 1
      from   OGGETTI_TRIBUTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk4_tipi_oggetto(var_tipo_oggetto number) is
      select 1
      from   OGGETTI_PRATICA
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  La colonna "TIPO_OGGETTO" non puo' essere modificata
      if OLD_TIPO_OGGETTO != NEW_TIPO_OGGETTO then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20001;
            errmsg := 'L''informazione Tipo Oggetto non puo'' essere modificata';
            raise integrity_error;
         end if;
      end if;

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_OGGETTO" non modificabile se esistono referenze su "OGGETTI"
      if (OLD_TIPO_OGGETTO != NEW_TIPO_OGGETTO) then
         open  cfk1_tipi_oggetto(OLD_TIPO_OGGETTO);
         fetch cfk1_tipi_oggetto into dummy;
         found := cfk1_tipi_oggetto%FOUND;
         close cfk1_tipi_oggetto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Tipi Oggetto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_OGGETTO" non modificabile se esistono referenze su "RIVALUTAZIONI_RENDITA"
      if (OLD_TIPO_OGGETTO != NEW_TIPO_OGGETTO) then
         open  cfk2_tipi_oggetto(OLD_TIPO_OGGETTO);
         fetch cfk2_tipi_oggetto into dummy;
         found := cfk2_tipi_oggetto%FOUND;
         close cfk2_tipi_oggetto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Rivalutazioni Rendita. La registrazione di Tipi Oggetto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_OGGETTO" non modificabile se esistono referenze su "OGGETTI_TRIBUTO"
      if (OLD_TIPO_OGGETTO != NEW_TIPO_OGGETTO) then
         open  cfk3_tipi_oggetto(OLD_TIPO_OGGETTO);
         fetch cfk3_tipi_oggetto into dummy;
         found := cfk3_tipi_oggetto%FOUND;
         close cfk3_tipi_oggetto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Tributo. La registrazione di Tipi Oggetto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_OGGETTO" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_TIPO_OGGETTO != NEW_TIPO_OGGETTO) then
         open  cfk4_tipi_oggetto(OLD_TIPO_OGGETTO);
         fetch cfk4_tipi_oggetto into dummy;
         found := cfk4_tipi_oggetto%FOUND;
         close cfk4_tipi_oggetto;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Tipi Oggetto non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_OGGETTO_PU */
/

-- Trigger TIPI_OGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_OGGETTO

create or replace trigger TIPI_OGGETTO_TIU
before INSERT
    or UPDATE
on TIPI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_OGGETTO_PU(:OLD.TIPO_OGGETTO,
                         :NEW.TIPO_OGGETTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_OGGETTO"
            cursor cpk_tipi_oggetto(var_TIPO_OGGETTO number) is
               select 1
                 from   TIPI_OGGETTO
                where  TIPO_OGGETTO = var_TIPO_OGGETTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_OGGETTO"
               if :new.TIPO_OGGETTO is not null then
                  open  cpk_tipi_oggetto(:new.TIPO_OGGETTO);
                  fetch cpk_tipi_oggetto into dummy;
                  found := cpk_tipi_oggetto%FOUND;
                  close cpk_tipi_oggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_OGGETTO||
                               '" gia'' presente in Tipi Oggetto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_OGGETTO_TIU */
/

-- Procedure TIPI_OGGETTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_OGGETTO

create or replace procedure TIPI_OGGETTO_PD
(old_tipo_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI"
   cursor cfk1_tipi_oggetto(var_tipo_oggetto number) is
      select 1
      from   OGGETTI
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Declaration of DeleteParentRestrict constraint for "RIVALUTAZIONI_RENDITA"
   cursor cfk2_tipi_oggetto(var_tipo_oggetto number) is
      select 1
      from   RIVALUTAZIONI_RENDITA
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_TRIBUTO"
   cursor cfk3_tipi_oggetto(var_tipo_oggetto number) is
      select 1
      from   OGGETTI_TRIBUTO
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk4_tipi_oggetto(var_tipo_oggetto number) is
      select 1
      from   OGGETTI_PRATICA
      where  TIPO_OGGETTO = var_tipo_oggetto
       and   var_tipo_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_OGGETTO" if children still exist in "OGGETTI"
      open  cfk1_tipi_oggetto(OLD_TIPO_OGGETTO);
      fetch cfk1_tipi_oggetto into dummy;
      found := cfk1_tipi_oggetto%FOUND;
      close cfk1_tipi_oggetto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Tipi Oggetto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_OGGETTO" if children still exist in "RIVALUTAZIONI_RENDITA"
      open  cfk2_tipi_oggetto(OLD_TIPO_OGGETTO);
      fetch cfk2_tipi_oggetto into dummy;
      found := cfk2_tipi_oggetto%FOUND;
      close cfk2_tipi_oggetto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Rivalutazioni Rendita. La registrazione di Tipi Oggetto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_OGGETTO" if children still exist in "OGGETTI_TRIBUTO"
      open  cfk3_tipi_oggetto(OLD_TIPO_OGGETTO);
      fetch cfk3_tipi_oggetto into dummy;
      found := cfk3_tipi_oggetto%FOUND;
      close cfk3_tipi_oggetto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Tributo. La registrazione di Tipi Oggetto non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_OGGETTO" if children still exist in "OGGETTI_PRATICA"
      open  cfk4_tipi_oggetto(OLD_TIPO_OGGETTO);
      fetch cfk4_tipi_oggetto into dummy;
      found := cfk4_tipi_oggetto%FOUND;
      close cfk4_tipi_oggetto;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di Tipi Oggetto non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_OGGETTO_PD */
/

-- Tigger TIPI_OGGETTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_OGGETTO

create or replace trigger TIPI_OGGETTO_TD
before DELETE
on TIPI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI

      -- Child Restrict Table: RIVALUTAZIONI_RENDITA

      -- Child Restrict Table: OGGETTI_TRIBUTO

      -- Child Restrict Table: OGGETTI_PRATICA

      TIPI_OGGETTO_PD(:OLD.TIPO_OGGETTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_OGGETTO_TD */
/

-- Procedure TIPI_PARAMETRO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_PARAMETRO

create or replace procedure TIPI_PARAMETRO_PU
(old_tipo_parametro IN varchar,
 new_tipo_parametro IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "PARAMETRI_UTENTE"
   cursor cfk1_tipi_parametro(var_tipo_parametro varchar) is
      select 1
      from   PARAMETRI_UTENTE
      where  TIPO_PARAMETRO = var_tipo_parametro
       and   var_tipo_parametro is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_PARAMETRO" non modificabile se esistono referenze su "PARAMETRI_UTENTE"
      if (OLD_TIPO_PARAMETRO != NEW_TIPO_PARAMETRO) then
         open  cfk1_tipi_parametro(OLD_TIPO_PARAMETRO);
         fetch cfk1_tipi_parametro into dummy;
         found := cfk1_tipi_parametro%FOUND;
         close cfk1_tipi_parametro;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Parametri Utente. La registrazione di Tipi_Parametro non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_PARAMETRO_PU */
/

-- Trigger TIPI_PARAMETRO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_PARAMETRO

create or replace trigger TIPI_PARAMETRO_TIU
before INSERT
    or UPDATE
on TIPI_PARAMETRO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_PARAMETRO_PU(:OLD.TIPO_PARAMETRO,
                         :NEW.TIPO_PARAMETRO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_PARAMETRO"
            cursor cpk_tipi_parametro(var_TIPO_PARAMETRO varchar) is
               select 1
                 from   TIPI_PARAMETRO
                where  TIPO_PARAMETRO = var_TIPO_PARAMETRO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_PARAMETRO"
               if :new.TIPO_PARAMETRO is not null then
                  open  cpk_tipi_parametro(:new.TIPO_PARAMETRO);
                  fetch cpk_tipi_parametro into dummy;
                  found := cpk_tipi_parametro%FOUND;
                  close cpk_tipi_parametro;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_PARAMETRO||
                               '" gia'' presente in Tipi_Parametro. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_PARAMETRO_TIU */
/

-- Procedure TIPI_PARAMETRO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_PARAMETRO

create or replace procedure TIPI_PARAMETRO_PD
(old_tipo_parametro IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "PARAMETRI_UTENTE"
   cursor cfk1_tipi_parametro(var_tipo_parametro varchar) is
      select 1
      from   PARAMETRI_UTENTE
      where  TIPO_PARAMETRO = var_tipo_parametro
       and   var_tipo_parametro is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_PARAMETRO" if children still exist in "PARAMETRI_UTENTE"
      open  cfk1_tipi_parametro(OLD_TIPO_PARAMETRO);
      fetch cfk1_tipi_parametro into dummy;
      found := cfk1_tipi_parametro%FOUND;
      close cfk1_tipi_parametro;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Parametri Utente. La registrazione di Tipi_Parametro non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_PARAMETRO_PD */
/

-- Tigger TIPI_PARAMETRO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_PARAMETRO

create or replace trigger TIPI_PARAMETRO_TD
before DELETE
on TIPI_PARAMETRO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: PARAMETRI_UTENTE

      TIPI_PARAMETRO_PD(:OLD.TIPO_PARAMETRO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_PARAMETRO_TD */
/

-- Procedure TIPI_RECAPITO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_RECAPITO

create or replace procedure TIPI_RECAPITO_PU
(old_tipo_recapito IN number,
 new_tipo_recapito IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "RECAPITI_SOGGETTO"
   cursor cfk1_tipi_recapito(var_tipo_recapito number) is
      select 1
      from   RECAPITI_SOGGETTO
      where  TIPO_RECAPITO = var_tipo_recapito
       and   var_tipo_recapito is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_RECAPITO" non modificabile se esistono referenze su "RECAPITI_SOGGETTO"
      if (OLD_TIPO_RECAPITO != NEW_TIPO_RECAPITO) then
         open  cfk1_tipi_recapito(OLD_TIPO_RECAPITO);
         fetch cfk1_tipi_recapito into dummy;
         found := cfk1_tipi_recapito%FOUND;
         close cfk1_tipi_recapito;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su RECAPITI_SOGGETTO. La registrazione di TIPI_RECAPITO non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_RECAPITO_PU */
/

-- Trigger TIPI_RECAPITO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_RECAPITO

create or replace trigger TIPI_RECAPITO_TIU
before INSERT
    or UPDATE
on TIPI_RECAPITO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_RECAPITO_PU(:OLD.TIPO_RECAPITO,
                         :NEW.TIPO_RECAPITO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_RECAPITO"
            cursor cpk_tipi_recapito(var_TIPO_RECAPITO number) is
               select 1
                 from   TIPI_RECAPITO
                where  TIPO_RECAPITO = var_TIPO_RECAPITO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_RECAPITO"
               if :new.TIPO_RECAPITO is not null then
                  open  cpk_tipi_recapito(:new.TIPO_RECAPITO);
                  fetch cpk_tipi_recapito into dummy;
                  found := cpk_tipi_recapito%FOUND;
                  close cpk_tipi_recapito;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_RECAPITO||
                               '" gia'' presente in TIPI_RECAPITO. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_RECAPITO_TIU */
/

-- Procedure TIPI_RECAPITO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_RECAPITO

create or replace procedure TIPI_RECAPITO_PD
(old_tipo_recapito IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "RECAPITI_SOGGETTO"
   cursor cfk1_tipi_recapito(var_tipo_recapito number) is
      select 1
      from   RECAPITI_SOGGETTO
      where  TIPO_RECAPITO = var_tipo_recapito
       and   var_tipo_recapito is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_RECAPITO" if children still exist in "RECAPITI_SOGGETTO"
      open  cfk1_tipi_recapito(OLD_TIPO_RECAPITO);
      fetch cfk1_tipi_recapito into dummy;
      found := cfk1_tipi_recapito%FOUND;
      close cfk1_tipi_recapito;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su RECAPITI_SOGGETTO. La registrazione di TIPI_RECAPITO non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_RECAPITO_PD */
/

-- Tigger TIPI_RECAPITO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_RECAPITO

create or replace trigger TIPI_RECAPITO_TD
before DELETE
on TIPI_RECAPITO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: RECAPITI_SOGGETTO

      TIPI_RECAPITO_PD(:OLD.TIPO_RECAPITO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_RECAPITO_TD */
/

-- Procedure TIPI_RICHIEDENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_RICHIEDENTE

create or replace procedure TIPI_RICHIEDENTE_PU
(old_tipo_richiedente IN number,
 new_tipo_richiedente IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "CONTATTI_CONTRIBUENTE"
   cursor cfk1_tipi_richiedente(var_tipo_richiedente number) is
      select 1
      from   CONTATTI_CONTRIBUENTE
      where  TIPO_RICHIEDENTE = var_tipo_richiedente
       and   var_tipo_richiedente is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_RICHIEDENTE" non modificabile se esistono referenze su "CONTATTI_CONTRIBUENTE"
      if (OLD_TIPO_RICHIEDENTE != NEW_TIPO_RICHIEDENTE) then
         open  cfk1_tipi_richiedente(OLD_TIPO_RICHIEDENTE);
         fetch cfk1_tipi_richiedente into dummy;
         found := cfk1_tipi_richiedente%FOUND;
         close cfk1_tipi_richiedente;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Contatti Contribuente. La registrazione di Tipi Richiedente non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_RICHIEDENTE_PU */
/

-- Trigger TIPI_RICHIEDENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_RICHIEDENTE

create or replace trigger TIPI_RICHIEDENTE_TIU
before INSERT
    or UPDATE
on TIPI_RICHIEDENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_RICHIEDENTE_PU(:OLD.TIPO_RICHIEDENTE,
                         :NEW.TIPO_RICHIEDENTE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_RICHIEDENTE"
            cursor cpk_tipi_richiedente(var_TIPO_RICHIEDENTE number) is
               select 1
                 from   TIPI_RICHIEDENTE
                where  TIPO_RICHIEDENTE = var_TIPO_RICHIEDENTE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_RICHIEDENTE"
               if :new.TIPO_RICHIEDENTE is not null then
                  open  cpk_tipi_richiedente(:new.TIPO_RICHIEDENTE);
                  fetch cpk_tipi_richiedente into dummy;
                  found := cpk_tipi_richiedente%FOUND;
                  close cpk_tipi_richiedente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_RICHIEDENTE||
                               '" gia'' presente in Tipi Richiedente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_RICHIEDENTE_TIU */
/

-- Procedure TIPI_RICHIEDENTE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_RICHIEDENTE

create or replace procedure TIPI_RICHIEDENTE_PD
(old_tipo_richiedente IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "CONTATTI_CONTRIBUENTE"
   cursor cfk1_tipi_richiedente(var_tipo_richiedente number) is
      select 1
      from   CONTATTI_CONTRIBUENTE
      where  TIPO_RICHIEDENTE = var_tipo_richiedente
       and   var_tipo_richiedente is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_RICHIEDENTE" if children still exist in "CONTATTI_CONTRIBUENTE"
      open  cfk1_tipi_richiedente(OLD_TIPO_RICHIEDENTE);
      fetch cfk1_tipi_richiedente into dummy;
      found := cfk1_tipi_richiedente%FOUND;
      close cfk1_tipi_richiedente;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Contatti Contribuente. La registrazione di Tipi Richiedente non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_RICHIEDENTE_PD */
/

-- Tigger TIPI_RICHIEDENTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_RICHIEDENTE

create or replace trigger TIPI_RICHIEDENTE_TD
before DELETE
on TIPI_RICHIEDENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: CONTATTI_CONTRIBUENTE

      TIPI_RICHIEDENTE_PD(:OLD.TIPO_RICHIEDENTE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_RICHIEDENTE_TD */
/

-- Procedure TIPI_RIDUZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table TIPI_RIDUZIONE

create or replace procedure TIPI_RIDUZIONE_PI
(new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk1_tipi_riduzione(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "TIPI_RIDUZIONE"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk1_tipi_riduzione(NEW_TIPO_TRIBUTO);
            fetch cpk1_tipi_riduzione into dummy;
            found := cpk1_tipi_riduzione%FOUND;
            close cpk1_tipi_riduzione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione TIPI_RIDUZIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_RIDUZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table TIPI_RIDUZIONE
/* End Trigger: TIPI_RIDUZIONE_TC */

-- Procedure TIPI_RIDUZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_RIDUZIONE

create or replace procedure TIPI_RIDUZIONE_PU
(old_tipo_riduzione IN number,
 old_tipo_tributo IN varchar,
 new_tipo_riduzione IN number,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk1_tipi_riduzione(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_tipi_riduzione(var_tipo_riduzione number) is
      select 1
      from   OGGETTI_PRATICA
      where  TIPO_RIDUZIONE = var_tipo_riduzione
       and   var_tipo_riduzione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "TIPI_RIDUZIONE"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk1_tipi_riduzione(NEW_TIPO_TRIBUTO);
            fetch cpk1_tipi_riduzione into dummy;
            found := cpk1_tipi_riduzione%FOUND;
            close cpk1_tipi_riduzione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione TIPI_RIDUZIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "TIPI_RIDUZIONE" non modificabile se esistono referenze su "OGGETTI_PRATICA"
      if (OLD_TIPO_RIDUZIONE != NEW_TIPO_RIDUZIONE) then
         open  cfk1_tipi_riduzione(OLD_TIPO_RIDUZIONE);
         fetch cfk1_tipi_riduzione into dummy;
         found := cfk1_tipi_riduzione%FOUND;
         close cfk1_tipi_riduzione;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di TIPI_RIDUZIONE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_RIDUZIONE_PU */
/

-- Trigger TIPI_RIDUZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_RIDUZIONE

create or replace trigger TIPI_RIDUZIONE_TIU
before INSERT
    or UPDATE
on TIPI_RIDUZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_RIDUZIONE_PU(:OLD.TIPO_RIDUZIONE,
                           :OLD.TIPO_TRIBUTO,
                         :NEW.TIPO_RIDUZIONE,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         TIPI_RIDUZIONE_PI(:NEW.TIPO_TRIBUTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_RIDUZIONE"
            cursor cpk_tipi_riduzione(var_TIPO_RIDUZIONE number) is
               select 1
                 from   TIPI_RIDUZIONE
                where  TIPO_RIDUZIONE = var_TIPO_RIDUZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_RIDUZIONE"
               if :new.TIPO_RIDUZIONE is not null then
                  open  cpk_tipi_riduzione(:new.TIPO_RIDUZIONE);
                  fetch cpk_tipi_riduzione into dummy;
                  found := cpk_tipi_riduzione%FOUND;
                  close cpk_tipi_riduzione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_RIDUZIONE||
                               '" gia'' presente in TIPI_RIDUZIONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_RIDUZIONE_TIU */
/

-- Procedure TIPI_RIDUZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_RIDUZIONE

create or replace procedure TIPI_RIDUZIONE_PD
(old_tipo_riduzione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_PRATICA"
   cursor cfk1_tipi_riduzione(var_tipo_riduzione number) is
      select 1
      from   OGGETTI_PRATICA
      where  TIPO_RIDUZIONE = var_tipo_riduzione
       and   var_tipo_riduzione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_RIDUZIONE" if children still exist in "OGGETTI_PRATICA"
      open  cfk1_tipi_riduzione(OLD_TIPO_RIDUZIONE);
      fetch cfk1_tipi_riduzione into dummy;
      found := cfk1_tipi_riduzione%FOUND;
      close cfk1_tipi_riduzione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Pratica. La registrazione di TIPI_RIDUZIONE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_RIDUZIONE_PD */
/

-- Tigger TIPI_RIDUZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_RIDUZIONE

create or replace trigger TIPI_RIDUZIONE_TD
before DELETE
on TIPI_RIDUZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI_PRATICA

      TIPI_RIDUZIONE_PD(:OLD.TIPO_RIDUZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_RIDUZIONE_TD */
/

-- Procedure TIPI_SPEDIZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_SPEDIZIONE

create or replace procedure TIPI_SPEDIZIONE_PU
(old_tipo_spedizione IN varchar,
 new_tipo_spedizione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_SPEDIZIONE_PU */
/

-- Trigger TIPI_SPEDIZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_SPEDIZIONE

create or replace trigger TIPI_SPEDIZIONE_TIU
before INSERT
    or UPDATE
on TIPI_SPEDIZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_SPEDIZIONE_PU(:OLD.TIPO_SPEDIZIONE,
                         :NEW.TIPO_SPEDIZIONE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_SPEDIZIONE"
            cursor cpk_tipi_spedizione(var_TIPO_SPEDIZIONE varchar) is
               select 1
                 from   TIPI_SPEDIZIONE
                where  TIPO_SPEDIZIONE = var_TIPO_SPEDIZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_SPEDIZIONE"
               if :new.TIPO_SPEDIZIONE is not null then
                  open  cpk_tipi_spedizione(:new.TIPO_SPEDIZIONE);
                  fetch cpk_tipi_spedizione into dummy;
                  found := cpk_tipi_spedizione%FOUND;
                  close cpk_tipi_spedizione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_SPEDIZIONE||
                               '" gia'' presente in Tipi Spedizione. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "TIPI_SPEDIZIONE" for all children in "ATTIVITA_ELABORAZIONE"
         if (:OLD.TIPO_SPEDIZIONE != :NEW.TIPO_SPEDIZIONE) then
            update ATTIVITA_ELABORAZIONE
             set   TIPO_SPEDIZIONE = :NEW.TIPO_SPEDIZIONE
            where  TIPO_SPEDIZIONE = :OLD.TIPO_SPEDIZIONE;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_SPEDIZIONE_TIU */
/

-- Procedure TIPI_SPEDIZIONE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_SPEDIZIONE

create or replace procedure TIPI_SPEDIZIONE_PD
(old_tipo_spedizione IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "ATTIVITA_ELABORAZIONE"
   cursor cfk1_tipi_spedizione(var_tipo_spedizione varchar) is
      select 1
      from   ATTIVITA_ELABORAZIONE
      where  TIPO_SPEDIZIONE = var_tipo_spedizione
       and   var_tipo_spedizione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_SPEDIZIONE" if children still exist in "ATTIVITA_ELABORAZIONE"
      open  cfk1_tipi_spedizione(OLD_TIPO_SPEDIZIONE);
      fetch cfk1_tipi_spedizione into dummy;
      found := cfk1_tipi_spedizione%FOUND;
      close cfk1_tipi_spedizione;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Attivita Elaborazione. La registrazione di Tipi Spedizione non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_SPEDIZIONE_PD */
/

-- Tigger TIPI_SPEDIZIONE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_SPEDIZIONE

create or replace trigger TIPI_SPEDIZIONE_TD
before DELETE
on TIPI_SPEDIZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: ATTIVITA_ELABORAZIONE

      TIPI_SPEDIZIONE_PD(:OLD.TIPO_SPEDIZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_SPEDIZIONE_TD */
/

-- Procedure TIPI_STATO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_STATO

create or replace procedure TIPI_STATO_PU
(old_tipo_stato IN varchar,
 new_tipo_stato IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   PRATICHE_TRIBUTO
      where  STATO_ACCERTAMENTO = var_tipo_stato
       and   var_tipo_stato is not null;

   --  Declaration of UpdateParentRestrict constraint for "ITER_PRATICA"
   cursor cfk2_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   ITER_PRATICA
      where  STATO = var_tipo_stato
       and   var_tipo_stato is not null;

   --  Declaration of UpdateParentRestrict constraint for "DATI_CONTABILI"
   cursor cfk3_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   DATI_CONTABILI
      where  STATO_PRATICA = var_tipo_stato
       and   var_tipo_stato is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk4_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   SUPPORTO_SERVIZI
      where  STATO = var_tipo_stato
       and   var_tipo_stato is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk5_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   SUPPORTO_SERVIZI
      where  LIQ2_STATO = var_tipo_stato
       and   var_tipo_stato is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_STATO" non modificabile se esistono referenze su "PRATICHE_TRIBUTO"
      if (OLD_TIPO_STATO != NEW_TIPO_STATO) then
         open  cfk1_tipi_stato(OLD_TIPO_STATO);
         fetch cfk1_tipi_stato into dummy;
         found := cfk1_tipi_stato%FOUND;
         close cfk1_tipi_stato;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Stato non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_STATO" non modificabile se esistono referenze su "ITER_PRATICA"
      if (OLD_TIPO_STATO != NEW_TIPO_STATO) then
         open  cfk2_tipi_stato(OLD_TIPO_STATO);
         fetch cfk2_tipi_stato into dummy;
         found := cfk2_tipi_stato%FOUND;
         close cfk2_tipi_stato;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Iter Pratica. La registrazione di Tipi Stato non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_STATO" non modificabile se esistono referenze su "DATI_CONTABILI"
      if (OLD_TIPO_STATO != NEW_TIPO_STATO) then
         open  cfk3_tipi_stato(OLD_TIPO_STATO);
         fetch cfk3_tipi_stato into dummy;
         found := cfk3_tipi_stato%FOUND;
         close cfk3_tipi_stato;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Dati Contabili. La registrazione di Tipi Stato non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_STATO" non modificabile se esistono referenze su "SUPPORTO_SERVIZI"
      if (OLD_TIPO_STATO != NEW_TIPO_STATO) then
         open  cfk4_tipi_stato(OLD_TIPO_STATO);
         fetch cfk4_tipi_stato into dummy;
         found := cfk4_tipi_stato%FOUND;
         close cfk4_tipi_stato;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Stato non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_STATO" non modificabile se esistono referenze su "SUPPORTO_SERVIZI"
      if (OLD_TIPO_STATO != NEW_TIPO_STATO) then
         open  cfk5_tipi_stato(OLD_TIPO_STATO);
         fetch cfk5_tipi_stato into dummy;
         found := cfk5_tipi_stato%FOUND;
         close cfk5_tipi_stato;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Stato non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_STATO_PU */
/

-- Trigger TIPI_STATO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_STATO

create or replace trigger TIPI_STATO_TIU
before INSERT
    or UPDATE
on TIPI_STATO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_STATO_PU(:OLD.TIPO_STATO,
                         :NEW.TIPO_STATO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_STATO"
            cursor cpk_tipi_stato(var_TIPO_STATO varchar) is
               select 1
                 from   TIPI_STATO
                where  TIPO_STATO = var_TIPO_STATO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_STATO"
               if :new.TIPO_STATO is not null then
                  open  cpk_tipi_stato(:new.TIPO_STATO);
                  fetch cpk_tipi_stato into dummy;
                  found := cpk_tipi_stato%FOUND;
                  close cpk_tipi_stato;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_STATO||
                               '" gia'' presente in Tipi Stato. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_STATO_TIU */
/

-- Procedure TIPI_STATO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_STATO

create or replace procedure TIPI_STATO_PD
(old_tipo_stato IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   PRATICHE_TRIBUTO
      where  STATO_ACCERTAMENTO = var_tipo_stato
       and   var_tipo_stato is not null;

   --  Declaration of DeleteParentRestrict constraint for "ITER_PRATICA"
   cursor cfk2_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   ITER_PRATICA
      where  STATO = var_tipo_stato
       and   var_tipo_stato is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_CONTABILI"
   cursor cfk3_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   DATI_CONTABILI
      where  STATO_PRATICA = var_tipo_stato
       and   var_tipo_stato is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk4_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   SUPPORTO_SERVIZI
      where  STATO = var_tipo_stato
       and   var_tipo_stato is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk5_tipi_stato(var_tipo_stato varchar) is
      select 1
      from   SUPPORTO_SERVIZI
      where  LIQ2_STATO = var_tipo_stato
       and   var_tipo_stato is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_STATO" if children still exist in "PRATICHE_TRIBUTO"
      open  cfk1_tipi_stato(OLD_TIPO_STATO);
      fetch cfk1_tipi_stato into dummy;
      found := cfk1_tipi_stato%FOUND;
      close cfk1_tipi_stato;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Stato non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_STATO" if children still exist in "ITER_PRATICA"
      open  cfk2_tipi_stato(OLD_TIPO_STATO);
      fetch cfk2_tipi_stato into dummy;
      found := cfk2_tipi_stato%FOUND;
      close cfk2_tipi_stato;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Iter Pratica. La registrazione di Tipi Stato non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_STATO" if children still exist in "DATI_CONTABILI"
      open  cfk3_tipi_stato(OLD_TIPO_STATO);
      fetch cfk3_tipi_stato into dummy;
      found := cfk3_tipi_stato%FOUND;
      close cfk3_tipi_stato;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dati Contabili. La registrazione di Tipi Stato non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_STATO" if children still exist in "SUPPORTO_SERVIZI"
      open  cfk4_tipi_stato(OLD_TIPO_STATO);
      fetch cfk4_tipi_stato into dummy;
      found := cfk4_tipi_stato%FOUND;
      close cfk4_tipi_stato;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Stato non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_STATO" if children still exist in "SUPPORTO_SERVIZI"
      open  cfk5_tipi_stato(OLD_TIPO_STATO);
      fetch cfk5_tipi_stato into dummy;
      found := cfk5_tipi_stato%FOUND;
      close cfk5_tipi_stato;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Stato non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_STATO_PD */
/

-- Tigger TIPI_STATO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_STATO

create or replace trigger TIPI_STATO_TD
before DELETE
on TIPI_STATO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: PRATICHE_TRIBUTO

      -- Child Restrict Table: ITER_PRATICA

      -- Child Restrict Table: DATI_CONTABILI

      -- Child Restrict Table: SUPPORTO_SERVIZI

      -- Child Restrict Table: SUPPORTO_SERVIZI

      TIPI_STATO_PD(:OLD.TIPO_STATO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_STATO_TD */
/

-- Procedure TIPI_STATO_CONTRIBUENTE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_STATO_CONTRIBUENTE

create or replace procedure TIPI_STATO_CONTRIBUENTE_PU
(old_tipo_stato_contribuente IN number,
 new_tipo_stato_contribuente IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_STATO_CONTRIBUENTE_PU */
/

-- Trigger TIPI_STATO_CONTRIBUENTE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_STATO_CONTRIBUENTE

create or replace trigger TIPI_STATO_CONTRIBUENTE_TIU
before INSERT
    or UPDATE
on TIPI_STATO_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_STATO_CONTRIBUENTE_PU(:OLD.TIPO_STATO_CONTRIBUENTE,
                         :NEW.TIPO_STATO_CONTRIBUENTE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_STATO_CONTRIBUENTE"
            cursor cpk_tipi_stato_contribuente(var_TIPO_STATO_CONTRIBUENTE number) is
               select 1
                 from   TIPI_STATO_CONTRIBUENTE
                where  TIPO_STATO_CONTRIBUENTE = var_TIPO_STATO_CONTRIBUENTE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_STATO_CONTRIBUENTE"
               if :new.TIPO_STATO_CONTRIBUENTE is not null then
                  open  cpk_tipi_stato_contribuente(:new.TIPO_STATO_CONTRIBUENTE);
                  fetch cpk_tipi_stato_contribuente into dummy;
                  found := cpk_tipi_stato_contribuente%FOUND;
                  close cpk_tipi_stato_contribuente;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_STATO_CONTRIBUENTE||
                               '" gia'' presente in Tipi Stato Contribuente. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "TIPI_STATO_CONTRIBUENTE" for all children in "STATI_CONTRIBUENTE"
         if (:OLD.TIPO_STATO_CONTRIBUENTE != :NEW.TIPO_STATO_CONTRIBUENTE) then
            update STATI_CONTRIBUENTE
             set   TIPO_STATO_CONTRIBUENTE = :NEW.TIPO_STATO_CONTRIBUENTE
            where  TIPO_STATO_CONTRIBUENTE = :OLD.TIPO_STATO_CONTRIBUENTE;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_STATO_CONTRIBUENTE_TIU */
/

-- Procedure TIPI_STATO_CONTRIBUENTE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_STATO_CONTRIBUENTE

create or replace procedure TIPI_STATO_CONTRIBUENTE_PD
(old_tipo_stato_contribuente IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "STATI_CONTRIBUENTE"
   cursor cfk1_tipi_stato_contribuente(var_tipo_stato_contribuente number) is
      select 1
      from   STATI_CONTRIBUENTE
      where  TIPO_STATO_CONTRIBUENTE = var_tipo_stato_contribuente
       and   var_tipo_stato_contribuente is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_STATO_CONTRIBUENTE" if children still exist in "STATI_CONTRIBUENTE"
      open  cfk1_tipi_stato_contribuente(OLD_TIPO_STATO_CONTRIBUENTE);
      fetch cfk1_tipi_stato_contribuente into dummy;
      found := cfk1_tipi_stato_contribuente%FOUND;
      close cfk1_tipi_stato_contribuente;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Stati Contribuente. La registrazione di Tipi Stato Contribuente non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_STATO_CONTRIBUENTE_PD */
/

-- Tigger TIPI_STATO_CONTRIBUENTE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_STATO_CONTRIBUENTE

create or replace trigger TIPI_STATO_CONTRIBUENTE_TD
before DELETE
on TIPI_STATO_CONTRIBUENTE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: STATI_CONTRIBUENTE

      TIPI_STATO_CONTRIBUENTE_PD(:OLD.TIPO_STATO_CONTRIBUENTE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_STATO_CONTRIBUENTE_TD */
/

-- Procedure TIPI_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_TRIBUTO

create or replace procedure TIPI_TRIBUTO_PU
(old_tipo_tributo IN varchar,
 new_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "DELEGHE_BANCARIE"
   cursor cfk1_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   DELEGHE_BANCARIE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "ALLINEAMENTO_DELEGHE"
   cursor cfk2_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   ALLINEAMENTO_DELEGHE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "RID_IMPAGATI"
   cursor cfk3_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   RID_IMPAGATI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "TIPI_ALIQUOTA"
   cursor cfk4_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_ALIQUOTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk5_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   UTILIZZI_OGGETTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "DETRAZIONI"
   cursor cfk6_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   DETRAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "MOTIVI_DETRAZIONE"
   cursor cfk7_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   MOTIVI_DETRAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_TRIBUTO_DEFUNTI"
   cursor cfk8_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SUCCESSIONI_TRIBUTO_DEFUNTI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUCCESSIONI_TRIBUTO_EREDI"
   cursor cfk9_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SUCCESSIONI_TRIBUTO_EREDI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "CONTATTI_CONTRIBUENTE"
   cursor cfk10_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   CONTATTI_CONTRIBUENTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "DETRAZIONI_MOBILI"
   cursor cfk11_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   DETRAZIONI_MOBILI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "COMPENSAZIONI"
   cursor cfk12_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   COMPENSAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "ALIQUOTE_MOBILI"
   cursor cfk13_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   ALIQUOTE_MOBILI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "ANOMALIE_PARAMETRI"
   cursor cfk14_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   ANOMALIE_PARAMETRI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "COMUNICAZIONE_PARAMETRI"
   cursor cfk15_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   COMUNICAZIONE_PARAMETRI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "CAUSALI"
   cursor cfk16_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   CAUSALI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "GRUPPI_TRIBUTO"
   cursor cfk17_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "RUOLI_AUTOMATICI"
   cursor cfk18_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   RUOLI_AUTOMATICI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "LIMITI_CALCOLO"
   cursor cfk19_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   LIMITI_CALCOLO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "AGGI"
   cursor cfk20_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   AGGI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk21_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SUPPORTO_SERVIZI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "STATI_CONTRIBUENTE"
   cursor cfk22_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   STATI_CONTRIBUENTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of UpdateParentRestrict constraint for "BONUS_SOCIALI_CONTRIBUENTE"
   cursor cfk23_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   BONUS_SOCIALI_CONTRIBUENTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "DELEGHE_BANCARIE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk1_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk1_tipi_tributo into dummy;
         found := cfk1_tipi_tributo%FOUND;
         close cfk1_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Deleghe Bancarie. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "ALLINEAMENTO_DELEGHE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk2_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk2_tipi_tributo into dummy;
         found := cfk2_tipi_tributo%FOUND;
         close cfk2_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Allineamento Deleghe. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "RID_IMPAGATI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk3_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk3_tipi_tributo into dummy;
         found := cfk3_tipi_tributo%FOUND;
         close cfk3_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su RID_IMPAGATI. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "TIPI_ALIQUOTA"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk4_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk4_tipi_tributo into dummy;
         found := cfk4_tipi_tributo%FOUND;
         close cfk4_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Tipi Aliquota. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "UTILIZZI_OGGETTO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk5_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk5_tipi_tributo into dummy;
         found := cfk5_tipi_tributo%FOUND;
         close cfk5_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "DETRAZIONI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk6_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk6_tipi_tributo into dummy;
         found := cfk6_tipi_tributo%FOUND;
         close cfk6_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Detrazioni. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "MOTIVI_DETRAZIONE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk7_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk7_tipi_tributo into dummy;
         found := cfk7_tipi_tributo%FOUND;
         close cfk7_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Motivi Detrazione. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "SUCCESSIONI_TRIBUTO_DEFUNTI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk8_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk8_tipi_tributo into dummy;
         found := cfk8_tipi_tributo%FOUND;
         close cfk8_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Successioni Tributo Defunti. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "SUCCESSIONI_TRIBUTO_EREDI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk9_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk9_tipi_tributo into dummy;
         found := cfk9_tipi_tributo%FOUND;
         close cfk9_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Successioni Tributo Eredi. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "CONTATTI_CONTRIBUENTE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk10_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk10_tipi_tributo into dummy;
         found := cfk10_tipi_tributo%FOUND;
         close cfk10_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Contatti Contribuente. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "DETRAZIONI_MOBILI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk11_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk11_tipi_tributo into dummy;
         found := cfk11_tipi_tributo%FOUND;
         close cfk11_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Detrazioni Mobili. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "COMPENSAZIONI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk12_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk12_tipi_tributo into dummy;
         found := cfk12_tipi_tributo%FOUND;
         close cfk12_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Compensazioni. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "ALIQUOTE_MOBILI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk13_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk13_tipi_tributo into dummy;
         found := cfk13_tipi_tributo%FOUND;
         close cfk13_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ALIQUOTE_MOBILI. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "ANOMALIE_PARAMETRI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk14_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk14_tipi_tributo into dummy;
         found := cfk14_tipi_tributo%FOUND;
         close cfk14_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su ANOMALIE_PARAMETRI. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "COMUNICAZIONE_PARAMETRI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk15_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk15_tipi_tributo into dummy;
         found := cfk15_tipi_tributo%FOUND;
         close cfk15_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su COMUNICAZIONE_PARAMETRI. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "CAUSALI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk16_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk16_tipi_tributo into dummy;
         found := cfk16_tipi_tributo%FOUND;
         close cfk16_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Causali. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "GRUPPI_TRIBUTO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk17_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk17_tipi_tributo into dummy;
         found := cfk17_tipi_tributo%FOUND;
         close cfk17_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Gruppi_tributo. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "RUOLI_AUTOMATICI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk18_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk18_tipi_tributo into dummy;
         found := cfk18_tipi_tributo%FOUND;
         close cfk18_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Ruoli Automatici. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "LIMITI_CALCOLO"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk19_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk19_tipi_tributo into dummy;
         found := cfk19_tipi_tributo%FOUND;
         close cfk19_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Limiti calcolo. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "AGGI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk20_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk20_tipi_tributo into dummy;
         found := cfk20_tipi_tributo%FOUND;
         close cfk20_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Aggi. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "SUPPORTO_SERVIZI"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk21_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk21_tipi_tributo into dummy;
         found := cfk21_tipi_tributo%FOUND;
         close cfk21_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "STATI_CONTRIBUENTE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk22_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk22_tipi_tributo into dummy;
         found := cfk22_tipi_tributo%FOUND;
         close cfk22_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Stati Contribuente. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_TRIBUTO" non modificabile se esistono referenze su "BONUS_SOCIALI_CONTRIBUENTE"
      if (OLD_TIPO_TRIBUTO != NEW_TIPO_TRIBUTO) then
         open  cfk23_tipi_tributo(OLD_TIPO_TRIBUTO);
         fetch cfk23_tipi_tributo into dummy;
         found := cfk23_tipi_tributo%FOUND;
         close cfk23_tipi_tributo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su BONUS_SOCIALI_CONTRIBUENTE. La registrazione di Tipi Tributo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_TRIBUTO_PU */
/

-- Trigger TIPI_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_TRIBUTO

create or replace trigger TIPI_TRIBUTO_TIU
before INSERT
    or UPDATE
on TIPI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_TRIBUTO_PU(:OLD.TIPO_TRIBUTO,
                         :NEW.TIPO_TRIBUTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_TRIBUTO"
            cursor cpk_tipi_tributo(var_TIPO_TRIBUTO varchar) is
               select 1
                 from   TIPI_TRIBUTO
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_TRIBUTO"
               if :new.TIPO_TRIBUTO is not null then
                  open  cpk_tipi_tributo(:new.TIPO_TRIBUTO);
                  fetch cpk_tipi_tributo into dummy;
                  found := cpk_tipi_tributo%FOUND;
                  close cpk_tipi_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||
                               '" gia'' presente in Tipi Tributo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "PRATICHE_TRIBUTO"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update PRATICHE_TRIBUTO
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "OGGETTI_TRIBUTO"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update OGGETTI_TRIBUTO
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "UTILIZZI_TRIBUTO"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update UTILIZZI_TRIBUTO
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "SCADENZE"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update SCADENZE
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "SANZIONI"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update SANZIONI
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "CODICI_TRIBUTO"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update CODICI_TRIBUTO
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "INTERESSI"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update INTERESSI
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "RUOLI"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update RUOLI
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "MODELLI"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update MODELLI
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "CONSISTENZE_TRIBUTO"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update CONSISTENZE_TRIBUTO
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "MOTIVI_PRATICA"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update MOTIVI_PRATICA
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "SANZIONI_PRATICA"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update SANZIONI_PRATICA
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "VERSAMENTI"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update VERSAMENTI
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "SPESE_ISTRUTTORIA"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update SPESE_ISTRUTTORIA
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "RATE_IMPOSTA"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update RATE_IMPOSTA
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "OGGETTI_OGIM"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update OGGETTI_OGIM
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "CODICI_F24"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update CODICI_F24
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "ELABORAZIONI_MASSIVE"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update ELABORAZIONI_MASSIVE
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "DATI_CONTABILI"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update DATI_CONTABILI
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "SPESE_NOTIFICA"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update SPESE_NOTIFICA
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "DATE_INTERESSI_VIOLAZIONI"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update DATE_INTERESSI_VIOLAZIONI
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "TIPI_RIDUZIONE"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update TIPI_RIDUZIONE
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;

         --  Modify parent code of "TIPI_TRIBUTO" for all children in "TIPI_ESENZIONE"
         if (:OLD.TIPO_TRIBUTO != :NEW.TIPO_TRIBUTO) then
            update TIPI_ESENZIONE
             set   TIPO_TRIBUTO = :NEW.TIPO_TRIBUTO
            where  TIPO_TRIBUTO = :OLD.TIPO_TRIBUTO;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_TRIBUTO_TIU */
/

-- Procedure TIPI_TRIBUTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_TRIBUTO

create or replace procedure TIPI_TRIBUTO_PD
(old_tipo_tributo IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "PRATICHE_TRIBUTO"
   cursor cfk1_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   PRATICHE_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_TRIBUTO"
   cursor cfk2_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   OGGETTI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "UTILIZZI_TRIBUTO"
   cursor cfk3_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   UTILIZZI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SCADENZE"
   cursor cfk4_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SCADENZE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SANZIONI"
   cursor cfk5_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SANZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "CODICI_TRIBUTO"
   cursor cfk6_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   CODICI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "INTERESSI"
   cursor cfk7_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   INTERESSI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI"
   cursor cfk8_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   RUOLI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "MODELLI"
   cursor cfk9_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   MODELLI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "CONSISTENZE_TRIBUTO"
   cursor cfk10_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   CONSISTENZE_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "MOTIVI_PRATICA"
   cursor cfk11_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   MOTIVI_PRATICA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SANZIONI_PRATICA"
   cursor cfk12_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SANZIONI_PRATICA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "VERSAMENTI"
   cursor cfk13_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   VERSAMENTI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "DELEGHE_BANCARIE"
   cursor cfk14_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   DELEGHE_BANCARIE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SPESE_ISTRUTTORIA"
   cursor cfk15_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SPESE_ISTRUTTORIA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "ALLINEAMENTO_DELEGHE"
   cursor cfk16_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   ALLINEAMENTO_DELEGHE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "RID_IMPAGATI"
   cursor cfk17_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   RID_IMPAGATI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "TIPI_ALIQUOTA"
   cursor cfk18_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_ALIQUOTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk19_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   UTILIZZI_OGGETTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETRAZIONI"
   cursor cfk20_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   DETRAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "MOTIVI_DETRAZIONE"
   cursor cfk21_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   MOTIVI_DETRAZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUCCESSIONI_TRIBUTO_DEFUNTI"
   cursor cfk22_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SUCCESSIONI_TRIBUTO_DEFUNTI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUCCESSIONI_TRIBUTO_EREDI"
   cursor cfk23_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SUCCESSIONI_TRIBUTO_EREDI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "CONTATTI_CONTRIBUENTE"
   cursor cfk24_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   CONTATTI_CONTRIBUENTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "DETRAZIONI_MOBILI"
   cursor cfk25_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   DETRAZIONI_MOBILI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "COMPENSAZIONI"
   cursor cfk26_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   COMPENSAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "ALIQUOTE_MOBILI"
   cursor cfk27_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   ALIQUOTE_MOBILI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "ANOMALIE_PARAMETRI"
   cursor cfk28_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   ANOMALIE_PARAMETRI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "COMUNICAZIONE_PARAMETRI"
   cursor cfk29_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   COMUNICAZIONE_PARAMETRI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "RATE_IMPOSTA"
   cursor cfk30_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   RATE_IMPOSTA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI_OGIM"
   cursor cfk31_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   OGGETTI_OGIM
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "CODICI_F24"
   cursor cfk32_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   CODICI_F24
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "CAUSALI"
   cursor cfk33_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   CAUSALI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "ELABORAZIONI_MASSIVE"
   cursor cfk34_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   ELABORAZIONI_MASSIVE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "GRUPPI_TRIBUTO"
   cursor cfk35_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   GRUPPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATI_CONTABILI"
   cursor cfk36_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   DATI_CONTABILI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "RUOLI_AUTOMATICI"
   cursor cfk37_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   RUOLI_AUTOMATICI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "LIMITI_CALCOLO"
   cursor cfk38_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   LIMITI_CALCOLO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "AGGI"
   cursor cfk39_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   AGGI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SUPPORTO_SERVIZI"
   cursor cfk40_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SUPPORTO_SERVIZI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "STATI_CONTRIBUENTE"
   cursor cfk41_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   STATI_CONTRIBUENTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "SPESE_NOTIFICA"
   cursor cfk42_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   SPESE_NOTIFICA
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "DATE_INTERESSI_VIOLAZIONI"
   cursor cfk43_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   DATE_INTERESSI_VIOLAZIONI
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "BONUS_SOCIALI_CONTRIBUENTE"
   cursor cfk44_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   BONUS_SOCIALI_CONTRIBUENTE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "TIPI_RIDUZIONE"
   cursor cfk45_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_RIDUZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Declaration of DeleteParentRestrict constraint for "TIPI_ESENZIONE"
   cursor cfk46_tipi_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_ESENZIONE
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "PRATICHE_TRIBUTO"
      open  cfk1_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk1_tipi_tributo into dummy;
      found := cfk1_tipi_tributo%FOUND;
      close cfk1_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Pratiche Tributo. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "OGGETTI_TRIBUTO"
      open  cfk2_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk2_tipi_tributo into dummy;
      found := cfk2_tipi_tributo%FOUND;
      close cfk2_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti Tributo. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "UTILIZZI_TRIBUTO"
      open  cfk3_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk3_tipi_tributo into dummy;
      found := cfk3_tipi_tributo%FOUND;
      close cfk3_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Utilizzi Tributo. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "SCADENZE"
      open  cfk4_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk4_tipi_tributo into dummy;
      found := cfk4_tipi_tributo%FOUND;
      close cfk4_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Scadenze. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "SANZIONI"
      open  cfk5_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk5_tipi_tributo into dummy;
      found := cfk5_tipi_tributo%FOUND;
      close cfk5_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sanzioni. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "CODICI_TRIBUTO"
      open  cfk6_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk6_tipi_tributo into dummy;
      found := cfk6_tipi_tributo%FOUND;
      close cfk6_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Codici Tributo. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "INTERESSI"
      open  cfk7_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk7_tipi_tributo into dummy;
      found := cfk7_tipi_tributo%FOUND;
      close cfk7_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Interessi. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "RUOLI"
      open  cfk8_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk8_tipi_tributo into dummy;
      found := cfk8_tipi_tributo%FOUND;
      close cfk8_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "MODELLI"
      open  cfk9_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk9_tipi_tributo into dummy;
      found := cfk9_tipi_tributo%FOUND;
      close cfk9_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Modelli. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "CONSISTENZE_TRIBUTO"
      open  cfk10_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk10_tipi_tributo into dummy;
      found := cfk10_tipi_tributo%FOUND;
      close cfk10_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Consistenze Tributo. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "MOTIVI_PRATICA"
      open  cfk11_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk11_tipi_tributo into dummy;
      found := cfk11_tipi_tributo%FOUND;
      close cfk11_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Motivi Pratica. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "SANZIONI_PRATICA"
      open  cfk12_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk12_tipi_tributo into dummy;
      found := cfk12_tipi_tributo%FOUND;
      close cfk12_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Sanzioni Pratica. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "VERSAMENTI"
      open  cfk13_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk13_tipi_tributo into dummy;
      found := cfk13_tipi_tributo%FOUND;
      close cfk13_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Versamenti. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "DELEGHE_BANCARIE"
      open  cfk14_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk14_tipi_tributo into dummy;
      found := cfk14_tipi_tributo%FOUND;
      close cfk14_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Deleghe Bancarie. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "SPESE_ISTRUTTORIA"
      open  cfk15_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk15_tipi_tributo into dummy;
      found := cfk15_tipi_tributo%FOUND;
      close cfk15_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Spese Istruttoria. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "ALLINEAMENTO_DELEGHE"
      open  cfk16_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk16_tipi_tributo into dummy;
      found := cfk16_tipi_tributo%FOUND;
      close cfk16_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Allineamento Deleghe. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "RID_IMPAGATI"
      open  cfk17_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk17_tipi_tributo into dummy;
      found := cfk17_tipi_tributo%FOUND;
      close cfk17_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su RID_IMPAGATI. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "TIPI_ALIQUOTA"
      open  cfk18_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk18_tipi_tributo into dummy;
      found := cfk18_tipi_tributo%FOUND;
      close cfk18_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Tipi Aliquota. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "UTILIZZI_OGGETTO"
      open  cfk19_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk19_tipi_tributo into dummy;
      found := cfk19_tipi_tributo%FOUND;
      close cfk19_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "DETRAZIONI"
      open  cfk20_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk20_tipi_tributo into dummy;
      found := cfk20_tipi_tributo%FOUND;
      close cfk20_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Detrazioni. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "MOTIVI_DETRAZIONE"
      open  cfk21_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk21_tipi_tributo into dummy;
      found := cfk21_tipi_tributo%FOUND;
      close cfk21_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Motivi Detrazione. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "SUCCESSIONI_TRIBUTO_DEFUNTI"
      open  cfk22_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk22_tipi_tributo into dummy;
      found := cfk22_tipi_tributo%FOUND;
      close cfk22_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Successioni Tributo Defunti. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "SUCCESSIONI_TRIBUTO_EREDI"
      open  cfk23_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk23_tipi_tributo into dummy;
      found := cfk23_tipi_tributo%FOUND;
      close cfk23_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Successioni Tributo Eredi. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "CONTATTI_CONTRIBUENTE"
      open  cfk24_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk24_tipi_tributo into dummy;
      found := cfk24_tipi_tributo%FOUND;
      close cfk24_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Contatti Contribuente. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "DETRAZIONI_MOBILI"
      open  cfk25_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk25_tipi_tributo into dummy;
      found := cfk25_tipi_tributo%FOUND;
      close cfk25_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Detrazioni Mobili. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "COMPENSAZIONI"
      open  cfk26_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk26_tipi_tributo into dummy;
      found := cfk26_tipi_tributo%FOUND;
      close cfk26_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Compensazioni. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "ALIQUOTE_MOBILI"
      open  cfk27_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk27_tipi_tributo into dummy;
      found := cfk27_tipi_tributo%FOUND;
      close cfk27_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ALIQUOTE_MOBILI. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "ANOMALIE_PARAMETRI"
      open  cfk28_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk28_tipi_tributo into dummy;
      found := cfk28_tipi_tributo%FOUND;
      close cfk28_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su ANOMALIE_PARAMETRI. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "COMUNICAZIONE_PARAMETRI"
      open  cfk29_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk29_tipi_tributo into dummy;
      found := cfk29_tipi_tributo%FOUND;
      close cfk29_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su COMUNICAZIONE_PARAMETRI. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "RATE_IMPOSTA"
      open  cfk30_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk30_tipi_tributo into dummy;
      found := cfk30_tipi_tributo%FOUND;
      close cfk30_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Rate Imposta. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "OGGETTI_OGIM"
      open  cfk31_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk31_tipi_tributo into dummy;
      found := cfk31_tipi_tributo%FOUND;
      close cfk31_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti OGIM. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "CODICI_F24"
      open  cfk32_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk32_tipi_tributo into dummy;
      found := cfk32_tipi_tributo%FOUND;
      close cfk32_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su CODICI_F24. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "CAUSALI"
      open  cfk33_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk33_tipi_tributo into dummy;
      found := cfk33_tipi_tributo%FOUND;
      close cfk33_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Causali. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "ELABORAZIONI_MASSIVE"
      open  cfk34_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk34_tipi_tributo into dummy;
      found := cfk34_tipi_tributo%FOUND;
      close cfk34_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Elaborazioni Massive. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "GRUPPI_TRIBUTO"
      open  cfk35_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk35_tipi_tributo into dummy;
      found := cfk35_tipi_tributo%FOUND;
      close cfk35_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Gruppi_tributo. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "DATI_CONTABILI"
      open  cfk36_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk36_tipi_tributo into dummy;
      found := cfk36_tipi_tributo%FOUND;
      close cfk36_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Dati Contabili. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "RUOLI_AUTOMATICI"
      open  cfk37_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk37_tipi_tributo into dummy;
      found := cfk37_tipi_tributo%FOUND;
      close cfk37_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Ruoli Automatici. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "LIMITI_CALCOLO"
      open  cfk38_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk38_tipi_tributo into dummy;
      found := cfk38_tipi_tributo%FOUND;
      close cfk38_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Limiti calcolo. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "AGGI"
      open  cfk39_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk39_tipi_tributo into dummy;
      found := cfk39_tipi_tributo%FOUND;
      close cfk39_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Aggi. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "SUPPORTO_SERVIZI"
      open  cfk40_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk40_tipi_tributo into dummy;
      found := cfk40_tipi_tributo%FOUND;
      close cfk40_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su SUPPORTO_SERVIZI. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "STATI_CONTRIBUENTE"
      open  cfk41_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk41_tipi_tributo into dummy;
      found := cfk41_tipi_tributo%FOUND;
      close cfk41_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Stati Contribuente. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "SPESE_NOTIFICA"
      open  cfk42_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk42_tipi_tributo into dummy;
      found := cfk42_tipi_tributo%FOUND;
      close cfk42_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Spese Notifica. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "DATE_INTERESSI_VIOLAZIONI"
      open  cfk43_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk43_tipi_tributo into dummy;
      found := cfk43_tipi_tributo%FOUND;
      close cfk43_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Date Interessi Violazioni. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "BONUS_SOCIALI_CONTRIBUENTE"
      open  cfk44_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk44_tipi_tributo into dummy;
      found := cfk44_tipi_tributo%FOUND;
      close cfk44_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su BONUS_SOCIALI_CONTRIBUENTE. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "TIPI_RIDUZIONE"
      open  cfk45_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk45_tipi_tributo into dummy;
      found := cfk45_tipi_tributo%FOUND;
      close cfk45_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su TIPI_RIDUZIONE. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_TRIBUTO" if children still exist in "TIPI_ESENZIONE"
      open  cfk46_tipi_tributo(OLD_TIPO_TRIBUTO);
      fetch cfk46_tipi_tributo into dummy;
      found := cfk46_tipi_tributo%FOUND;
      close cfk46_tipi_tributo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su TIPI_ESENZIONE. La registrazione di Tipi Tributo non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_TRIBUTO_PD */
/

-- Tigger TIPI_TRIBUTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_TRIBUTO

create or replace trigger TIPI_TRIBUTO_TD
before DELETE
on TIPI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: PRATICHE_TRIBUTO

      -- Child Restrict Table: OGGETTI_TRIBUTO

      -- Child Restrict Table: UTILIZZI_TRIBUTO

      -- Child Restrict Table: SCADENZE

      -- Child Restrict Table: SANZIONI

      -- Child Restrict Table: CODICI_TRIBUTO

      -- Child Restrict Table: INTERESSI

      -- Child Restrict Table: RUOLI

      -- Child Restrict Table: MODELLI

      -- Child Restrict Table: CONSISTENZE_TRIBUTO

      -- Child Restrict Table: MOTIVI_PRATICA

      -- Child Restrict Table: SANZIONI_PRATICA

      -- Child Restrict Table: VERSAMENTI

      -- Child Restrict Table: DELEGHE_BANCARIE

      -- Child Restrict Table: SPESE_ISTRUTTORIA

      -- Child Restrict Table: ALLINEAMENTO_DELEGHE

      -- Child Restrict Table: RID_IMPAGATI

      -- Child Restrict Table: TIPI_ALIQUOTA

      -- Child Restrict Table: UTILIZZI_OGGETTO

      -- Child Restrict Table: DETRAZIONI

      -- Child Restrict Table: MOTIVI_DETRAZIONE

      -- Child Restrict Table: SUCCESSIONI_TRIBUTO_DEFUNTI

      -- Child Restrict Table: SUCCESSIONI_TRIBUTO_EREDI

      -- Child Restrict Table: CONTATTI_CONTRIBUENTE

      -- Child Restrict Table: DETRAZIONI_MOBILI

      -- Child Restrict Table: COMPENSAZIONI

      -- Child Restrict Table: ALIQUOTE_MOBILI

      -- Child Restrict Table: ANOMALIE_PARAMETRI

      -- Child Restrict Table: COMUNICAZIONE_PARAMETRI

      -- Child Restrict Table: RATE_IMPOSTA

      -- Child Restrict Table: OGGETTI_OGIM

      -- Child Restrict Table: CODICI_F24

      -- Child Restrict Table: CAUSALI

      -- Child Restrict Table: ELABORAZIONI_MASSIVE

      -- Child Restrict Table: GRUPPI_TRIBUTO

      -- Child Restrict Table: DATI_CONTABILI

      -- Child Restrict Table: RUOLI_AUTOMATICI

      -- Child Restrict Table: LIMITI_CALCOLO

      -- Child Restrict Table: AGGI

      -- Child Restrict Table: SUPPORTO_SERVIZI

      -- Child Restrict Table: STATI_CONTRIBUENTE

      -- Child Restrict Table: SPESE_NOTIFICA

      -- Child Restrict Table: DATE_INTERESSI_VIOLAZIONI

      -- Child Restrict Table: BONUS_SOCIALI_CONTRIBUENTE

      -- Child Restrict Table: TIPI_RIDUZIONE

      -- Child Restrict Table: TIPI_ESENZIONE

      TIPI_TRIBUTO_PD(:OLD.TIPO_TRIBUTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_TRIBUTO_TD */
/

-- Procedure TIPI_USO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_USO

create or replace procedure TIPI_USO_PU
(old_tipo_uso IN number,
 new_tipo_uso IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "OGGETTI"
   cursor cfk1_tipi_uso(var_tipo_uso number) is
      select 1
      from   OGGETTI
      where  TIPO_USO = var_tipo_uso
       and   var_tipo_uso is not null;

   --  Declaration of UpdateParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk2_tipi_uso(var_tipo_uso number) is
      select 1
      from   UTILIZZI_OGGETTO
      where  TIPO_USO = var_tipo_uso
       and   var_tipo_uso is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_USO" non modificabile se esistono referenze su "OGGETTI"
      if (OLD_TIPO_USO != NEW_TIPO_USO) then
         open  cfk1_tipi_uso(OLD_TIPO_USO);
         fetch cfk1_tipi_uso into dummy;
         found := cfk1_tipi_uso%FOUND;
         close cfk1_tipi_uso;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Tipi Uso non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_USO" non modificabile se esistono referenze su "UTILIZZI_OGGETTO"
      if (OLD_TIPO_USO != NEW_TIPO_USO) then
         open  cfk2_tipi_uso(OLD_TIPO_USO);
         fetch cfk2_tipi_uso into dummy;
         found := cfk2_tipi_uso%FOUND;
         close cfk2_tipi_uso;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Tipi Uso non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_USO_PU */
/

-- Trigger TIPI_USO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_USO

create or replace trigger TIPI_USO_TIU
before INSERT
    or UPDATE
on TIPI_USO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_USO_PU(:OLD.TIPO_USO,
                         :NEW.TIPO_USO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_USO"
            cursor cpk_tipi_uso(var_TIPO_USO number) is
               select 1
                 from   TIPI_USO
                where  TIPO_USO = var_TIPO_USO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_USO"
               if :new.TIPO_USO is not null then
                  open  cpk_tipi_uso(:new.TIPO_USO);
                  fetch cpk_tipi_uso into dummy;
                  found := cpk_tipi_uso%FOUND;
                  close cpk_tipi_uso;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_USO||
                               '" gia'' presente in Tipi Uso. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_USO_TIU */
/

-- Procedure TIPI_USO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_USO

create or replace procedure TIPI_USO_PD
(old_tipo_uso IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "OGGETTI"
   cursor cfk1_tipi_uso(var_tipo_uso number) is
      select 1
      from   OGGETTI
      where  TIPO_USO = var_tipo_uso
       and   var_tipo_uso is not null;

   --  Declaration of DeleteParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk2_tipi_uso(var_tipo_uso number) is
      select 1
      from   UTILIZZI_OGGETTO
      where  TIPO_USO = var_tipo_uso
       and   var_tipo_uso is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_USO" if children still exist in "OGGETTI"
      open  cfk1_tipi_uso(OLD_TIPO_USO);
      fetch cfk1_tipi_uso into dummy;
      found := cfk1_tipi_uso%FOUND;
      close cfk1_tipi_uso;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Oggetti. La registrazione di Tipi Uso non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_USO" if children still exist in "UTILIZZI_OGGETTO"
      open  cfk2_tipi_uso(OLD_TIPO_USO);
      fetch cfk2_tipi_uso into dummy;
      found := cfk2_tipi_uso%FOUND;
      close cfk2_tipi_uso;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Tipi Uso non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_USO_PD */
/

-- Tigger TIPI_USO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_USO

create or replace trigger TIPI_USO_TD
before DELETE
on TIPI_USO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: OGGETTI

      -- Child Restrict Table: UTILIZZI_OGGETTO

      TIPI_USO_PD(:OLD.TIPO_USO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_USO_TD */
/

-- Procedure TIPI_UTILIZZO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TIPI_UTILIZZO

create or replace procedure TIPI_UTILIZZO_PU
(old_tipo_utilizzo IN number,
 new_tipo_utilizzo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk1_tipi_utilizzo(var_tipo_utilizzo number) is
      select 1
      from   UTILIZZI_OGGETTO
      where  TIPO_UTILIZZO = var_tipo_utilizzo
       and   var_tipo_utilizzo is not null;

   --  Declaration of UpdateParentRestrict constraint for "UTILIZZI_TRIBUTO"
   cursor cfk2_tipi_utilizzo(var_tipo_utilizzo number) is
      select 1
      from   UTILIZZI_TRIBUTO
      where  TIPO_UTILIZZO = var_tipo_utilizzo
       and   var_tipo_utilizzo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TIPI_UTILIZZO" non modificabile se esistono referenze su "UTILIZZI_OGGETTO"
      if (OLD_TIPO_UTILIZZO != NEW_TIPO_UTILIZZO) then
         open  cfk1_tipi_utilizzo(OLD_TIPO_UTILIZZO);
         fetch cfk1_tipi_utilizzo into dummy;
         found := cfk1_tipi_utilizzo%FOUND;
         close cfk1_tipi_utilizzo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Tipi Utilizzo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TIPI_UTILIZZO" non modificabile se esistono referenze su "UTILIZZI_TRIBUTO"
      if (OLD_TIPO_UTILIZZO != NEW_TIPO_UTILIZZO) then
         open  cfk2_tipi_utilizzo(OLD_TIPO_UTILIZZO);
         fetch cfk2_tipi_utilizzo into dummy;
         found := cfk2_tipi_utilizzo%FOUND;
         close cfk2_tipi_utilizzo;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su Utilizzi Tributo. La registrazione di Tipi Utilizzo non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_UTILIZZO_PU */
/

-- Trigger TIPI_UTILIZZO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TIPI_UTILIZZO

create or replace trigger TIPI_UTILIZZO_TIU
before INSERT
    or UPDATE
on TIPI_UTILIZZO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TIPI_UTILIZZO_PU(:OLD.TIPO_UTILIZZO,
                         :NEW.TIPO_UTILIZZO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TIPI_UTILIZZO"
            cursor cpk_tipi_utilizzo(var_TIPO_UTILIZZO number) is
               select 1
                 from   TIPI_UTILIZZO
                where  TIPO_UTILIZZO = var_TIPO_UTILIZZO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TIPI_UTILIZZO"
               if :new.TIPO_UTILIZZO is not null then
                  open  cpk_tipi_utilizzo(:new.TIPO_UTILIZZO);
                  fetch cpk_tipi_utilizzo into dummy;
                  found := cpk_tipi_utilizzo%FOUND;
                  close cpk_tipi_utilizzo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_UTILIZZO||
                               '" gia'' presente in Tipi Utilizzo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_UTILIZZO_TIU */
/

-- Procedure TIPI_UTILIZZO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TIPI_UTILIZZO

create or replace procedure TIPI_UTILIZZO_PD
(old_tipo_utilizzo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "UTILIZZI_OGGETTO"
   cursor cfk1_tipi_utilizzo(var_tipo_utilizzo number) is
      select 1
      from   UTILIZZI_OGGETTO
      where  TIPO_UTILIZZO = var_tipo_utilizzo
       and   var_tipo_utilizzo is not null;

   --  Declaration of DeleteParentRestrict constraint for "UTILIZZI_TRIBUTO"
   cursor cfk2_tipi_utilizzo(var_tipo_utilizzo number) is
      select 1
      from   UTILIZZI_TRIBUTO
      where  TIPO_UTILIZZO = var_tipo_utilizzo
       and   var_tipo_utilizzo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TIPI_UTILIZZO" if children still exist in "UTILIZZI_OGGETTO"
      open  cfk1_tipi_utilizzo(OLD_TIPO_UTILIZZO);
      fetch cfk1_tipi_utilizzo into dummy;
      found := cfk1_tipi_utilizzo%FOUND;
      close cfk1_tipi_utilizzo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Utilizzi Oggetto. La registrazione di Tipi Utilizzo non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TIPI_UTILIZZO" if children still exist in "UTILIZZI_TRIBUTO"
      open  cfk2_tipi_utilizzo(OLD_TIPO_UTILIZZO);
      fetch cfk2_tipi_utilizzo into dummy;
      found := cfk2_tipi_utilizzo%FOUND;
      close cfk2_tipi_utilizzo;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su Utilizzi Tributo. La registrazione di Tipi Utilizzo non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TIPI_UTILIZZO_PD */
/

-- Tigger TIPI_UTILIZZO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TIPI_UTILIZZO

create or replace trigger TIPI_UTILIZZO_TD
before DELETE
on TIPI_UTILIZZO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: UTILIZZI_OGGETTO

      -- Child Restrict Table: UTILIZZI_TRIBUTO

      TIPI_UTILIZZO_PD(:OLD.TIPO_UTILIZZO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TIPI_UTILIZZO_TD */
/

-- Procedure TITOLI_DOCUMENTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table TITOLI_DOCUMENTO

create or replace procedure TITOLI_DOCUMENTO_PU
(old_titolo_documento IN number,
 new_titolo_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "DOCUMENTI_CARICATI"
   cursor cfk1_titoli_documento(var_titolo_documento number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;

   --  Declaration of UpdateParentRestrict constraint for "WEB_PARAMETRI_IMPORT"
   cursor cfk2_titoli_documento(var_titolo_documento number) is
      select 1
      from   WEB_PARAMETRI_IMPORT
      where  ID_TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;

   --  Declaration of UpdateParentRestrict constraint for "LOCAZIONI_TIPI_TRACCIATO"
   cursor cfk3_titoli_documento(var_titolo_documento number) is
      select 1
      from   LOCAZIONI_TIPI_TRACCIATO
      where  TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "TITOLI_DOCUMENTO" non modificabile se esistono referenze su "DOCUMENTI_CARICATI"
      if (OLD_TITOLO_DOCUMENTO != NEW_TITOLO_DOCUMENTO) then
         open  cfk1_titoli_documento(OLD_TITOLO_DOCUMENTO);
         fetch cfk1_titoli_documento into dummy;
         found := cfk1_titoli_documento%FOUND;
         close cfk1_titoli_documento;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su DOCUMENTI_CARICATI. La registrazione di Titoli Documento non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TITOLI_DOCUMENTO" non modificabile se esistono referenze su "WEB_PARAMETRI_IMPORT"
      if (OLD_TITOLO_DOCUMENTO != NEW_TITOLO_DOCUMENTO) then
         open  cfk2_titoli_documento(OLD_TITOLO_DOCUMENTO);
         fetch cfk2_titoli_documento into dummy;
         found := cfk2_titoli_documento%FOUND;
         close cfk2_titoli_documento;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_PARAMETRI_IMPORT. La registrazione di Titoli Documento non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "TITOLI_DOCUMENTO" non modificabile se esistono referenze su "LOCAZIONI_TIPI_TRACCIATO"
      if (OLD_TITOLO_DOCUMENTO != NEW_TITOLO_DOCUMENTO) then
         open  cfk3_titoli_documento(OLD_TITOLO_DOCUMENTO);
         fetch cfk3_titoli_documento into dummy;
         found := cfk3_titoli_documento%FOUND;
         close cfk3_titoli_documento;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su LOCAZIONI_TIPI_TRACCIATO. La registrazione di Titoli Documento non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TITOLI_DOCUMENTO_PU */
/

-- Trigger TITOLI_DOCUMENTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table TITOLI_DOCUMENTO

create or replace trigger TITOLI_DOCUMENTO_TIU
before INSERT
    or UPDATE
on TITOLI_DOCUMENTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         TITOLI_DOCUMENTO_PU(:OLD.TITOLO_DOCUMENTO,
                         :NEW.TITOLO_DOCUMENTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "TITOLI_DOCUMENTO"
            cursor cpk_titoli_documento(var_TITOLO_DOCUMENTO number) is
               select 1
                 from   TITOLI_DOCUMENTO
                where  TITOLO_DOCUMENTO = var_TITOLO_DOCUMENTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "TITOLI_DOCUMENTO"
               if :new.TITOLO_DOCUMENTO is not null then
                  open  cpk_titoli_documento(:new.TITOLO_DOCUMENTO);
                  fetch cpk_titoli_documento into dummy;
                  found := cpk_titoli_documento%FOUND;
                  close cpk_titoli_documento;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TITOLO_DOCUMENTO||
                               '" gia'' presente in Titoli Documento. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TITOLI_DOCUMENTO_TIU */
/

-- Procedure TITOLI_DOCUMENTO_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table TITOLI_DOCUMENTO

create or replace procedure TITOLI_DOCUMENTO_PD
(old_titolo_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "DOCUMENTI_CARICATI"
   cursor cfk1_titoli_documento(var_titolo_documento number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;

   --  Declaration of DeleteParentRestrict constraint for "WEB_PARAMETRI_IMPORT"
   cursor cfk2_titoli_documento(var_titolo_documento number) is
      select 1
      from   WEB_PARAMETRI_IMPORT
      where  ID_TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;

   --  Declaration of DeleteParentRestrict constraint for "LOCAZIONI_TIPI_TRACCIATO"
   cursor cfk3_titoli_documento(var_titolo_documento number) is
      select 1
      from   LOCAZIONI_TIPI_TRACCIATO
      where  TITOLO_DOCUMENTO = var_titolo_documento
       and   var_titolo_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "TITOLI_DOCUMENTO" if children still exist in "DOCUMENTI_CARICATI"
      open  cfk1_titoli_documento(OLD_TITOLO_DOCUMENTO);
      fetch cfk1_titoli_documento into dummy;
      found := cfk1_titoli_documento%FOUND;
      close cfk1_titoli_documento;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su DOCUMENTI_CARICATI. La registrazione di Titoli Documento non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TITOLI_DOCUMENTO" if children still exist in "WEB_PARAMETRI_IMPORT"
      open  cfk2_titoli_documento(OLD_TITOLO_DOCUMENTO);
      fetch cfk2_titoli_documento into dummy;
      found := cfk2_titoli_documento%FOUND;
      close cfk2_titoli_documento;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WEB_PARAMETRI_IMPORT. La registrazione di Titoli Documento non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "TITOLI_DOCUMENTO" if children still exist in "LOCAZIONI_TIPI_TRACCIATO"
      open  cfk3_titoli_documento(OLD_TITOLO_DOCUMENTO);
      fetch cfk3_titoli_documento into dummy;
      found := cfk3_titoli_documento%FOUND;
      close cfk3_titoli_documento;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su LOCAZIONI_TIPI_TRACCIATO. La registrazione di Titoli Documento non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: TITOLI_DOCUMENTO_PD */
/

-- Tigger TITOLI_DOCUMENTO_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table TITOLI_DOCUMENTO

create or replace trigger TITOLI_DOCUMENTO_TD
before DELETE
on TITOLI_DOCUMENTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: DOCUMENTI_CARICATI

      -- Child Restrict Table: WEB_PARAMETRI_IMPORT

      -- Child Restrict Table: LOCAZIONI_TIPI_TRACCIATO

      TITOLI_DOCUMENTO_PD(:OLD.TITOLO_DOCUMENTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: TITOLI_DOCUMENTO_TD */
/

-- Procedure UTENZE_DATI_FORNITURA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table UTENZE_DATI_FORNITURA

create or replace procedure UTENZE_DATI_FORNITURA_PI
(new_tipo_fornitura IN varchar,
 new_tipo_utenza IN varchar,
 new_forniture_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "UTENZE_FORNITURE"
   cursor cpk1_utenze_dati_fornitura(var_forniture_id number) is
      select 1
      from   UTENZE_FORNITURE
      where  FORNITURE_ID = var_forniture_id
       and   var_forniture_id is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "UTENZE_TIPI_UTENZA"
   cursor cpk2_utenze_dati_fornitura(var_tipo_fornitura varchar,
                                     var_tipo_utenza varchar) is
      select 1
      from   UTENZE_TIPI_UTENZA
      where  TIPO_FORNITURA = var_tipo_fornitura
       and   TIPO_UTENZA = var_tipo_utenza
       and   var_tipo_fornitura is not null
       and   var_tipo_utenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "UTENZE_FORNITURE" deve esistere quando si inserisce su "UTENZE_DATI_FORNITURA"
         if NEW_FORNITURE_ID is not null then
            open  cpk1_utenze_dati_fornitura(NEW_FORNITURE_ID);
            fetch cpk1_utenze_dati_fornitura into dummy;
            found := cpk1_utenze_dati_fornitura%FOUND;
            close cpk1_utenze_dati_fornitura;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su UTENZE_FORNITURE. La registrazione UTENZE_DATI_FORNITURA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "UTENZE_TIPI_UTENZA" deve esistere quando si inserisce su "UTENZE_DATI_FORNITURA"
         if NEW_TIPO_FORNITURA is not null and
            NEW_TIPO_UTENZA is not null then
            open  cpk2_utenze_dati_fornitura(NEW_TIPO_FORNITURA,
                                             NEW_TIPO_UTENZA);
            fetch cpk2_utenze_dati_fornitura into dummy;
            found := cpk2_utenze_dati_fornitura%FOUND;
            close cpk2_utenze_dati_fornitura;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su UTENZE_TIPI_UTENZA. La registrazione UTENZE_DATI_FORNITURA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTENZE_DATI_FORNITURA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table UTENZE_DATI_FORNITURA
/* End Trigger: UTENZE_DATI_FORNITURA_TC */

-- Procedure UTENZE_DATI_FORNITURA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table UTENZE_DATI_FORNITURA

create or replace procedure UTENZE_DATI_FORNITURA_PU
(old_dati_fornitura_id IN number,
 old_tipo_fornitura IN varchar,
 old_tipo_utenza IN varchar,
 old_forniture_id IN number,
 new_dati_fornitura_id IN number,
 new_tipo_fornitura IN varchar,
 new_tipo_utenza IN varchar,
 new_forniture_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "UTENZE_FORNITURE"
   cursor cpk1_utenze_dati_fornitura(var_forniture_id number) is
      select 1
      from   UTENZE_FORNITURE
      where  FORNITURE_ID = var_forniture_id
       and   var_forniture_id is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "UTENZE_TIPI_UTENZA"
   cursor cpk2_utenze_dati_fornitura(var_tipo_fornitura varchar,
                                     var_tipo_utenza varchar) is
      select 1
      from   UTENZE_TIPI_UTENZA
      where  TIPO_FORNITURA = var_tipo_fornitura
       and   TIPO_UTENZA = var_tipo_utenza
       and   var_tipo_fornitura is not null
       and   var_tipo_utenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "UTENZE_FORNITURE" deve esistere quando si modifica "UTENZE_DATI_FORNITURA"
         if  NEW_FORNITURE_ID is not null and ( seq = 0 )
         and (   (NEW_FORNITURE_ID != OLD_FORNITURE_ID or OLD_FORNITURE_ID is null) ) then
            open  cpk1_utenze_dati_fornitura(NEW_FORNITURE_ID);
            fetch cpk1_utenze_dati_fornitura into dummy;
            found := cpk1_utenze_dati_fornitura%FOUND;
            close cpk1_utenze_dati_fornitura;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su UTENZE_FORNITURE. La registrazione UTENZE_DATI_FORNITURA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "UTENZE_TIPI_UTENZA" deve esistere quando si modifica "UTENZE_DATI_FORNITURA"
         if  NEW_TIPO_FORNITURA is not null and
             NEW_TIPO_UTENZA is not null and ( seq = 0 )
         and (   (NEW_TIPO_FORNITURA != OLD_TIPO_FORNITURA or OLD_TIPO_FORNITURA is null)
              or (NEW_TIPO_UTENZA != OLD_TIPO_UTENZA or OLD_TIPO_UTENZA is null) ) then
            open  cpk2_utenze_dati_fornitura(NEW_TIPO_FORNITURA,
                                             NEW_TIPO_UTENZA);
            fetch cpk2_utenze_dati_fornitura into dummy;
            found := cpk2_utenze_dati_fornitura%FOUND;
            close cpk2_utenze_dati_fornitura;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su UTENZE_TIPI_UTENZA. La registrazione UTENZE_DATI_FORNITURA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTENZE_DATI_FORNITURA_PU */
/

-- Trigger UTENZE_DATI_FORNITURA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table UTENZE_DATI_FORNITURA

create or replace trigger UTENZE_DATI_FORNITURA_TIU
before INSERT
    or UPDATE
on UTENZE_DATI_FORNITURA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         UTENZE_DATI_FORNITURA_PU(:OLD.DATI_FORNITURA_ID,
                                  :OLD.TIPO_FORNITURA,
                                  :OLD.TIPO_UTENZA,
                                  :OLD.FORNITURE_ID,
                         :NEW.DATI_FORNITURA_ID,
                         :NEW.TIPO_FORNITURA,
                         :NEW.TIPO_UTENZA,
                         :NEW.FORNITURE_ID);
         null;
      end if;
      if INSERTING then
         UTENZE_DATI_FORNITURA_PI(:NEW.TIPO_FORNITURA,
                                  :NEW.TIPO_UTENZA,
                                  :NEW.FORNITURE_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "UTENZE_DATI_FORNITURA"
            cursor cpk_utenze_dati_fornitura(var_DATI_FORNITURA_ID number) is
               select 1
                 from   UTENZE_DATI_FORNITURA
                where  DATI_FORNITURA_ID = var_DATI_FORNITURA_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "UTENZE_DATI_FORNITURA"
               if :new.DATI_FORNITURA_ID is not null then
                  open  cpk_utenze_dati_fornitura(:new.DATI_FORNITURA_ID);
                  fetch cpk_utenze_dati_fornitura into dummy;
                  found := cpk_utenze_dati_fornitura%FOUND;
                  close cpk_utenze_dati_fornitura;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DATI_FORNITURA_ID||
                               '" gia'' presente in UTENZE_DATI_FORNITURA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: UTENZE_DATI_FORNITURA_TIU */
/

-- Procedure UTENZE_FORNITURE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table UTENZE_FORNITURE

create or replace procedure UTENZE_FORNITURE_PI
(new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk1_utenze_forniture(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "UTENZE_FORNITURE"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk1_utenze_forniture(NEW_DOCUMENTO_ID);
            fetch cpk1_utenze_forniture into dummy;
            found := cpk1_utenze_forniture%FOUND;
            close cpk1_utenze_forniture;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione UTENZE_FORNITURE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTENZE_FORNITURE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table UTENZE_FORNITURE
/* End Trigger: UTENZE_FORNITURE_TC */

-- Procedure UTENZE_FORNITURE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table UTENZE_FORNITURE

create or replace procedure UTENZE_FORNITURE_PU
(old_forniture_id IN number,
 old_documento_id IN number,
 new_forniture_id IN number,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk1_utenze_forniture(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "UTENZE_DATI_FORNITURA"
   cursor cfk1_utenze_forniture(var_forniture_id number) is
      select 1
      from   UTENZE_DATI_FORNITURA
      where  FORNITURE_ID = var_forniture_id
       and   var_forniture_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "UTENZE_FORNITURE"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk1_utenze_forniture(NEW_DOCUMENTO_ID);
            fetch cpk1_utenze_forniture into dummy;
            found := cpk1_utenze_forniture%FOUND;
            close cpk1_utenze_forniture;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione UTENZE_FORNITURE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "UTENZE_FORNITURE" non modificabile se esistono referenze su "UTENZE_DATI_FORNITURA"
      if (OLD_FORNITURE_ID != NEW_FORNITURE_ID) then
         open  cfk1_utenze_forniture(OLD_FORNITURE_ID);
         fetch cfk1_utenze_forniture into dummy;
         found := cfk1_utenze_forniture%FOUND;
         close cfk1_utenze_forniture;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su UTENZE_DATI_FORNITURA. La registrazione di UTENZE_FORNITURE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTENZE_FORNITURE_PU */
/

-- Trigger UTENZE_FORNITURE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table UTENZE_FORNITURE

create or replace trigger UTENZE_FORNITURE_TIU
before INSERT
    or UPDATE
on UTENZE_FORNITURE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         UTENZE_FORNITURE_PU(:OLD.FORNITURE_ID,
                             :OLD.DOCUMENTO_ID,
                         :NEW.FORNITURE_ID,
                         :NEW.DOCUMENTO_ID);
         null;
      end if;
      if INSERTING then
         UTENZE_FORNITURE_PI(:NEW.DOCUMENTO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "UTENZE_FORNITURE"
            cursor cpk_utenze_forniture(var_FORNITURE_ID number) is
               select 1
                 from   UTENZE_FORNITURE
                where  FORNITURE_ID = var_FORNITURE_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "UTENZE_FORNITURE"
               if :new.FORNITURE_ID is not null then
                  open  cpk_utenze_forniture(:new.FORNITURE_ID);
                  fetch cpk_utenze_forniture into dummy;
                  found := cpk_utenze_forniture%FOUND;
                  close cpk_utenze_forniture;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.FORNITURE_ID||
                               '" gia'' presente in UTENZE_FORNITURE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: UTENZE_FORNITURE_TIU */
/

-- Procedure UTENZE_FORNITURE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table UTENZE_FORNITURE

create or replace procedure UTENZE_FORNITURE_PD
(old_forniture_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "UTENZE_DATI_FORNITURA"
   cursor cfk1_utenze_forniture(var_forniture_id number) is
      select 1
      from   UTENZE_DATI_FORNITURA
      where  FORNITURE_ID = var_forniture_id
       and   var_forniture_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "UTENZE_FORNITURE" if children still exist in "UTENZE_DATI_FORNITURA"
      open  cfk1_utenze_forniture(OLD_FORNITURE_ID);
      fetch cfk1_utenze_forniture into dummy;
      found := cfk1_utenze_forniture%FOUND;
      close cfk1_utenze_forniture;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su UTENZE_DATI_FORNITURA. La registrazione di UTENZE_FORNITURE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTENZE_FORNITURE_PD */
/

-- Tigger UTENZE_FORNITURE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table UTENZE_FORNITURE

create or replace trigger UTENZE_FORNITURE_TD
before DELETE
on UTENZE_FORNITURE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: UTENZE_DATI_FORNITURA

      UTENZE_FORNITURE_PD(:OLD.FORNITURE_ID);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: UTENZE_FORNITURE_TD */
/

-- Procedure UTENZE_TIPI_UTENZA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table UTENZE_TIPI_UTENZA

create or replace procedure UTENZE_TIPI_UTENZA_PU
(old_tipo_fornitura IN varchar,
 old_tipo_utenza IN varchar,
 new_tipo_fornitura IN varchar,
 new_tipo_utenza IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "UTENZE_DATI_FORNITURA"
   cursor cfk1_utenze_tipi_utenza(var_tipo_fornitura varchar,
                                  var_tipo_utenza varchar) is
      select 1
      from   UTENZE_DATI_FORNITURA
      where  TIPO_FORNITURA = var_tipo_fornitura
       and   TIPO_UTENZA = var_tipo_utenza
       and   var_tipo_fornitura is not null
       and   var_tipo_utenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "UTENZE_TIPI_UTENZA" non modificabile se esistono referenze su "UTENZE_DATI_FORNITURA"
      if (OLD_TIPO_FORNITURA != NEW_TIPO_FORNITURA) or
         (OLD_TIPO_UTENZA != NEW_TIPO_UTENZA) then
         open  cfk1_utenze_tipi_utenza(OLD_TIPO_FORNITURA,
                                       OLD_TIPO_UTENZA);
         fetch cfk1_utenze_tipi_utenza into dummy;
         found := cfk1_utenze_tipi_utenza%FOUND;
         close cfk1_utenze_tipi_utenza;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su UTENZE_DATI_FORNITURA. La registrazione di UTENZE_TIPI_UTENZA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTENZE_TIPI_UTENZA_PU */
/

-- Trigger UTENZE_TIPI_UTENZA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table UTENZE_TIPI_UTENZA

create or replace trigger UTENZE_TIPI_UTENZA_TIU
before INSERT
    or UPDATE
on UTENZE_TIPI_UTENZA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         UTENZE_TIPI_UTENZA_PU(:OLD.TIPO_FORNITURA,
                               :OLD.TIPO_UTENZA,
                         :NEW.TIPO_FORNITURA,
                         :NEW.TIPO_UTENZA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "UTENZE_TIPI_UTENZA"
            cursor cpk_utenze_tipi_utenza(var_TIPO_FORNITURA varchar,
                                          var_TIPO_UTENZA varchar) is
               select 1
                 from   UTENZE_TIPI_UTENZA
                where  TIPO_FORNITURA = var_TIPO_FORNITURA and
                       TIPO_UTENZA = var_TIPO_UTENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "UTENZE_TIPI_UTENZA"
               if :new.TIPO_FORNITURA is not null and
                  :new.TIPO_UTENZA is not null then
                  open  cpk_utenze_tipi_utenza(:new.TIPO_FORNITURA,
                                               :new.TIPO_UTENZA);
                  fetch cpk_utenze_tipi_utenza into dummy;
                  found := cpk_utenze_tipi_utenza%FOUND;
                  close cpk_utenze_tipi_utenza;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_FORNITURA||' '||
                               :new.TIPO_UTENZA||
                               '" gia'' presente in UTENZE_TIPI_UTENZA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: UTENZE_TIPI_UTENZA_TIU */
/

-- Procedure UTENZE_TIPI_UTENZA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table UTENZE_TIPI_UTENZA

create or replace procedure UTENZE_TIPI_UTENZA_PD
(old_tipo_fornitura IN varchar,
 old_tipo_utenza IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "UTENZE_DATI_FORNITURA"
   cursor cfk1_utenze_tipi_utenza(var_tipo_fornitura varchar,
                                  var_tipo_utenza varchar) is
      select 1
      from   UTENZE_DATI_FORNITURA
      where  TIPO_FORNITURA = var_tipo_fornitura
       and   TIPO_UTENZA = var_tipo_utenza
       and   var_tipo_fornitura is not null
       and   var_tipo_utenza is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "UTENZE_TIPI_UTENZA" if children still exist in "UTENZE_DATI_FORNITURA"
      open  cfk1_utenze_tipi_utenza(OLD_TIPO_FORNITURA,
                                    OLD_TIPO_UTENZA);
      fetch cfk1_utenze_tipi_utenza into dummy;
      found := cfk1_utenze_tipi_utenza%FOUND;
      close cfk1_utenze_tipi_utenza;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su UTENZE_DATI_FORNITURA. La registrazione di UTENZE_TIPI_UTENZA non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTENZE_TIPI_UTENZA_PD */
/

-- Tigger UTENZE_TIPI_UTENZA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table UTENZE_TIPI_UTENZA

create or replace trigger UTENZE_TIPI_UTENZA_TD
before DELETE
on UTENZE_TIPI_UTENZA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: UTENZE_DATI_FORNITURA

      UTENZE_TIPI_UTENZA_PD(:OLD.TIPO_FORNITURA,
                            :OLD.TIPO_UTENZA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: UTENZE_TIPI_UTENZA_TD */
/

-- Procedure UTILIZZI_OGGETTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table UTILIZZI_OGGETTO

create or replace procedure UTILIZZI_OGGETTO_PI
(new_oggetto IN number,
 new_tipo_tributo IN varchar,
 new_tipo_utilizzo IN number,
 new_ni IN number,
 new_tipo_uso IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI"
   cursor cpk1_utilizzi_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_UTILIZZO"
   cursor cpk2_utilizzi_oggetto(var_tipo_utilizzo number) is
      select 1
      from   TIPI_UTILIZZO
      where  TIPO_UTILIZZO = var_tipo_utilizzo
       and   var_tipo_utilizzo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_USO"
   cursor cpk3_utilizzi_oggetto(var_tipo_uso number) is
      select 1
      from   TIPI_USO
      where  TIPO_USO = var_tipo_uso
       and   var_tipo_uso is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "SOGGETTI"
   cursor cpk4_utilizzi_oggetto(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk5_utilizzi_oggetto(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "OGGETTI" deve esistere quando si inserisce su "UTILIZZI_OGGETTO"
         if NEW_OGGETTO is not null then
            open  cpk1_utilizzi_oggetto(NEW_OGGETTO);
            fetch cpk1_utilizzi_oggetto into dummy;
            found := cpk1_utilizzi_oggetto%FOUND;
            close cpk1_utilizzi_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Utilizzi Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_UTILIZZO" deve esistere quando si inserisce su "UTILIZZI_OGGETTO"
         if NEW_TIPO_UTILIZZO is not null then
            open  cpk2_utilizzi_oggetto(NEW_TIPO_UTILIZZO);
            fetch cpk2_utilizzi_oggetto into dummy;
            found := cpk2_utilizzi_oggetto%FOUND;
            close cpk2_utilizzi_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Utilizzo. La registrazione Utilizzi Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_USO" deve esistere quando si inserisce su "UTILIZZI_OGGETTO"
         if NEW_TIPO_USO is not null then
            open  cpk3_utilizzi_oggetto(NEW_TIPO_USO);
            fetch cpk3_utilizzi_oggetto into dummy;
            found := cpk3_utilizzi_oggetto%FOUND;
            close cpk3_utilizzi_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Uso. La registrazione Utilizzi Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si inserisce su "UTILIZZI_OGGETTO"
         if NEW_NI is not null then
            open  cpk4_utilizzi_oggetto(NEW_NI);
            fetch cpk4_utilizzi_oggetto into dummy;
            found := cpk4_utilizzi_oggetto%FOUND;
            close cpk4_utilizzi_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Utilizzi Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "UTILIZZI_OGGETTO"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk5_utilizzi_oggetto(NEW_TIPO_TRIBUTO);
            fetch cpk5_utilizzi_oggetto into dummy;
            found := cpk5_utilizzi_oggetto%FOUND;
            close cpk5_utilizzi_oggetto;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Utilizzi Oggetto non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTILIZZI_OGGETTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table UTILIZZI_OGGETTO
/* End Trigger: UTILIZZI_OGGETTO_TC */

-- Procedure UTILIZZI_OGGETTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table UTILIZZI_OGGETTO

create or replace procedure UTILIZZI_OGGETTO_PU
(old_oggetto IN number,
 old_tipo_tributo IN varchar,
 old_anno IN number,
 old_tipo_utilizzo IN number,
 old_sequenza IN number,
 old_ni IN number,
 old_tipo_uso IN number,
 new_oggetto IN number,
 new_tipo_tributo IN varchar,
 new_anno IN number,
 new_tipo_utilizzo IN number,
 new_sequenza IN number,
 new_ni IN number,
 new_tipo_uso IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI"
   cursor cpk1_utilizzi_oggetto(var_oggetto number) is
      select 1
      from   OGGETTI
      where  OGGETTO = var_oggetto
       and   var_oggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_UTILIZZO"
   cursor cpk2_utilizzi_oggetto(var_tipo_utilizzo number) is
      select 1
      from   TIPI_UTILIZZO
      where  TIPO_UTILIZZO = var_tipo_utilizzo
       and   var_tipo_utilizzo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_USO"
   cursor cpk3_utilizzi_oggetto(var_tipo_uso number) is
      select 1
      from   TIPI_USO
      where  TIPO_USO = var_tipo_uso
       and   var_tipo_uso is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "SOGGETTI"
   cursor cpk4_utilizzi_oggetto(var_ni number) is
      select 1
      from   SOGGETTI
      where  NI = var_ni
       and   var_ni is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk5_utilizzi_oggetto(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "OGGETTI" deve esistere quando si modifica "UTILIZZI_OGGETTO"
         if  NEW_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_OGGETTO != OLD_OGGETTO or OLD_OGGETTO is null) ) then
            open  cpk1_utilizzi_oggetto(NEW_OGGETTO);
            fetch cpk1_utilizzi_oggetto into dummy;
            found := cpk1_utilizzi_oggetto%FOUND;
            close cpk1_utilizzi_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti. La registrazione Utilizzi Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_UTILIZZO" deve esistere quando si modifica "UTILIZZI_OGGETTO"
         if  NEW_TIPO_UTILIZZO is not null and ( seq = 0 )
         and (   (NEW_TIPO_UTILIZZO != OLD_TIPO_UTILIZZO or OLD_TIPO_UTILIZZO is null) ) then
            open  cpk2_utilizzi_oggetto(NEW_TIPO_UTILIZZO);
            fetch cpk2_utilizzi_oggetto into dummy;
            found := cpk2_utilizzi_oggetto%FOUND;
            close cpk2_utilizzi_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Utilizzo. La registrazione Utilizzi Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_USO" deve esistere quando si modifica "UTILIZZI_OGGETTO"
         if  NEW_TIPO_USO is not null and ( seq = 0 )
         and (   (NEW_TIPO_USO != OLD_TIPO_USO or OLD_TIPO_USO is null) ) then
            open  cpk3_utilizzi_oggetto(NEW_TIPO_USO);
            fetch cpk3_utilizzi_oggetto into dummy;
            found := cpk3_utilizzi_oggetto%FOUND;
            close cpk3_utilizzi_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Uso. La registrazione Utilizzi Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "SOGGETTI" deve esistere quando si modifica "UTILIZZI_OGGETTO"
         if  NEW_NI is not null and ( seq = 0 )
         and (   (NEW_NI != OLD_NI or OLD_NI is null) ) then
            open  cpk4_utilizzi_oggetto(NEW_NI);
            fetch cpk4_utilizzi_oggetto into dummy;
            found := cpk4_utilizzi_oggetto%FOUND;
            close cpk4_utilizzi_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Soggetti. La registrazione Utilizzi Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "UTILIZZI_OGGETTO"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk5_utilizzi_oggetto(NEW_TIPO_TRIBUTO);
            fetch cpk5_utilizzi_oggetto into dummy;
            found := cpk5_utilizzi_oggetto%FOUND;
            close cpk5_utilizzi_oggetto;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Utilizzi Oggetto non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTILIZZI_OGGETTO_PU */
/

-- Trigger UTILIZZI_OGGETTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table UTILIZZI_OGGETTO

create or replace trigger UTILIZZI_OGGETTO_TIU
before INSERT
    or UPDATE
on UTILIZZI_OGGETTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
       UTILIZZI_OGGETTO_NR (:new.oggetto,:new.anno,:new.tipo_utilizzo,:new.tipo_tributo,:new.sequenza);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         UTILIZZI_OGGETTO_PU(:OLD.OGGETTO,
                             :OLD.TIPO_TRIBUTO,
                             :OLD.ANNO,
                             :OLD.TIPO_UTILIZZO,
                             :OLD.SEQUENZA,
                             :OLD.NI,
                             :OLD.TIPO_USO,
                         :NEW.OGGETTO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.ANNO,
                         :NEW.TIPO_UTILIZZO,
                         :NEW.SEQUENZA,
                         :NEW.NI,
                         :NEW.TIPO_USO);
         null;
      end if;
      if INSERTING then
         UTILIZZI_OGGETTO_PI(:NEW.OGGETTO,
                             :NEW.TIPO_TRIBUTO,
                             :NEW.TIPO_UTILIZZO,
                             :NEW.NI,
                             :NEW.TIPO_USO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "UTILIZZI_OGGETTO"
            cursor cpk_utilizzi_oggetto(var_OGGETTO number,
                                        var_TIPO_TRIBUTO varchar,
                                        var_ANNO number,
                                        var_TIPO_UTILIZZO number,
                                        var_SEQUENZA number) is
               select 1
                 from   UTILIZZI_OGGETTO
                where  OGGETTO = var_OGGETTO and
                       TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       ANNO = var_ANNO and
                       TIPO_UTILIZZO = var_TIPO_UTILIZZO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "UTILIZZI_OGGETTO"
               if :new.OGGETTO is not null and
                  :new.TIPO_TRIBUTO is not null and
                  :new.ANNO is not null and
                  :new.TIPO_UTILIZZO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_utilizzi_oggetto(:new.OGGETTO,
                                             :new.TIPO_TRIBUTO,
                                             :new.ANNO,
                                             :new.TIPO_UTILIZZO,
                                             :new.SEQUENZA);
                  fetch cpk_utilizzi_oggetto into dummy;
                  found := cpk_utilizzi_oggetto%FOUND;
                  close cpk_utilizzi_oggetto;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.OGGETTO||' '||
                               :new.TIPO_TRIBUTO||' '||
                               :new.ANNO||' '||
                               :new.TIPO_UTILIZZO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Utilizzi Oggetto. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: UTILIZZI_OGGETTO_TIU */
/

-- Procedure UTILIZZI_TRIBUTO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table UTILIZZI_TRIBUTO

create or replace procedure UTILIZZI_TRIBUTO_PI
(new_tipo_tributo IN varchar,
 new_tipo_utilizzo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_UTILIZZO"
   cursor cpk1_utilizzi_tributo(var_tipo_utilizzo number) is
      select 1
      from   TIPI_UTILIZZO
      where  TIPO_UTILIZZO = var_tipo_utilizzo
       and   var_tipo_utilizzo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk2_utilizzi_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TIPI_UTILIZZO" deve esistere quando si inserisce su "UTILIZZI_TRIBUTO"
         if NEW_TIPO_UTILIZZO is not null then
            open  cpk1_utilizzi_tributo(NEW_TIPO_UTILIZZO);
            fetch cpk1_utilizzi_tributo into dummy;
            found := cpk1_utilizzi_tributo%FOUND;
            close cpk1_utilizzi_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Utilizzo. La registrazione Utilizzi Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "UTILIZZI_TRIBUTO"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk2_utilizzi_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk2_utilizzi_tributo into dummy;
            found := cpk2_utilizzi_tributo%FOUND;
            close cpk2_utilizzi_tributo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Utilizzi Tributo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTILIZZI_TRIBUTO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table UTILIZZI_TRIBUTO
/* End Trigger: UTILIZZI_TRIBUTO_TC */

-- Procedure UTILIZZI_TRIBUTO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table UTILIZZI_TRIBUTO

create or replace procedure UTILIZZI_TRIBUTO_PU
(old_tipo_tributo IN varchar,
 old_tipo_utilizzo IN number,
 new_tipo_tributo IN varchar,
 new_tipo_utilizzo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_UTILIZZO"
   cursor cpk1_utilizzi_tributo(var_tipo_utilizzo number) is
      select 1
      from   TIPI_UTILIZZO
      where  TIPO_UTILIZZO = var_tipo_utilizzo
       and   var_tipo_utilizzo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk2_utilizzi_tributo(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TIPI_UTILIZZO" deve esistere quando si modifica "UTILIZZI_TRIBUTO"
         if  NEW_TIPO_UTILIZZO is not null and ( seq = 0 )
         and (   (NEW_TIPO_UTILIZZO != OLD_TIPO_UTILIZZO or OLD_TIPO_UTILIZZO is null) ) then
            open  cpk1_utilizzi_tributo(NEW_TIPO_UTILIZZO);
            fetch cpk1_utilizzi_tributo into dummy;
            found := cpk1_utilizzi_tributo%FOUND;
            close cpk1_utilizzi_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Utilizzo. La registrazione Utilizzi Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "UTILIZZI_TRIBUTO"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk2_utilizzi_tributo(NEW_TIPO_TRIBUTO);
            fetch cpk2_utilizzi_tributo into dummy;
            found := cpk2_utilizzi_tributo%FOUND;
            close cpk2_utilizzi_tributo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Utilizzi Tributo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: UTILIZZI_TRIBUTO_PU */
/

-- Trigger UTILIZZI_TRIBUTO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table UTILIZZI_TRIBUTO

create or replace trigger UTILIZZI_TRIBUTO_TIU
before INSERT
    or UPDATE
on UTILIZZI_TRIBUTO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         UTILIZZI_TRIBUTO_PU(:OLD.TIPO_TRIBUTO,
                             :OLD.TIPO_UTILIZZO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.TIPO_UTILIZZO);
         null;
      end if;
      if INSERTING then
         UTILIZZI_TRIBUTO_PI(:NEW.TIPO_TRIBUTO,
                             :NEW.TIPO_UTILIZZO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "UTILIZZI_TRIBUTO"
            cursor cpk_utilizzi_tributo(var_TIPO_TRIBUTO varchar,
                                        var_TIPO_UTILIZZO number) is
               select 1
                 from   UTILIZZI_TRIBUTO
                where  TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       TIPO_UTILIZZO = var_TIPO_UTILIZZO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "UTILIZZI_TRIBUTO"
               if :new.TIPO_TRIBUTO is not null and
                  :new.TIPO_UTILIZZO is not null then
                  open  cpk_utilizzi_tributo(:new.TIPO_TRIBUTO,
                                             :new.TIPO_UTILIZZO);
                  fetch cpk_utilizzi_tributo into dummy;
                  found := cpk_utilizzi_tributo%FOUND;
                  close cpk_utilizzi_tributo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.TIPO_TRIBUTO||' '||
                               :new.TIPO_UTILIZZO||
                               '" gia'' presente in Utilizzi Tributo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: UTILIZZI_TRIBUTO_TIU */
/

-- Procedure VERSAMENTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table VERSAMENTI

create or replace procedure VERSAMENTI_PI
(new_cod_fiscale IN varchar,
 new_tipo_tributo IN varchar,
 new_oggetto_imposta IN number,
 new_rata_imposta IN number,
 new_pratica IN number,
 new_fonte IN number,
 new_ruolo IN number,
 new_fattura IN number,
 new_id_compensazione IN number,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "CONTRIBUENTI"
   cursor cpk1_versamenti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FONTI"
   cursor cpk2_versamenti(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk3_versamenti(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "OGGETTI_IMPOSTA"
   cursor cpk4_versamenti(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RATE_IMPOSTA"
   cursor cpk5_versamenti(var_rata_imposta number) is
      select 1
      from   RATE_IMPOSTA
      where  RATA_IMPOSTA = var_rata_imposta
       and   var_rata_imposta is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TIPI_TRIBUTO"
   cursor cpk6_versamenti(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk7_versamenti(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FATTURE"
   cursor cpk8_versamenti(var_fattura number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "COMPENSAZIONI"
   cursor cpk9_versamenti(var_id_compensazione number) is
      select 1
      from   COMPENSAZIONI
      where  ID_COMPENSAZIONE = var_id_compensazione
       and   var_id_compensazione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "DOCUMENTI_CARICATI"
   cursor cpk10_versamenti(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_COD_FISCALE is not null then
            open  cpk1_versamenti(NEW_COD_FISCALE);
            fetch cpk1_versamenti into dummy;
            found := cpk1_versamenti%FOUND;
            close cpk1_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_FONTE is not null then
            open  cpk2_versamenti(NEW_FONTE);
            fetch cpk2_versamenti into dummy;
            found := cpk2_versamenti%FOUND;
            close cpk2_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_PRATICA is not null then
            open  cpk3_versamenti(NEW_PRATICA);
            fetch cpk3_versamenti into dummy;
            found := cpk3_versamenti%FOUND;
            close cpk3_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_OGGETTO_IMPOSTA is not null then
            open  cpk4_versamenti(NEW_OGGETTO_IMPOSTA);
            fetch cpk4_versamenti into dummy;
            found := cpk4_versamenti%FOUND;
            close cpk4_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RATE_IMPOSTA" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_RATA_IMPOSTA is not null then
            open  cpk5_versamenti(NEW_RATA_IMPOSTA);
            fetch cpk5_versamenti into dummy;
            found := cpk5_versamenti%FOUND;
            close cpk5_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Rate Imposta. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_TIPO_TRIBUTO is not null then
            open  cpk6_versamenti(NEW_TIPO_TRIBUTO);
            fetch cpk6_versamenti into dummy;
            found := cpk6_versamenti%FOUND;
            close cpk6_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_RUOLO is not null then
            open  cpk7_versamenti(NEW_RUOLO);
            fetch cpk7_versamenti into dummy;
            found := cpk7_versamenti%FOUND;
            close cpk7_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FATTURE" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_FATTURA is not null then
            open  cpk8_versamenti(NEW_FATTURA);
            fetch cpk8_versamenti into dummy;
            found := cpk8_versamenti%FOUND;
            close cpk8_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "COMPENSAZIONI" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_ID_COMPENSAZIONE is not null then
            open  cpk9_versamenti(NEW_ID_COMPENSAZIONE);
            fetch cpk9_versamenti into dummy;
            found := cpk9_versamenti%FOUND;
            close cpk9_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Compensazioni. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si inserisce su "VERSAMENTI"
         if NEW_DOCUMENTO_ID is not null then
            open  cpk10_versamenti(NEW_DOCUMENTO_ID);
            fetch cpk10_versamenti into dummy;
            found := cpk10_versamenti%FOUND;
            close cpk10_versamenti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione Versamenti non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: VERSAMENTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table VERSAMENTI

create or replace trigger VERSAMENTI_tb
before INSERT
    or UPDATE
    or DELETE
on VERSAMENTI
BEGIN
   -- RESET PostEvent for Custom Functional Check
   IF IntegrityPackage.GetNestLevel = 0 THEN
      IntegrityPackage.InitNestLevel;
   END IF;
END;
/* End Trigger: VERSAMENTI_TB */
/

create or replace trigger VERSAMENTI_tc
after INSERT
   or UPDATE
   or DELETE
on VERSAMENTI
BEGIN
   -- EXEC PostEvent for Custom Functional Check
   IntegrityPackage.Exec_PostEvent;
END;
/* End Trigger: VERSAMENTI_TC */
/

-- Procedure VERSAMENTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table VERSAMENTI

create or replace procedure VERSAMENTI_PU
(old_cod_fiscale IN varchar,
 old_anno IN number,
 old_tipo_tributo IN varchar,
 old_sequenza IN number,
 old_oggetto_imposta IN number,
 old_rata_imposta IN number,
 old_pratica IN number,
 old_fonte IN number,
 old_ruolo IN number,
 old_fattura IN number,
 old_id_compensazione IN number,
 old_documento_id IN number,
 new_cod_fiscale IN varchar,
 new_anno IN number,
 new_tipo_tributo IN varchar,
 new_sequenza IN number,
 new_oggetto_imposta IN number,
 new_rata_imposta IN number,
 new_pratica IN number,
 new_fonte IN number,
 new_ruolo IN number,
 new_fattura IN number,
 new_id_compensazione IN number,
 new_documento_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "CONTRIBUENTI"
   cursor cpk1_versamenti(var_cod_fiscale varchar) is
      select 1
      from   CONTRIBUENTI
      where  COD_FISCALE = var_cod_fiscale
       and   var_cod_fiscale is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FONTI"
   cursor cpk2_versamenti(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk3_versamenti(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "OGGETTI_IMPOSTA"
   cursor cpk4_versamenti(var_oggetto_imposta number) is
      select 1
      from   OGGETTI_IMPOSTA
      where  OGGETTO_IMPOSTA = var_oggetto_imposta
       and   var_oggetto_imposta is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RATE_IMPOSTA"
   cursor cpk5_versamenti(var_rata_imposta number) is
      select 1
      from   RATE_IMPOSTA
      where  RATA_IMPOSTA = var_rata_imposta
       and   var_rata_imposta is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TIPI_TRIBUTO"
   cursor cpk6_versamenti(var_tipo_tributo varchar) is
      select 1
      from   TIPI_TRIBUTO
      where  TIPO_TRIBUTO = var_tipo_tributo
       and   var_tipo_tributo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk7_versamenti(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FATTURE"
   cursor cpk8_versamenti(var_fattura number) is
      select 1
      from   FATTURE
      where  FATTURA = var_fattura
       and   var_fattura is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "COMPENSAZIONI"
   cursor cpk9_versamenti(var_id_compensazione number) is
      select 1
      from   COMPENSAZIONI
      where  ID_COMPENSAZIONE = var_id_compensazione
       and   var_id_compensazione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "DOCUMENTI_CARICATI"
   cursor cpk10_versamenti(var_documento_id number) is
      select 1
      from   DOCUMENTI_CARICATI
      where  DOCUMENTO_ID = var_documento_id
       and   var_documento_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "CONTRIBUENTI" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_COD_FISCALE is not null and ( seq = 0 )
         and (   (NEW_COD_FISCALE != OLD_COD_FISCALE or OLD_COD_FISCALE is null) ) then
            open  cpk1_versamenti(NEW_COD_FISCALE);
            fetch cpk1_versamenti into dummy;
            found := cpk1_versamenti%FOUND;
            close cpk1_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Contribuenti. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FONTI" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_FONTE is not null and ( seq = 0 )
         and (   (NEW_FONTE != OLD_FONTE or OLD_FONTE is null) ) then
            open  cpk2_versamenti(NEW_FONTE);
            fetch cpk2_versamenti into dummy;
            found := cpk2_versamenti%FOUND;
            close cpk2_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk3_versamenti(NEW_PRATICA);
            fetch cpk3_versamenti into dummy;
            found := cpk3_versamenti%FOUND;
            close cpk3_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "OGGETTI_IMPOSTA" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_OGGETTO_IMPOSTA is not null and ( seq = 0 )
         and (   (NEW_OGGETTO_IMPOSTA != OLD_OGGETTO_IMPOSTA or OLD_OGGETTO_IMPOSTA is null) ) then
            open  cpk4_versamenti(NEW_OGGETTO_IMPOSTA);
            fetch cpk4_versamenti into dummy;
            found := cpk4_versamenti%FOUND;
            close cpk4_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Oggetti Imposta. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RATE_IMPOSTA" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_RATA_IMPOSTA is not null and ( seq = 0 )
         and (   (NEW_RATA_IMPOSTA != OLD_RATA_IMPOSTA or OLD_RATA_IMPOSTA is null) ) then
            open  cpk5_versamenti(NEW_RATA_IMPOSTA);
            fetch cpk5_versamenti into dummy;
            found := cpk5_versamenti%FOUND;
            close cpk5_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Rate Imposta. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "TIPI_TRIBUTO" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_TIPO_TRIBUTO is not null and ( seq = 0 )
         and (   (NEW_TIPO_TRIBUTO != OLD_TIPO_TRIBUTO or OLD_TIPO_TRIBUTO is null) ) then
            open  cpk6_versamenti(NEW_TIPO_TRIBUTO);
            fetch cpk6_versamenti into dummy;
            found := cpk6_versamenti%FOUND;
            close cpk6_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Tipi Tributo. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk7_versamenti(NEW_RUOLO);
            fetch cpk7_versamenti into dummy;
            found := cpk7_versamenti%FOUND;
            close cpk7_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "FATTURE" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_FATTURA is not null and ( seq = 0 )
         and (   (NEW_FATTURA != OLD_FATTURA or OLD_FATTURA is null) ) then
            open  cpk8_versamenti(NEW_FATTURA);
            fetch cpk8_versamenti into dummy;
            found := cpk8_versamenti%FOUND;
            close cpk8_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fatture. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "COMPENSAZIONI" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_ID_COMPENSAZIONE is not null and ( seq = 0 )
         and (   (NEW_ID_COMPENSAZIONE != OLD_ID_COMPENSAZIONE or OLD_ID_COMPENSAZIONE is null) ) then
            open  cpk9_versamenti(NEW_ID_COMPENSAZIONE);
            fetch cpk9_versamenti into dummy;
            found := cpk9_versamenti%FOUND;
            close cpk9_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Compensazioni. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "DOCUMENTI_CARICATI" deve esistere quando si modifica "VERSAMENTI"
         if  NEW_DOCUMENTO_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null) ) then
            open  cpk10_versamenti(NEW_DOCUMENTO_ID);
            fetch cpk10_versamenti into dummy;
            found := cpk10_versamenti%FOUND;
            close cpk10_versamenti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su DOCUMENTI_CARICATI. La registrazione Versamenti non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: VERSAMENTI_PU */
/

-- Trigger VERSAMENTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table VERSAMENTI

create or replace trigger VERSAMENTI_TIU
before INSERT
    or UPDATE
on VERSAMENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      VERSAMENTI_DI (:new.data_pagamento,:new.importo_versato,:new.pratica,:new.rata,
                     :new.tipo_versamento);
      :new.data_variazione := trunc(sysdate);
   end;

   if INSERTING and :new.sequenza is null then
          VERSAMENTI_NR(:new.cod_fiscale,:new.anno,:new.tipo_tributo,:new.sequenza);
    end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         VERSAMENTI_PU(:OLD.COD_FISCALE,
                       :OLD.ANNO,
                       :OLD.TIPO_TRIBUTO,
                       :OLD.SEQUENZA,
                       :OLD.OGGETTO_IMPOSTA,
                       :OLD.RATA_IMPOSTA,
                       :OLD.PRATICA,
                       :OLD.FONTE,
                       :OLD.RUOLO,
                       :OLD.FATTURA,
                       :OLD.ID_COMPENSAZIONE,
                       :OLD.DOCUMENTO_ID,
                         :NEW.COD_FISCALE,
                         :NEW.ANNO,
                         :NEW.TIPO_TRIBUTO,
                         :NEW.SEQUENZA,
                         :NEW.OGGETTO_IMPOSTA,
                         :NEW.RATA_IMPOSTA,
                         :NEW.PRATICA,
                         :NEW.FONTE,
                         :NEW.RUOLO,
                         :NEW.FATTURA,
                         :NEW.ID_COMPENSAZIONE,
                         :NEW.DOCUMENTO_ID);
         null;
      end if;
      if INSERTING then
         VERSAMENTI_PI(:NEW.COD_FISCALE,
                       :NEW.TIPO_TRIBUTO,
                       :NEW.OGGETTO_IMPOSTA,
                       :NEW.RATA_IMPOSTA,
                       :NEW.PRATICA,
                       :NEW.FONTE,
                       :NEW.RUOLO,
                       :NEW.FATTURA,
                       :NEW.ID_COMPENSAZIONE,
                       :NEW.DOCUMENTO_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "VERSAMENTI"
            cursor cpk_versamenti(var_COD_FISCALE varchar,
                                  var_ANNO number,
                                  var_TIPO_TRIBUTO varchar,
                                  var_SEQUENZA number) is
               select 1
                 from   VERSAMENTI
                where  COD_FISCALE = var_COD_FISCALE and
                       ANNO = var_ANNO and
                       TIPO_TRIBUTO = var_TIPO_TRIBUTO and
                       SEQUENZA = var_SEQUENZA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "VERSAMENTI"
               if :new.COD_FISCALE is not null and
                  :new.ANNO is not null and
                  :new.TIPO_TRIBUTO is not null and
                  :new.SEQUENZA is not null then
                  open  cpk_versamenti(:new.COD_FISCALE,
                                       :new.ANNO,
                                       :new.TIPO_TRIBUTO,
                                       :new.SEQUENZA);
                  fetch cpk_versamenti into dummy;
                  found := cpk_versamenti%FOUND;
                  close cpk_versamenti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.COD_FISCALE||' '||
                               :new.ANNO||' '||
                               :new.TIPO_TRIBUTO||' '||
                               :new.SEQUENZA||
                               '" gia'' presente in Versamenti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: VERSAMENTI_TIU */
/

-- Tigger VERSAMENTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table VERSAMENTI

create or replace trigger VERSAMENTI_TD
before DELETE
on VERSAMENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      VERSAMENTI_PD(:OLD.COD_FISCALE,
                    :OLD.ANNO,
                    :OLD.TIPO_TRIBUTO,
                    :OLD.SEQUENZA);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;

   begin  -- Set PostEvent Check REFERENTIAL Integrity on DELETE
      DECLARE
	a_istruzione  varchar2(2000);
              a_messaggio   varchar2(2000);
      BEGIN
            a_istruzione := 'BEGIN CONTRIBUENTI_CHK_DEL('''||:old.cod_fiscale||''','||nvl(:old.pratica,0)||'); end;';
            a_messaggio := '';
            IntegrityPackage.Set_PostEvent(a_istruzione, a_messaggio);
      EXCEPTION
         WHEN OTHERS THEN
              IntegrityPackage.InitNestLevel;
              raise;
      END;

   end;

exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: VERSAMENTI_TD */
/

-- Procedure WEB_CALCOLO_DETTAGLI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WEB_CALCOLO_DETTAGLI

create or replace procedure WEB_CALCOLO_DETTAGLI_PI
(new_id_calcolo_individuale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WEB_CALCOLO_INDIVIDUALE"
   cursor cpk1_web_calcolo_dettagli(var_id_calcolo_individuale number) is
      select 1
      from   WEB_CALCOLO_INDIVIDUALE
      where  ID_CALCOLO_INDIVIDUALE = var_id_calcolo_individuale
       and   var_id_calcolo_individuale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WEB_CALCOLO_INDIVIDUALE" deve esistere quando si inserisce su "WEB_CALCOLO_DETTAGLI"
         if NEW_ID_CALCOLO_INDIVIDUALE is not null then
            open  cpk1_web_calcolo_dettagli(NEW_ID_CALCOLO_INDIVIDUALE);
            fetch cpk1_web_calcolo_dettagli into dummy;
            found := cpk1_web_calcolo_dettagli%FOUND;
            close cpk1_web_calcolo_dettagli;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WEB_CALCOLO_INDIVIDUALE. La registrazione WEB_CALCOLO_DETTAGLI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CALCOLO_DETTAGLI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WEB_CALCOLO_DETTAGLI
/* End Trigger: WEB_CALCOLO_DETTAGLI_TC */

-- Procedure WEB_CALCOLO_DETTAGLI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CALCOLO_DETTAGLI

create or replace procedure WEB_CALCOLO_DETTAGLI_PU
(old_id_calcolo_dettagli IN number,
 old_id_calcolo_individuale IN number,
 new_id_calcolo_dettagli IN number,
 new_id_calcolo_individuale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WEB_CALCOLO_INDIVIDUALE"
   cursor cpk1_web_calcolo_dettagli(var_id_calcolo_individuale number) is
      select 1
      from   WEB_CALCOLO_INDIVIDUALE
      where  ID_CALCOLO_INDIVIDUALE = var_id_calcolo_individuale
       and   var_id_calcolo_individuale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WEB_CALCOLO_INDIVIDUALE" deve esistere quando si modifica "WEB_CALCOLO_DETTAGLI"
         if  NEW_ID_CALCOLO_INDIVIDUALE is not null and ( seq = 0 )
         and (   (NEW_ID_CALCOLO_INDIVIDUALE != OLD_ID_CALCOLO_INDIVIDUALE or OLD_ID_CALCOLO_INDIVIDUALE is null) ) then
            open  cpk1_web_calcolo_dettagli(NEW_ID_CALCOLO_INDIVIDUALE);
            fetch cpk1_web_calcolo_dettagli into dummy;
            found := cpk1_web_calcolo_dettagli%FOUND;
            close cpk1_web_calcolo_dettagli;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WEB_CALCOLO_INDIVIDUALE. La registrazione WEB_CALCOLO_DETTAGLI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CALCOLO_DETTAGLI_PU */
/

-- Trigger WEB_CALCOLO_DETTAGLI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CALCOLO_DETTAGLI

create or replace trigger WEB_CALCOLO_DETTAGLI_TIU
before INSERT
    or UPDATE
on WEB_CALCOLO_DETTAGLI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
    IF INSERTING
    THEN
      IF :NEW.ID_CALCOLO_DETTAGLI IS NULL
      THEN
         SELECT WCDE_SQ.NEXTVAL INTO :NEW.ID_CALCOLO_DETTAGLI FROM DUAL;
      END IF;
      IF :NEW.VERSION IS NULL
      THEN
        :NEW.VERSION := 0;
      END IF;
      :NEW.DATE_CREATED := SYSDATE;
    END IF;
    SELECT CASE :NEW.TIPO_OGGETTO
                WHEN 'TERRENO' THEN 1
                WHEN 'AREA' THEN 2
                WHEN 'ABITAZIONE_PRINCIPALE' THEN 3
                WHEN 'RURALE' THEN 4
                WHEN 'ALTRO_FABBRICATO' THEN 5
                WHEN 'FABBRICATO_D' THEN 6
                WHEN 'FABBRICATO_MERCE' THEN 7
                WHEN 'DETRAZIONE' THEN 8
             END
      INTO :NEW.ORDINAMENTO
      FROM DUAL;

    :NEW.LAST_UPDATED := SYSDATE;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CALCOLO_DETTAGLI_PU(:OLD.ID_CALCOLO_DETTAGLI,
                                 :OLD.ID_CALCOLO_INDIVIDUALE,
                         :NEW.ID_CALCOLO_DETTAGLI,
                         :NEW.ID_CALCOLO_INDIVIDUALE);
         null;
      end if;
      if INSERTING then
         WEB_CALCOLO_DETTAGLI_PI(:NEW.ID_CALCOLO_INDIVIDUALE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CALCOLO_DETTAGLI"
            cursor cpk_web_calcolo_dettagli(var_ID_CALCOLO_DETTAGLI number) is
               select 1
                 from   WEB_CALCOLO_DETTAGLI
                where  ID_CALCOLO_DETTAGLI = var_ID_CALCOLO_DETTAGLI;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CALCOLO_DETTAGLI"
               if :new.ID_CALCOLO_DETTAGLI is not null then
                  open  cpk_web_calcolo_dettagli(:new.ID_CALCOLO_DETTAGLI);
                  fetch cpk_web_calcolo_dettagli into dummy;
                  found := cpk_web_calcolo_dettagli%FOUND;
                  close cpk_web_calcolo_dettagli;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_CALCOLO_DETTAGLI||
                               '" gia'' presente in WEB_CALCOLO_DETTAGLI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CALCOLO_DETTAGLI_TIU */
/

-- Procedure WEB_CALCOLO_INDIVIDUALE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WEB_CALCOLO_INDIVIDUALE

create or replace procedure WEB_CALCOLO_INDIVIDUALE_PI
(new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "PRATICHE_TRIBUTO"
   cursor cpk1_web_calcolo_individuale(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si inserisce su "WEB_CALCOLO_INDIVIDUALE"
         if NEW_PRATICA is not null then
            open  cpk1_web_calcolo_individuale(NEW_PRATICA);
            fetch cpk1_web_calcolo_individuale into dummy;
            found := cpk1_web_calcolo_individuale%FOUND;
            close cpk1_web_calcolo_individuale;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione WEB_CALCOLO_INDIVIDUALE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CALCOLO_INDIVIDUALE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WEB_CALCOLO_INDIVIDUALE
/* End Trigger: WEB_CALCOLO_INDIVIDUALE_TC */

-- Procedure WEB_CALCOLO_INDIVIDUALE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CALCOLO_INDIVIDUALE

create or replace procedure WEB_CALCOLO_INDIVIDUALE_PU
(old_id_calcolo_individuale IN number,
 old_pratica IN number,
 new_id_calcolo_individuale IN number,
 new_pratica IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "PRATICHE_TRIBUTO"
   cursor cpk1_web_calcolo_individuale(var_pratica number) is
      select 1
      from   PRATICHE_TRIBUTO
      where  PRATICA = var_pratica
       and   var_pratica is not null;

   --  Declaration of UpdateParentRestrict constraint for "WEB_CALCOLO_DETTAGLI"
   cursor cfk1_web_calcolo_individuale(var_id_calcolo_individuale number) is
      select 1
      from   WEB_CALCOLO_DETTAGLI
      where  ID_CALCOLO_INDIVIDUALE = var_id_calcolo_individuale
       and   var_id_calcolo_individuale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "PRATICHE_TRIBUTO" deve esistere quando si modifica "WEB_CALCOLO_INDIVIDUALE"
         if  NEW_PRATICA is not null and ( seq = 0 )
         and (   (NEW_PRATICA != OLD_PRATICA or OLD_PRATICA is null) ) then
            open  cpk1_web_calcolo_individuale(NEW_PRATICA);
            fetch cpk1_web_calcolo_individuale into dummy;
            found := cpk1_web_calcolo_individuale%FOUND;
            close cpk1_web_calcolo_individuale;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Pratiche Tributo. La registrazione WEB_CALCOLO_INDIVIDUALE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "WEB_CALCOLO_INDIVIDUALE" non modificabile se esistono referenze su "WEB_CALCOLO_DETTAGLI"
      if (OLD_ID_CALCOLO_INDIVIDUALE != NEW_ID_CALCOLO_INDIVIDUALE) then
         open  cfk1_web_calcolo_individuale(OLD_ID_CALCOLO_INDIVIDUALE);
         fetch cfk1_web_calcolo_individuale into dummy;
         found := cfk1_web_calcolo_individuale%FOUND;
         close cfk1_web_calcolo_individuale;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_CALCOLO_DETTAGLI. La registrazione di WEB_CALCOLO_INDIVIDUALE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CALCOLO_INDIVIDUALE_PU */
/

-- Trigger WEB_CALCOLO_INDIVIDUALE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CALCOLO_INDIVIDUALE

create or replace trigger WEB_CALCOLO_INDIVIDUALE_TIU
before INSERT
    or UPDATE
on WEB_CALCOLO_INDIVIDUALE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
    IF INSERTING
    THEN
      IF :NEW.ID_CALCOLO_INDIVIDUALE IS NULL
      THEN
         SELECT WCIN_SQ.NEXTVAL INTO :NEW.ID_CALCOLO_INDIVIDUALE FROM DUAL;
      END IF;
      IF :NEW.VERSION IS NULL
      THEN
        :NEW.VERSION := 0;
      END IF;
      :NEW.DATE_CREATED := SYSDATE;
    END IF;

    :NEW.LAST_UPDATED := SYSDATE;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CALCOLO_INDIVIDUALE_PU(:OLD.ID_CALCOLO_INDIVIDUALE,
                                    :OLD.PRATICA,
                         :NEW.ID_CALCOLO_INDIVIDUALE,
                         :NEW.PRATICA);
         null;
      end if;
      if INSERTING then
         WEB_CALCOLO_INDIVIDUALE_PI(:NEW.PRATICA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CALCOLO_INDIVIDUALE"
            cursor cpk_web_calcolo_individuale(var_ID_CALCOLO_INDIVIDUALE number) is
               select 1
                 from   WEB_CALCOLO_INDIVIDUALE
                where  ID_CALCOLO_INDIVIDUALE = var_ID_CALCOLO_INDIVIDUALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CALCOLO_INDIVIDUALE"
               if :new.ID_CALCOLO_INDIVIDUALE is not null then
                  open  cpk_web_calcolo_individuale(:new.ID_CALCOLO_INDIVIDUALE);
                  fetch cpk_web_calcolo_individuale into dummy;
                  found := cpk_web_calcolo_individuale%FOUND;
                  close cpk_web_calcolo_individuale;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_CALCOLO_INDIVIDUALE||
                               '" gia'' presente in WEB_CALCOLO_INDIVIDUALE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CALCOLO_INDIVIDUALE_TIU */
/

-- Procedure WEB_CALCOLO_INDIVIDUALE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WEB_CALCOLO_INDIVIDUALE

create or replace procedure WEB_CALCOLO_INDIVIDUALE_PD
(old_id_calcolo_individuale IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CALCOLO_INDIVIDUALE_PD */
/

-- Tigger WEB_CALCOLO_INDIVIDUALE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WEB_CALCOLO_INDIVIDUALE

create or replace trigger WEB_CALCOLO_INDIVIDUALE_TD
before DELETE
on WEB_CALCOLO_INDIVIDUALE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      WEB_CALCOLO_INDIVIDUALE_PD(:OLD.ID_CALCOLO_INDIVIDUALE);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "WEB_CALCOLO_DETTAGLI"
      delete WEB_CALCOLO_DETTAGLI
      where  ID_CALCOLO_INDIVIDUALE = :OLD.ID_CALCOLO_INDIVIDUALE;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CALCOLO_INDIVIDUALE_TD */
/

-- Procedure WEB_CC_FABBRICATI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CC_FABBRICATI

create or replace procedure WEB_CC_FABBRICATI_PU
(old_id_fabbricato IN number,
 new_id_fabbricato IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "WEB_CC_IDENTIFICATIVI"
   cursor cfk1_web_cc_fabbricati(var_id_fabbricato number) is
      select 1
      from   WEB_CC_IDENTIFICATIVI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;

   --  Declaration of UpdateParentRestrict constraint for "WEB_CC_INDIRIZZI"
   cursor cfk2_web_cc_fabbricati(var_id_fabbricato number) is
      select 1
      from   WEB_CC_INDIRIZZI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;

   --  Declaration of UpdateParentRestrict constraint for "WEB_CC_TITOLARITA"
   cursor cfk3_web_cc_fabbricati(var_id_fabbricato number) is
      select 1
      from   WEB_CC_TITOLARITA
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "WEB_CC_FABBRICATI" non modificabile se esistono referenze su "WEB_CC_IDENTIFICATIVI"
      if (OLD_ID_FABBRICATO != NEW_ID_FABBRICATO) then
         open  cfk1_web_cc_fabbricati(OLD_ID_FABBRICATO);
         fetch cfk1_web_cc_fabbricati into dummy;
         found := cfk1_web_cc_fabbricati%FOUND;
         close cfk1_web_cc_fabbricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_CC_IDENTIFICATIVI. La registrazione di WEB_CC_FABBRICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "WEB_CC_FABBRICATI" non modificabile se esistono referenze su "WEB_CC_INDIRIZZI"
      if (OLD_ID_FABBRICATO != NEW_ID_FABBRICATO) then
         open  cfk2_web_cc_fabbricati(OLD_ID_FABBRICATO);
         fetch cfk2_web_cc_fabbricati into dummy;
         found := cfk2_web_cc_fabbricati%FOUND;
         close cfk2_web_cc_fabbricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_CC_INDIRIZZI. La registrazione di WEB_CC_FABBRICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "WEB_CC_FABBRICATI" non modificabile se esistono referenze su "WEB_CC_TITOLARITA"
      if (OLD_ID_FABBRICATO != NEW_ID_FABBRICATO) then
         open  cfk3_web_cc_fabbricati(OLD_ID_FABBRICATO);
         fetch cfk3_web_cc_fabbricati into dummy;
         found := cfk3_web_cc_fabbricati%FOUND;
         close cfk3_web_cc_fabbricati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_CC_TITOLARITA. La registrazione di WEB_CC_FABBRICATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_FABBRICATI_PU */
/

-- Trigger WEB_CC_FABBRICATI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CC_FABBRICATI

create or replace trigger WEB_CC_FABBRICATI_TIU
before INSERT
    or UPDATE
on WEB_CC_FABBRICATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CC_FABBRICATI_PU(:OLD.ID_FABBRICATO,
                         :NEW.ID_FABBRICATO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CC_FABBRICATI"
            cursor cpk_web_cc_fabbricati(var_ID_FABBRICATO number) is
               select 1
                 from   WEB_CC_FABBRICATI
                where  ID_FABBRICATO = var_ID_FABBRICATO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CC_FABBRICATI"
               if :new.ID_FABBRICATO is not null then
                  open  cpk_web_cc_fabbricati(:new.ID_FABBRICATO);
                  fetch cpk_web_cc_fabbricati into dummy;
                  found := cpk_web_cc_fabbricati%FOUND;
                  close cpk_web_cc_fabbricati;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_FABBRICATO||
                               '" gia'' presente in WEB_CC_FABBRICATI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_FABBRICATI_TIU */
/

-- Procedure WEB_CC_FABBRICATI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WEB_CC_FABBRICATI

create or replace procedure WEB_CC_FABBRICATI_PD
(old_id_fabbricato IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WEB_CC_IDENTIFICATIVI"
   cursor cfk1_web_cc_fabbricati(var_id_fabbricato number) is
      select 1
      from   WEB_CC_IDENTIFICATIVI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;

   --  Declaration of DeleteParentRestrict constraint for "WEB_CC_INDIRIZZI"
   cursor cfk2_web_cc_fabbricati(var_id_fabbricato number) is
      select 1
      from   WEB_CC_INDIRIZZI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;

   --  Declaration of DeleteParentRestrict constraint for "WEB_CC_TITOLARITA"
   cursor cfk3_web_cc_fabbricati(var_id_fabbricato number) is
      select 1
      from   WEB_CC_TITOLARITA
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WEB_CC_FABBRICATI" if children still exist in "WEB_CC_IDENTIFICATIVI"
      open  cfk1_web_cc_fabbricati(OLD_ID_FABBRICATO);
      fetch cfk1_web_cc_fabbricati into dummy;
      found := cfk1_web_cc_fabbricati%FOUND;
      close cfk1_web_cc_fabbricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WEB_CC_IDENTIFICATIVI. La registrazione di WEB_CC_FABBRICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "WEB_CC_FABBRICATI" if children still exist in "WEB_CC_INDIRIZZI"
      open  cfk2_web_cc_fabbricati(OLD_ID_FABBRICATO);
      fetch cfk2_web_cc_fabbricati into dummy;
      found := cfk2_web_cc_fabbricati%FOUND;
      close cfk2_web_cc_fabbricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WEB_CC_INDIRIZZI. La registrazione di WEB_CC_FABBRICATI non e'' eliminabile.';
         raise integrity_error;
      end if;

      --  Cannot delete parent "WEB_CC_FABBRICATI" if children still exist in "WEB_CC_TITOLARITA"
      open  cfk3_web_cc_fabbricati(OLD_ID_FABBRICATO);
      fetch cfk3_web_cc_fabbricati into dummy;
      found := cfk3_web_cc_fabbricati%FOUND;
      close cfk3_web_cc_fabbricati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WEB_CC_TITOLARITA. La registrazione di WEB_CC_FABBRICATI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_FABBRICATI_PD */
/

-- Tigger WEB_CC_FABBRICATI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WEB_CC_FABBRICATI

create or replace trigger WEB_CC_FABBRICATI_TD
before DELETE
on WEB_CC_FABBRICATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WEB_CC_IDENTIFICATIVI

      -- Child Restrict Table: WEB_CC_INDIRIZZI

      -- Child Restrict Table: WEB_CC_TITOLARITA

      WEB_CC_FABBRICATI_PD(:OLD.ID_FABBRICATO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_FABBRICATI_TD */
/

-- Procedure WEB_CC_IDENTIFICATIVI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WEB_CC_IDENTIFICATIVI

create or replace procedure WEB_CC_IDENTIFICATIVI_PI
(new_id_fabbricato IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WEB_CC_FABBRICATI"
   cursor cpk1_web_cc_identificativi(var_id_fabbricato number) is
      select 1
      from   WEB_CC_FABBRICATI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WEB_CC_FABBRICATI" deve esistere quando si inserisce su "WEB_CC_IDENTIFICATIVI"
         if NEW_ID_FABBRICATO is not null then
            open  cpk1_web_cc_identificativi(NEW_ID_FABBRICATO);
            fetch cpk1_web_cc_identificativi into dummy;
            found := cpk1_web_cc_identificativi%FOUND;
            close cpk1_web_cc_identificativi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WEB_CC_FABBRICATI. La registrazione WEB_CC_IDENTIFICATIVI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_IDENTIFICATIVI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WEB_CC_IDENTIFICATIVI
/* End Trigger: WEB_CC_IDENTIFICATIVI_TC */

-- Procedure WEB_CC_IDENTIFICATIVI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CC_IDENTIFICATIVI

create or replace procedure WEB_CC_IDENTIFICATIVI_PU
(old_id_identificativo IN number,
 old_id_fabbricato IN number,
 new_id_identificativo IN number,
 new_id_fabbricato IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WEB_CC_FABBRICATI"
   cursor cpk1_web_cc_identificativi(var_id_fabbricato number) is
      select 1
      from   WEB_CC_FABBRICATI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WEB_CC_FABBRICATI" deve esistere quando si modifica "WEB_CC_IDENTIFICATIVI"
         if  NEW_ID_FABBRICATO is not null and ( seq = 0 )
         and (   (NEW_ID_FABBRICATO != OLD_ID_FABBRICATO or OLD_ID_FABBRICATO is null) ) then
            open  cpk1_web_cc_identificativi(NEW_ID_FABBRICATO);
            fetch cpk1_web_cc_identificativi into dummy;
            found := cpk1_web_cc_identificativi%FOUND;
            close cpk1_web_cc_identificativi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WEB_CC_FABBRICATI. La registrazione WEB_CC_IDENTIFICATIVI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_IDENTIFICATIVI_PU */
/

-- Trigger WEB_CC_IDENTIFICATIVI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CC_IDENTIFICATIVI

create or replace trigger WEB_CC_IDENTIFICATIVI_TIU
before INSERT
    or UPDATE
on WEB_CC_IDENTIFICATIVI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CC_IDENTIFICATIVI_PU(:OLD.ID_IDENTIFICATIVO,
                                  :OLD.ID_FABBRICATO,
                         :NEW.ID_IDENTIFICATIVO,
                         :NEW.ID_FABBRICATO);
         null;
      end if;
      if INSERTING then
         WEB_CC_IDENTIFICATIVI_PI(:NEW.ID_FABBRICATO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CC_IDENTIFICATIVI"
            cursor cpk_web_cc_identificativi(var_ID_IDENTIFICATIVO number) is
               select 1
                 from   WEB_CC_IDENTIFICATIVI
                where  ID_IDENTIFICATIVO = var_ID_IDENTIFICATIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CC_IDENTIFICATIVI"
               if :new.ID_IDENTIFICATIVO is not null then
                  open  cpk_web_cc_identificativi(:new.ID_IDENTIFICATIVO);
                  fetch cpk_web_cc_identificativi into dummy;
                  found := cpk_web_cc_identificativi%FOUND;
                  close cpk_web_cc_identificativi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_IDENTIFICATIVO||
                               '" gia'' presente in WEB_CC_IDENTIFICATIVI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_IDENTIFICATIVI_TIU */
/

-- Procedure WEB_CC_INDIRIZZI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WEB_CC_INDIRIZZI

create or replace procedure WEB_CC_INDIRIZZI_PI
(new_id_fabbricato IN number,
 new_id_toponimo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WEB_CC_FABBRICATI"
   cursor cpk1_web_cc_indirizzi(var_id_fabbricato number) is
      select 1
      from   WEB_CC_FABBRICATI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WEB_CC_TOPONIMI"
   cursor cpk2_web_cc_indirizzi(var_id_toponimo number) is
      select 1
      from   WEB_CC_TOPONIMI
      where  ID_TOPONIMO = var_id_toponimo
       and   var_id_toponimo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WEB_CC_FABBRICATI" deve esistere quando si inserisce su "WEB_CC_INDIRIZZI"
         if NEW_ID_FABBRICATO is not null then
            open  cpk1_web_cc_indirizzi(NEW_ID_FABBRICATO);
            fetch cpk1_web_cc_indirizzi into dummy;
            found := cpk1_web_cc_indirizzi%FOUND;
            close cpk1_web_cc_indirizzi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WEB_CC_FABBRICATI. La registrazione WEB_CC_INDIRIZZI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WEB_CC_TOPONIMI" deve esistere quando si inserisce su "WEB_CC_INDIRIZZI"
         if NEW_ID_TOPONIMO is not null then
            open  cpk2_web_cc_indirizzi(NEW_ID_TOPONIMO);
            fetch cpk2_web_cc_indirizzi into dummy;
            found := cpk2_web_cc_indirizzi%FOUND;
            close cpk2_web_cc_indirizzi;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WEB_CC_TOPONIMI. La registrazione WEB_CC_INDIRIZZI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_INDIRIZZI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WEB_CC_INDIRIZZI
/* End Trigger: WEB_CC_INDIRIZZI_TC */

-- Procedure WEB_CC_INDIRIZZI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CC_INDIRIZZI

create or replace procedure WEB_CC_INDIRIZZI_PU
(old_id_indirizzo IN number,
 old_id_fabbricato IN number,
 old_id_toponimo IN number,
 new_id_indirizzo IN number,
 new_id_fabbricato IN number,
 new_id_toponimo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WEB_CC_FABBRICATI"
   cursor cpk1_web_cc_indirizzi(var_id_fabbricato number) is
      select 1
      from   WEB_CC_FABBRICATI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WEB_CC_TOPONIMI"
   cursor cpk2_web_cc_indirizzi(var_id_toponimo number) is
      select 1
      from   WEB_CC_TOPONIMI
      where  ID_TOPONIMO = var_id_toponimo
       and   var_id_toponimo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WEB_CC_FABBRICATI" deve esistere quando si modifica "WEB_CC_INDIRIZZI"
         if  NEW_ID_FABBRICATO is not null and ( seq = 0 )
         and (   (NEW_ID_FABBRICATO != OLD_ID_FABBRICATO or OLD_ID_FABBRICATO is null) ) then
            open  cpk1_web_cc_indirizzi(NEW_ID_FABBRICATO);
            fetch cpk1_web_cc_indirizzi into dummy;
            found := cpk1_web_cc_indirizzi%FOUND;
            close cpk1_web_cc_indirizzi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WEB_CC_FABBRICATI. La registrazione WEB_CC_INDIRIZZI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WEB_CC_TOPONIMI" deve esistere quando si modifica "WEB_CC_INDIRIZZI"
         if  NEW_ID_TOPONIMO is not null and ( seq = 0 )
         and (   (NEW_ID_TOPONIMO != OLD_ID_TOPONIMO or OLD_ID_TOPONIMO is null) ) then
            open  cpk2_web_cc_indirizzi(NEW_ID_TOPONIMO);
            fetch cpk2_web_cc_indirizzi into dummy;
            found := cpk2_web_cc_indirizzi%FOUND;
            close cpk2_web_cc_indirizzi;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WEB_CC_TOPONIMI. La registrazione WEB_CC_INDIRIZZI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_INDIRIZZI_PU */
/

-- Trigger WEB_CC_INDIRIZZI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CC_INDIRIZZI

create or replace trigger WEB_CC_INDIRIZZI_TIU
before INSERT
    or UPDATE
on WEB_CC_INDIRIZZI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CC_INDIRIZZI_PU(:OLD.ID_INDIRIZZO,
                             :OLD.ID_FABBRICATO,
                             :OLD.ID_TOPONIMO,
                         :NEW.ID_INDIRIZZO,
                         :NEW.ID_FABBRICATO,
                         :NEW.ID_TOPONIMO);
         null;
      end if;
      if INSERTING then
         WEB_CC_INDIRIZZI_PI(:NEW.ID_FABBRICATO,
                             :NEW.ID_TOPONIMO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CC_INDIRIZZI"
            cursor cpk_web_cc_indirizzi(var_ID_INDIRIZZO number) is
               select 1
                 from   WEB_CC_INDIRIZZI
                where  ID_INDIRIZZO = var_ID_INDIRIZZO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CC_INDIRIZZI"
               if :new.ID_INDIRIZZO is not null then
                  open  cpk_web_cc_indirizzi(:new.ID_INDIRIZZO);
                  fetch cpk_web_cc_indirizzi into dummy;
                  found := cpk_web_cc_indirizzi%FOUND;
                  close cpk_web_cc_indirizzi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_INDIRIZZO||
                               '" gia'' presente in WEB_CC_INDIRIZZI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_INDIRIZZI_TIU */
/

-- Procedure WEB_CC_PARTICELLE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CC_PARTICELLE

create or replace procedure WEB_CC_PARTICELLE_PU
(old_id_particella IN number,
 new_id_particella IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "WEB_CC_TITOLARITA"
   cursor cfk1_web_cc_particelle(var_id_particella number) is
      select 1
      from   WEB_CC_TITOLARITA
      where  ID_PARTICELLA = var_id_particella
       and   var_id_particella is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "WEB_CC_PARTICELLE" non modificabile se esistono referenze su "WEB_CC_TITOLARITA"
      if (OLD_ID_PARTICELLA != NEW_ID_PARTICELLA) then
         open  cfk1_web_cc_particelle(OLD_ID_PARTICELLA);
         fetch cfk1_web_cc_particelle into dummy;
         found := cfk1_web_cc_particelle%FOUND;
         close cfk1_web_cc_particelle;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_CC_TITOLARITA. La registrazione di WEB_CC_PARTICELLE non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_PARTICELLE_PU */
/

-- Trigger WEB_CC_PARTICELLE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CC_PARTICELLE

create or replace trigger WEB_CC_PARTICELLE_TIU
before INSERT
    or UPDATE
on WEB_CC_PARTICELLE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CC_PARTICELLE_PU(:OLD.ID_PARTICELLA,
                         :NEW.ID_PARTICELLA);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CC_PARTICELLE"
            cursor cpk_web_cc_particelle(var_ID_PARTICELLA number) is
               select 1
                 from   WEB_CC_PARTICELLE
                where  ID_PARTICELLA = var_ID_PARTICELLA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CC_PARTICELLE"
               if :new.ID_PARTICELLA is not null then
                  open  cpk_web_cc_particelle(:new.ID_PARTICELLA);
                  fetch cpk_web_cc_particelle into dummy;
                  found := cpk_web_cc_particelle%FOUND;
                  close cpk_web_cc_particelle;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_PARTICELLA||
                               '" gia'' presente in WEB_CC_PARTICELLE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_PARTICELLE_TIU */
/

-- Procedure WEB_CC_PARTICELLE_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WEB_CC_PARTICELLE

create or replace procedure WEB_CC_PARTICELLE_PD
(old_id_particella IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WEB_CC_TITOLARITA"
   cursor cfk1_web_cc_particelle(var_id_particella number) is
      select 1
      from   WEB_CC_TITOLARITA
      where  ID_PARTICELLA = var_id_particella
       and   var_id_particella is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WEB_CC_PARTICELLE" if children still exist in "WEB_CC_TITOLARITA"
      open  cfk1_web_cc_particelle(OLD_ID_PARTICELLA);
      fetch cfk1_web_cc_particelle into dummy;
      found := cfk1_web_cc_particelle%FOUND;
      close cfk1_web_cc_particelle;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WEB_CC_TITOLARITA. La registrazione di WEB_CC_PARTICELLE non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_PARTICELLE_PD */
/

-- Tigger WEB_CC_PARTICELLE_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WEB_CC_PARTICELLE

create or replace trigger WEB_CC_PARTICELLE_TD
before DELETE
on WEB_CC_PARTICELLE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WEB_CC_TITOLARITA

      WEB_CC_PARTICELLE_PD(:OLD.ID_PARTICELLA);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_PARTICELLE_TD */
/

-- Procedure WEB_CC_SOGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CC_SOGGETTI

create or replace procedure WEB_CC_SOGGETTI_PU
(old_id_soggetto IN number,
 new_id_soggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "WEB_CC_TITOLARITA"
   cursor cfk1_web_cc_soggetti(var_id_soggetto number) is
      select 1
      from   WEB_CC_TITOLARITA
      where  ID_SOGGETTO = var_id_soggetto
       and   var_id_soggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "WEB_CC_SOGGETTI" non modificabile se esistono referenze su "WEB_CC_TITOLARITA"
      if (OLD_ID_SOGGETTO != NEW_ID_SOGGETTO) then
         open  cfk1_web_cc_soggetti(OLD_ID_SOGGETTO);
         fetch cfk1_web_cc_soggetti into dummy;
         found := cfk1_web_cc_soggetti%FOUND;
         close cfk1_web_cc_soggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_CC_TITOLARITA. La registrazione di WEB_CC_SOGGETTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_SOGGETTI_PU */
/

-- Trigger WEB_CC_SOGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CC_SOGGETTI

create or replace trigger WEB_CC_SOGGETTI_TIU
before INSERT
    or UPDATE
on WEB_CC_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CC_SOGGETTI_PU(:OLD.ID_SOGGETTO,
                         :NEW.ID_SOGGETTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CC_SOGGETTI"
            cursor cpk_web_cc_soggetti(var_ID_SOGGETTO number) is
               select 1
                 from   WEB_CC_SOGGETTI
                where  ID_SOGGETTO = var_ID_SOGGETTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CC_SOGGETTI"
               if :new.ID_SOGGETTO is not null then
                  open  cpk_web_cc_soggetti(:new.ID_SOGGETTO);
                  fetch cpk_web_cc_soggetti into dummy;
                  found := cpk_web_cc_soggetti%FOUND;
                  close cpk_web_cc_soggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_SOGGETTO||
                               '" gia'' presente in WEB_CC_SOGGETTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_SOGGETTI_TIU */
/

-- Procedure WEB_CC_SOGGETTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WEB_CC_SOGGETTI

create or replace procedure WEB_CC_SOGGETTI_PD
(old_id_soggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WEB_CC_TITOLARITA"
   cursor cfk1_web_cc_soggetti(var_id_soggetto number) is
      select 1
      from   WEB_CC_TITOLARITA
      where  ID_SOGGETTO = var_id_soggetto
       and   var_id_soggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WEB_CC_SOGGETTI" if children still exist in "WEB_CC_TITOLARITA"
      open  cfk1_web_cc_soggetti(OLD_ID_SOGGETTO);
      fetch cfk1_web_cc_soggetti into dummy;
      found := cfk1_web_cc_soggetti%FOUND;
      close cfk1_web_cc_soggetti;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WEB_CC_TITOLARITA. La registrazione di WEB_CC_SOGGETTI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_SOGGETTI_PD */
/

-- Tigger WEB_CC_SOGGETTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WEB_CC_SOGGETTI

create or replace trigger WEB_CC_SOGGETTI_TD
before DELETE
on WEB_CC_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WEB_CC_TITOLARITA

      WEB_CC_SOGGETTI_PD(:OLD.ID_SOGGETTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_SOGGETTI_TD */
/

-- Procedure WEB_CC_TITOLARITA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WEB_CC_TITOLARITA

create or replace procedure WEB_CC_TITOLARITA_PI
(new_id_soggetto IN number,
 new_id_fabbricato IN number,
 new_id_particella IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WEB_CC_SOGGETTI"
   cursor cpk1_web_cc_titolarita(var_id_soggetto number) is
      select 1
      from   WEB_CC_SOGGETTI
      where  ID_SOGGETTO = var_id_soggetto
       and   var_id_soggetto is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WEB_CC_FABBRICATI"
   cursor cpk2_web_cc_titolarita(var_id_fabbricato number) is
      select 1
      from   WEB_CC_FABBRICATI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WEB_CC_PARTICELLE"
   cursor cpk3_web_cc_titolarita(var_id_particella number) is
      select 1
      from   WEB_CC_PARTICELLE
      where  ID_PARTICELLA = var_id_particella
       and   var_id_particella is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WEB_CC_SOGGETTI" deve esistere quando si inserisce su "WEB_CC_TITOLARITA"
         if NEW_ID_SOGGETTO is not null then
            open  cpk1_web_cc_titolarita(NEW_ID_SOGGETTO);
            fetch cpk1_web_cc_titolarita into dummy;
            found := cpk1_web_cc_titolarita%FOUND;
            close cpk1_web_cc_titolarita;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WEB_CC_SOGGETTI. La registrazione WEB_CC_TITOLARITA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WEB_CC_FABBRICATI" deve esistere quando si inserisce su "WEB_CC_TITOLARITA"
         if NEW_ID_FABBRICATO is not null then
            open  cpk2_web_cc_titolarita(NEW_ID_FABBRICATO);
            fetch cpk2_web_cc_titolarita into dummy;
            found := cpk2_web_cc_titolarita%FOUND;
            close cpk2_web_cc_titolarita;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WEB_CC_FABBRICATI. La registrazione WEB_CC_TITOLARITA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WEB_CC_PARTICELLE" deve esistere quando si inserisce su "WEB_CC_TITOLARITA"
         if NEW_ID_PARTICELLA is not null then
            open  cpk3_web_cc_titolarita(NEW_ID_PARTICELLA);
            fetch cpk3_web_cc_titolarita into dummy;
            found := cpk3_web_cc_titolarita%FOUND;
            close cpk3_web_cc_titolarita;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WEB_CC_PARTICELLE. La registrazione WEB_CC_TITOLARITA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_TITOLARITA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WEB_CC_TITOLARITA
/* End Trigger: WEB_CC_TITOLARITA_TC */

-- Procedure WEB_CC_TITOLARITA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CC_TITOLARITA

create or replace procedure WEB_CC_TITOLARITA_PU
(old_id_titolarita IN number,
 old_id_soggetto IN number,
 old_id_fabbricato IN number,
 old_id_particella IN number,
 new_id_titolarita IN number,
 new_id_soggetto IN number,
 new_id_fabbricato IN number,
 new_id_particella IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WEB_CC_SOGGETTI"
   cursor cpk1_web_cc_titolarita(var_id_soggetto number) is
      select 1
      from   WEB_CC_SOGGETTI
      where  ID_SOGGETTO = var_id_soggetto
       and   var_id_soggetto is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WEB_CC_FABBRICATI"
   cursor cpk2_web_cc_titolarita(var_id_fabbricato number) is
      select 1
      from   WEB_CC_FABBRICATI
      where  ID_FABBRICATO = var_id_fabbricato
       and   var_id_fabbricato is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WEB_CC_PARTICELLE"
   cursor cpk3_web_cc_titolarita(var_id_particella number) is
      select 1
      from   WEB_CC_PARTICELLE
      where  ID_PARTICELLA = var_id_particella
       and   var_id_particella is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WEB_CC_SOGGETTI" deve esistere quando si modifica "WEB_CC_TITOLARITA"
         if  NEW_ID_SOGGETTO is not null and ( seq = 0 )
         and (   (NEW_ID_SOGGETTO != OLD_ID_SOGGETTO or OLD_ID_SOGGETTO is null) ) then
            open  cpk1_web_cc_titolarita(NEW_ID_SOGGETTO);
            fetch cpk1_web_cc_titolarita into dummy;
            found := cpk1_web_cc_titolarita%FOUND;
            close cpk1_web_cc_titolarita;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WEB_CC_SOGGETTI. La registrazione WEB_CC_TITOLARITA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WEB_CC_FABBRICATI" deve esistere quando si modifica "WEB_CC_TITOLARITA"
         if  NEW_ID_FABBRICATO is not null and ( seq = 0 )
         and (   (NEW_ID_FABBRICATO != OLD_ID_FABBRICATO or OLD_ID_FABBRICATO is null) ) then
            open  cpk2_web_cc_titolarita(NEW_ID_FABBRICATO);
            fetch cpk2_web_cc_titolarita into dummy;
            found := cpk2_web_cc_titolarita%FOUND;
            close cpk2_web_cc_titolarita;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WEB_CC_FABBRICATI. La registrazione WEB_CC_TITOLARITA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WEB_CC_PARTICELLE" deve esistere quando si modifica "WEB_CC_TITOLARITA"
         if  NEW_ID_PARTICELLA is not null and ( seq = 0 )
         and (   (NEW_ID_PARTICELLA != OLD_ID_PARTICELLA or OLD_ID_PARTICELLA is null) ) then
            open  cpk3_web_cc_titolarita(NEW_ID_PARTICELLA);
            fetch cpk3_web_cc_titolarita into dummy;
            found := cpk3_web_cc_titolarita%FOUND;
            close cpk3_web_cc_titolarita;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WEB_CC_PARTICELLE. La registrazione WEB_CC_TITOLARITA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_TITOLARITA_PU */
/

-- Trigger WEB_CC_TITOLARITA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CC_TITOLARITA

create or replace trigger WEB_CC_TITOLARITA_TIU
before INSERT
    or UPDATE
on WEB_CC_TITOLARITA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CC_TITOLARITA_PU(:OLD.ID_TITOLARITA,
                              :OLD.ID_SOGGETTO,
                              :OLD.ID_FABBRICATO,
                              :OLD.ID_PARTICELLA,
                         :NEW.ID_TITOLARITA,
                         :NEW.ID_SOGGETTO,
                         :NEW.ID_FABBRICATO,
                         :NEW.ID_PARTICELLA);
         null;
      end if;
      if INSERTING then
         WEB_CC_TITOLARITA_PI(:NEW.ID_SOGGETTO,
                              :NEW.ID_FABBRICATO,
                              :NEW.ID_PARTICELLA);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CC_TITOLARITA"
            cursor cpk_web_cc_titolarita(var_ID_TITOLARITA number) is
               select 1
                 from   WEB_CC_TITOLARITA
                where  ID_TITOLARITA = var_ID_TITOLARITA;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CC_TITOLARITA"
               if :new.ID_TITOLARITA is not null then
                  open  cpk_web_cc_titolarita(:new.ID_TITOLARITA);
                  fetch cpk_web_cc_titolarita into dummy;
                  found := cpk_web_cc_titolarita%FOUND;
                  close cpk_web_cc_titolarita;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_TITOLARITA||
                               '" gia'' presente in WEB_CC_TITOLARITA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_TITOLARITA_TIU */
/

-- Procedure WEB_CC_TOPONIMI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_CC_TOPONIMI

create or replace procedure WEB_CC_TOPONIMI_PU
(old_id_toponimo IN number,
 new_id_toponimo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "WEB_CC_INDIRIZZI"
   cursor cfk1_web_cc_toponimi(var_id_toponimo number) is
      select 1
      from   WEB_CC_INDIRIZZI
      where  ID_TOPONIMO = var_id_toponimo
       and   var_id_toponimo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "WEB_CC_TOPONIMI" non modificabile se esistono referenze su "WEB_CC_INDIRIZZI"
      if (OLD_ID_TOPONIMO != NEW_ID_TOPONIMO) then
         open  cfk1_web_cc_toponimi(OLD_ID_TOPONIMO);
         fetch cfk1_web_cc_toponimi into dummy;
         found := cfk1_web_cc_toponimi%FOUND;
         close cfk1_web_cc_toponimi;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WEB_CC_INDIRIZZI. La registrazione di WEB_CC_TOPONIMI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_TOPONIMI_PU */
/

-- Trigger WEB_CC_TOPONIMI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_CC_TOPONIMI

create or replace trigger WEB_CC_TOPONIMI_TIU
before INSERT
    or UPDATE
on WEB_CC_TOPONIMI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_CC_TOPONIMI_PU(:OLD.ID_TOPONIMO,
                         :NEW.ID_TOPONIMO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_CC_TOPONIMI"
            cursor cpk_web_cc_toponimi(var_ID_TOPONIMO number) is
               select 1
                 from   WEB_CC_TOPONIMI
                where  ID_TOPONIMO = var_ID_TOPONIMO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_CC_TOPONIMI"
               if :new.ID_TOPONIMO is not null then
                  open  cpk_web_cc_toponimi(:new.ID_TOPONIMO);
                  fetch cpk_web_cc_toponimi into dummy;
                  found := cpk_web_cc_toponimi%FOUND;
                  close cpk_web_cc_toponimi;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_TOPONIMO||
                               '" gia'' presente in WEB_CC_TOPONIMI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_TOPONIMI_TIU */
/

-- Procedure WEB_CC_TOPONIMI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WEB_CC_TOPONIMI

create or replace procedure WEB_CC_TOPONIMI_PD
(old_id_toponimo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WEB_CC_INDIRIZZI"
   cursor cfk1_web_cc_toponimi(var_id_toponimo number) is
      select 1
      from   WEB_CC_INDIRIZZI
      where  ID_TOPONIMO = var_id_toponimo
       and   var_id_toponimo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WEB_CC_TOPONIMI" if children still exist in "WEB_CC_INDIRIZZI"
      open  cfk1_web_cc_toponimi(OLD_ID_TOPONIMO);
      fetch cfk1_web_cc_toponimi into dummy;
      found := cfk1_web_cc_toponimi%FOUND;
      close cfk1_web_cc_toponimi;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WEB_CC_INDIRIZZI. La registrazione di WEB_CC_TOPONIMI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_CC_TOPONIMI_PD */
/

-- Tigger WEB_CC_TOPONIMI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WEB_CC_TOPONIMI

create or replace trigger WEB_CC_TOPONIMI_TD
before DELETE
on WEB_CC_TOPONIMI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WEB_CC_INDIRIZZI

      WEB_CC_TOPONIMI_PD(:OLD.ID_TOPONIMO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_CC_TOPONIMI_TD */
/

-- Procedure WEB_PARAMETRI_IMPORT_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WEB_PARAMETRI_IMPORT

create or replace procedure WEB_PARAMETRI_IMPORT_PI
(new_id_titolo_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "TITOLI_DOCUMENTO"
   cursor cpk1_web_parametri_import(var_id_titolo_documento number) is
      select 1
      from   TITOLI_DOCUMENTO
      where  TITOLO_DOCUMENTO = var_id_titolo_documento
       and   var_id_titolo_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "TITOLI_DOCUMENTO" deve esistere quando si inserisce su "WEB_PARAMETRI_IMPORT"
         if NEW_ID_TITOLO_DOCUMENTO is not null then
            open  cpk1_web_parametri_import(NEW_ID_TITOLO_DOCUMENTO);
            fetch cpk1_web_parametri_import into dummy;
            found := cpk1_web_parametri_import%FOUND;
            close cpk1_web_parametri_import;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Titoli Documento. La registrazione WEB_PARAMETRI_IMPORT non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_PARAMETRI_IMPORT_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WEB_PARAMETRI_IMPORT
/* End Trigger: WEB_PARAMETRI_IMPORT_TC */

-- Procedure WEB_PARAMETRI_IMPORT_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WEB_PARAMETRI_IMPORT

create or replace procedure WEB_PARAMETRI_IMPORT_PU
(old_id_parametro_import IN number,
 old_id_titolo_documento IN number,
 new_id_parametro_import IN number,
 new_id_titolo_documento IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "TITOLI_DOCUMENTO"
   cursor cpk1_web_parametri_import(var_id_titolo_documento number) is
      select 1
      from   TITOLI_DOCUMENTO
      where  TITOLO_DOCUMENTO = var_id_titolo_documento
       and   var_id_titolo_documento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "TITOLI_DOCUMENTO" deve esistere quando si modifica "WEB_PARAMETRI_IMPORT"
         if  NEW_ID_TITOLO_DOCUMENTO is not null and ( seq = 0 )
         and (   (NEW_ID_TITOLO_DOCUMENTO != OLD_ID_TITOLO_DOCUMENTO or OLD_ID_TITOLO_DOCUMENTO is null) ) then
            open  cpk1_web_parametri_import(NEW_ID_TITOLO_DOCUMENTO);
            fetch cpk1_web_parametri_import into dummy;
            found := cpk1_web_parametri_import%FOUND;
            close cpk1_web_parametri_import;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Titoli Documento. La registrazione WEB_PARAMETRI_IMPORT non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "TITOLI_DOCUMENTO" non modificabile sul figlio: "WEB_PARAMETRI_IMPORT"
      if (OLD_ID_TITOLO_DOCUMENTO != NEW_ID_TITOLO_DOCUMENTO) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di Titoli Documento non e'' modificabile su WEB_PARAMETRI_IMPORT.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WEB_PARAMETRI_IMPORT_PU */
/

-- Trigger WEB_PARAMETRI_IMPORT_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WEB_PARAMETRI_IMPORT

create or replace trigger WEB_PARAMETRI_IMPORT_TIU
before INSERT
    or UPDATE
on WEB_PARAMETRI_IMPORT
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WEB_PARAMETRI_IMPORT_PU(:OLD.ID_PARAMETRO_IMPORT,
                                 :OLD.ID_TITOLO_DOCUMENTO,
                         :NEW.ID_PARAMETRO_IMPORT,
                         :NEW.ID_TITOLO_DOCUMENTO);
         null;
      end if;
      if INSERTING then
         WEB_PARAMETRI_IMPORT_PI(:NEW.ID_TITOLO_DOCUMENTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WEB_PARAMETRI_IMPORT"
            cursor cpk_web_parametri_import(var_ID_PARAMETRO_IMPORT number) is
               select 1
                 from   WEB_PARAMETRI_IMPORT
                where  ID_PARAMETRO_IMPORT = var_ID_PARAMETRO_IMPORT;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WEB_PARAMETRI_IMPORT"
               if :new.ID_PARAMETRO_IMPORT is not null then
                  open  cpk_web_parametri_import(:new.ID_PARAMETRO_IMPORT);
                  fetch cpk_web_parametri_import into dummy;
                  found := cpk_web_parametri_import%FOUND;
                  close cpk_web_parametri_import;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID_PARAMETRO_IMPORT||
                               '" gia'' presente in WEB_PARAMETRI_IMPORT. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WEB_PARAMETRI_IMPORT_TIU */
/

-- Procedure WRK_DOCFA_CAUSALI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_DOCFA_CAUSALI

create or replace procedure WRK_DOCFA_CAUSALI_PU
(old_causale IN varchar,
 new_causale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "WRK_DOCFA_TESTATA"
   cursor cfk1_wrk_docfa_causali(var_causale varchar) is
      select 1
      from   WRK_DOCFA_TESTATA
      where  CAUSALE = var_causale
       and   var_causale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "WRK_DOCFA_CAUSALI" non modificabile se esistono referenze su "WRK_DOCFA_TESTATA"
      if (OLD_CAUSALE != NEW_CAUSALE) then
         open  cfk1_wrk_docfa_causali(OLD_CAUSALE);
         fetch cfk1_wrk_docfa_causali into dummy;
         found := cfk1_wrk_docfa_causali%FOUND;
         close cfk1_wrk_docfa_causali;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WRK_DOCFA_TESTATA. La registrazione di WRK_DOCFA_CAUSALI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_CAUSALI_PU */
/

-- Trigger WRK_DOCFA_CAUSALI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_DOCFA_CAUSALI

create or replace trigger WRK_DOCFA_CAUSALI_TIU
before INSERT
    or UPDATE
on WRK_DOCFA_CAUSALI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_DOCFA_CAUSALI_PU(:OLD.CAUSALE,
                         :NEW.CAUSALE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_DOCFA_CAUSALI"
            cursor cpk_wrk_docfa_causali(var_CAUSALE varchar) is
               select 1
                 from   WRK_DOCFA_CAUSALI
                where  CAUSALE = var_CAUSALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_DOCFA_CAUSALI"
               if :new.CAUSALE is not null then
                  open  cpk_wrk_docfa_causali(:new.CAUSALE);
                  fetch cpk_wrk_docfa_causali into dummy;
                  found := cpk_wrk_docfa_causali%FOUND;
                  close cpk_wrk_docfa_causali;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.CAUSALE||
                               '" gia'' presente in WRK_DOCFA_CAUSALI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_DOCFA_CAUSALI_TIU */
/

-- Procedure WRK_DOCFA_CAUSALI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WRK_DOCFA_CAUSALI

create or replace procedure WRK_DOCFA_CAUSALI_PD
(old_causale IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WRK_DOCFA_TESTATA"
   cursor cfk1_wrk_docfa_causali(var_causale varchar) is
      select 1
      from   WRK_DOCFA_TESTATA
      where  CAUSALE = var_causale
       and   var_causale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WRK_DOCFA_CAUSALI" if children still exist in "WRK_DOCFA_TESTATA"
      open  cfk1_wrk_docfa_causali(OLD_CAUSALE);
      fetch cfk1_wrk_docfa_causali into dummy;
      found := cfk1_wrk_docfa_causali%FOUND;
      close cfk1_wrk_docfa_causali;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WRK_DOCFA_TESTATA. La registrazione di WRK_DOCFA_CAUSALI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_CAUSALI_PD */
/

-- Tigger WRK_DOCFA_CAUSALI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WRK_DOCFA_CAUSALI

create or replace trigger WRK_DOCFA_CAUSALI_TD
before DELETE
on WRK_DOCFA_CAUSALI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WRK_DOCFA_TESTATA

      WRK_DOCFA_CAUSALI_PD(:OLD.CAUSALE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_DOCFA_CAUSALI_TD */
/

-- Procedure WRK_DOCFA_OGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WRK_DOCFA_OGGETTI

create or replace procedure WRK_DOCFA_OGGETTI_PI
(new_documento_id IN number,
 new_documento_multi_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WRK_DOCFA_TESTATA"
   cursor cpk1_wrk_docfa_oggetti(var_documento_id number,
                                 var_documento_multi_id number) is
      select 1
      from   WRK_DOCFA_TESTATA
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   var_documento_id is not null
       and   var_documento_multi_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WRK_DOCFA_TESTATA" deve esistere quando si inserisce su "WRK_DOCFA_OGGETTI"
         if NEW_DOCUMENTO_ID is not null and
            NEW_DOCUMENTO_MULTI_ID is not null then
            open  cpk1_wrk_docfa_oggetti(NEW_DOCUMENTO_ID,
                                         NEW_DOCUMENTO_MULTI_ID);
            fetch cpk1_wrk_docfa_oggetti into dummy;
            found := cpk1_wrk_docfa_oggetti%FOUND;
            close cpk1_wrk_docfa_oggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WRK_DOCFA_TESTATA. La registrazione WRK_DOCFA_OGGETTI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_OGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WRK_DOCFA_OGGETTI
/* End Trigger: WRK_DOCFA_OGGETTI_TC */

-- Procedure WRK_DOCFA_OGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_DOCFA_OGGETTI

create or replace procedure WRK_DOCFA_OGGETTI_PU
(old_documento_id IN number,
 old_documento_multi_id IN number,
 old_progr_oggetto IN number,
 new_documento_id IN number,
 new_documento_multi_id IN number,
 new_progr_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WRK_DOCFA_TESTATA"
   cursor cpk1_wrk_docfa_oggetti(var_documento_id number,
                                 var_documento_multi_id number) is
      select 1
      from   WRK_DOCFA_TESTATA
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   var_documento_id is not null
       and   var_documento_multi_id is not null;

   --  Declaration of UpdateParentRestrict constraint for "WRK_DOCFA_SOGGETTI"
   cursor cfk1_wrk_docfa_oggetti(var_documento_id number,
                                 var_documento_multi_id number,
                                 var_progr_oggetto number) is
      select 1
      from   WRK_DOCFA_SOGGETTI
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   PROGR_OGGETTO = var_progr_oggetto
       and   var_documento_id is not null
       and   var_documento_multi_id is not null
       and   var_progr_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WRK_DOCFA_TESTATA" deve esistere quando si modifica "WRK_DOCFA_OGGETTI"
         if  NEW_DOCUMENTO_ID is not null and
             NEW_DOCUMENTO_MULTI_ID is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null)
              or (NEW_DOCUMENTO_MULTI_ID != OLD_DOCUMENTO_MULTI_ID or OLD_DOCUMENTO_MULTI_ID is null) ) then
            open  cpk1_wrk_docfa_oggetti(NEW_DOCUMENTO_ID,
                                         NEW_DOCUMENTO_MULTI_ID);
            fetch cpk1_wrk_docfa_oggetti into dummy;
            found := cpk1_wrk_docfa_oggetti%FOUND;
            close cpk1_wrk_docfa_oggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WRK_DOCFA_TESTATA. La registrazione WRK_DOCFA_OGGETTI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "WRK_DOCFA_OGGETTI" non modificabile se esistono referenze su "WRK_DOCFA_SOGGETTI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) or
         (OLD_DOCUMENTO_MULTI_ID != NEW_DOCUMENTO_MULTI_ID) or
         (OLD_PROGR_OGGETTO != NEW_PROGR_OGGETTO) then
         open  cfk1_wrk_docfa_oggetti(OLD_DOCUMENTO_ID,
                                      OLD_DOCUMENTO_MULTI_ID,
                                      OLD_PROGR_OGGETTO);
         fetch cfk1_wrk_docfa_oggetti into dummy;
         found := cfk1_wrk_docfa_oggetti%FOUND;
         close cfk1_wrk_docfa_oggetti;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WRK_DOCFA_SOGGETTI. La registrazione di WRK_DOCFA_OGGETTI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_OGGETTI_PU */
/

-- Trigger WRK_DOCFA_OGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_DOCFA_OGGETTI

create or replace trigger WRK_DOCFA_OGGETTI_TIU
before INSERT
    or UPDATE
on WRK_DOCFA_OGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_DOCFA_OGGETTI_PU(:OLD.DOCUMENTO_ID,
                              :OLD.DOCUMENTO_MULTI_ID,
                              :OLD.PROGR_OGGETTO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.DOCUMENTO_MULTI_ID,
                         :NEW.PROGR_OGGETTO);
         null;
      end if;
      if INSERTING then
         WRK_DOCFA_OGGETTI_PI(:NEW.DOCUMENTO_ID,
                              :NEW.DOCUMENTO_MULTI_ID);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_DOCFA_OGGETTI"
            cursor cpk_wrk_docfa_oggetti(var_DOCUMENTO_ID number,
                                         var_DOCUMENTO_MULTI_ID number,
                                         var_PROGR_OGGETTO number) is
               select 1
                 from   WRK_DOCFA_OGGETTI
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       DOCUMENTO_MULTI_ID = var_DOCUMENTO_MULTI_ID and
                       PROGR_OGGETTO = var_PROGR_OGGETTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_DOCFA_OGGETTI"
               if :new.DOCUMENTO_ID is not null and
                  :new.DOCUMENTO_MULTI_ID is not null and
                  :new.PROGR_OGGETTO is not null then
                  open  cpk_wrk_docfa_oggetti(:new.DOCUMENTO_ID,
                                              :new.DOCUMENTO_MULTI_ID,
                                              :new.PROGR_OGGETTO);
                  fetch cpk_wrk_docfa_oggetti into dummy;
                  found := cpk_wrk_docfa_oggetti%FOUND;
                  close cpk_wrk_docfa_oggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.DOCUMENTO_MULTI_ID||' '||
                               :new.PROGR_OGGETTO||
                               '" gia'' presente in WRK_DOCFA_OGGETTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_DOCFA_OGGETTI_TIU */
/

-- Procedure WRK_DOCFA_OGGETTI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WRK_DOCFA_OGGETTI

create or replace procedure WRK_DOCFA_OGGETTI_PD
(old_documento_id IN number,
 old_documento_multi_id IN number,
 old_progr_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_OGGETTI_PD */
/

-- Tigger WRK_DOCFA_OGGETTI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WRK_DOCFA_OGGETTI

create or replace trigger WRK_DOCFA_OGGETTI_TD
before DELETE
on WRK_DOCFA_OGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      WRK_DOCFA_OGGETTI_PD(:OLD.DOCUMENTO_ID,
                           :OLD.DOCUMENTO_MULTI_ID,
                           :OLD.PROGR_OGGETTO);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "WRK_DOCFA_SOGGETTI"
      delete WRK_DOCFA_SOGGETTI
      where  DOCUMENTO_ID = :OLD.DOCUMENTO_ID
       and   DOCUMENTO_MULTI_ID = :OLD.DOCUMENTO_MULTI_ID
       and   PROGR_OGGETTO = :OLD.PROGR_OGGETTO;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_DOCFA_OGGETTI_TD */
/

-- Procedure WRK_DOCFA_SOGGETTI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WRK_DOCFA_SOGGETTI

create or replace procedure WRK_DOCFA_SOGGETTI_PI
(new_documento_id IN number,
 new_documento_multi_id IN number,
 new_progr_oggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WRK_DOCFA_OGGETTI"
   cursor cpk1_wrk_docfa_soggetti(var_documento_id number,
                                  var_documento_multi_id number,
                                  var_progr_oggetto number) is
      select 1
      from   WRK_DOCFA_OGGETTI
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   PROGR_OGGETTO = var_progr_oggetto
       and   var_documento_id is not null
       and   var_documento_multi_id is not null
       and   var_progr_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WRK_DOCFA_OGGETTI" deve esistere quando si inserisce su "WRK_DOCFA_SOGGETTI"
         if NEW_DOCUMENTO_ID is not null and
            NEW_DOCUMENTO_MULTI_ID is not null and
            NEW_PROGR_OGGETTO is not null then
            open  cpk1_wrk_docfa_soggetti(NEW_DOCUMENTO_ID,
                                          NEW_DOCUMENTO_MULTI_ID,
                                          NEW_PROGR_OGGETTO);
            fetch cpk1_wrk_docfa_soggetti into dummy;
            found := cpk1_wrk_docfa_soggetti%FOUND;
            close cpk1_wrk_docfa_soggetti;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WRK_DOCFA_OGGETTI. La registrazione WRK_DOCFA_SOGGETTI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_SOGGETTI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WRK_DOCFA_SOGGETTI
/* End Trigger: WRK_DOCFA_SOGGETTI_TC */

-- Procedure WRK_DOCFA_SOGGETTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_DOCFA_SOGGETTI

create or replace procedure WRK_DOCFA_SOGGETTI_PU
(old_documento_id IN number,
 old_documento_multi_id IN number,
 old_progr_oggetto IN number,
 old_progr_soggetto IN number,
 new_documento_id IN number,
 new_documento_multi_id IN number,
 new_progr_oggetto IN number,
 new_progr_soggetto IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WRK_DOCFA_OGGETTI"
   cursor cpk1_wrk_docfa_soggetti(var_documento_id number,
                                  var_documento_multi_id number,
                                  var_progr_oggetto number) is
      select 1
      from   WRK_DOCFA_OGGETTI
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   PROGR_OGGETTO = var_progr_oggetto
       and   var_documento_id is not null
       and   var_documento_multi_id is not null
       and   var_progr_oggetto is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WRK_DOCFA_OGGETTI" deve esistere quando si modifica "WRK_DOCFA_SOGGETTI"
         if  NEW_DOCUMENTO_ID is not null and
             NEW_DOCUMENTO_MULTI_ID is not null and
             NEW_PROGR_OGGETTO is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null)
              or (NEW_DOCUMENTO_MULTI_ID != OLD_DOCUMENTO_MULTI_ID or OLD_DOCUMENTO_MULTI_ID is null)
              or (NEW_PROGR_OGGETTO != OLD_PROGR_OGGETTO or OLD_PROGR_OGGETTO is null) ) then
            open  cpk1_wrk_docfa_soggetti(NEW_DOCUMENTO_ID,
                                          NEW_DOCUMENTO_MULTI_ID,
                                          NEW_PROGR_OGGETTO);
            fetch cpk1_wrk_docfa_soggetti into dummy;
            found := cpk1_wrk_docfa_soggetti%FOUND;
            close cpk1_wrk_docfa_soggetti;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WRK_DOCFA_OGGETTI. La registrazione WRK_DOCFA_SOGGETTI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_SOGGETTI_PU */
/

-- Trigger WRK_DOCFA_SOGGETTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_DOCFA_SOGGETTI

create or replace trigger WRK_DOCFA_SOGGETTI_TIU
before INSERT
    or UPDATE
on WRK_DOCFA_SOGGETTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_DOCFA_SOGGETTI_PU(:OLD.DOCUMENTO_ID,
                               :OLD.DOCUMENTO_MULTI_ID,
                               :OLD.PROGR_OGGETTO,
                               :OLD.PROGR_SOGGETTO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.DOCUMENTO_MULTI_ID,
                         :NEW.PROGR_OGGETTO,
                         :NEW.PROGR_SOGGETTO);
         null;
      end if;
      if INSERTING then
         WRK_DOCFA_SOGGETTI_PI(:NEW.DOCUMENTO_ID,
                               :NEW.DOCUMENTO_MULTI_ID,
                               :NEW.PROGR_OGGETTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_DOCFA_SOGGETTI"
            cursor cpk_wrk_docfa_soggetti(var_DOCUMENTO_ID number,
                                          var_DOCUMENTO_MULTI_ID number,
                                          var_PROGR_OGGETTO number,
                                          var_PROGR_SOGGETTO number) is
               select 1
                 from   WRK_DOCFA_SOGGETTI
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       DOCUMENTO_MULTI_ID = var_DOCUMENTO_MULTI_ID and
                       PROGR_OGGETTO = var_PROGR_OGGETTO and
                       PROGR_SOGGETTO = var_PROGR_SOGGETTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_DOCFA_SOGGETTI"
               if :new.DOCUMENTO_ID is not null and
                  :new.DOCUMENTO_MULTI_ID is not null and
                  :new.PROGR_OGGETTO is not null and
                  :new.PROGR_SOGGETTO is not null then
                  open  cpk_wrk_docfa_soggetti(:new.DOCUMENTO_ID,
                                               :new.DOCUMENTO_MULTI_ID,
                                               :new.PROGR_OGGETTO,
                                               :new.PROGR_SOGGETTO);
                  fetch cpk_wrk_docfa_soggetti into dummy;
                  found := cpk_wrk_docfa_soggetti%FOUND;
                  close cpk_wrk_docfa_soggetti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.DOCUMENTO_MULTI_ID||' '||
                               :new.PROGR_OGGETTO||' '||
                               :new.PROGR_SOGGETTO||
                               '" gia'' presente in WRK_DOCFA_SOGGETTI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_DOCFA_SOGGETTI_TIU */
/

-- Procedure WRK_DOCFA_TESTATA_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WRK_DOCFA_TESTATA

create or replace procedure WRK_DOCFA_TESTATA_PI
(new_causale IN varchar,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "FONTI"
   cursor cpk1_wrk_docfa_testata(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WRK_DOCFA_CAUSALI"
   cursor cpk2_wrk_docfa_testata(var_causale varchar) is
      select 1
      from   WRK_DOCFA_CAUSALI
      where  CAUSALE = var_causale
       and   var_causale is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "FONTI" deve esistere quando si inserisce su "WRK_DOCFA_TESTATA"
         if NEW_FONTE is not null then
            open  cpk1_wrk_docfa_testata(NEW_FONTE);
            fetch cpk1_wrk_docfa_testata into dummy;
            found := cpk1_wrk_docfa_testata%FOUND;
            close cpk1_wrk_docfa_testata;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione WRK_DOCFA_TESTATA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WRK_DOCFA_CAUSALI" deve esistere quando si inserisce su "WRK_DOCFA_TESTATA"
         if NEW_CAUSALE is not null then
            open  cpk2_wrk_docfa_testata(NEW_CAUSALE);
            fetch cpk2_wrk_docfa_testata into dummy;
            found := cpk2_wrk_docfa_testata%FOUND;
            close cpk2_wrk_docfa_testata;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WRK_DOCFA_CAUSALI. La registrazione WRK_DOCFA_TESTATA non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_TESTATA_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WRK_DOCFA_TESTATA
/* End Trigger: WRK_DOCFA_TESTATA_TC */

-- Procedure WRK_DOCFA_TESTATA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_DOCFA_TESTATA

create or replace procedure WRK_DOCFA_TESTATA_PU
(old_documento_id IN number,
 old_documento_multi_id IN number,
 old_causale IN varchar,
 old_fonte IN number,
 new_documento_id IN number,
 new_documento_multi_id IN number,
 new_causale IN varchar,
 new_fonte IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "FONTI"
   cursor cpk1_wrk_docfa_testata(var_fonte number) is
      select 1
      from   FONTI
      where  FONTE = var_fonte
       and   var_fonte is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WRK_DOCFA_CAUSALI"
   cursor cpk2_wrk_docfa_testata(var_causale varchar) is
      select 1
      from   WRK_DOCFA_CAUSALI
      where  CAUSALE = var_causale
       and   var_causale is not null;

   --  Declaration of UpdateParentRestrict constraint for "WRK_DOCFA_OGGETTI"
   cursor cfk1_wrk_docfa_testata(var_documento_id number,
                                 var_documento_multi_id number) is
      select 1
      from   WRK_DOCFA_OGGETTI
      where  DOCUMENTO_ID = var_documento_id
       and   DOCUMENTO_MULTI_ID = var_documento_multi_id
       and   var_documento_id is not null
       and   var_documento_multi_id is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "FONTI" deve esistere quando si modifica "WRK_DOCFA_TESTATA"
         if  NEW_FONTE is not null and ( seq = 0 )
         and (   (NEW_FONTE != OLD_FONTE or OLD_FONTE is null) ) then
            open  cpk1_wrk_docfa_testata(NEW_FONTE);
            fetch cpk1_wrk_docfa_testata into dummy;
            found := cpk1_wrk_docfa_testata%FOUND;
            close cpk1_wrk_docfa_testata;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Fonti. La registrazione WRK_DOCFA_TESTATA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WRK_DOCFA_CAUSALI" deve esistere quando si modifica "WRK_DOCFA_TESTATA"
         if  NEW_CAUSALE is not null and ( seq = 0 )
         and (   (NEW_CAUSALE != OLD_CAUSALE or OLD_CAUSALE is null) ) then
            open  cpk2_wrk_docfa_testata(NEW_CAUSALE);
            fetch cpk2_wrk_docfa_testata into dummy;
            found := cpk2_wrk_docfa_testata%FOUND;
            close cpk2_wrk_docfa_testata;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WRK_DOCFA_CAUSALI. La registrazione WRK_DOCFA_TESTATA non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "WRK_DOCFA_TESTATA" non modificabile se esistono referenze su "WRK_DOCFA_OGGETTI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) or
         (OLD_DOCUMENTO_MULTI_ID != NEW_DOCUMENTO_MULTI_ID) then
         open  cfk1_wrk_docfa_testata(OLD_DOCUMENTO_ID,
                                      OLD_DOCUMENTO_MULTI_ID);
         fetch cfk1_wrk_docfa_testata into dummy;
         found := cfk1_wrk_docfa_testata%FOUND;
         close cfk1_wrk_docfa_testata;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WRK_DOCFA_OGGETTI. La registrazione di WRK_DOCFA_TESTATA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_TESTATA_PU */
/

-- Trigger WRK_DOCFA_TESTATA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_DOCFA_TESTATA

create or replace trigger WRK_DOCFA_TESTATA_TIU
before INSERT
    or UPDATE
on WRK_DOCFA_TESTATA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_DOCFA_TESTATA_PU(:OLD.DOCUMENTO_ID,
                              :OLD.DOCUMENTO_MULTI_ID,
                              :OLD.CAUSALE,
                              :OLD.FONTE,
                         :NEW.DOCUMENTO_ID,
                         :NEW.DOCUMENTO_MULTI_ID,
                         :NEW.CAUSALE,
                         :NEW.FONTE);
         null;
      end if;
      if INSERTING then
         WRK_DOCFA_TESTATA_PI(:NEW.CAUSALE,
                              :NEW.FONTE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_DOCFA_TESTATA"
            cursor cpk_wrk_docfa_testata(var_DOCUMENTO_ID number,
                                         var_DOCUMENTO_MULTI_ID number) is
               select 1
                 from   WRK_DOCFA_TESTATA
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       DOCUMENTO_MULTI_ID = var_DOCUMENTO_MULTI_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_DOCFA_TESTATA"
               if :new.DOCUMENTO_ID is not null and
                  :new.DOCUMENTO_MULTI_ID is not null then
                  open  cpk_wrk_docfa_testata(:new.DOCUMENTO_ID,
                                              :new.DOCUMENTO_MULTI_ID);
                  fetch cpk_wrk_docfa_testata into dummy;
                  found := cpk_wrk_docfa_testata%FOUND;
                  close cpk_wrk_docfa_testata;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.DOCUMENTO_MULTI_ID||
                               '" gia'' presente in WRK_DOCFA_TESTATA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_DOCFA_TESTATA_TIU */
/

-- Procedure WRK_DOCFA_TESTATA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WRK_DOCFA_TESTATA

create or replace procedure WRK_DOCFA_TESTATA_PD
(old_documento_id IN number,
 old_documento_multi_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check REFERENTIAL Integrity
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_DOCFA_TESTATA_PD */
/

-- Tigger WRK_DOCFA_TESTATA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WRK_DOCFA_TESTATA

create or replace trigger WRK_DOCFA_TESTATA_TD
before DELETE
on WRK_DOCFA_TESTATA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE
      /*  Procedura non Attivata in assenza di Table CHILD in Delete Restrict
      WRK_DOCFA_TESTATA_PD(:OLD.DOCUMENTO_ID,
                           :OLD.DOCUMENTO_MULTI_ID);
      */  null;
   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "WRK_DOCFA_OGGETTI"
      delete WRK_DOCFA_OGGETTI
      where  DOCUMENTO_ID = :OLD.DOCUMENTO_ID
       and   DOCUMENTO_MULTI_ID = :OLD.DOCUMENTO_MULTI_ID;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_DOCFA_TESTATA_TD */
/

-- Procedure WRK_ENC_CONTITOLARI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WRK_ENC_CONTITOLARI

create or replace procedure WRK_ENC_CONTITOLARI_PI
(new_documento_id IN number,
 new_progr_dichiarazione IN number,
 new_tipo_immobile IN varchar,
 new_progr_immobile IN number,
 new_num_ordine IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WRK_ENC_TESTATA"
   cursor cpk1_wrk_enc_contitolari(var_documento_id number,
                                   var_progr_dichiarazione number) is
      select 1
      from   WRK_ENC_TESTATA
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null;

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WRK_ENC_IMMOBILI"
   cursor cpk2_wrk_enc_contitolari(var_documento_id number,
                                   var_progr_dichiarazione number,
                                   var_tipo_immobile varchar,
                                   var_progr_immobile number,
                                   var_num_ordine number) is
      select 1
      from   WRK_ENC_IMMOBILI
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   TIPO_IMMOBILE = var_tipo_immobile
       and   PROGR_IMMOBILE = var_progr_immobile
       and   NUM_ORDINE = var_num_ordine
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null
       and   var_tipo_immobile is not null
       and   var_progr_immobile is not null
       and   var_num_ordine is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WRK_ENC_TESTATA" deve esistere quando si inserisce su "WRK_ENC_CONTITOLARI"
         if NEW_DOCUMENTO_ID is not null and
            NEW_PROGR_DICHIARAZIONE is not null then
            open  cpk1_wrk_enc_contitolari(NEW_DOCUMENTO_ID,
                                           NEW_PROGR_DICHIARAZIONE);
            fetch cpk1_wrk_enc_contitolari into dummy;
            found := cpk1_wrk_enc_contitolari%FOUND;
            close cpk1_wrk_enc_contitolari;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WRK_ENC_TESTATA. La registrazione WRK_ENC_CONTITOLARI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WRK_ENC_IMMOBILI" deve esistere quando si inserisce su "WRK_ENC_CONTITOLARI"
         if NEW_DOCUMENTO_ID is not null and
            NEW_PROGR_DICHIARAZIONE is not null and
            NEW_TIPO_IMMOBILE is not null and
            NEW_PROGR_IMMOBILE is not null and
            NEW_NUM_ORDINE is not null then
            open  cpk2_wrk_enc_contitolari(NEW_DOCUMENTO_ID,
                                           NEW_PROGR_DICHIARAZIONE,
                                           NEW_TIPO_IMMOBILE,
                                           NEW_PROGR_IMMOBILE,
                                           NEW_NUM_ORDINE);
            fetch cpk2_wrk_enc_contitolari into dummy;
            found := cpk2_wrk_enc_contitolari%FOUND;
            close cpk2_wrk_enc_contitolari;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WRK_ENC_IMMOBILI. La registrazione WRK_ENC_CONTITOLARI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_ENC_CONTITOLARI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WRK_ENC_CONTITOLARI
/* End Trigger: WRK_ENC_CONTITOLARI_TC */

-- Procedure WRK_ENC_CONTITOLARI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_ENC_CONTITOLARI

create or replace procedure WRK_ENC_CONTITOLARI_PU
(old_documento_id IN number,
 old_progr_dichiarazione IN number,
 old_progr_contitolare IN number,
 old_tipo_immobile IN varchar,
 old_progr_immobile IN number,
 old_num_ordine IN number,
 new_documento_id IN number,
 new_progr_dichiarazione IN number,
 new_progr_contitolare IN number,
 new_tipo_immobile IN varchar,
 new_progr_immobile IN number,
 new_num_ordine IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WRK_ENC_TESTATA"
   cursor cpk1_wrk_enc_contitolari(var_documento_id number,
                                   var_progr_dichiarazione number) is
      select 1
      from   WRK_ENC_TESTATA
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null;

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WRK_ENC_IMMOBILI"
   cursor cpk2_wrk_enc_contitolari(var_documento_id number,
                                   var_progr_dichiarazione number,
                                   var_tipo_immobile varchar,
                                   var_progr_immobile number,
                                   var_num_ordine number) is
      select 1
      from   WRK_ENC_IMMOBILI
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   TIPO_IMMOBILE = var_tipo_immobile
       and   PROGR_IMMOBILE = var_progr_immobile
       and   NUM_ORDINE = var_num_ordine
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null
       and   var_tipo_immobile is not null
       and   var_progr_immobile is not null
       and   var_num_ordine is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WRK_ENC_TESTATA" deve esistere quando si modifica "WRK_ENC_CONTITOLARI"
         if  NEW_DOCUMENTO_ID is not null and
             NEW_PROGR_DICHIARAZIONE is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null)
              or (NEW_PROGR_DICHIARAZIONE != OLD_PROGR_DICHIARAZIONE or OLD_PROGR_DICHIARAZIONE is null) ) then
            open  cpk1_wrk_enc_contitolari(NEW_DOCUMENTO_ID,
                                           NEW_PROGR_DICHIARAZIONE);
            fetch cpk1_wrk_enc_contitolari into dummy;
            found := cpk1_wrk_enc_contitolari%FOUND;
            close cpk1_wrk_enc_contitolari;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WRK_ENC_TESTATA. La registrazione WRK_ENC_CONTITOLARI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      begin  --  Parent "WRK_ENC_IMMOBILI" deve esistere quando si modifica "WRK_ENC_CONTITOLARI"
         if  NEW_DOCUMENTO_ID is not null and
             NEW_PROGR_DICHIARAZIONE is not null and
             NEW_TIPO_IMMOBILE is not null and
             NEW_PROGR_IMMOBILE is not null and
             NEW_NUM_ORDINE is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null)
              or (NEW_PROGR_DICHIARAZIONE != OLD_PROGR_DICHIARAZIONE or OLD_PROGR_DICHIARAZIONE is null)
              or (NEW_TIPO_IMMOBILE != OLD_TIPO_IMMOBILE or OLD_TIPO_IMMOBILE is null)
              or (NEW_PROGR_IMMOBILE != OLD_PROGR_IMMOBILE or OLD_PROGR_IMMOBILE is null)
              or (NEW_NUM_ORDINE != OLD_NUM_ORDINE or OLD_NUM_ORDINE is null) ) then
            open  cpk2_wrk_enc_contitolari(NEW_DOCUMENTO_ID,
                                           NEW_PROGR_DICHIARAZIONE,
                                           NEW_TIPO_IMMOBILE,
                                           NEW_PROGR_IMMOBILE,
                                           NEW_NUM_ORDINE);
            fetch cpk2_wrk_enc_contitolari into dummy;
            found := cpk2_wrk_enc_contitolari%FOUND;
            close cpk2_wrk_enc_contitolari;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WRK_ENC_IMMOBILI. La registrazione WRK_ENC_CONTITOLARI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "WRK_ENC_IMMOBILI" non modificabile sul figlio: "WRK_ENC_CONTITOLARI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) or
         (OLD_PROGR_DICHIARAZIONE != NEW_PROGR_DICHIARAZIONE) or
         (OLD_TIPO_IMMOBILE != NEW_TIPO_IMMOBILE) or
         (OLD_PROGR_IMMOBILE != NEW_PROGR_IMMOBILE) or
         (OLD_NUM_ORDINE != NEW_NUM_ORDINE) then
         if IntegrityPackage.GetNestLevel = 0 then
            errno  := -20004;
            errmsg := 'L''identificazione di WRK_ENC_IMMOBILI non e'' modificabile su WRK_ENC_CONTITOLARI.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_ENC_CONTITOLARI_PU */
/

-- Trigger WRK_ENC_CONTITOLARI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_ENC_CONTITOLARI

create or replace trigger WRK_ENC_CONTITOLARI_TIU
before INSERT
    or UPDATE
on WRK_ENC_CONTITOLARI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_ENC_CONTITOLARI_PU(:OLD.DOCUMENTO_ID,
                                :OLD.PROGR_DICHIARAZIONE,
                                :OLD.PROGR_CONTITOLARE,
                                :OLD.TIPO_IMMOBILE,
                                :OLD.PROGR_IMMOBILE,
                                :OLD.NUM_ORDINE,
                         :NEW.DOCUMENTO_ID,
                         :NEW.PROGR_DICHIARAZIONE,
                         :NEW.PROGR_CONTITOLARE,
                         :NEW.TIPO_IMMOBILE,
                         :NEW.PROGR_IMMOBILE,
                         :NEW.NUM_ORDINE);
         null;
      end if;
      if INSERTING then
         WRK_ENC_CONTITOLARI_PI(:NEW.DOCUMENTO_ID,
                                :NEW.PROGR_DICHIARAZIONE,
                                :NEW.TIPO_IMMOBILE,
                                :NEW.PROGR_IMMOBILE,
                                :NEW.NUM_ORDINE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_ENC_CONTITOLARI"
            cursor cpk_wrk_enc_contitolari(var_DOCUMENTO_ID number,
                                           var_PROGR_DICHIARAZIONE number,
                                           var_PROGR_CONTITOLARE number,
                                           var_TIPO_IMMOBILE varchar,
                                           var_PROGR_IMMOBILE number) is
               select 1
                 from   WRK_ENC_CONTITOLARI
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       PROGR_DICHIARAZIONE = var_PROGR_DICHIARAZIONE and
                       PROGR_CONTITOLARE = var_PROGR_CONTITOLARE and
                       TIPO_IMMOBILE = var_TIPO_IMMOBILE and
                       PROGR_IMMOBILE = var_PROGR_IMMOBILE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_ENC_CONTITOLARI"
               if :new.DOCUMENTO_ID is not null and
                  :new.PROGR_DICHIARAZIONE is not null and
                  :new.PROGR_CONTITOLARE is not null and
                  :new.TIPO_IMMOBILE is not null and
                  :new.PROGR_IMMOBILE is not null then
                  open  cpk_wrk_enc_contitolari(:new.DOCUMENTO_ID,
                                                :new.PROGR_DICHIARAZIONE,
                                                :new.PROGR_CONTITOLARE,
                                                :new.TIPO_IMMOBILE,
                                                :new.PROGR_IMMOBILE);
                  fetch cpk_wrk_enc_contitolari into dummy;
                  found := cpk_wrk_enc_contitolari%FOUND;
                  close cpk_wrk_enc_contitolari;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.PROGR_DICHIARAZIONE||' '||
                               :new.PROGR_CONTITOLARE||' '||
                               :new.TIPO_IMMOBILE||' '||
                               :new.PROGR_IMMOBILE||
                               '" gia'' presente in WRK_ENC_CONTITOLARI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_ENC_CONTITOLARI_TIU */
/

-- Procedure WRK_ENC_IMMOBILI_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WRK_ENC_IMMOBILI

create or replace procedure WRK_ENC_IMMOBILI_PI
(new_documento_id IN number,
 new_progr_dichiarazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WRK_ENC_TESTATA"
   cursor cpk1_wrk_enc_immobili(var_documento_id number,
                                var_progr_dichiarazione number) is
      select 1
      from   WRK_ENC_TESTATA
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WRK_ENC_TESTATA" deve esistere quando si inserisce su "WRK_ENC_IMMOBILI"
         if NEW_DOCUMENTO_ID is not null and
            NEW_PROGR_DICHIARAZIONE is not null then
            open  cpk1_wrk_enc_immobili(NEW_DOCUMENTO_ID,
                                        NEW_PROGR_DICHIARAZIONE);
            fetch cpk1_wrk_enc_immobili into dummy;
            found := cpk1_wrk_enc_immobili%FOUND;
            close cpk1_wrk_enc_immobili;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WRK_ENC_TESTATA. La registrazione WRK_ENC_IMMOBILI non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_ENC_IMMOBILI_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WRK_ENC_IMMOBILI
/* End Trigger: WRK_ENC_IMMOBILI_TC */

-- Procedure WRK_ENC_IMMOBILI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_ENC_IMMOBILI

create or replace procedure WRK_ENC_IMMOBILI_PU
(old_documento_id IN number,
 old_progr_dichiarazione IN number,
 old_tipo_immobile IN varchar,
 old_progr_immobile IN number,
 old_num_ordine IN number,
 new_documento_id IN number,
 new_progr_dichiarazione IN number,
 new_tipo_immobile IN varchar,
 new_progr_immobile IN number,
 new_num_ordine IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WRK_ENC_TESTATA"
   cursor cpk1_wrk_enc_immobili(var_documento_id number,
                                var_progr_dichiarazione number) is
      select 1
      from   WRK_ENC_TESTATA
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "WRK_ENC_CONTITOLARI"
   cursor cfk1_wrk_enc_immobili(var_documento_id number,
                                var_progr_dichiarazione number,
                                var_tipo_immobile varchar,
                                var_progr_immobile number,
                                var_num_ordine number) is
      select 1
      from   WRK_ENC_CONTITOLARI
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   TIPO_IMMOBILE = var_tipo_immobile
       and   PROGR_IMMOBILE = var_progr_immobile
       and   NUM_ORDINE = var_num_ordine
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null
       and   var_tipo_immobile is not null
       and   var_progr_immobile is not null
       and   var_num_ordine is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WRK_ENC_TESTATA" deve esistere quando si modifica "WRK_ENC_IMMOBILI"
         if  NEW_DOCUMENTO_ID is not null and
             NEW_PROGR_DICHIARAZIONE is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null)
              or (NEW_PROGR_DICHIARAZIONE != OLD_PROGR_DICHIARAZIONE or OLD_PROGR_DICHIARAZIONE is null) ) then
            open  cpk1_wrk_enc_immobili(NEW_DOCUMENTO_ID,
                                        NEW_PROGR_DICHIARAZIONE);
            fetch cpk1_wrk_enc_immobili into dummy;
            found := cpk1_wrk_enc_immobili%FOUND;
            close cpk1_wrk_enc_immobili;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WRK_ENC_TESTATA. La registrazione WRK_ENC_IMMOBILI non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;

      --  Chiave di "WRK_ENC_IMMOBILI" non modificabile se esistono referenze su "WRK_ENC_CONTITOLARI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) or
         (OLD_PROGR_DICHIARAZIONE != NEW_PROGR_DICHIARAZIONE) or
         (OLD_TIPO_IMMOBILE != NEW_TIPO_IMMOBILE) or
         (OLD_PROGR_IMMOBILE != NEW_PROGR_IMMOBILE) or
         (OLD_NUM_ORDINE != NEW_NUM_ORDINE) then
         open  cfk1_wrk_enc_immobili(OLD_DOCUMENTO_ID,
                                     OLD_PROGR_DICHIARAZIONE,
                                     OLD_TIPO_IMMOBILE,
                                     OLD_PROGR_IMMOBILE,
                                     OLD_NUM_ORDINE);
         fetch cfk1_wrk_enc_immobili into dummy;
         found := cfk1_wrk_enc_immobili%FOUND;
         close cfk1_wrk_enc_immobili;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WRK_ENC_CONTITOLARI. La registrazione di WRK_ENC_IMMOBILI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_ENC_IMMOBILI_PU */
/

-- Trigger WRK_ENC_IMMOBILI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_ENC_IMMOBILI

create or replace trigger WRK_ENC_IMMOBILI_TIU
before INSERT
    or UPDATE
on WRK_ENC_IMMOBILI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_ENC_IMMOBILI_PU(:OLD.DOCUMENTO_ID,
                             :OLD.PROGR_DICHIARAZIONE,
                             :OLD.TIPO_IMMOBILE,
                             :OLD.PROGR_IMMOBILE,
                             :OLD.NUM_ORDINE,
                         :NEW.DOCUMENTO_ID,
                         :NEW.PROGR_DICHIARAZIONE,
                         :NEW.TIPO_IMMOBILE,
                         :NEW.PROGR_IMMOBILE,
                         :NEW.NUM_ORDINE);
         null;
      end if;
      if INSERTING then
         WRK_ENC_IMMOBILI_PI(:NEW.DOCUMENTO_ID,
                             :NEW.PROGR_DICHIARAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_ENC_IMMOBILI"
            cursor cpk_wrk_enc_immobili(var_DOCUMENTO_ID number,
                                        var_PROGR_DICHIARAZIONE number,
                                        var_TIPO_IMMOBILE varchar,
                                        var_PROGR_IMMOBILE number,
                                        var_NUM_ORDINE number) is
               select 1
                 from   WRK_ENC_IMMOBILI
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       PROGR_DICHIARAZIONE = var_PROGR_DICHIARAZIONE and
                       TIPO_IMMOBILE = var_TIPO_IMMOBILE and
                       PROGR_IMMOBILE = var_PROGR_IMMOBILE and
                       NUM_ORDINE = var_NUM_ORDINE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_ENC_IMMOBILI"
               if :new.DOCUMENTO_ID is not null and
                  :new.PROGR_DICHIARAZIONE is not null and
                  :new.TIPO_IMMOBILE is not null and
                  :new.PROGR_IMMOBILE is not null and
                  :new.NUM_ORDINE is not null then
                  open  cpk_wrk_enc_immobili(:new.DOCUMENTO_ID,
                                             :new.PROGR_DICHIARAZIONE,
                                             :new.TIPO_IMMOBILE,
                                             :new.PROGR_IMMOBILE,
                                             :new.NUM_ORDINE);
                  fetch cpk_wrk_enc_immobili into dummy;
                  found := cpk_wrk_enc_immobili%FOUND;
                  close cpk_wrk_enc_immobili;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.PROGR_DICHIARAZIONE||' '||
                               :new.TIPO_IMMOBILE||' '||
                               :new.PROGR_IMMOBILE||' '||
                               :new.NUM_ORDINE||
                               '" gia'' presente in WRK_ENC_IMMOBILI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_ENC_IMMOBILI_TIU */
/

-- Procedure WRK_ENC_IMMOBILI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WRK_ENC_IMMOBILI

create or replace procedure WRK_ENC_IMMOBILI_PD
(old_documento_id IN number,
 old_progr_dichiarazione IN number,
 old_tipo_immobile IN varchar,
 old_progr_immobile IN number,
 old_num_ordine IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WRK_ENC_CONTITOLARI"
   cursor cfk1_wrk_enc_immobili(var_documento_id number,
                                var_progr_dichiarazione number,
                                var_tipo_immobile varchar,
                                var_progr_immobile number,
                                var_num_ordine number) is
      select 1
      from   WRK_ENC_CONTITOLARI
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   TIPO_IMMOBILE = var_tipo_immobile
       and   PROGR_IMMOBILE = var_progr_immobile
       and   NUM_ORDINE = var_num_ordine
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null
       and   var_tipo_immobile is not null
       and   var_progr_immobile is not null
       and   var_num_ordine is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WRK_ENC_IMMOBILI" if children still exist in "WRK_ENC_CONTITOLARI"
      open  cfk1_wrk_enc_immobili(OLD_DOCUMENTO_ID,
                                  OLD_PROGR_DICHIARAZIONE,
                                  OLD_TIPO_IMMOBILE,
                                  OLD_PROGR_IMMOBILE,
                                  OLD_NUM_ORDINE);
      fetch cfk1_wrk_enc_immobili into dummy;
      found := cfk1_wrk_enc_immobili%FOUND;
      close cfk1_wrk_enc_immobili;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WRK_ENC_CONTITOLARI. La registrazione di WRK_ENC_IMMOBILI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_ENC_IMMOBILI_PD */
/

-- Tigger WRK_ENC_IMMOBILI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WRK_ENC_IMMOBILI

create or replace trigger WRK_ENC_IMMOBILI_TD
before DELETE
on WRK_ENC_IMMOBILI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WRK_ENC_CONTITOLARI

      WRK_ENC_IMMOBILI_PD(:OLD.DOCUMENTO_ID,
                          :OLD.PROGR_DICHIARAZIONE,
                          :OLD.TIPO_IMMOBILE,
                          :OLD.PROGR_IMMOBILE,
                          :OLD.NUM_ORDINE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_ENC_IMMOBILI_TD */
/

-- Procedure WRK_ENC_TESTATA_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_ENC_TESTATA

create or replace procedure WRK_ENC_TESTATA_PU
(old_documento_id IN number,
 old_progr_dichiarazione IN number,
 new_documento_id IN number,
 new_progr_dichiarazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "WRK_ENC_IMMOBILI"
   cursor cfk1_wrk_enc_testata(var_documento_id number,
                               var_progr_dichiarazione number) is
      select 1
      from   WRK_ENC_IMMOBILI
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null;

   --  Declaration of UpdateParentRestrict constraint for "WRK_ENC_CONTITOLARI"
   cursor cfk2_wrk_enc_testata(var_documento_id number,
                               var_progr_dichiarazione number) is
      select 1
      from   WRK_ENC_CONTITOLARI
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "WRK_ENC_TESTATA" non modificabile se esistono referenze su "WRK_ENC_IMMOBILI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) or
         (OLD_PROGR_DICHIARAZIONE != NEW_PROGR_DICHIARAZIONE) then
         open  cfk1_wrk_enc_testata(OLD_DOCUMENTO_ID,
                                    OLD_PROGR_DICHIARAZIONE);
         fetch cfk1_wrk_enc_testata into dummy;
         found := cfk1_wrk_enc_testata%FOUND;
         close cfk1_wrk_enc_testata;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WRK_ENC_IMMOBILI. La registrazione di WRK_ENC_TESTATA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;

      --  Chiave di "WRK_ENC_TESTATA" non modificabile se esistono referenze su "WRK_ENC_CONTITOLARI"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) or
         (OLD_PROGR_DICHIARAZIONE != NEW_PROGR_DICHIARAZIONE) then
         open  cfk2_wrk_enc_testata(OLD_DOCUMENTO_ID,
                                    OLD_PROGR_DICHIARAZIONE);
         fetch cfk2_wrk_enc_testata into dummy;
         found := cfk2_wrk_enc_testata%FOUND;
         close cfk2_wrk_enc_testata;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WRK_ENC_CONTITOLARI. La registrazione di WRK_ENC_TESTATA non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_ENC_TESTATA_PU */
/

-- Trigger WRK_ENC_TESTATA_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_ENC_TESTATA

create or replace trigger WRK_ENC_TESTATA_TIU
before INSERT
    or UPDATE
on WRK_ENC_TESTATA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_ENC_TESTATA_PU(:OLD.DOCUMENTO_ID,
                            :OLD.PROGR_DICHIARAZIONE,
                         :NEW.DOCUMENTO_ID,
                         :NEW.PROGR_DICHIARAZIONE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_ENC_TESTATA"
            cursor cpk_wrk_enc_testata(var_DOCUMENTO_ID number,
                                       var_PROGR_DICHIARAZIONE number) is
               select 1
                 from   WRK_ENC_TESTATA
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       PROGR_DICHIARAZIONE = var_PROGR_DICHIARAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_ENC_TESTATA"
               if :new.DOCUMENTO_ID is not null and
                  :new.PROGR_DICHIARAZIONE is not null then
                  open  cpk_wrk_enc_testata(:new.DOCUMENTO_ID,
                                            :new.PROGR_DICHIARAZIONE);
                  fetch cpk_wrk_enc_testata into dummy;
                  found := cpk_wrk_enc_testata%FOUND;
                  close cpk_wrk_enc_testata;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.PROGR_DICHIARAZIONE||
                               '" gia'' presente in WRK_ENC_TESTATA. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_ENC_TESTATA_TIU */
/

-- Procedure WRK_ENC_TESTATA_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WRK_ENC_TESTATA

create or replace procedure WRK_ENC_TESTATA_PD
(old_documento_id IN number,
 old_progr_dichiarazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WRK_ENC_CONTITOLARI"
   cursor cfk1_wrk_enc_testata(var_documento_id number,
                               var_progr_dichiarazione number) is
      select 1
      from   WRK_ENC_CONTITOLARI
      where  DOCUMENTO_ID = var_documento_id
       and   PROGR_DICHIARAZIONE = var_progr_dichiarazione
       and   var_documento_id is not null
       and   var_progr_dichiarazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WRK_ENC_TESTATA" if children still exist in "WRK_ENC_CONTITOLARI"
      open  cfk1_wrk_enc_testata(OLD_DOCUMENTO_ID,
                                 OLD_PROGR_DICHIARAZIONE);
      fetch cfk1_wrk_enc_testata into dummy;
      found := cfk1_wrk_enc_testata%FOUND;
      close cfk1_wrk_enc_testata;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WRK_ENC_CONTITOLARI. La registrazione di WRK_ENC_TESTATA non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_ENC_TESTATA_PD */
/

-- Tigger WRK_ENC_TESTATA_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WRK_ENC_TESTATA

create or replace trigger WRK_ENC_TESTATA_TD
before DELETE
on WRK_ENC_TESTATA
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WRK_ENC_CONTITOLARI

      WRK_ENC_TESTATA_PD(:OLD.DOCUMENTO_ID,
                         :OLD.PROGR_DICHIARAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;

      --  Delete all children in "WRK_ENC_IMMOBILI"
      delete WRK_ENC_IMMOBILI
      where  DOCUMENTO_ID = :OLD.DOCUMENTO_ID
       and   PROGR_DICHIARAZIONE = :OLD.PROGR_DICHIARAZIONE;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_ENC_TESTATA_TD */
/

-- Procedure WRK_GRAFFATI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_GRAFFATI

create or replace procedure WRK_GRAFFATI_PU
(old_documento_id IN number,
 old_riferimento IN varchar,
 new_documento_id IN number,
 new_riferimento IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "WRK_GRAFFATI_CONT"
   cursor cfk1_wrk_graffati(var_documento_id number,
                            var_riferimento varchar) is
      select 1
      from   WRK_GRAFFATI_CONT
      where  DOCUMENTO_ID = var_documento_id
       and   RIFERIMENTO = var_riferimento
       and   var_documento_id is not null
       and   var_riferimento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "WRK_GRAFFATI" non modificabile se esistono referenze su "WRK_GRAFFATI_CONT"
      if (OLD_DOCUMENTO_ID != NEW_DOCUMENTO_ID) or
         (OLD_RIFERIMENTO != NEW_RIFERIMENTO) then
         open  cfk1_wrk_graffati(OLD_DOCUMENTO_ID,
                                 OLD_RIFERIMENTO);
         fetch cfk1_wrk_graffati into dummy;
         found := cfk1_wrk_graffati%FOUND;
         close cfk1_wrk_graffati;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WRK_GRAFFATI_CONT. La registrazione di WRK_GRAFFATI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_GRAFFATI_PU */
/

-- Trigger WRK_GRAFFATI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_GRAFFATI

create or replace trigger WRK_GRAFFATI_TIU
before INSERT
    or UPDATE
on WRK_GRAFFATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_GRAFFATI_PU(:OLD.DOCUMENTO_ID,
                         :OLD.RIFERIMENTO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.RIFERIMENTO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_GRAFFATI"
            cursor cpk_wrk_graffati(var_DOCUMENTO_ID number,
                                    var_RIFERIMENTO varchar) is
               select 1
                 from   WRK_GRAFFATI
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       RIFERIMENTO = var_RIFERIMENTO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_GRAFFATI"
               if :new.DOCUMENTO_ID is not null and
                  :new.RIFERIMENTO is not null then
                  open  cpk_wrk_graffati(:new.DOCUMENTO_ID,
                                         :new.RIFERIMENTO);
                  fetch cpk_wrk_graffati into dummy;
                  found := cpk_wrk_graffati%FOUND;
                  close cpk_wrk_graffati;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.RIFERIMENTO||
                               '" gia'' presente in WRK_GRAFFATI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_GRAFFATI_TIU */
/

-- Procedure WRK_GRAFFATI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WRK_GRAFFATI

create or replace procedure WRK_GRAFFATI_PD
(old_documento_id IN number,
 old_riferimento IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WRK_GRAFFATI_CONT"
   cursor cfk1_wrk_graffati(var_documento_id number,
                            var_riferimento varchar) is
      select 1
      from   WRK_GRAFFATI_CONT
      where  DOCUMENTO_ID = var_documento_id
       and   RIFERIMENTO = var_riferimento
       and   var_documento_id is not null
       and   var_riferimento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WRK_GRAFFATI" if children still exist in "WRK_GRAFFATI_CONT"
      open  cfk1_wrk_graffati(OLD_DOCUMENTO_ID,
                              OLD_RIFERIMENTO);
      fetch cfk1_wrk_graffati into dummy;
      found := cfk1_wrk_graffati%FOUND;
      close cfk1_wrk_graffati;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WRK_GRAFFATI_CONT. La registrazione di WRK_GRAFFATI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_GRAFFATI_PD */
/

-- Tigger WRK_GRAFFATI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WRK_GRAFFATI

create or replace trigger WRK_GRAFFATI_TD
before DELETE
on WRK_GRAFFATI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WRK_GRAFFATI_CONT

      WRK_GRAFFATI_PD(:OLD.DOCUMENTO_ID,
                      :OLD.RIFERIMENTO);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_GRAFFATI_TD */
/

-- Procedure WRK_GRAFFATI_CONT_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WRK_GRAFFATI_CONT

create or replace procedure WRK_GRAFFATI_CONT_PI
(new_documento_id IN number,
 new_riferimento IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WRK_GRAFFATI"
   cursor cpk1_wrk_graffati_cont(var_documento_id number,
                                 var_riferimento varchar) is
      select 1
      from   WRK_GRAFFATI
      where  DOCUMENTO_ID = var_documento_id
       and   RIFERIMENTO = var_riferimento
       and   var_documento_id is not null
       and   var_riferimento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WRK_GRAFFATI" deve esistere quando si inserisce su "WRK_GRAFFATI_CONT"
         if NEW_DOCUMENTO_ID is not null and
            NEW_RIFERIMENTO is not null then
            open  cpk1_wrk_graffati_cont(NEW_DOCUMENTO_ID,
                                         NEW_RIFERIMENTO);
            fetch cpk1_wrk_graffati_cont into dummy;
            found := cpk1_wrk_graffati_cont%FOUND;
            close cpk1_wrk_graffati_cont;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WRK_GRAFFATI. La registrazione WRK_GRAFFATI_CONT non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_GRAFFATI_CONT_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WRK_GRAFFATI_CONT
/* End Trigger: WRK_GRAFFATI_CONT_TC */

-- Procedure WRK_GRAFFATI_CONT_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_GRAFFATI_CONT

create or replace procedure WRK_GRAFFATI_CONT_PU
(old_documento_id IN number,
 old_id_immobile IN number,
 old_cod_fiscale IN varchar,
 old_riferimento IN varchar,
 new_documento_id IN number,
 new_id_immobile IN number,
 new_cod_fiscale IN varchar,
 new_riferimento IN varchar)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WRK_GRAFFATI"
   cursor cpk1_wrk_graffati_cont(var_documento_id number,
                                 var_riferimento varchar) is
      select 1
      from   WRK_GRAFFATI
      where  DOCUMENTO_ID = var_documento_id
       and   RIFERIMENTO = var_riferimento
       and   var_documento_id is not null
       and   var_riferimento is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WRK_GRAFFATI" deve esistere quando si modifica "WRK_GRAFFATI_CONT"
         if  NEW_DOCUMENTO_ID is not null and
             NEW_RIFERIMENTO is not null and ( seq = 0 )
         and (   (NEW_DOCUMENTO_ID != OLD_DOCUMENTO_ID or OLD_DOCUMENTO_ID is null)
              or (NEW_RIFERIMENTO != OLD_RIFERIMENTO or OLD_RIFERIMENTO is null) ) then
            open  cpk1_wrk_graffati_cont(NEW_DOCUMENTO_ID,
                                         NEW_RIFERIMENTO);
            fetch cpk1_wrk_graffati_cont into dummy;
            found := cpk1_wrk_graffati_cont%FOUND;
            close cpk1_wrk_graffati_cont;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WRK_GRAFFATI. La registrazione WRK_GRAFFATI_CONT non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_GRAFFATI_CONT_PU */
/

-- Trigger WRK_GRAFFATI_CONT_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_GRAFFATI_CONT

create or replace trigger WRK_GRAFFATI_CONT_TIU
before INSERT
    or UPDATE
on WRK_GRAFFATI_CONT
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_GRAFFATI_CONT_PU(:OLD.DOCUMENTO_ID,
                              :OLD.ID_IMMOBILE,
                              :OLD.COD_FISCALE,
                              :OLD.RIFERIMENTO,
                         :NEW.DOCUMENTO_ID,
                         :NEW.ID_IMMOBILE,
                         :NEW.COD_FISCALE,
                         :NEW.RIFERIMENTO);
         null;
      end if;
      if INSERTING then
         WRK_GRAFFATI_CONT_PI(:NEW.DOCUMENTO_ID,
                              :NEW.RIFERIMENTO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_GRAFFATI_CONT"
            cursor cpk_wrk_graffati_cont(var_DOCUMENTO_ID number,
                                         var_ID_IMMOBILE number,
                                         var_COD_FISCALE varchar) is
               select 1
                 from   WRK_GRAFFATI_CONT
                where  DOCUMENTO_ID = var_DOCUMENTO_ID and
                       ID_IMMOBILE = var_ID_IMMOBILE and
                       COD_FISCALE = var_COD_FISCALE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_GRAFFATI_CONT"
               if :new.DOCUMENTO_ID is not null and
                  :new.ID_IMMOBILE is not null and
                  :new.COD_FISCALE is not null then
                  open  cpk_wrk_graffati_cont(:new.DOCUMENTO_ID,
                                              :new.ID_IMMOBILE,
                                              :new.COD_FISCALE);
                  fetch cpk_wrk_graffati_cont into dummy;
                  found := cpk_wrk_graffati_cont%FOUND;
                  close cpk_wrk_graffati_cont;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.DOCUMENTO_ID||' '||
                               :new.ID_IMMOBILE||' '||
                               :new.COD_FISCALE||
                               '" gia'' presente in WRK_GRAFFATI_CONT. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_GRAFFATI_CONT_TIU */
/

-- Trigger WRK_POPOLAMENTO_TASI_IMU_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_POPOLAMENTO_TASI_IMU

create or replace trigger WRK_POPOLAMENTO_TASI_IMU_TIU
before INSERT
    or UPDATE
on WRK_POPOLAMENTO_TASI_IMU
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.id is null then
       WRK_POPOLAMENTO_TASI_IMU_NR(:new.ID);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
/*
      if UPDATING then
         WRK_POPOLAMENTO_TASI_IMU_PU(:OLD.ID,
                         :NEW.ID);
         null;
      end if;
*/
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_POPOLAMENTO_TASI_IMU"
            cursor cpk_wrk_popolamento_tasi_imu(var_ID number) is
               select 1
                 from   WRK_POPOLAMENTO_TASI_IMU
                where  ID = var_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_POPOLAMENTO_TASI_IMU"
               if :new.ID is not null then
                  open  cpk_wrk_popolamento_tasi_imu(:new.ID);
                  fetch cpk_wrk_popolamento_tasi_imu into dummy;
                  found := cpk_wrk_popolamento_tasi_imu%FOUND;
                  close cpk_wrk_popolamento_tasi_imu;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID||
                               '" gia'' presente in WRK_POPOLAMENTO_TASI_IMU. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_POPOLAMENTO_TASI_IMU_TIU */
/

-- Procedure WRK_TRASMISSIONE_RUOLO_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WRK_TRASMISSIONE_RUOLO

create or replace procedure WRK_TRASMISSIONE_RUOLO_PI
(new_ruolo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "RUOLI"
   cursor cpk1_wrk_trasmissione_ruolo(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "RUOLI" deve esistere quando si inserisce su "WRK_TRASMISSIONE_RUOLO"
         if NEW_RUOLO is not null then
            open  cpk1_wrk_trasmissione_ruolo(NEW_RUOLO);
            fetch cpk1_wrk_trasmissione_ruolo into dummy;
            found := cpk1_wrk_trasmissione_ruolo%FOUND;
            close cpk1_wrk_trasmissione_ruolo;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Wrk Trasmissione Ruolo non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_TRASMISSIONE_RUOLO_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WRK_TRASMISSIONE_RUOLO
/* End Trigger: WRK_TRASMISSIONE_RUOLO_TC */

-- Procedure WRK_TRASMISSIONE_RUOLO_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_TRASMISSIONE_RUOLO

create or replace procedure WRK_TRASMISSIONE_RUOLO_PU
(old_ruolo IN number,
 old_progressivo IN number,
 new_ruolo IN number,
 new_progressivo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "RUOLI"
   cursor cpk1_wrk_trasmissione_ruolo(var_ruolo number) is
      select 1
      from   RUOLI
      where  RUOLO = var_ruolo
       and   var_ruolo is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "RUOLI" deve esistere quando si modifica "WRK_TRASMISSIONE_RUOLO"
         if  NEW_RUOLO is not null and ( seq = 0 )
         and (   (NEW_RUOLO != OLD_RUOLO or OLD_RUOLO is null) ) then
            open  cpk1_wrk_trasmissione_ruolo(NEW_RUOLO);
            fetch cpk1_wrk_trasmissione_ruolo into dummy;
            found := cpk1_wrk_trasmissione_ruolo%FOUND;
            close cpk1_wrk_trasmissione_ruolo;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su Ruoli. La registrazione Wrk Trasmissione Ruolo non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_TRASMISSIONE_RUOLO_PU */
/

-- Trigger WRK_TRASMISSIONE_RUOLO_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_TRASMISSIONE_RUOLO

create or replace trigger WRK_TRASMISSIONE_RUOLO_TIU
before INSERT
    or UPDATE
on WRK_TRASMISSIONE_RUOLO
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_TRASMISSIONE_RUOLO_PU(:OLD.RUOLO,
                                   :OLD.PROGRESSIVO,
                         :NEW.RUOLO,
                         :NEW.PROGRESSIVO);
         null;
      end if;
      if INSERTING then
         WRK_TRASMISSIONE_RUOLO_PI(:NEW.RUOLO);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_TRASMISSIONE_RUOLO"
            cursor cpk_wrk_trasmissione_ruolo(var_RUOLO number,
                                              var_PROGRESSIVO number) is
               select 1
                 from   WRK_TRASMISSIONE_RUOLO
                where  RUOLO = var_RUOLO and
                       PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_TRASMISSIONE_RUOLO"
               if :new.RUOLO is not null and
                  :new.PROGRESSIVO is not null then
                  open  cpk_wrk_trasmissione_ruolo(:new.RUOLO,
                                                   :new.PROGRESSIVO);
                  fetch cpk_wrk_trasmissione_ruolo into dummy;
                  found := cpk_wrk_trasmissione_ruolo%FOUND;
                  close cpk_wrk_trasmissione_ruolo;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.RUOLO||' '||
                               :new.PROGRESSIVO||
                               '" gia'' presente in Wrk Trasmissione Ruolo. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_TRASMISSIONE_RUOLO_TIU */
/

-- Procedure WRK_VERSAMENTI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WRK_VERSAMENTI

create or replace procedure WRK_VERSAMENTI_PU
(old_progressivo IN number,
 new_progressivo IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WRK_VERSAMENTI_PU */
/

-- Trigger WRK_VERSAMENTI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WRK_VERSAMENTI

create or replace trigger WRK_VERSAMENTI_TIU
before INSERT
    or UPDATE
on WRK_VERSAMENTI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      :new.data_variazione := trunc(sysdate);
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WRK_VERSAMENTI_PU(:OLD.PROGRESSIVO,
                         :NEW.PROGRESSIVO);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WRK_VERSAMENTI"
            cursor cpk_wrk_versamenti(var_PROGRESSIVO number) is
               select 1
                 from   WRK_VERSAMENTI
                where  PROGRESSIVO = var_PROGRESSIVO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WRK_VERSAMENTI"
               if :new.PROGRESSIVO is not null then
                  open  cpk_wrk_versamenti(:new.PROGRESSIVO);
                  fetch cpk_wrk_versamenti into dummy;
                  found := cpk_wrk_versamenti%FOUND;
                  close cpk_wrk_versamenti;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.PROGRESSIVO||
                               '" gia'' presente in WRK Versamenti. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WRK_VERSAMENTI_TIU */
/

-- Procedure WS_INDIRIZZI_INTEGRAZIONE_PI for Check REFERENTIAL Integrity
--                      at INSERT on Table WS_INDIRIZZI_INTEGRAZIONE

create or replace procedure WS_INDIRIZZI_INTEGRAZIONE_PI
(new_codice_integrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   cardinality      integer;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione di InsertChildParentExist per la tabella padre "WS_INTEGRAZIONI"
   cursor cpk1_ws_indirizzi_integrazione(var_codice_integrazione number) is
      select 1
      from   WS_INTEGRAZIONI
      where  CODICE_INTEGRAZIONE = var_codice_integrazione
       and   var_codice_integrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      begin  --  Parent "WS_INTEGRAZIONI" deve esistere quando si inserisce su "WS_INDIRIZZI_INTEGRAZIONE"
         if NEW_CODICE_INTEGRAZIONE is not null then
            open  cpk1_ws_indirizzi_integrazione(NEW_CODICE_INTEGRAZIONE);
            fetch cpk1_ws_indirizzi_integrazione into dummy;
            found := cpk1_ws_indirizzi_integrazione%FOUND;
            close cpk1_ws_indirizzi_integrazione;
            if not found then
               errno  := -20002;
               errmsg := 'Non esiste riferimento su WS_INTEGRAZIONI. La registrazione WS_INDIRIZZI_INTEGRAZIONE non puo'' essere inserita.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WS_INDIRIZZI_INTEGRAZIONE_PI */
/

-- Triggers for Custom Functional Check
--           at INSERT or UPDATE or DELETE on Table WS_INDIRIZZI_INTEGRAZIONE
/* End Trigger: WS_INDIRIZZI_INTEGRAZIONE_TC */

-- Procedure WS_INDIRIZZI_INTEGRAZIONE_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WS_INDIRIZZI_INTEGRAZIONE

create or replace procedure WS_INDIRIZZI_INTEGRAZIONE_PU
(old_codice_istat IN varchar,
 old_codice_integrazione IN number,
 old_identificativo_servizio IN number,
 new_codice_istat IN varchar,
 new_codice_integrazione IN number,
 new_identificativo_servizio IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Dichiarazione UpdateChildParentExist constraint per la tabella "WS_INTEGRAZIONI"
   cursor cpk1_ws_indirizzi_integrazione(var_codice_integrazione number) is
      select 1
      from   WS_INTEGRAZIONI
      where  CODICE_INTEGRAZIONE = var_codice_integrazione
       and   var_codice_integrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      begin  --  Parent "WS_INTEGRAZIONI" deve esistere quando si modifica "WS_INDIRIZZI_INTEGRAZIONE"
         if  NEW_CODICE_INTEGRAZIONE is not null and ( seq = 0 )
         and (   (NEW_CODICE_INTEGRAZIONE != OLD_CODICE_INTEGRAZIONE or OLD_CODICE_INTEGRAZIONE is null) ) then
            open  cpk1_ws_indirizzi_integrazione(NEW_CODICE_INTEGRAZIONE);
            fetch cpk1_ws_indirizzi_integrazione into dummy;
            found := cpk1_ws_indirizzi_integrazione%FOUND;
            close cpk1_ws_indirizzi_integrazione;
            if not found then
               errno  := -20003;
               errmsg := 'Non esiste riferimento su WS_INTEGRAZIONI. La registrazione WS_INDIRIZZI_INTEGRAZIONE non e'' modificabile.';
               raise integrity_error;
            end if;
         end if;
      exception
         when MUTATING then null;  -- Ignora Check su Relazioni Ricorsive
      end;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WS_INDIRIZZI_INTEGRAZIONE_PU */
/

-- Trigger WS_INDIRIZZI_INTEGRAZIONE_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WS_INDIRIZZI_INTEGRAZIONE

create or replace trigger WS_INDIRIZZI_INTEGRAZIONE_TIU
before INSERT
    or UPDATE
on WS_INDIRIZZI_INTEGRAZIONE
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WS_INDIRIZZI_INTEGRAZIONE_PU(:OLD.CODICE_ISTAT,
                                      :OLD.CODICE_INTEGRAZIONE,
                                      :OLD.IDENTIFICATIVO_SERVIZIO,
                         :NEW.CODICE_ISTAT,
                         :NEW.CODICE_INTEGRAZIONE,
                         :NEW.IDENTIFICATIVO_SERVIZIO);
         null;
      end if;
      if INSERTING then
         WS_INDIRIZZI_INTEGRAZIONE_PI(:NEW.CODICE_INTEGRAZIONE);
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WS_INDIRIZZI_INTEGRAZIONE"
            cursor cpk_ws_indirizzi_integrazione(var_CODICE_ISTAT varchar,
                                                 var_CODICE_INTEGRAZIONE number,
                                                 var_IDENTIFICATIVO_SERVIZIO number) is
               select 1
                 from   WS_INDIRIZZI_INTEGRAZIONE
                where  CODICE_ISTAT = var_CODICE_ISTAT and
                       CODICE_INTEGRAZIONE = var_CODICE_INTEGRAZIONE and
                       IDENTIFICATIVO_SERVIZIO = var_IDENTIFICATIVO_SERVIZIO;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WS_INDIRIZZI_INTEGRAZIONE"
               if :new.CODICE_ISTAT is not null and
                  :new.CODICE_INTEGRAZIONE is not null and
                  :new.IDENTIFICATIVO_SERVIZIO is not null then
                  open  cpk_ws_indirizzi_integrazione(:new.CODICE_ISTAT,
                                                      :new.CODICE_INTEGRAZIONE,
                                                      :new.IDENTIFICATIVO_SERVIZIO);
                  fetch cpk_ws_indirizzi_integrazione into dummy;
                  found := cpk_ws_indirizzi_integrazione%FOUND;
                  close cpk_ws_indirizzi_integrazione;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.CODICE_ISTAT||' '||
                               :new.CODICE_INTEGRAZIONE||' '||
                               :new.IDENTIFICATIVO_SERVIZIO||
                               '" gia'' presente in WS_INDIRIZZI_INTEGRAZIONE. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WS_INDIRIZZI_INTEGRAZIONE_TIU */
/

-- Procedure WS_INTEGRAZIONI_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WS_INTEGRAZIONI

create or replace procedure WS_INTEGRAZIONI_PU
(old_codice_integrazione IN number,
 new_codice_integrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);

   --  Declaration of UpdateParentRestrict constraint for "WS_INDIRIZZI_INTEGRAZIONE"
   cursor cfk1_ws_integrazioni(var_codice_integrazione number) is
      select 1
      from   WS_INDIRIZZI_INTEGRAZIONE
      where  CODICE_INTEGRAZIONE = var_codice_integrazione
       and   var_codice_integrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;

      --  Chiave di "WS_INTEGRAZIONI" non modificabile se esistono referenze su "WS_INDIRIZZI_INTEGRAZIONE"
      if (OLD_CODICE_INTEGRAZIONE != NEW_CODICE_INTEGRAZIONE) then
         open  cfk1_ws_integrazioni(OLD_CODICE_INTEGRAZIONE);
         fetch cfk1_ws_integrazioni into dummy;
         found := cfk1_ws_integrazioni%FOUND;
         close cfk1_ws_integrazioni;
         if found then
            errno  := -20005;
            errmsg := 'Esistono riferimenti su WS_INDIRIZZI_INTEGRAZIONE. La registrazione di WS_INTEGRAZIONI non e'' modificabile.';
            raise integrity_error;
         end if;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WS_INTEGRAZIONI_PU */
/

-- Trigger WS_INTEGRAZIONI_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WS_INTEGRAZIONI

create or replace trigger WS_INTEGRAZIONI_TIU
before INSERT
    or UPDATE
on WS_INTEGRAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WS_INTEGRAZIONI_PU(:OLD.CODICE_INTEGRAZIONE,
                         :NEW.CODICE_INTEGRAZIONE);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WS_INTEGRAZIONI"
            cursor cpk_ws_integrazioni(var_CODICE_INTEGRAZIONE number) is
               select 1
                 from   WS_INTEGRAZIONI
                where  CODICE_INTEGRAZIONE = var_CODICE_INTEGRAZIONE;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WS_INTEGRAZIONI"
               if :new.CODICE_INTEGRAZIONE is not null then
                  open  cpk_ws_integrazioni(:new.CODICE_INTEGRAZIONE);
                  fetch cpk_ws_integrazioni into dummy;
                  found := cpk_ws_integrazioni%FOUND;
                  close cpk_ws_integrazioni;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.CODICE_INTEGRAZIONE||
                               '" gia'' presente in WS_INTEGRAZIONI. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WS_INTEGRAZIONI_TIU */
/

-- Procedure WS_INTEGRAZIONI_PD for Check REFERENTIAL Integrity
--                      at DELETE on Table WS_INTEGRAZIONI

create or replace procedure WS_INTEGRAZIONI_PD
(old_codice_integrazione IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;

   --  Declaration of DeleteParentRestrict constraint for "WS_INDIRIZZI_INTEGRAZIONE"
   cursor cfk1_ws_integrazioni(var_codice_integrazione number) is
      select 1
      from   WS_INDIRIZZI_INTEGRAZIONE
      where  CODICE_INTEGRAZIONE = var_codice_integrazione
       and   var_codice_integrazione is not null;
begin
   begin  -- Check REFERENTIAL Integrity

      --  Cannot delete parent "WS_INTEGRAZIONI" if children still exist in "WS_INDIRIZZI_INTEGRAZIONE"
      open  cfk1_ws_integrazioni(OLD_CODICE_INTEGRAZIONE);
      fetch cfk1_ws_integrazioni into dummy;
      found := cfk1_ws_integrazioni%FOUND;
      close cfk1_ws_integrazioni;
      if found then
         errno  := -20006;
         errmsg := 'Esistono riferimenti su WS_INDIRIZZI_INTEGRAZIONE. La registrazione di WS_INTEGRAZIONI non e'' eliminabile.';
         raise integrity_error;
      end if;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WS_INTEGRAZIONI_PD */
/

-- Tigger WS_INTEGRAZIONI_TD for Set FUNCTIONAL Integrity
--                         Check REFERENTIAL Integrity
--                         Set REFERENTIAL Integrity
--                      at DELETE on Table WS_INTEGRAZIONI

create or replace trigger WS_INTEGRAZIONI_TD
before DELETE
on WS_INTEGRAZIONI
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin -- Set FUNCTIONAL Integrity on DELETE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Check REFERENTIAL Integrity on DELETE

      -- Child Restrict Table: WS_INDIRIZZI_INTEGRAZIONE

      WS_INTEGRAZIONI_PD(:OLD.CODICE_INTEGRAZIONE);

   end;

   begin  -- Set REFERENTIAL Integrity on DELETE
      IntegrityPackage.NextNestLevel;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WS_INTEGRAZIONI_TD */
/

-- Procedure WS_LOG_PU for Check REFERENTIAL Integrity
--                      at UPDATE on Table WS_LOG

create or replace procedure WS_LOG_PU
(old_id IN number,
 new_id IN number)
is
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
   seq              number;
   mutating         exception;
   PRAGMA exception_init(mutating, -4091);
begin
   begin  -- Check REFERENTIAL Integrity

      seq := IntegrityPackage.GetNestLevel;
      null;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Procedure: WS_LOG_PU */
/

-- Trigger WS_LOG_TIU for Check DATA Integrity
--                          Check REFERENTIAL Integrity
--                            Set REFERENTIAL Integrity
--                            Set FUNCTIONAL Integrity
--                       at INSERT or UPDATE on Table WS_LOG

create or replace trigger WS_LOG_TIU
before INSERT
    or UPDATE
on WS_LOG
for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);
   dummy            integer;
   found            boolean;
begin
   begin  -- Check DATA Integrity on INSERT or UPDATE
      /* NONE */ null;
   end;

   if INSERTING and :new.id is null then
      WS_LOG_NR(:new.id);
   end if;

   begin  -- Check REFERENTIAL Integrity on INSERT or UPDATE
      if UPDATING then
         WS_LOG_PU(:OLD.ID,
                         :NEW.ID);
         null;
      end if;
      if INSERTING then
         if IntegrityPackage.GetNestLevel = 0 then
            declare  --  Check UNIQUE PK Integrity per la tabella "WS_LOG"
            cursor cpk_ws_log(var_ID number) is
               select 1
                 from   WS_LOG
                where  ID = var_ID;
            mutating         exception;
            PRAGMA exception_init(mutating, -4091);
            begin  -- Check UNIQUE Integrity on PK of "WS_LOG"
               if :new.ID is not null then
                  open  cpk_ws_log(:new.ID);
                  fetch cpk_ws_log into dummy;
                  found := cpk_ws_log%FOUND;
                  close cpk_ws_log;
                  if found then
                     errno  := -20007;
                     errmsg := 'Identificazione "'||
                               :new.ID||
                               '" gia'' presente in WS_LOG. La registrazione  non puo'' essere inserita.';
                     raise integrity_error;
                  end if;
               end if;
            exception
               when MUTATING then null;  -- Ignora Check su UNIQUE PK Integrity
            end;
         end if;
      end if;
   end;

   begin  -- Set REFERENTIAL Integrity on UPDATE
      if UPDATING then
         IntegrityPackage.NextNestLevel;
         IntegrityPackage.PreviousNestLevel;
      end if;
   end;

   begin  -- Set FUNCTIONAL Integrity on INSERT or UPDATE
      if IntegrityPackage.GetNestLevel = 0 then
         IntegrityPackage.NextNestLevel;
         begin  -- Global FUNCTIONAL Integrity at Level 0
            /* NONE */ null;
         end;
         if IntegrityPackage.Functional then
            begin  -- Switched FUNCTIONAL Integrity at Level 0
               /* NONE */ null;
            end;
         end if;
         IntegrityPackage.PreviousNestLevel;
      end if;
      IntegrityPackage.NextNestLevel;
      begin  -- Full FUNCTIONAL Integrity at Any Level
         /* NONE */ null;
      end;
      IntegrityPackage.PreviousNestLevel;
   end;
exception
   when integrity_error then
        IntegrityPackage.InitNestLevel;
        raise_application_error(errno, errmsg);
   when others then
        IntegrityPackage.InitNestLevel;
        raise;
end;
/* End Trigger: WS_LOG_TIU */
/

